;;; This file is part of Compact.
;;; Copyright (C) 2025 Midnight Foundation
;;; SPDX-License-Identifier: Apache-2.0
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;; 	http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(library (sourcemaps)
  (export open-output-file/line&col-positions
          make-sourcemap-tracker
          record-sourcemap-segment!
          record-sourcemap-eof!
          display-sourcemap)
  (import (chezscheme)
          (vlq)
          (only (utils)
                compact-input-transcoder
                registered-source-root
                registered-target-pathname
                registered-source-pathnames))

#|
  Overview
  --------

  This library implements support code for generating source-map
  files.  A source-map file correlates source positions in a
  source-language program, such as an Typescript or Compact source
  program, with source positions in a target-language program, such
  as a Javascript program generated from the Typescript or Compact
  source program.  Source-map files are used by debuggers to provide
  feedback and allow breakpoints to be set based on the original
  source-language program rather than the generated target-language
  program.

  Structure of a source-map file
  ------------------------------

  The following source-map file generated by the Compact compiler
  illustrates the structure and contents of a source-map file.

  {
    "version": 3,
    "file": "index.js",
    "sourceRoot": "",
    "sources": ["lib/std.compact", "examples/tiny.compact"],
    "sourcesContent": [null, null],
    "names": [],
    "mappings": ";;;;;;;;;;;;qFAO8B,KAAK;;;;;ECYnC,SAAA,MASC,CATW,EAAa;UACvB,EAAgC;UAChC,GAA2B,iBAAJ,EAAE;8EAClB,GAAG;;;;;;;;;UAEV,WAAiC;2BAC1B,WAAW;;;;WAEX,WAAW;GACnB;EAED,SAAA,MAOC,CAPW,KAAY;;;;;UAEtB,EAAgC;UAChC,GAA2B,iBAAJ,EAAE;0EACN,GAAG;;qEACK,KAAK;;;;GAEjC;;;8BAGuD,EAAE;;;;;;;;;;;;;;;;;qFDjC5B,OAAK;;;;;ECYnC,SAAA,MASC,CATW,EAAa;UACvB,EAAgC;UAChC,KAA2B,iBAAJ,EAAE;8EAClB,KAAG;;;;;;;;;UAEV,WAAiC;2BAC1B,WAAW;;;;WAEX,WAAW;GACnB;EAED,SAAA,MAOC,CAPW,OAAY;;;;;UAEtB,EAAgC;UAChC,KAA2B,iBAAJ,EAAE;6DACN,KAAG;iEACK,OAAK;;;;GAEjC;;;8BAGuD,EAAE;;2DA7BnC,GAAG;+DACK,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
  }

  The "version" entry says that the file is in Version 3 source-map
  format.  The "file" entry names the object file to which the
  source mappings map.  The "sourceRoot" entry names the root path
  for source files from which the source mappings map.  The "sources"
  entry names the source files themselves.  The "sourcesContent"
  entry could include the actual source code for the source files;
  null indicates that the source code is not duplicated here.  The
  "names" entry can be used to list source names of interest, though
  it's not clear how the list actually helps debugging tools, most
  of which apparently ignore the names anyway.  Finally, the
  "mappings" entry actually provides the source-correlation information
  in Base64-VLQ format.

  The value of the "mappings" entry is a single string.  The portion
  of the string before the first semi-colon represents mappings for
  the first object-file line, the portion before the second represents
  those for the second, and so on.  The portion after the last
  semi-colon represents those for the last line.  No semi-colon
  delimiters can be omitted, at least until after the last mapping,
  since there is no other way for a source-map consumer to know to
  which object-file line a particular set of mappings belongs.

  The set of mappings for a single line is a comma-separated sequence
  of "segments".  Each segment specifies a single mapping and is
  structured as a tuple of numbers encoded in Base64-VLQ format.
  The Base64-VLQ format is described in detail in sourceMaps/vlq.ss.
  For our purposes it's enough to know that each segment encodes a
  tuple of four numbers: [tcol, sfile, sline, scol], identifying:

  tcol:  the target-file column,
  sfile: the source file,
  sline: the source-file line, and
  scol:  the source-file column.

  The target-file line (tline) is not explicitly represented by a
  segment but is implicit in the number of semi-colons that appears
  before the segment in the "mappings" string.

  Thus the segment tells the source-map consumer that column tcol
  of line tline of the target file maps to column scol of line sline
  of the source-file sfile.

  To reduce the size of the encodings, the tuple elements are relative
  offsets rather than absolute.  That is:

  - within the group of segments for a single line, the first tcol
    is an absolute target-file column number (zero-based) and each
    of the remaining tcols for that line are relative to its preceding
    tcol;

  - the first sfile in the "mappings" string is an absolute index
    (zero-based) into the array of source files listed in the
    "sources" array, and each of the remaining sfiles in the mappings
    string (not just for that line) is relative to its preceding
    sfile;

  - the first sline in the "mappings" string is an absolute source-file
    line number (zero-based), and each of the remaining slines in the
    "mappings" string is relative to its preceding sline; and

  - (similarly) the first scol in the "mappings" string is an absolute
    source-file column number (zero-based), and each of the remaining
    scols in the "mappings" string is relative to its preceding scol.

  For example, let's consider the segments in the following prefix of
  the above "mappings" string from the example above.

    ;;;;;;;;;;;;qFAO8B,KAAK;;;;;ECYnC

  The first segment qFAO8B appears after 12 semi-colons, so the
  target-file line tline = 12 (zero-based, so we're actually talking
  about the thirteenth line in the file).  qFAO8B is the Base64-VLQ
  encoding of [85, 0, 7, 30], which we can verify most easily by
  running our vlq decoder:

  echo '(import (vlq)) (vlq-decode "qFAO8B")' | scheme -q => (85 0 7 30)

  Since this is the first tcol for line 12, the tcol is absolute, and
  since these are the first occurrences of sfile, sline, and scol in 
  the "mappings" string, these are all absolute as well.

  Since sfile = 0 and element zero of the "sources" array is
  "lib/std.compact", and since the target file listed in the "files"
  entry is "index.js", this segment tells the consumer:

  index.js line 12, column 85 maps to lib/std.compact line 7, column 30.

  The next segment, KAAK, is in the same group as qFA08B for line
  12, so its tline is also 12.  KAAK decodes to [5, 0, 0, 5].  Its
  tcol is 5 relative to the preceding tcol on the same line (80),
  so effectively 90.  Its sfile is 0 relative to the preceding sfile
  overall (0), so effectively 0 (again identifying "lib/std.compact").
  Its sline is 0 relative to the preceding sline overall (7) so
  effectively 7.  Finally, its scol is 5 relative to the preceding
  scol overall (30) so effectively 35.  Putting it altogether, this
  segment tells the consumer:

  index.js line 12, column 90 maps to lib/std.compact line 7, column 35.

  It happens that line 12, column 85 of index.js references a variable
  with a five-letter name "value" and that this maps to a lib/std.compact
  line 7, column 30 reference of the same variable.  So these first two
  segments mark the beginning and end of this variable reference and
  allow the debugger to present a reference to the index.js 'value" as
  as if it were a reference to the lib/std.compact "value".
  
  The third segment, ECYnC, appears five semi-colon line-markers
  beyond the other two segments, so its tline is 17.  It decodes
  to the tuple [2, 1, 12, -35].  Its tcol is 2, and this is absolute
  since this is the first segment on this line.  Its sfile is 1
  relative to the preceding sfile overall (0), so effectively 1
  (this time identifying "tiny.compact").  Its sline is 12 relative to
  the preceding sline overall (7) so effectively 19.  Finally, its
  scol is -35 relative to the preceding scol overall (35) so
  effectively 0.  So this segment tells the consumer:

  index.js line 17, column 2 maps to tiny.compact line 19, column 0.

  This happens to map the site of an index.js function definition
  to the site of the corresponding tiny.compact circuit definition.

  Some of the segment entries we include are optional in the spec,
  though we always include all four of those described above.  There
  is an optional fifth entry we never currently produce identifying
  a name in the "names" array.

  While we assume that mappings for identifier bindings and references
  are useful to the debugger, we haven't found guidance for what
  other mappings might be of interest.  It would be nice to have
  all and only the right mappings: missing mappings can reduce the
  quality of the debugging experience, while extra mappings can
  increase the size of the source-map files.

  ; source maps references:
  ; https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?hl=en_US&pli=1&pli=1
  ; https://www.mattzeunert.com/2016/02/14/how-do-source-maps-work.html
|#

  (module (replace-source-path! replacement-source-path)
    (define source-path-ht (make-hashtable string-hash string=?))
    (define (replace-source-path! source-path new-source-path)
      (hashtable-set! source-path-ht source-path new-source-path))
    (define (replacement-source-path source-path)
      (hashtable-ref source-path-ht source-path source-path)))

  ; Find the longest common root for those source pathnames that have
  ; a root in common with the target pathname.  This defines the number
  ; of leading "../" components of the computed source root. 
  ; Then find the common root of those source pathnames.  This defines
  ; the named components of source root that follow the "../" components.
  ; The replacement source paths are computed from the remaining source-pathname
  ; components.  The source pathnames with no root in common with the target
  ; pathname are left without replacement source paths.
  (define (compute-source-root)
    (define (maybe-add-dot path)
      (if (or (path-absolute? path)
              (string=? (path-first path) "."))
          path
          (format "./~a" path)))
    (define (path-ancestors path)
      (let f ([path (maybe-add-dot path)])
        (let ([first (path-first path)])
          (if (string=? first "")
              '()
              (cons first (f (path-rest path)))))))
    (define (common-head? path1)
      (lambda (path2)
        (and (not (null? path1))
             (not (null? path2))
             (string=? (car path1) (car path2)))))
    (let* ([target (path-ancestors (format "~a/index.js" (registered-target-pathname)))]
           [p* (filter
                 (let ([common-head? (common-head? target)])
                   (lambda (p) (common-head? (cdr p))))
                 (map cons
                      (registered-source-pathnames)
                      (map path-ancestors (registered-source-pathnames))))]
           [source-pathname* (map car p*)]
           [source* (map cdr p*)])
      (if (null? source*)
          ""
          (let loop ([target target] [source* source*])
            (let ([target (cdr target)] [source* (map cdr source*)])
              (if (andmap (common-head? target) source*)
                  (loop target source*)
                  (if (member ".." target)
                      ; punt in cases where any of the remaining target components is "..",
                      ; we could handle them by getting and using real paths, when possible,
                      ; via realpath(3) on Unix-based systems and GetFullPathName()
                      ; on Windows.
                      ""
                      (let loop ([source* source*] [component* '()])
                        (if (andmap (common-head? (car source*)) source*)
                            (loop (map cdr source*) (cons (caar source*) component*))
                            (begin
                              (for-each
                                (lambda (source-pathname source)
                                  (replace-source-path! source-pathname
                                    (format "~{~a/~}~a" source (path-last source-pathname))))
                                source-pathname*
                                source*)
                              (format "~{../~*~}~{~a/~}" (cdr target) (reverse component*))))))))))))

  (define-record-type position
    (nongenerative)
    (fields line col))

  (define (open-output-file/line&col-positions path if-exists)
    (let ([op (open-output-file path if-exists)] [line 0] [col 0])
      (make-custom-textual-output-port
        path
        (lambda (s i n)
          (let loop ([i i] [line^ line] [col^ col])
            (if (fx= i n)
                (begin (set! line line^) (set! col col^))
                (let ([c (string-ref s i)])
                  (if (char=? c #\newline)
                      (loop (fx+ i 1) (fx+ line^ 1) 0)
                      (loop (fx+ i 1) line^ (fx+ col^ 1))))))
          (put-string op s i n)
          n)
        (lambda () (make-position line col))
        #f
        (lambda () (close-port op)))))

  (define-record-type segment
    (nongenerative)
    (fields objline objcol srcpath srcline srccol))

  (define-record-type sourcemap-tracker
    (nongenerative)
    (fields
      (mutable rsegment*)  ; reversed list of segment records
      (mutable eofline)    ; obj-file line at eof
      )
    (protocol
      (lambda (new)
        (lambda ()
          (new '() #f)))))

  (define (get-source-info who src start?)
    (call-with-values
      (lambda () (parameterize ([current-transcoder compact-input-transcoder]) (locate-source-object-source src start? #t)))
      (case-lambda
        [() (values #f #f #f)]
        [(path line col) (values path (- line 1) (- col 1))])))

  (define (record-sourcemap-segment! tracker src start?)
    (define who 'record-sourcemap-segment!)
    (unless (sourcemap-tracker? tracker) (errorf who "~s is not a sourcemap tracker" tracker))
    (unless (source-object? src) (errorf who "~s is not a source object" src))
    (unless (boolean? start?) (errorf who "~s is not a boolean value" start?))
    (let ([pos (file-position (current-output-port))])
      (unless (position? pos) (errorf who "port-position ~s retrieved from ~s is not a position" pos (current-output-port)))
      (let-values ([(src-path src-line src-col) (get-source-info who src start?)])
        (when src-path
          (sourcemap-tracker-rsegment*-set! tracker
            (cons (make-segment (position-line pos)
                                (position-col pos)
                                src-path
                                src-line
                                src-col)
                  (sourcemap-tracker-rsegment* tracker)))))))

  (define (record-sourcemap-eof! tracker pos)
    (define who 'record-eof!)
    (unless (sourcemap-tracker? tracker) (errorf who "~s is not a sourcemap tracker" tracker))
    (unless (position? pos) (errorf who "~s is not a position" pos))
    (sourcemap-tracker-eofline-set! tracker (position-line pos)))

  (module (display-sourcemap)
    (define (assign-srcpath-indices segment*)
      (let ([srcpath-ht (make-hashtable string-hash string=?)]
            [rsrcpath* '()])
        (let ([next-index 0])
          (for-each
            (lambda (segment)
              (let ([srcpath (segment-srcpath segment)])
                (let ([a (hashtable-cell srcpath-ht srcpath #f)])
                  (unless (cdr a)
                    (set-cdr! a next-index)
                    (set! next-index (+ next-index 1))
                    (set! rsrcpath* (cons srcpath rsrcpath*))))))
            segment*))
        (values srcpath-ht (reverse rsrcpath*))))
  
    (define (encode-segments segment* srcpath-ht eofline)
      (let next-line ([segment* segment*]
                      [objline 0] [pathindex 0] [srcline 0] [srccol 0]
                      [rencoded-segment** '()])
        (if (and (= objline eofline) (null? segment*))
            (reverse rencoded-segment**)
            (let next-segment ([segment* segment*]
                               [objcol 0] [pathindex pathindex] [srcline srcline] [srccol srccol]
                               [rencoded-segment* '()])
              (if (or (null? segment*) (not (= (segment-objline (car segment*)) objline)))
                  (next-line
                    segment*
                    (+ objline 1) pathindex srcline srccol
                    (cons (reverse rencoded-segment*) rencoded-segment**))
                  (let ([s (car segment*)])
                    (let ([new-objcol (segment-objcol s)]
                          [new-pathindex (hashtable-ref srcpath-ht (segment-srcpath s) #f)]
                          [new-srcline (segment-srcline s)]
                          [new-srccol (segment-srccol s)])
                      (next-segment
                        (cdr segment*)
                        new-objcol new-pathindex new-srcline new-srccol
                        (cons
                          (vlq-encode
                            (list
                              (- new-objcol objcol)
                              (- new-pathindex pathindex)
                              (- new-srcline srcline)
                              (- new-srccol srccol)))
                          rencoded-segment*)))))))))
  
    (define (display-sourcemap tracker map-port)
      (define who 'display-sourcemap)
      (unless (sourcemap-tracker? tracker) (errorf who "~s is not a sourcemap tracker" tracker))
      (unless (and (output-port? map-port) (textual-port? map-port)) (errorf who "~s is not a textual output port" map-port))
      (let ([segment* (reverse (sourcemap-tracker-rsegment* tracker))]
            [eofline (sourcemap-tracker-eofline tracker)])
        (unless eofline (errorf 'display-sourcemap "record-sourcemap-eof! has not been called"))
        (let-values ([(srcpath-ht srcpath*) (assign-srcpath-indices segment*)])
          (let ([source-root (or (registered-source-root) (compute-source-root))]
                [encoded-segment** (encode-segments segment* srcpath-ht eofline)])
            (fprintf map-port "{\n")
            (fprintf map-port "  \"version\": 3,\n")
            (fprintf map-port "  \"file\": \"index.js\",\n")
            (fprintf map-port "  \"sourceRoot\": \"~a\",\n" source-root)
            (fprintf map-port "  \"sources\": [~{\"~a\"~^, ~}],\n" (map replacement-source-path srcpath*))
            ; some tools don't like having sourcesContent, and it should be unnecessary
            ; (fprintf map-port "  \"sourcesContent\": [~{~a~^, ~}],\n" (map (lambda (x) "null") srcpath*))
            (fprintf map-port "  \"names\": [],\n")
            (fprintf map-port "  \"mappings\": \"~{~a~^;~}\"\n"
                     (map
                       (lambda (segment*) (format "~{~a~^,~}" segment*))
                       encoded-segment**))
            (fprintf map-port "}\n"))))))
)
