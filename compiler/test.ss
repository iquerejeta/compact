#!chezscheme

;;; This file is part of Compact.
;;; Copyright (C) 2025 Midnight Foundation
;;; SPDX-License-Identifier: Apache-2.0
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;; 	http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; The initial version of this code was extracted from Chez Scheme
;;; examples/ez-grammar-test.ss. test-equal? was adapted from Chez
;;; Scheme mats/mat.ss equivalent-expansion.  Both are covered by
;;; the following copyright notice:
;;;
;;; Copyright 2017 Cisco Systems, Inc.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;; http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

#|
NB: Please follow the existing formatting and indentation of tests in this file.
The formatting and indentation is specifically crafted to simplify comparison
and updating of check forms (e.g., return and oops forms).  That is, when the
test driver prints the actual check form, it is in the expected format and with
the expected indentation.  This simplifies comparisons between the expected and
actual check output and the replacement of expected check output with new expected
output based on the actual output.

For single-file tests, the test form should be indented two spaces from the left
margin, the input filename or list of strings two spaces in from that (four total),
and the checks also indented two spaces in from the test form (four total).
The closing newline for the test should appear on a separate line from the last
check. For example:

  (test
    '(
      "circuit foo() : Bytes<20> { return 'Hello world!'; }"
      )
    (returns
      (program
        (circuit #f #f foo () ()
            (tbytes 20)
          (block (return ,(string->utf8 "Hello world!"))))))
    )

When replacing a check form with the one printed by the test driver, resist
any reformtting, since this complicates comparison.  If the output is not to
your liking, consider instead changing the formatting controls embedded in the
lparser.ss or langs.ss intermediate language definitions.

For test groups, the test-group form should be indented two spaces from the left
margin.  The group members should be indented two spaces in from that (four total).
The checkers should be indented one space in from that (five total).  The closing
newline for the group member should appear on a separate line from the last check.
For example:

  (test-group
    ((create-file "testfile.compact" '())
     (custom-check
       (lambda (pass-name x)
         (chmod "compiler/testdir/testfile.compact" 000)
         #t))
     )
    ((source-file "compiler/testdir/testfile.compact")
     (oops
       message: "error ~a: ~a"
       irritants: '("opening source file" "failed for compiler/testdir/testfile.compact: permission denied"))
     )
    )

The test driver knows to indent the actual check output differently for test
groups than for single tests.
|#


(import (except (chezscheme) errorf)
        (nanopass)
        (langs)
        (parser)
        (passes)
        (sourcemaps)
        (utils)
        (json)
        (runtime-version)
        (language-version)
        (compiler-version))

#|
(module ()
(record-writer (record-rtd (make-eq-hashtable))
    (lambda (x p wr)
      (let-values ([(keys vals) (hashtable-entries x)])
        (fprintf p "eqht{~{~a~^, ~a~}}"
          (map (lambda (key val) (format "~s=~s" key val))
               (vector->list keys) (vector->list vals)))))))
|#

(module (run-tests test-group test oops warning returns succeeds custom-check >output-file output-file stage-javascript run-javascript
         testdir show-last-successes show-successes show-all-passes show-stack-backtrace with-compact-path)

  (define n)
  (define nfail)
  (define positive-feedback)
  (define negative-feedback)
  (define warning-conditions (make-parameter '()))

  (define target-file-name)
  (define contractCode*)
  (define test-root*)

  (define show-last-successes (make-parameter 0))
  (define show-successes (make-parameter #f))
  (define show-all-passes (make-parameter #f))
  (define show-stack-backtrace (make-parameter #t))

  (define-syntax testdir (identifier-syntax "compiler/testdir"))
  (define (recreate-testdir)
    (rm-rf testdir)
    (mkdir testdir))

  (define (pretty-print/formats pretty-formats x)
    (let loop ([alist pretty-formats])
      (if (null? alist)
          (pretty-print x)
          (let ([a (car alist)] [alist (cdr alist)])
            (parameterize ([(let ([name (car a)])
                              (case-lambda
                                [() (pretty-format name)]
                                [(x) (pretty-format name x)]))
                            (cdr a)])
              (loop alist))))))

  (define (print-result pretty-formats result)
    (pretty-print/formats
      (cons
        (cons 'returns '(returns #f e))
        pretty-formats)
      (list 'returns result)))

  (define (indent in s) ; prefixes each line by "in" and aligns tabbed text
    (define (end-col rcol* rchar*)
      (if (null? rchar*)
          rcol*
          (cons (list->string (reverse rchar*)) rcol*)))
    (define (end-line rline* rcol* rchar*)
      (cons (reverse (end-col rcol* rchar*)) rline*))
    (let ([n (string-length s)])
      (let loop ([i 0] [rline* '()] [rcol* '()] [rchar* '()])
        (if (fx= i n)
            (let* ([line+ (reverse (end-line rline* rcol* rchar*))]
                   [ncols (apply fxmax 0 (map length line+))]
                   [width* (map (lambda (s*) (apply fxmax 0 (map string-length s*)))
                                (apply map list
                                       (map (lambda (col*)
                                              (append col*
                                                (make-list (fx- ncols (length col*)) "")))
                                            line+)))])
                (let doline ([line+ line+])
                  (let ([col* (car line+)])
                    (unless (null? col*)
                      (let docol ([col+ col*] [width+ width*] [in in])
                        (let ([col (car col+)] [col* (cdr col+)] [width (car width+)] [width* (cdr width+)])
                          (display-string in)
                          (display-string col)
                          (unless (null? col*)
                            (docol col* width*
                              (make-string (fx- (fx+ width 1) (string-length col)) #\space)))))))
                  (let ([line* (cdr line+)])
                    (unless (null? line*)
                      (newline)
                      (doline line*)))))
            (let ([c (string-ref s i)])
              (case c
                [(#\newline) (loop (fx+ i 1) (end-line rline* rcol* rchar*) '() '())]
                [(#\tab) (loop (fx+ i 1) rline* (end-col rcol* rchar*) '())]
                [else (loop (fx+ i 1) rline* rcol* (cons c rchar*))]))))))

  (define (format-stack-backtrace c n)
    (unless (continuation-condition? c)
      (internal-errorf 'format-stack-backtrace "~s is not a continuation condition" c))
    (with-output-to-string
      (lambda ()
        (let loop ([n n] [x (inspect/object (condition-continuation c))])
          (if (eq? (x 'type) 'continuation)
              (if (= n 0)
                  '("...")
                  (begin
                    (printf "~a:\t" (or ((x 'code) 'name) "unknown"))
                    (call-with-values
                      (lambda () (x 'source-path))
                      (case-lambda
                        [() (printf "source file unknown\n")]
                        [(path pos) (printf "~a character ~s\n" path pos)]
                        [(path line col) (printf "~a line ~s, char ~s\n" path line col)]))
                    (loop (- n 1) (x 'link))))
              '())))))

  (define-syntax with-compact-path
    (syntax-rules ()
      [(_ new-path test)
       (lambda (pass-name maybe-src)
         (parameterize ([compact-path new-path])
           (test pass-name maybe-src)))]))

  (define-record-type groupie
    (nongenerative)
    (fields sfn code tfn okay?*))

  (define-syntax test-group
    (lambda (x)
      (define (do-groupie groupie)
        (syntax-case groupie (source-file create-file)
          [((source-file sfn) okay? ...)
           (string? (datum sfn))
           #`(make-groupie
               sfn
               sfn
               #,(format "~a/~a" testdir (path-root (path-last (datum sfn))))
               (list okay? ...))]
          [((create-file sfn code) okay? ...)
           (string? (datum sfn))
           #`(make-groupie
               #,(format "~a/~a" testdir (datum sfn))
               code
               #,(format "~a/~a" testdir (path-root (path-last (datum sfn))))
               (list okay? ...))]))
      (syntax-case x ()
        [(_ (file okay? ...) ... (file^ okay?^ ...))
         (begin
           (when (null? #'(okay?^ ...)) (syntax-error x "last groupie has no checks"))
           #`($test 5 "../src/" #,@(map do-groupie #'((file okay? ...) ... (file^ okay?^ ...)))))])))
  (indirect-export test-group $test)

  (define-syntax test
    (lambda (x)
      (define (do-groupie code checks)
        (syntax-case code ()
          [sfn
           (string? (datum sfn))
           #`(make-groupie sfn sfn testdir #,checks)]
          [code
           #`(make-groupie
               (format "~a/testfile.compact" testdir)
               code
               testdir
               #,checks)]))
      (syntax-case x ()
        [(_ code okay? ...)
         (when (null? #'(okay? ...)) (syntax-error x "test has no checks"))
         #`($test 4 "../src/" #,(do-groupie #'code #'(list okay? ...)))])))
  (indirect-export test make-groupie)

  (define ($test result-indent sourceRoot . groupie*)
    (lambda (pass-name maybe-src)
      (define-record-type success
        (nongenerative)
        (fields pass-name unparser pretty-formats ir))
      (define (print-code code)
        (printf "  test code:\n")
        (if (string? code)
            (printf "    ~a\n" code)
            (for-each (lambda (line) (printf "    ~a\n" line)) code)))
      (define (print-pass-output success)
        (let ([result ((success-unparser success) (success-ir success))])
          (printf "  pass ~s produced:\n" (success-pass-name success))
          (parameterize ([pretty-initial-indent result-indent] [print-gensym #f])
            (printf (make-string result-indent #\space))
            (print-result (success-pretty-formats success) result))))
      (define (print-feedback feedback)
        (printf "  results:\n")
        (for-each
          (lambda (th) (indent (make-string result-indent #\space) (with-output-to-string th)))
          (reverse feedback)))
      (define (go source-fn target-fn okay?* code)
        (define successes '())
        (fluid-let ([positive-feedback '()] [negative-feedback '()] [condition-recorded? #f])
          (parameterize ([id-counter 0] [warning-conditions '()])
            (let-values ([(result pretty-formats)
                          (parameterize ([pending-conditions '()])
                            (guard (c [else (values
                                              (let ([c* (pending-conditions)])
                                                (if (null? c*)
                                                    c
                                                    (condition c (make-others-condition (pending-conditions)))))
                                              '())])
                              (with-exception-handler
                                (lambda (c)
                                  (if (warning? c)
                                      (warning-conditions (cons c (warning-conditions)))
                                      (raise-continuable c)))
                                (lambda ()
                                  (generate-everything source-fn target-fn
                                    pass-name
                                    (lambda (pass-name unparser pretty-formats x)
                                      (set! successes (cons (make-success pass-name unparser pretty-formats x) successes))))))))])
              (let* ([okay? (not (memq #f (maplr (lambda (okay?) (okay? pass-name pretty-formats result)) okay?*)))]
                     [okay? (if (null? (warning-conditions)) okay? (warnings-okay?))])
                (when (and okay? (show-successes))
                  (printf "test ~s succeeded\n" n)
                  (print-code code)
                  (print-feedback positive-feedback)
                  (when (show-all-passes)
                    (for-each print-pass-output (reverse successes))))
                (unless okay?
                  (set! nfail (+ nfail 1))
                  (let () (import (go)) (failed #t))
                  (printf "test ~s failed~@[ at ~a~]\n" n (and maybe-src (format-source-object maybe-src)))
                  (print-code code)
                  (print-feedback negative-feedback)
                  (let ([n (show-last-successes)])
                    (for-each
                      print-pass-output
                      (if (fx<= n (length successes)) (list-head successes n) successes))))
                okay?)))))
      (recreate-testdir)
      (set! n (+ n 1))
      ; (printf "starting test ~s\n" n)
      (fluid-let ([contractCode* '()] [test-root* '()])
        (for-each
          (lambda (groupie)
            (unregister-pathnames!)
            (register-source-root! sourceRoot)
            (let ([sfn (groupie-sfn groupie)] [code (groupie-code groupie)] [tfn (groupie-tfn groupie)])
              (fluid-let ([target-file-name tfn])
                (unless (equal? code sfn)
                  (when (file-exists? sfn)
                    (internal-errorf #f "file ~s to be created already exists~@[ at ~a~]"
                                     sfn
                                     (and maybe-src (format-source-object maybe-src))))
                  (unless (and (list? code) (andmap string? code))
                    (internal-errorf #f "supplied code is not a list of strings~@[ at ~a~]" 
                                     (and maybe-src (format-source-object maybe-src))))
                  (mkdir-p (path-parent sfn))
                  (with-output-to-file sfn
                    (lambda () (printf "~{~a~^\n~}" code))))
                (unless (null? (groupie-okay?* groupie))
                  (go sfn tfn (groupie-okay?* groupie) code)))))
          groupie*))
      (void)))

  (define ($run-tests pass-name stx* . test*)
    (let* ([t (current-time)])
      (printf "\\\\\\\\ Starting ~s.\n" pass-name)
      (flush-output-port (current-output-port))
      (fluid-let ([n 0] [nfail 0])
        (for-each
          (lambda (stx test)
            (test pass-name
              (let ([a (syntax->annotation stx)])
                (and (annotation? a) (annotation-source a)))))
          stx* test*)
        (let ([t (time-difference (current-time) t)])
          (printf "//// Completed ~s with ~s/~s passing in ~,2fs.\n" pass-name (- n nfail) n
                  (/ (+ (* (time-second t) (expt 10 9))
                        (time-nanosecond t))
                     (expt 10 9)))
          (flush-output-port (current-output-port))))))

  (define-syntax run-tests
    (syntax-rules ()
      [(_ ?pass test ...)
       ($run-tests '?pass #'(test ...) test ...)]))

  (indirect-export run-tests $run-tests)

  (define test-equal?
   ; equal modulo unification of syms in the second input with gensyms and ids in the first
   ; a procedure in the second input is used as predicate for the first
    (lambda (pretty-formats x y)
      (and (not (condition? x))
        (let ([syms (make-hashtable symbol-hash eq?)] [oops? #f])
          (let e? ([x x] [y y])
            (or (cond
                  [(pair? y) (and (pair? x) (e? (car x) (car y)) (e? (cdr x) (cdr y)))]
                  [(symbol? y)
                   (let ([a (hashtable-cell syms y #f)])
                     (if (cdr a)
                         (eq? x (cdr a))
                         (and (or (eq? x y) (id? x) (gensym? x))
                              (begin (set-cdr! a x) #t))))]
                  [(eqv? x y) #t]
                  [(string? x) (and (string? y) (string=? x y))]
                  [(bytevector? x) (and (bytevector? y) (bytevector=? x y))]
                  [(vector? x)
                   (and (vector? y)
                        (fx= (vector-length x) (vector-length y))
                        (let f ([i (fx- (vector-length x) 1)])
                          (or (fx< i 0)
                              (and (e? (tuple-ref x i) (tuple-ref y i))
                                   (f (fx1- i))))))]
                  [(procedure? y) (y x)]
                  [else #f])
                (begin
                  (unless oops?
                    (set! oops? #t)
                    (printf "failure in test-equal?:\n  ")
                    (parameterize ([pretty-initial-indent 2]) (pretty-print/formats pretty-formats x))
                    (printf "is not equivalent to\n  ")
                    (parameterize ([pretty-initial-indent 2]) (pretty-print/formats pretty-formats y)))
                  #f)))))))

  (define (warning-feedback)
    (let ([c* (reverse (warning-conditions))])
      (lambda ()
        (for-each
          (lambda (c) (printf "~a\n" (format-condition c)))
          c*)
        (printf "(warning~{~a~})\n"
          (map (lambda (c)
                 (format "\n  message: ~s\n  irritants: '~s"
                   (if (message-condition? c) (condition-message c) "no message")
                   (if (irritants-condition? c) (condition-irritants c) '())))
               c*)))))

  (define (warnings-okay?)
    (or (null? (warning-conditions))
        (begin
          (set! negative-feedback (cons (warning-feedback) negative-feedback))
          #f)))

  (module (make-others-condition returns condition-recorded? oops warning succeeds custom-check >output-file output-file stage-javascript run-javascript)
    (define-condition-type &others-condition &condition
      make-others-condition others-condition?
      (others condition-others))

    (define condition-recorded?)
    (define (condition! c)
      (unless condition-recorded?
        (set! condition-recorded? #t)
        (let ([feedback
               (lambda ()
                 (define (print-condition c)
                   (display-string (format-condition c))
                   (newline)
                   (when (and (show-stack-backtrace) (continuation-condition? c))
                     (printf "stack backtrace:\n")
                     (indent "  " (format-stack-backtrace c 10))))
                 (when (pass-name-condition? c)
                   (printf "exception occurred while running ~s\n" (condition-pass-name c)))
                 (cond
                   [(or (halt-condition? c) (source-error-condition? c))
                    (let ([c* (let ([c* (if (others-condition? c) (condition-others c) '())])
                                (reverse (if (source-error-condition? c) (cons c c*) c*)))])
                      (for-each print-condition c*)
                      (printf "(oops~{~a~})\n"
                        (map (lambda (c)
                               (format "\n  message: ~s\n  irritants: '~s"
                                 (if (message-condition? c) (condition-message c) "no message")
                                 (if (irritants-condition? c) (condition-irritants c) '())))
                             c*)))]
                   [else
                    (when (others-condition? c) (for-each print-condition (condition-others c)))
                    (printf "Internal compiler error: ")
                    (print-condition c)
                    (printf "(internal-error)\n")]))])
          (set! negative-feedback (cons feedback negative-feedback))))
      #f)

    (define ($returns k)
      (lambda (pass-name pretty-formats x)
        (if (condition? x)
            (condition! x)
            (let* ([printed-result (with-output-to-string (lambda () (print-result pretty-formats x)))]
                   [feedback (lambda () (display-string printed-result))])
              (let-values ([(op get-output) (open-string-output-port)])
                (if (parameterize ([current-output-port op])
                      (test-equal? pretty-formats x k))
                    (begin
                      (set! positive-feedback (cons feedback positive-feedback))
                      #t)
                    (let ([msg (get-output)])
                      (set! negative-feedback (cons* (lambda () (display-string msg)) negative-feedback))
                      (set! negative-feedback (cons feedback negative-feedback))
                      #f)))))))

    (define-syntax returns
      (syntax-rules ()
        [(_ k) ($returns `k)]))

    (indirect-export returns $returns)

    (define ($oops ls)
      (let ([feedback (lambda ()
                        (printf "test did not produce the expected exception(s):\n")
                        (for-each
                          (lambda (message irritants)
                            (indent "  " (format "Exception: ~?\n" message irritants)))
                          (map car ls)
                          (map cdr ls)))])
        (lambda (pass-name pretty-formats x)
          (if (condition? x)
              (or (and (or (source-error-condition? x) (halt-condition? x))
                       (let ([c* (let ([c* (if (others-condition? x) (condition-others x) '())])
                                   (reverse (if (source-error-condition? x) (cons x c*) c*)))])
                         (and (andmap message-condition? c*)
                              (andmap irritants-condition? c*)
                              (fx= (length c*) (length ls))
                              (andmap equal? (map condition-message c*) (map car ls))
                              (andmap equal? (map condition-irritants c*) (map cdr ls)))))
                  (begin
                    (set! negative-feedback (cons feedback negative-feedback))
                    (condition! x)))
              (begin
                (set! negative-feedback (cons feedback negative-feedback))
                (set! negative-feedback (cons (lambda () (print-result pretty-formats x)) negative-feedback))
                #f)))))

    (define-syntax oops
      (lambda (x)
        (syntax-case x ()
          [(_ x ...)
           #`($oops
               (list
                 #,@(let f ([x* #'(x ...)])
                      (syntax-case x* (message: irritants:)
                        [() '()]
                        [(message: ?message irritants: ?irritants x ...)
                         (cons #`(cons ?message ?irritants) (f #'(x ...)))]))))])))

    (indirect-export oops $oops)

    (define ($warning ls)
      (lambda (pass-name pretty-formats x)
        (let ([c* (reverse (warning-conditions))] [feedback (warning-feedback)])
          (warning-conditions '())
          (if (and (andmap message-condition? c*)
                   (andmap irritants-condition? c*)
                   (fx= (length c*) (length ls))
                   (andmap equal? (map condition-message c*) (map car ls))
                   (andmap equal? (map condition-irritants c*) (map cdr ls)))
              (begin
                (set! positive-feedback (cons feedback positive-feedback))
                #t)
              (begin
                (set! negative-feedback (cons feedback negative-feedback))
                #f)))))

    (define-syntax warning
      (lambda (x)
        (syntax-case x ()
          [(_ x ...)
           #`($warning
               (list
                 #,@(let f ([x* #'(x ...)])
                      (syntax-case x* (message: irritants:)
                        [() '()]
                        [(message: ?message irritants: ?irritants x ...)
                         (cons #`(cons ?message ?irritants) (f #'(x ...)))]))))])))

    (indirect-export warning $warning)

    (define (succeeds)
      (lambda (pass-name pretty-formats x)
        (if (condition? x)
            (condition! x)
            #t)))

    (define (custom-check proc)
      (lambda (pass-name pretty-formats x)
        (if (condition? x)
            (condition! x)
            (proc pass-name x))))

    (define (file->lines path)
      (call-with-port
        (open-input-file path)
        (lambda (ip)
          (define (get-line)
            (let loop ([rc* '()])
              (let ([c (get-char ip)])
                (if (eof-object? c)
                    (if (null? rc*) c (warningf 'string->lines "~a is missing a trailing newline" path))
                    (if (char=? c #\newline)
                        (list->string (reverse rc*))
                        (loop (cons c rc*)))))))
          (let f ()
            (let ([line (get-line)])
              (if (eof-object? line)
                  '()
                  (cons line (f))))))))

    (define-syntax >output-file
      (syntax-rules (call-with-port open-input-file)
        [(_ ipath opath)
         (and (string? (datum ipath)) (string? (datum opath)))
         (lambda (pass-name pretty-formats x)
           (if (condition? x)
               (condition! x)
               (call-with-port (open-output-file opath 'replace)
                 (lambda (op) (put-string op (call-with-port (open-input-file ipath) get-string-all)))))
           #t)]))
    (indirect-export >output-file condition!)

    (define (output-file path k)
      (lambda (pass-name pretty-formats x)
        (if (condition? x)
            (condition! x)
            (guard (c [else
                       (let ([feedback
                              (lambda ()
                                (display-string (format-condition c))
                                (newline))])
                         (set! negative-feedback (cons feedback negative-feedback))
                         #f)])
              (let ([line* (and k (if (and (string? k) (file-exists? k))
                                      (file->lines k)
                                      k))]
                    [line^* (and (file-exists? path) (file->lines path))])
                (let ([feedback
                       (lambda ()
                         (if line^*
                             (if (null? line^*)
                                 (printf "(output-file ~s '())\n" path)
                                 (printf "(output-file ~s\n  '(~{\n    ~s~}))\n" path line^*))
                             (printf "(output-file ~s #f)\n" path)))])
                  (if (equal? line^* line*)
                      (begin
                        (set! positive-feedback (cons feedback positive-feedback))
                        #t)
                      (begin
                        (set! negative-feedback (cons feedback negative-feedback))
                        #f))))))))

    (module (stage-javascript run-javascript)
      (define javascript-fn "compiler/javascript-tests.ts")
      (define javascript-dir "compiler/javascript-code")
      (define javascript-counter 0)
      (define javascript-op #f)
      (define (copy-file ifn ofn)
        (call-with-port
          (open-output-file ofn)
          (lambda (op)
            (let ([x (call-with-port (open-input-file ifn) get-string-all)])
              (unless (eof-object? x) (put-string op x))))))
      (define (copy-dir src dst)
        (when (file-directory? src)
          (mkdir-p dst)
          (for-each
           (lambda (name)
             (unless (member name '("." ".."))
               (let* ([src-path (format "~a/~a" src name)]
                      [dst-path (format "~a/~a" dst name)])
                 (if (file-directory? src-path)
                     (copy-dir src-path dst-path)
                     (copy-file src-path dst-path)))))
           (directory-list src))))
      (define-syntax stage-javascript
        (lambda (x)
          (syntax-case x ()
            [(_ contractCode k) #`($stage-javascript #'#,x 'contractCode k)]
            [(_ k) #`($stage-javascript #'#,x 'contractCode k)])))
      (indirect-export stage-javascript $stage-javascript)
      (define ($stage-javascript stx contractCode k)
        (lambda (pass-name pretty-formats x)
          (if (condition? x)
              (condition! x)
              (let ([desc (format-source-object (annotation-source (syntax->annotation stx)))]
                    [line* (if (string? k) (file->lines k) k)])
                (unless javascript-op
                  (rm-rf javascript-dir)
                  (delete-file javascript-fn)
                  (set! javascript-op (open-output-file javascript-fn 'replace))
                  (for-each
                    (lambda (s) (put-string javascript-op s))
                    '(
                      "import { describe, expect, test } from 'vitest';\n"
                      "import * as runtime from '@midnight-ntwrk/compact-runtime';\n"
                      "import { startContract } from './util.js';\n"
                      "\n"
                      )))
                (unless (file-directory? javascript-dir) (mkdir javascript-dir))
                (when (null? contractCode*) (set! javascript-counter (+ javascript-counter 1)))
                (let ([test-root (cond
                                   [(string=? target-file-name "compiler/testdir")
                                    (format "~a/test~d" javascript-dir javascript-counter)]
                                   [(string-prefix? "compiler/testdir/" target-file-name)
                                    (format "~a/test~d/~a" javascript-dir javascript-counter (path-rest (path-rest target-file-name)))]
                                   [else (assert #f)])])
                  (mkdir-p test-root)
                  (let* ([source-path* (registered-source-pathnames)]
                         [source-dir*
                           (map (lambda (s)
                                  (let ([s (path-parent s)])
                                    (assert (not (string-prefix? "/" s)))
                                    (assert (not (string-prefix? "." s)))
                                    (format "~a/src/~a" test-root s)))
                                source-path*)])
                    (for-each
                      (lambda (source-dir source-path)
                        (mkdir-p source-dir)
                        (copy-file source-path (format "~a/~a" source-dir (path-last source-path))))
                      source-dir* source-path*))
                  (let ([contract-dir (format "~a/contract" test-root)])
                    (mkdir contract-dir)
                    (copy-dir (format "~a/zkir" target-file-name) (format "~a/zkir" test-root))
                    (for-each
                      (lambda (ext)
                        (let ([fn (format "index.~a" ext)])
                          (copy-file
                            (format "~a/contract/~a" target-file-name fn)
                            (format "~a/~a" contract-dir fn))))
                      '("d.ts" "js" "js.map"))
                    (let ([_contractCode (format "_$~d~a" javascript-counter contractCode)])
                      (fprintf javascript-op "import * as ~a from '../~a/index.js'\n" _contractCode contract-dir)
                      (set! contractCode* (cons (cons contractCode _contractCode) contractCode*))
                      (set! test-root* (cons test-root test-root*)))
                    (unless (null? line*)
                      (fprintf javascript-op "{\n")
                      (for-each
                        (lambda (a test-root)
                          (fprintf javascript-op "  const ~a = { ...~a, zkirDir: '~a' };\n" (car a) (cdr a) (format "../~a/zkir" test-root)))
                        (reverse contractCode*) (reverse test-root*))
                      (fprintf javascript-op "  describe('~a', () => {\n" desc)
                      (fprintf javascript-op "~{    ~a\n~}" line*)
                      (fprintf javascript-op "  })\n}\n"))))
                #t))))
      (define (run-javascript)
        (when javascript-op
          (close-output-port javascript-op)
          (let ([t (current-time)])
            (printf "\\\\\\\\ Starting ~s.\n" 'run-javascript)
            (let-values ([(stdout stderr) (shell (format "exec test-center/run-test ~a" javascript-fn))])
              (let ([t (time-difference (current-time) t)])
                (let ([success? (and (equal? stdout "success\n") (equal? stderr ""))])
                  (unless success?
                    (let () (import (go)) (failed #t))
                    (printf "test 1 failed: 'run-test ~a' produced:\n~a~a"
                            javascript-fn stderr stdout))
                  (printf "//// Completed ~s with ~s/~s passing in ~,2fs.\n"
                          'run-javascript
                          (if success? 1 0)
                          1
                          (/ (+ (* (time-second t) (expt 10 9))
                                (time-nanosecond t))
                             (expt 10 9)))))))
          (set! javascript-op #f))))
    )
)

(run-tests parse-file/format/reparse
  (test
    '(
      "// a"
      "// b"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "// a"
        "// b"))
    )

  (test
    "compiler/standard-library.compact"
    (succeeds)
    )

  (test
    '(
      "circuit foo() : Bytes<20> { return 'Hello world!'; }"
      )
    (returns
      (program
        (circuit #f #f foo () ()
            (tbytes 20)
          (block (return ,(string->utf8 "Hello world!"))))))
    )

  (test
    '(
      "contract C {"
      "  circuit foo(x: Bytes<32>): [];"
      "  pure circuit bar(): Bytes<32>;"
      "}"
      )
    (returns
      (program
        (external-contract #f C
          (#f foo ([x (tbytes 32)]) (ttuple))
          (#t bar () (tbytes 32)))))
    )

  (test
    '(
      "export circuit f(): [] {}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit f(): [] {"
        "}"))
    )

  (test
    '(
      "export // ?"
      "  circuit f(): [] {}"
      )
    (returns (program (circuit #t #f f () () (ttuple) (block))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export // ?"
        "circuit f(): [] {"
        "}"))
    )

  (test
    '(
      "module M {"
      "  export // ?"
      "    circuit f(): [] {}"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "module M {"
        "  export // ?"
        "  circuit f(): [] {"
        "  }"
        "}"))
    )

  (test
    '(
      "export circuit f(): [] {}"
      "export circuit g(): [] {}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit f(): [] {"
        "}"
        ""
        "export circuit g(): [] {"
        "}"))
    )

  (test
    '(
      "module M {"
      "  export circuit f(): [] {}"
      "  export circuit g(): [] {}"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "module M {"
        "  export circuit f(): [] {"
        "  }"
        "  export circuit g(): [] {"
        "  }"
        "}"))
    )

  (test
    '(
      "module M {"
      "  /*"
      "     1 2 3"
      "  */"
      "  export circuit f(): [] {}"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "module M {"
        "  /*"
        "     1 2 3"
        "  */"
        "  export circuit f(): [] {"
        "  }"
        "}"))
    )

  (test
    '(
      "module M {"
      "  struct S { x: Field, y: Field, /* z: Field */ }"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "module M {"
        "  struct S {"
        "    x: Field,"
        "    y: Field,"
        "    /* z: Field */"
        "  }"
        "}"))
    )

  (test
    '(
      "module M {"
      "  struct S { x: Field, y: Field /* cool, right? */ } // end of struct S"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "module M {"
        "  struct S {"
        "    x: Field,"
        "    y: Field"
        "    /* cool, right? */"
        "  } // end of struct S"
        "}"))
    )

  (test
    '(
      "module M {"
      "  struct S { x: Uint<16>, y: Field /* cool, right? */, }"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "module M {"
        "  struct S {"
        "    x: Uint<16>,"
        "    y: Field /* cool, right? */,"
        "  }"
        "}"))
    )

  (test
    '(
      "export circuit foo(): Field {"
      "  return 'gotta love strings\n that span multiple lines' as Field;"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit foo(): Field {"
        "  return 'gotta love strings"
        " that span multiple lines'"
        "         as Field;"
        "}"))
    )

  (test
    '(
      "export circuit"
      "foo(v: Vector<3, Field>):"
      "    Field { /* let's try a"
      "               multiline block comment"
      "               stuck out here"
      "            */"
      "  return fold((add), 1, v);"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit foo(v: Vector<3, Field>): Field { /* let's try a"
        "                                                    multiline block comment"
        "                                                    stuck out here"
        "                                                 */"
        "  return fold((add), 1, v);"
        "}"))
    )

  (test
    '(
      "export circuit"
      "foo(): Field {"
      "  return /*0*/ 1 /*1*/, 2, /*2*/ 3 /*3*/;"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit foo(): Field {"
        "  return /*0*/ 1 /*1*/, 2, /*2*/ 3 /*3*/;"
        "}"))
    )

  (test
    '(
      "export {} /* export nothing! */"
      "export { E, S } /* export E and S */"
      "export { bar } /* export bar */"
      "enum E { num };"
      "struct S { x: Uint<8>, y: [E], };"
      "/*"
      "   blank lines in block comments ..."
      ""
      ""
      ""
      "... should be preserved."
      "*/"
      "circuit foo(): [Field, Boolean, S] {"
      "  const s = S { 15, E.num };"
      "  return [17, true, S {...s, x: s.x + 7}];"
      "}"
      "export circuit bar(): [E, Field] {"
      "  const [a, , { x, y : [z] }] = foo();"
      "  return [z, a + x];"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export { } /* export nothing! */"
        ""
        "export { E, S } /* export E and S */"
        ""
        "export { bar } /* export bar */"
        ""
        "enum E {"
        "  num"
        "};"
        ""
        "struct S {"
        "  x: Uint<8>,"
        "  y: [E],"
        "};"
        ""
        "/*"
        "   blank lines in block comments ..."
        ""
        ""
        ""
        "... should be preserved."
        "*/"
        "circuit foo(): [Field, Boolean, S] {"
        "  const s = S { 15, E.num };"
        "  return [17, true, S { ...s, x: s.x + 7 }];"
        "}"
        ""
        "export circuit bar(): [E, Field] {"
        "  const [a,, {x, y: [z]}] = foo();"
        "  return [z, a + x];"
        "}"))
    )

  (test
    '(
      "enum State {"
      "  no_game,"
      "  red_started,   // First player."
      "  blue_started,  // Ready to start."
      "  red_turn,"
      "  blue_turn,"
      "  red_wins,      // Game over."
      "  blue_wins"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "enum State {"
        "  no_game,"
        "  red_started, // First player."
        "  blue_started, // Ready to start."
        "  red_turn,"
        "  blue_turn,"
        "  red_wins, // Game over."
        "  blue_wins"
        "}"))
    )

  (test
    '(
      "circuit foo(): S { return S {}; }"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): S {"
        "  return S { };"
        "}"))
    )

  (test
    '(
      "circuit red_guess(pos: Field): Field { return pos; }"
      "circuit blue_guess(pos: Field): Field { return pos; }"
      "export circuit f(player_is_red: Boolean, position: Field): [] {"
      "return disclose(player_is_red ? red_guess(position) : blue_guess(position));"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit red_guess(pos: Field): Field {"
        "  return pos;"
        "}"
        ""
        "circuit blue_guess(pos: Field): Field {"
        "  return pos;"
        "}"
        ""
        "export circuit f(player_is_red: Boolean, position: Field): [] {"
        "  return disclose(player_is_red ? red_guess(position) : blue_guess(position));"
        "}"))
    )

  (test
    '(
      "circuit foo(pos: Uint<32>): Boolean {"
      "return pos == 1 || pos == 2 || pos == 3 || pos == 4 || pos == 5 || pos == 6 || pos == 7 || pos == 8 || pos == 9;"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(pos: Uint<32>): Boolean {"
        "  return pos == 1 ||"
        "         pos == 2 ||"
        "         pos == 3 ||"
        "         pos == 4 ||"
        "         pos == 5 ||"
        "         pos == 6 ||"
        "         pos == 7 ||"
        "         pos == 8 ||"
        "         pos == 9;"
        "}"))
    )

  (test
    '(
      "circuit foo(pos: Uint<32>): Uint<64> {"
      "return pos + 1 + pos - 2 + pos - 3 + pos - 4 + pos - 5 + pos - 6 + pos - 7 + pos - 8 + pos - 9;"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(pos: Uint<32>): Uint<64> {"
        "  return pos +"
        "         1 +"
        "         pos -"
        "         2 +"
        "         pos -"
        "         3 +"
        "         pos -"
        "         4 +"
        "         pos -"
        "         5 +"
        "         pos -"
        "         6 +"
        "         pos -"
        "         7 +"
        "         pos -"
        "         8 +"
        "         pos -"
        "         9;"
        "}"))
    )

  (test
    '(
      "ledger f1: Bytes<17>;"
      "ledger f2: Counter;"
      "export circuit foo(): [] {"
      "  f1 = pad(32, 'hello');"
      "  f2 += 3;"
      "  f2 -= 2;"
      "  return;"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "ledger f1: Bytes<17>;"
        ""
        "ledger f2: Counter;"
        ""
        "export circuit foo(): [] {"
        "  f1 = pad(32, 'hello');"
        "  f2 += 3;"
        "  f2 -= 2;"
        "  return;"
        "}"))
    )

  (test
    '(
      "     /* fun with tabs"
      "\tshould line up"
      " \tshould line up"
      "  \tshould line up"
      "   \tshould line up"
      "    \tshould line up"
      "     \tshould line up"
      "      \tshould line up"
      "       \tshould line up"
      "        should line up"
      "    */"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "/* fun with tabs"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "*/"))
    )

  (test
    '(
      "         /* fun with tabs"
      "\t    should line up"
      " \t    should line up"
      "  \t    should line up"
      "   \t    should line up"
      "    \t    should line up"
      "     \t    should line up"
      "      \t    should line up"
      "       \t    should line up"
      "            should line up"
      "    */"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "/* fun with tabs"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "*/"))
    )

  (test
    '(
      "// Hi!"
      "/* what's up? */"
      ""
      "/*0*/ module /*1*/ M /*3*/ { /*4*/"
      "  /*5*/"
      "  export module N<#N, T> {"
      "  }"
      ""
      "  export struct S { x: Uint<16>, y: Uint<0..78> }"
      "/*6*/}"
      ""
      "import M;"
      ""
      "import N<3, Field>;"
      ""
      "enum E { pepperoni, sausage, onions, /* beans, */ anchovies, peppers/*, mayonaise */}"
      ""
      "export contract C { circuit foo(x: A): [], pure circuit bar(): A }"
      ""
      "export /* here are the exports */ { a, b }"
      ""
      "export {"
      "         // redundant, isn't it?"
      "         a, b }"
      "export {// redundant, isn't it?"
      "        a, b }"
      "export {a,"
      "        // redundant, isn't it?"
      "        b }"
      ""
      "sealed ledger L: C;"
      ""
      "export circuit foo<T>(x: T, y: Field): Vector<3, T>;"
      ""
      "circuit rat(): Vector<1, Vector<2, S>> {"
      "  const q = S {x: 3, y: 4};"
      "  const q = // S is ..."
      "            S {x: 3, y: 4};"
      "  const q ="
      "            // S is ..."
      "            S {x: 3, y: 4};"
      "  // this for loop is ..."
      "  for (const x of 3..7) { // why?"
      "    assert((bar(true ? x : q), x != 1), 'oops');"
      "  }"
      "  return [[q, S {x: 5, y: 6}]];"
      "}"
      ""
      "export pure circuit sum(v: Vector<3, Field>): Field {"
      "  return fold((a, x) => a + x, 0, v);"
      "}"
      ""
      "constructor(c: C) {"
      "  L = c;"
      "  for (const x of /* vector coming: */ [1, 5, 7]) {"
      "    assert((x + x) * x != 1, 'oops');"
      "  }"
      "  /*0*/ if /*1*/ (/*2*/ L /*3*/"
      "                  /*4*/"
      "                  /*5*/ == /*6*/"
      "                  /*7*/"
      "                  /*8*/ 12 /*9*/"
      "                  /*10*/"
      "                  /*11*/ ) /*12*/"
      "    /*13*/"
      "    /*14*/ L /*15*/ = /*16*/ 24 /*17*/; /*18*/"
      "    /*19*/"
      "  /*20*/ else /*21*/"
      "    /*22*/"
      "    L = 0;"
      "  /*23*/"
      "/*24*/ } /*25*/"
      ""
      "// and that's the program."
      "// nada mas."
      )
    (returns
      (program
        (module #f M ()
          (module #t N ((nat-valued N) T))
          (struct #t S () [x (tunsigned 16)] [y (tunsigned 0 78)]))
        (import M () "")
        (import N (3 (tfield)) "")
        (enum #f E pepperoni sausage onions anchovies peppers)
        (external-contract #t C
          (#f foo ([x (type-ref A)]) (ttuple))
          (#t bar () (type-ref A)))
        (export a b)
        (export a b)
        (export a b)
        (export a b)
        (public-ledger-declaration #f #t L (type-ref C))
        (external #t foo (T) ([x (type-ref T)] [y (tfield)])
             (tvector 3 (type-ref T)))
        (circuit #f #f rat () ()
             (tvector 1 (tvector 2 (type-ref S)))
          (block
            (const ([q (tundeclared) (new (type-ref S) (x 3) (y 4))]))
            (const ([q (tundeclared) (new (type-ref S) (x 3) (y 4))]))
            (const ([q (tundeclared) (new (type-ref S) (x 3) (y 4))]))
            (for x (tuple 3 4 5 6)
              (block
                (assert (seq (call bar (if #t x q)) (!= x 1)) "oops")))
            (return (tuple (tuple q (new (type-ref S) (x 5) (y 6)))))))
        (circuit #t #t sum () ([v (tvector 3 (tfield))])
             (tfield)
          (block
            (return
              (fold (circuit ([a (tundeclared)] [x (tundeclared)])
                         (tundeclared)
                      (return (+ a x)))
                0
                v))))
        (constructor ([c (type-ref C)])
          (block
            (= L c)
            (for x (tuple 1 5 7)
              (block (assert (!= (* (+ x x) x) 1) "oops")))
            (if (== L 12) (= L 24) (= L 0))))))
    )

  (test
    '(
      "enum E { A, B, C, };"
      "export circuit f(v: Vector<3, Uint<32>>, ): Vector<3, Uint<64>> {"
      "  return map((a, n) => a + n, v);"
      "}"
      )
    (returns
      (program
        (enum #f E A B C)
        (circuit #t #f f () ([v (tvector 3 (tunsigned 32))])
             (tvector 3 (tunsigned 64))
          (block
            (return
              (map (circuit ([a (tundeclared)] [n (tundeclared)])
                        (tundeclared)
                     (return (+ a n)))
                v))))))
    )

  (test
    '(
      "pragma compiler_version >= 0.0 && (!0.0.1 || < 3 || <= 4 && > 5) || 2.2.2222;"
      )
    (returns
      (program))
    )

  (test ;; FIXME uncomment composable contract in test.compact
    "test-center/compact/test.compact"
    (returns
      (program
        (include "empty")
        (import CompactStandardLibrary () "")
        (import CompactStandardLibrary () "" ())
        (module #f M ((nat-valued a) b)
          (struct #t frob () [q (tfield)])
          (struct #t pair ()
            [x (tfield)]
            [y (tvector (type-size-ref a) (type-ref b))])
          (circuit #t #f slicer () ([v (tvector 10 (tfield))])
               (tvector 5 (tfield))
            (block (return (tuple-slice v 3 5)))))
        (enum #f PublicState setup commit reveal final)
        (import M (5 (topaque "sisters")) "M$")
        (circuit #t #t foo () ([a (tboolean)] [b (tfield)])
             (tboolean)
          (block (return #f)))
        (circuit #t #f bar () ([a (tboolean)] [b (tboolean)])
             (type-ref M$frob)
          (block
            (const ([x (tundeclared) (call foo #t 17)]))
            (const ([y (tundeclared) (if a (if b 3 2) (if b 1 0))]))
            (const ([w (tboolean) (if a #t #f)]))
            (const ([v (tundeclared)
              (if a #f (fold foo #t (tuple-ref (tuple (tuple)) 0)))]))
            (if a
                (if b
                    (assert a "a should be true")
                    (if b (assert a "a should be true") (tuple)))
                (tuple))
            (if a
                (block (if b (assert a "a should be true") (tuple)))
                (block
                  (const ([v (tundeclared) a]))
                  (if b (assert v "a should be false") (tuple))))
            (fold (circuit ([b (tboolean)] [c (tboolean)] [d (tfield)])
                       (tboolean)
                    (block (return (if (and a b) c #f))))
              #t
              (tuple #f #t #t #f)
              (tuple 0 1 2 3))
            (tuple-ref (tuple 1 2 3 4) 2)
            (map foo (tuple #f #f #t #f) (tuple 1 2 3 4))
            (assert
              (== (elt-call kernel self) (elt-call kernel2 self))
              "oops")
            (return (new (type-ref M$frob) (elt-call x0 read)))))
        (witness #f C () ([a (tboolean)] [b (tbytes 10)])
             (tbytes 20))
        (witness #f W () ([a (tvector 7 (tvector 9 (tfield)))]
                          [b (topaque "bogeytype")])
             (ttuple))
        (circuit #t #f baz () ([b (tboolean)])
             (tunsigned 10)
          (block (return (disclose (cast (tunsigned 10) b)))))
        (circuit #t #f nullX () ()
             (tboolean)
          (block (return (default (tboolean)))))
        (public-ledger-declaration #f #f kernel2 (type-ref Kernel))
        (public-ledger-declaration #f #f x0 (tfield))
        (public-ledger-declaration #f #t x1 (type-ref Set (tfield)))
        (public-ledger-declaration #f #f x2 (type-ref Counter))
        (public-ledger-declaration #f #f
          x3
          (type-ref List (tfield)))
        (public-ledger-declaration #f #f
          x4
          (type-ref Map (tfield) (tboolean)))
        (public-ledger-declaration #f #f
          x5
          (type-ref MerkleTree 32 (tfield)))
        (public-ledger-declaration #f #f
          x6
          (type-ref HistoricMerkleTree 10 (tfield)))
        (public-ledger-declaration #f #f x7 (type-ref CoinInfo))
        (public-ledger-declaration #f #f
          x10
          (type-ref MerkleTreeDigest))
        (public-ledger-declaration #f #f
          x11
          (type-ref QualifiedCoinInfo))
        (public-ledger-declaration #f #f
          x13
          (type-ref ContractAddress))
        (public-ledger-declaration #f #f authority (tbytes 32))
        (public-ledger-declaration #f #f
          state
          (type-ref PublicState))
        (public-ledger-declaration #f #f
          topic
          (type-ref Maybe (topaque "string")))
        (public-ledger-declaration #f #f
          tally_yes
          (type-ref Counter))
        (public-ledger-declaration #f #f
          committed_votes
          (type-ref MerkleTree 10 (tbytes 32)))
        (public-ledger-declaration #f #f
          committed
          (type-ref Set (tbytes 32)))
        (public-ledger-declaration #f #f
          ciphertexts
          (topaque "Uint8Array"))
        (constructor ([state (tfield)])
          (block (for i (tuple) (+ state 1))))
        (circuit #f #f foosbar () ()
             (ttuple)
          (block (for i (tuple 3 2 1) (+ i 1))))
        (circuit #f #f ballot_repr () ()
             (tbytes 32)
          (block
            (return
              #vu8(121 101 115 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 0 0 0 0 0))))
        (circuit #f #f check_rel_ops () ([x (tunsigned 16)])
             (tboolean)
          (block
            (return
              (or (or (or (or (< x 100) (<= x 10)) (> x 40)) (>= x 45))
                  (!= x 10)))))))
    )

  (test ; just see if it succeeds
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it succeeds
    "examples/election.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/counter/contract/src/counter.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/welcome/contract/src/welcome.compact"
    (succeeds))

  (test
    "examples/tiny.compact"
    (succeeds))

  (test
    '(
      "circuit boring(x: Field, y: Field): Field {"
      "  return x + y;"
      "}"
      ""
      "circuit f(topic_param: Opaque<'string'>,"
      "          beneficiary_param: ZswapCoinPublicKey,"
      "          seedCoin: CoinInfo): []"
      "{ }
      "
      "circuit g(xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxtopic_param: Opaque<'string'>,"
      "         ): []"
      "{ }
      "
      "circuit g(xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxtopic_param: Opaque<'string'>,"
      "         ): []"
      "{ }
      "
      "circuit set_topic(topic_param: Opaque<'string'>,"
      "                  beneficiary_param: ZswapCoinPublicKey,"
      "                  seedCoin: CoinInfo): [] // Really minor - why not moving the closing paren and return type declaration to next line and why moving opening brace to the next line in this case?"
      "{"
      ""
      "pot.writeCoin(mergeCoinImmediate(pot, seedCoin),"
      "                      right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "return mintToken("
      "           dao_token_domain_separator(),"
      "           amount,"
      "           evolveNonce(0, coin.nonce),"
      "           left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));"
      ""
      "if (a)"
      "  return b;"
      ""
      "if (a)"
      "{"
      "  return b;"
      "}"
      ""
      "if (a)"
      "  return b;"
      "else"
      "  return c;"
      ""
      "if (a)"
      "  return b;"
      "else {"
      "  return c;"
      "}"
      ""
      "if (a)"
      "{"
      "  return b;"
      "} else"
      "  return c;"
      ""
      "if (a)"
      "{"
      "  return b;"
      "} else {"
      "  return c;"
      "}"
      ""
      "if (a < f(a))"
      "return mintToken("
      "           dao_token_domain_separator(),"
      "           amount,"
      "           evolveNonce(0, coin.nonce),"
      "           left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit boring(x: Field, y: Field): Field {"
        "  return x + y;"
        "}"
        ""
        "circuit f(topic_param: Opaque<'string'>,"
        "          beneficiary_param: ZswapCoinPublicKey,"
        "          seedCoin: CoinInfo"
        "          ): [] {"
        "}"
        ""
        "circuit g(xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxtopic_param: Opaque<'string'>,): [] {"
        "}"
        ""
        "circuit g(xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxtopic_param: Opaque<'string'>,"
        "          ): [] {"
        "}"
        ""
        "circuit set_topic("
        "          topic_param: Opaque<'string'>,"
        "          beneficiary_param: ZswapCoinPublicKey,"
        "          seedCoin: CoinInfo"
        "          ): [] // Really minor - why not moving the closing paren and return type declaration to next line and why moving opening brace to the next line in this case?"
        "{"
        ""
        "  pot.writeCoin("
        "    mergeCoinImmediate(pot, seedCoin),"
        "    right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
        "  return mintToken("
        "           dao_token_domain_separator(),"
        "           amount,"
        "           evolveNonce(0, coin.nonce),"
        "           left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));"
        ""
        "  if (a) return b;"
        ""
        "  if (a) {"
        "    return b;"
        "  }"
        ""
        "  if (a)"
        "     return b;"
        "  else"
        "     return c;"
        ""
        "  if (a)"
        "     return b;"
        "  else {"
        "     return c;"
        "  }"
        ""
        "  if (a) {"
        "     return b;"
        "  } else"
        "     return c;"
        ""
        "  if (a) {"
        "     return b;"
        "  } else {"
        "     return c;"
        "  }"
        ""
        "  if (a < f(a))"
        "    return mintToken("
        "             dao_token_domain_separator(),"
        "             amount,"
        "             evolveNonce(0, coin.nonce),"
        "             left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));"
        "}"))
    )

  (test
    '(
      "circuit foo(): Bytes<100> {"
      "  return pad(100, "
      "'howdy"
      "y\\'all!'"
      ")"
      ";"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Bytes<100> {"
        "  return pad(100, 'howdy"
        "y\\'all!');"
        "}"))
    )

  (test
    '(
      "circuit foo(): Field {"
      "   // return 3"
      ""
      " // on second thought, return 4"
      ""
      "    return 4;"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  // return 3"
        ""
        "  // on second thought, return 4"
        ""
        "  return 4;"
        "}"))
    )

  (test
    '(
      "// test trailing commas in parameter lists, calls, and more"
      "import CompactStandardLibrary;"
      "contract C {"
      "  circuit cf(a: Uint<16>,): [],"
      "}"
      "ledger state: Map<Uint<8>, Field,>;"
      "constructor(a: Uint<8>, c: C) {"
      "  c.cf(a,);"
      "  state.insert(a, a,);"
      "}"
      "circuit f1(a: Field, b: Uint<8>,): Field {"
      "  return a * b;"
      "}"
      "export circuit f2(a: Uint<16>, b: Uint<8>,): Field {"
      "  return f1(a, b,) + f1(b, a as Uint<8>,);"
      "}"
      "export circuit f3(a: Vector<7, Uint<8>>,): Field {"
      "  return fold(f1, state.lookup(a[3],), a,);"
      "}"
      "export circuit f4(a: Vector<7, Uint<8>>,): Vector<7, Field> {"
      "  return map(f1, a, a,);"
      "}"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "// test trailing commas in parameter lists, calls, and more"
        "import CompactStandardLibrary;"
        ""
        "contract C { circuit cf(a: Uint<16>,): [],}"
        ""
        "ledger state: Map<Uint<8>, Field,>;"
        ""
        "constructor(a: Uint<8>, c: C) {"
        "  c.cf(a,);"
        "  state.insert(a, a,);"
        "}"
        ""
        "circuit f1(a: Field, b: Uint<8>,): Field {"
        "  return a * b;"
        "}"
        ""
        "export circuit f2(a: Uint<16>, b: Uint<8>,): Field {"
        "  return f1(a, b,) + f1(b, a as Uint<8>,);"
        "}"
        ""
        "export circuit f3(a: Vector<7, Uint<8>>,): Field {"
        "  return fold(f1, state.lookup(a[3],), a,);"
        "}"
        ""
        "export circuit f4(a: Vector<7, Uint<8>>,): Vector<7, Field> {"
        "  return map(f1, a, a,);"
        "}"))
    (returns
      (program
        (import CompactStandardLibrary () "")
        (external-contract #f C
          (#f cf ([a (tunsigned 16)]) (ttuple)))
        (public-ledger-declaration #f #f
          state
          (type-ref Map (tunsigned 8) (tfield)))
        (constructor ([a (tunsigned 8)] [c (type-ref C)])
          (block (elt-call c cf a) (elt-call state insert a a)))
        (circuit #f #f f1 () ([a (tfield)] [b (tunsigned 8)])
             (tfield)
          (block (return (* a b))))
        (circuit #t #f f2 () ([a (tunsigned 16)] [b (tunsigned 8)])
             (tfield)
          (block
            (return
              (+ (call f1 a b) (call f1 b (cast (tunsigned 8) a))))))
        (circuit #t #f f3 () ([a (tvector 7 (tunsigned 8))])
             (tfield)
          (block
            (return
              (fold f1 (elt-call state lookup (tuple-ref a 3)) a))))
        (circuit #t #f f4 () ([a (tvector 7 (tunsigned 8))])
             (tvector 7 (tfield))
          (block (return (map f1 a a))))))
    )

  ; tests that 'trailing' commas are not permitted in empty comma- and semicolon-separated sequences
  (test
    '(
      "import CompactStandardLibrary;"
      "ledger state: Q<,>"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 17" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a generic argument" "\">\""))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger state: Map<Uint<8>, Field,>;"
      "constructor(,) {"
      "  assert(state.isEmpty(), 'oops');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 13" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a typed pattern" "\")\""))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger state: Map<Uint<8>, Field,>;"
      "constructor() {"
      "  assert(state.isEmpty(,), 'oops');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 24" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression" "\")\""))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "contract C { ; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 14" "parse error: found ~a looking for~?" ("\";\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an external contract circuit" "\"}\""))))
    )

  (test
    '(
      "struct S { x: Uint<16>, y: Uint<0..78> }"
      "circuit rat(): Vector<1, Vector<2, S>> {"
      "  const q = S {x: 3, y: 4}, x = 1;"
      "  const q = // S is ..."
      "            S {x: 3, y: 4};"
      "  const q ="
      "            // S is ..."
      "            S {x: 3, y: 4};"
      "  return [[q, S {x: 5, y: 6}]];"
      "}"
      )
    (returns
      (program
        (struct #f S () [x (tunsigned 16)] [y (tunsigned 0 78)])
        (circuit #f #f rat () ()
             (tvector 1 (tvector 2 (type-ref S)))
          (block
            (const ([q (tundeclared) (new (type-ref S) (x 3) (y 4))]
                    [x (tundeclared) 1]))
            (const ([q (tundeclared) (new (type-ref S) (x 3) (y 4))]))
            (const ([q (tundeclared) (new (type-ref S) (x 3) (y 4))]))
            (return
              (tuple (tuple q (new (type-ref S) (x 5) (y 6)))))))))
    )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const x = 2, y = 22 + n,;"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 27" "parse error: found ~a looking for~?" ("\";\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a const binding"))))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const x = 2, y = 22 + n;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (const ([x (tundeclared) 2] [y (tundeclared) (+ 22 n)]))
            (return y)))))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const [x, y] = [a, 12], [a, b] = [1, 2];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (const ([(x y) (tundeclared) (tuple a 12)]
                    [(a b) (tundeclared) (tuple 1 2)]))
            (return y)))))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const [x, y] = [a, 12] // something something"
     "               , [a, b] = [1, 2];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (const ([(x y) (tundeclared) (tuple a 12)]
                    [(a b) (tundeclared) (tuple 1 2)]))
            (return y)))))
   )

  (test
    '(
      "export circuit bar(v: Vector<2, Field>, i: Vector<2, Field>): Vector<4, Field> {"
      "  return [...v, ...i];"
      "}"
      )
    (returns
      (program
        (circuit #t #f bar () ([v (tvector 2 (tfield))]
                               [i (tvector 2 (tfield))])
             (tvector 4 (tfield))
          (block (return (tuple (spread v) (spread i)))))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit bar(v: Vector<2, Field>, i: Vector<2, Field>): Vector<4, Field> {"
        "  return [...v, ...i];"
        "}"))
    )

  (test
    '(
      "export circuit foo(v: Vector<6, Field>): [Field, Field] {"
      "  const k = 2;"
      "  return slice(v, k);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 15" "parse error: found ~a looking for~?" ("\"(\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\"<\""))))
    )

  (test
    '(
      "export circuit foo(v: Vector<6, Field>): [Field, Field] {"
      "  const k = 2;"
      "  return slice<k>(v, k);"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([v (tvector 6 (tfield))])
             (ttuple (tfield) (tfield))
          (block
            (const ([k (tundeclared) 2]))
            (return (tuple-slice v k (type-size-ref k)))))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit foo(v: Vector<6, Field>): [Field, Field] {"
        "  const k = 2;"
        "  return slice<k>(v, k);"
        "}"))
    )

  (test
    '(
      "export circuit foo(v: Vector<6, Field>): [Field, Field] {"
      "  const k = 2;"
      "  return slice<2>(v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 20" "parse error: found ~a looking for~?" ("\")\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\",\"" "\"||\"" "\"&&\"" "\"==\"" "\"!=\"" "\"as\"" "\"+\"" "\"-\"" "\"*\"" "\"[\"" "\".\"" "\"?\"" "\"=\"" "\"+=\"" "\"-=\"" "\"<\"" "\"<=\"" "\">=\"" "\">\"" "\"(\"" "\"{\"" "a generic argument list"))))
    )

  (test
    '(
      "export circuit foo(v: Vector<6, Field>): [Field, Field] {"
      "  const k = 2;"
      "  return slice<2>(v, k, k);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 23" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\")\"" "\"||\"" "\"&&\"" "\"==\"" "\"!=\"" "\"as\"" "\"+\"" "\"-\"" "\"*\"" "\"[\"" "\".\"" "\"?\"" "\"=\"" "\"+=\"" "\"-=\"" "\"<\"" "\"<=\"" "\">=\"" "\">\"" "\"(\"" "\"{\"" "a generic argument list"))))
    )

  (test
    '(
      "export circuit foo(v: Vector<6,Field>): [Field,Field] {"
      "  return slice<2>(v, 2);"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([v (tvector 6 (tfield))])
             (ttuple (tfield) (tfield))
          (block (return (tuple-slice v 2 2))))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit foo(v: Vector<6, Field>): [Field, Field] {"
        "  return slice<2>(v, 2);"
        "}"))
    )

  (test
    '(
      "export circuit foo(v: [Field, Field, Field]): [Field, Field] {"
      "  const k = 2;"
      "  return slice<2>(v, k);"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([v (ttuple
                                    (tfield)
                                    (tfield)
                                    (tfield))])
             (ttuple (tfield) (tfield))
          (block
            (const ([k (tundeclared) 2]))
            (return (tuple-slice v k 2))))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit foo(v: [Field, Field, Field]): [Field, Field] {"
        "  const k = 2;"
        "  return slice<2>(v, k);"
        "}"))
    )

  (test
    '(
      "export circuit foo(v: Vector<6, Field>): [Field, Field] {"
      "  const k = 2;"
      "  return slice<2>(v, k);"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([v (tvector 6 (tfield))])
             (ttuple (tfield) (tfield))
          (block
            (const ([k (tundeclared) 2]))
            (return (tuple-slice v k 2))))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit foo(v: Vector<6, Field>): [Field, Field] {"
        "  const k = 2;"
        "  return slice<2>(v, k);"
        "}"))
    )

  (test
    '(
      "circuit foo() : Field { return 0b110; }"
      )
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 6)))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  return 0b110;"
        "}"))
    )

  (test
    '(
      "circuit foo() : Field { return 0B110; }"
      )
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 6)))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  return 0B110;"
        "}"))
    )

  (test
    '(
      "circuit foo() : Field { return 0o177; }"
      )
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 127)))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  return 0o177;"
        "}"))
    )

  (test
    '(
      "circuit foo() : Field { return 0O177; }"
      )
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 127)))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  return 0O177;"
        "}"))
    )

  (test
    '(
      "circuit foo() : Field { return 0x177; }"
      )
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 375)))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  return 0x177;"
        "}"))
    )

  (test
    '(
      "circuit foo() : Field { return 0X177; }"
      )
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 375)))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  return 0X177;"
        "}"))
    )

  (test
    '(
      "circuit foo() : Field { return 0XabcdefABCDEF0123456789; }"
      )
    (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block (return #xabcdefABCDEF0123456789)))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  return 0XabcdefABCDEF0123456789;"
        "}"))
    )

  (test
    '(
      "circuit foo() : Field { return 0xAbCdEfaBcDeF0123456789; }"
      )
    (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block (return #xabcdefABCDEF0123456789)))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  return 0xAbCdEfaBcDeF0123456789;"
        "}"))
    )

  (test
    '(
      "export circuit inc(v: Vector<3, [Boolean, Boolean]>): Vector<3, Boolean> {"
      "return map(([a, b]) =>  a && b , v);"
      "}"
      )
    (returns
      (program
        (circuit #t #f inc () ([v (tvector
                                    3
                                    (ttuple (tboolean) (tboolean)))])
             (tvector 3 (tboolean))
          (block
            (return
              (map (circuit ([(a b) (tundeclared)])
                        (tundeclared)
                     (return (and a b)))
                v))))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit inc(v: Vector<3, [Boolean, Boolean]>): Vector<3, Boolean> {"
        "  return map(([a, b]) => a && b, v);"
        "}"))
    )

  (test
    '(
      "export circuit sum(v: Vector<3, [Field, Field]>): Field {"
      "  return fold(([x, y]) => x + y, 0, v);"
      "}"
      )
    (returns
      (program
        (circuit #t #f sum () ([v (tvector
                                    3
                                    (ttuple (tfield) (tfield)))])
             (tfield)
          (block
            (return
              (fold (circuit ([(x y) (tundeclared)])
                         (tundeclared)
                      (return (+ x y)))
                0
                v))))))
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "export circuit sum(v: Vector<3, [Field, Field]>): Field {"
        "  return fold(([x, y]) => x + y, 0, v);"
        "}")))

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, , y] : [Field, , Field] = [1, 2, 3];"
      "  return x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 28" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a type" "\"]\"")))))

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, , y] : [Field, Field, Field] = [1, 2, 3];"
      "  return x;"
      "}"
      )
    (succeeds))

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, , y] : [Field, Field, Field] = [1, , 3];"
      "  return x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 48" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a tuple argument" "\"]\"")))))

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, , y] : [Field, Field, Field] = [1, 2];"
      "  return x;"
      "}"
      )
    (succeeds))

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a, } : S = S {1, true, false};"
      "  return a;"
      "}"
      )
    (succeeds))

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a, } : S = S {1, };"
      "  return a;"
      "}"
      )
    (succeeds))

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a, , c} : S = S {1, true, false};"
      "  return a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 13" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a pattern struct element" "\"}\"")))))

  (test
    '(
      "struct T {b: Field, a: Boolean}"
      "export circuit foo(T{a,  }: T) : Field { return a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 21" "parse error: found ~a looking for~?" ("\"{\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\":\""))))
    )

  (test
    '(
      "struct T {b: Field, a: Boolean}"
      "export circuit foo({a, ,  }: T) : Field { return a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 24" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a pattern struct element" "\"}\""))))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a, b, c} : S = S {1, true, };"
      "  return a;"
      "}"
      )
    (succeeds))

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a: x, } : S = S {1, true, false};"
      "  return x;"
      "}"
      )
    (succeeds))

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a: b, b } : S = S {1, true, false};"
      "  return a;"
      "}"
      )
    (succeeds))

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a: b, b: x } : S = S {1, true, false};"
      "  return a;"
      "}"
      )
    (succeeds))

  (test
    '(
      "struct SS {a: Field, b: Boolean, c : Boolean}"
      "struct S {b: Field, a: Boolean}"
      "circuit foo<T>({a, }: T) : Field { return a; }"
      "export circuit foo_S(x: S): Field { return foo<S>; }"
      "export circuit foo_SS(x: SS): Field { return foo<SS>; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 50" "parse error: found ~a looking for~?" ("\";\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\"(\"" "\"{\""))))
    )

  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    F = disclose(ix + ix);"
      "    return F;"
      "  }"
      "}"
      "import { foo as peter, foo as paul, foo as mary, foo } from M;"
      "import { foo as peter, foo as paul, foo as mary, foo } from M prefix M$;"
      "export { peter, paul, mary, foo };"
      "export { M$peter, M$paul, M$mary, M$foo };"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "module M {"
        "  export ledger F: Field;"
        "  export circuit foo(ix: Field): Field {"
        "    F = disclose(ix + ix);"
        "    return F;"
        "  }"
        "}"
        ""
        "import { foo as peter, foo as paul, foo as mary, foo } from M;"
        ""
        "import { foo as peter, foo as paul, foo as mary, foo } from M prefix M$;"
        ""
        "export { peter, paul, mary, foo };"
        ""
        "export { M$peter, M$paul, M$mary, M$foo };"))
    )

  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    F = disclose(ix + ix);"
      "    return F;"
      "  }"
      "}"
      "import { foo as peter, foo as paul, foo as mary, foo,"
      "         foo as red, foo as blue, foo as green, foo as yellow }"
      "  from M;"
      "export { foo, peter, paul, mary, red, blue, green, yellow };"
      )
    (output-file "compiler/testdir/formatter/testfile.compact"
      '(
        "module M {"
        "  export ledger F: Field;"
        "  export circuit foo(ix: Field): Field {"
        "    F = disclose(ix + ix);"
        "    return F;"
        "  }"
        "}"
        ""
        "import"
        "  { foo as peter,"
        "    foo as paul,"
        "    foo as mary,"
        "    foo,"
        "    foo as red,"
        "    foo as blue,"
        "    foo as green,"
        "    foo as yellow }"
        "  from M;"
        ""
        "export { foo, peter, paul, mary, red, blue, green, yellow };"))
    )
)

(run-tests parse-file/fixup/format/reparse
  (test
    '(
      "// a"
      "// b"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "// a"
        "// b"))
    )

  (test
    '(
      "export circuit f(): [] {}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "export circuit f(): [] {"
        "}"))
    )

  (test
    '(
      "export // ?"
      "  circuit f(): [] {}"
      )
    (returns (program (circuit #t #f f () () (ttuple) (block))))
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "export // ?"
        "circuit f(): [] {"
        "}"))
    )

  (test
    '(
      "module M {"
      "  export // ?"
      "    circuit f(): [] {}"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "module M {"
        "  export // ?"
        "  circuit f(): [] {"
        "  }"
        "}"))
    )

  (test
    '(
      "export circuit f(): [] {}"
      "export circuit g(): [] {}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "export circuit f(): [] {"
        "}"
        ""
        "export circuit g(): [] {"
        "}"))
    )

  (test
    '(
      "module M {"
      "  export circuit f(): [] {}"
      "  export circuit g(): [] {}"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "module M {"
        "  export circuit f(): [] {"
        "  }"
        "  export circuit g(): [] {"
        "  }"
        "}"))
    )

  (test
    '(
      "module M {"
      "  /*"
      "     1 2 3"
      "  */"
      "  export circuit f(): [] {}"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "module M {"
        "  /*"
        "     1 2 3"
        "  */"
        "  export circuit f(): [] {"
        "  }"
        "}"))
    )

  (test
    '(
      "module M {"
      "  struct S { x: Field, y: Field, /* z: Field */ }"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "module M {"
        "  struct S {"
        "    x: Field,"
        "    y: Field,"
        "    /* z: Field */"
        "  }"
        "}"))
    )

  (test
    '(
      "module M {"
      "  struct S { x: Field, y: Field /* cool, right? */ } // end of struct S"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "module M {"
        "  struct S {"
        "    x: Field,"
        "    y: Field"
        "    /* cool, right? */"
        "  } // end of struct S"
        "}"))
    )

  (test
    '(
      "module M {"
      "  struct S { x: Uint<16>, y: Field /* cool, right? */, }"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "module M {"
        "  struct S {"
        "    x: Uint<16>,"
        "    y: Field /* cool, right? */,"
        "  }"
        "}"))
    )

  (test
    '(
      "export circuit foo(): Field {"
      "  return 'gotta love strings\n that span multiple lines' as Field;"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "export circuit foo(): Field {"
        "  return 'gotta love strings"
        " that span multiple lines'"
        "         as Field;"
        "}"))
    )

  (test
    '(
      "export circuit"
      "foo(): Field {"
      "  return /*0*/ 1 /*1*/, 2, /*2*/ 3 /*3*/;"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "export circuit foo(): Field {"
        "  return /*0*/ 1 /*1*/, 2, /*2*/ 3 /*3*/;"
        "}"))
    )

  (test
    '(
      "enum State {"
      "  no_game,"
      "  red_started,   // First player."
      "  blue_started,  // Ready to start."
      "  red_turn,"
      "  blue_turn,"
      "  red_wins,      // Game over."
      "  blue_wins"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "enum State {"
        "  no_game,"
        "  red_started, // First player."
        "  blue_started, // Ready to start."
        "  red_turn,"
        "  blue_turn,"
        "  red_wins, // Game over."
        "  blue_wins"
        "}"))
    )

  (test
    '(
      "circuit foo(pos: Uint<32>): Boolean {"
      "return pos == 1 || pos == 2 || pos == 3 || pos == 4 || pos == 5 || pos == 6 || pos == 7 || pos == 8 || pos == 9;"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "circuit foo(pos: Uint<32>): Boolean {"
        "  return pos == 1 ||"
        "         pos == 2 ||"
        "         pos == 3 ||"
        "         pos == 4 ||"
        "         pos == 5 ||"
        "         pos == 6 ||"
        "         pos == 7 ||"
        "         pos == 8 ||"
        "         pos == 9;"
        "}"))
    )

  (test
    '(
      "circuit foo(pos: Uint<32>): Uint<64> {"
      "return pos + 1 + pos - 2 + pos - 3 + pos - 4 + pos - 5 + pos - 6 + pos - 7 + pos - 8 + pos - 9;"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "circuit foo(pos: Uint<32>): Uint<64> {"
        "  return pos +"
        "         1 +"
        "         pos -"
        "         2 +"
        "         pos -"
        "         3 +"
        "         pos -"
        "         4 +"
        "         pos -"
        "         5 +"
        "         pos -"
        "         6 +"
        "         pos -"
        "         7 +"
        "         pos -"
        "         8 +"
        "         pos -"
        "         9;"
        "}"))
    )

  (test
    '(
      "     /* fun with tabs"
      "\tshould line up"
      " \tshould line up"
      "  \tshould line up"
      "   \tshould line up"
      "    \tshould line up"
      "     \tshould line up"
      "      \tshould line up"
      "       \tshould line up"
      "        should line up"
      "    */"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "/* fun with tabs"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "*/"))
    )

  (test
    '(
      "         /* fun with tabs"
      "\t    should line up"
      " \t    should line up"
      "  \t    should line up"
      "   \t    should line up"
      "    \t    should line up"
      "     \t    should line up"
      "      \t    should line up"
      "       \t    should line up"
      "            should line up"
      "    */"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "/* fun with tabs"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "   should line up"
        "*/"))
    )

  (test
    '(
      "pragma compiler_version >= 0.0 && (!0.0.1 || < 3 || <= 4 && > 5) || 2.2.2222;"
      )
    (returns
      (program))
    )

  (test ; just see if it succeeds
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it succeeds
    "examples/election.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/counter/contract/src/counter.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/welcome/contract/src/welcome.compact"
    (succeeds))

  (test
    "examples/tiny.compact"
    (succeeds))

  (test
    '(
      "circuit foo(): Bytes<100> {"
      "  return pad(100, "
      "'howdy"
      "y\\'all!'"
      ")"
      ";"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "circuit foo(): Bytes<100> {"
        "  return pad(100, 'howdy"
        "y\\'all!');"
        "}"))
    )

  (test
    '(
      "circuit foo(): Field {"
      "   // return 3"
      ""
      " // on second thought, return 4"
      ""
      "    return 4;"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "circuit foo(): Field {"
        "  // return 3"
        ""
        "  // on second thought, return 4"
        ""
        "  return 4;"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger A: Map<Field, Field>;"
      "export circuit foo(x: Field): [] {"
      "  assert(A.is_empty(), 'oops1');"
      "  A.insert_default(x);"
      "  assert(!A.isEmpty(), 'oops2');"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "import CompactStandardLibrary;"
        ""
        "ledger A: Map<Field, Field>;"
        ""
        "export circuit foo(x: Field): [] {"
        "  assert(A.isEmpty(), 'oops1');"
        "  A.insertDefault(x);"
        "  assert(!A.isEmpty(), 'oops2');"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger A: Map<Field, Field>;"
      "module M1 {"
      "  export circuit public_key(sk: Bytes<32>): Bytes<32> {"
      "    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, 'welcome:pk:'), sk]);"
      "  }"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "import CompactStandardLibrary;"
        ""
        "ledger A: Map<Field, Field>;"
        ""
        "module M1 {"
        "  export circuit public_key(sk: Bytes<32>): Bytes<32> {"
        "    return persistentHash<Vector<2, Bytes<32>>>([pad(32, 'welcome:pk:'), sk]);"
        "  }"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger A: Map<Field, Field>;"
      "module M2 {"
      " // For now, at least, choosing not to warn about existing bindings for new"
      " // names since doing so in a way that makes sense, particularly in the face"
      " // of function overloading is complicated and expensive.  So no error for"
      " // the following even though it shadows the new standard library binding for"
      " // persistentHash, and no error for the refererence to persistent_hash below"
      " // even though renaming it will have the effect of changing it to a reference"
      " // to the local rather than standard-library binding"
      "  circuit persistentHash<a>(x: a): Bytes<32> { return default<Bytes<32>>; }"
      "  export circuit public_key(sk: Bytes<32>): Bytes<32> {"
      "    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, 'welcome:pk:'), sk]);"
      "  }"
      "}"
      )
    (warning
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 11 char 3" "existing binding of ~s may lead to unintended shadowing of renamed standard-library circuit ~:*~s" (persistentHash)))
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "import CompactStandardLibrary;"
        ""
        "ledger A: Map<Field, Field>;"
        ""
        "module M2 {"
        "  // For now, at least, choosing not to warn about existing bindings for new"
        "  // names since doing so in a way that makes sense, particularly in the face"
        "  // of function overloading is complicated and expensive.  So no error for"
        "  // the following even though it shadows the new standard library binding for"
        "  // persistentHash, and no error for the refererence to persistent_hash below"
        "  // even though renaming it will have the effect of changing it to a reference"
        "  // to the local rather than standard-library binding"
        "  circuit persistentHash<a>(x: a): Bytes<32> {"
        "    return default<Bytes<32>>;"
        "  }"
        "  export circuit public_key(sk: Bytes<32>): Bytes<32> {"
        "    return persistentHash<Vector<2, Bytes<32>>>([pad(32, 'welcome:pk:'), sk]);"
        "  }"
        "}"))
    (returns
      (program
        (import CompactStandardLibrary () "")
        (public-ledger-declaration #f #f
          A
          (type-ref Map (tfield) (tfield)))
        (module #f M2 ()
          (circuit #f #f persistentHash (a) ([x (type-ref a)])
               (tbytes 32)
            (block (return (default (tbytes 32)))))
          (circuit #t #f public_key () ([sk (tbytes 32)])
               (tbytes 32)
            (block
              (return
                (call (fref persistentHash (tvector 2 (tbytes 32)))
                  (tuple
                    #vu8(119 101 108 99 111 109 101 58 112 107 58 0 0 0 0 0 0 0
                         0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                    sk))))))))
    )

  (test
    '(
      "module M {"
      "  import CompactStandardLibrary;"
      "  export { persistent_hash };"
      "}"
      "import M prefix std$;"
      "export circuit public_key(sk: Bytes<32>): Bytes<32> {"
      "  return std$persistent_hash<Vector<2, Bytes<32>>>([pad(32, 'welcome:pk:'), sk]);"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "module M {"
        "  import CompactStandardLibrary;"
        "  export { persistentHash };"
        "}"
        ""
        "import M prefix std$;"
        ""
        "export circuit public_key(sk: Bytes<32>): Bytes<32> {"
        "  return std$persistentHash<Vector<2, Bytes<32>>>([pad(32, 'welcome:pk:'), sk]);"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger A: Map<Field, Field>;"
      "module M3 {"
      "  circuit persistent_hash<a>(x: a): Bytes<32> { return default<Bytes<32>>; }"
      "  export circuit public_key(sk: Bytes<32>): Bytes<32> {"
      "    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, 'welcome:pk:'), sk]);"
      "  }"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "import CompactStandardLibrary;"
        ""
        "ledger A: Map<Field, Field>;"
        ""
        "module M3 {"
        "  circuit persistent_hash<a>(x: a): Bytes<32> {"
        "    return default<Bytes<32>>;"
        "  }"
        "  export circuit public_key(sk: Bytes<32>): Bytes<32> {"
        "    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, 'welcome:pk:'), sk]);"
        "  }"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger A: Map<Field, Field>;"
      "export circuit foo(is_empty: Field): [] {"
      "  assert(A.is_empty(), 'oops1');"
      "  A.insert_default(is_empty);"
      "  assert(!A.isEmpty(), 'oops2');"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "import CompactStandardLibrary;"
        ""
        "ledger A: Map<Field, Field>;"
        ""
        "export circuit foo(is_empty: Field): [] {"
        "  assert(A.isEmpty(), 'oops1');"
        "  A.insertDefault(is_empty);"
        "  assert(!A.isEmpty(), 'oops2');"
        "}"))
    (returns
      (program
        (import CompactStandardLibrary () "")
        (public-ledger-declaration #f #f
          A
          (type-ref Map (tfield) (tfield)))
        (circuit #t #f foo () ([is_empty (tfield)])
             (ttuple)
          (block
            (assert (elt-call A isEmpty) "oops1")
            (elt-call A insertDefault is_empty)
            (assert (not (elt-call A isEmpty)) "oops2")))))
    )

  (test
    '(
      "circuit A<#t>(x: Uint<0..t>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<12>(x);"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "circuit A<#t>(x: Uint<0..t>): Field {"
        "  return x;"
        "}"
        ""
        "export circuit B(x: Uint<0..8>): Field {"
        "  return A<12>(x);"
        "}"))
    (returns
      (program
        (circuit #f #f A ((nat-valued t)) ([x (tunsigned
                                                0
                                                (type-size-ref t))])
             (tfield)
          (block (return x)))
        (circuit #t #f B () ([x (tunsigned 0 8)])
             (tfield)
          (block (return (call (fref A 12) x))))))
    )
)

(parameterize ([(let () (import (fixup)) update-Uint-ranges) #t])
(run-tests parse-file/fixup/format/reparse
  (test
    '(
      "ledger F: Uint<0..7>;"
      "export circuit foo(x: Uint<0..7>): Uint<0..7> {"
      "  F = disclose(x) * 2 as Uint<0..7>;"
      "  return F;"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "ledger F: Uint<0..8>;"
        ""
        "export circuit foo(x: Uint<0..8>): Uint<0..8> {"
        "  F = disclose(x) * 2 as Uint<0..8>;"
        "  return F;"
        "}"))
    (returns
      (program
        (public-ledger-declaration #f #f F (tunsigned 0 8))
        (circuit #t #f foo () ([x (tunsigned 0 8)])
             (tunsigned 0 8)
          (block
            (= F (cast (tunsigned 0 8) (* (disclose x) 2)))
            (return F)))))
    )

  (test
    '(
      "ledger F: Uint<0..7>;"
      "export circuit foo(x: Uint<0x0..0x7>): Uint<0o0..0o7> {"
      "  F = disclose(x) * 2 as Uint<0b0..0b111>;"
      "  return F;"
      "}"
      )
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "ledger F: Uint<0..8>;"
        ""
        "export circuit foo(x: Uint<0x0..0x8>): Uint<0o0..0o10> {"
        "  F = disclose(x) * 2 as Uint<0b0..0b1000>;"
        "  return F;"
        "}"))
    (returns
      (program
        (public-ledger-declaration #f #f F (tunsigned 0 8))
        (circuit #t #f foo () ([x (tunsigned 0 8)])
             (tunsigned 0 8)
          (block
            (= F (cast (tunsigned 0 8) (* (disclose x) 2)))
            (return F)))))
    )

  (test
    '(
      "module M<#N> {"
      "  ledger F: Uint<0..N>;"
      "  export circuit foo(x: Uint<0..N>): Uint<0..N> {"
      "    F = disclose(x) * 2 as Uint<0..N>;"
      "    return F + N as Uint<0..N>;"
      "  }"
      "}"
      "import M<7>;"
      "export { foo };"
      )
    (warning
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 21" "Uint range end expressed as a reference to generic size ~a is left unchanged and must be updated manually" (N))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 33" "Uint range end expressed as a reference to generic size ~a is left unchanged and must be updated manually" (N))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 46" "Uint range end expressed as a reference to generic size ~a is left unchanged and must be updated manually" (N))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 36" "Uint range end expressed as a reference to generic size ~a is left unchanged and must be updated manually" (N))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 29" "Uint range end expressed as a reference to generic size ~a is left unchanged and must be updated manually" (N)))
    (returns
      (program
        (module #f M ((nat-valued N))
          (public-ledger-declaration #f #f
            F
            (tunsigned 0 (type-size-ref N)))
          (circuit #t #f foo () ([x (tunsigned 0 (type-size-ref N))])
               (tunsigned 0 (type-size-ref N))
            (block
              (= F
                 (cast (tunsigned 0 (type-size-ref N)) (* (disclose x) 2)))
              (return (cast (tunsigned 0 (type-size-ref N)) (+ F N))))))
        (import M (7) "")
        (export foo)))
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "module M<#N> {"
        "  ledger F: Uint<0..N>;"
        "  export circuit foo(x: Uint<0..N>): Uint<0..N> {"
        "    F = disclose(x) * 2 as Uint<0..N>;"
        "    return F + N as Uint<0..N>;"
        "  }"
        "}"
        ""
        "import M<7>;"
        ""
        "export { foo };"))
    )

  (test
    '(
      "circuit A<#t>(x: Uint<0..t>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..7>): Field {"
      "  return A<12>(x);"
      "}"
      )
    (warning
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 26" "Uint range end expressed as a reference to generic size ~a is left unchanged and must be updated manually" (t)))
    (output-file "compiler/testdir/fixup/testfile.compact"
      '(
        "circuit A<#t>(x: Uint<0..t>): Field {"
        "  return x;"
        "}"
        ""
        "export circuit B(x: Uint<0..8>): Field {"
        "  return A<12>(x);"
        "}"))
    (returns
      (program
        (circuit #f #f A ((nat-valued t)) ([x (tunsigned
                                                0
                                                (type-size-ref t))])
             (tfield)
          (block (return x)))
        (circuit #t #f B () ([x (tunsigned 0 8)])
             (tfield)
          (block (return (call (fref A 12) x))))))
    )
))

(run-tests parse-file
  (test
    '(
      "circuit foo() : Bytes<20> { return 'Hello world!'; }"
      )
    (returns
      (program
        (circuit #f #f foo () ()
            (tbytes 20)
          (block (return ,(string->utf8 "Hello world!"))))))
    )

  (test ;; FIXME uncomment composable contract in test.compact
    "test-center/compact/test.compact"
    (returns
      (program
        (include "empty")
        (import CompactStandardLibrary () "")
        (import CompactStandardLibrary () "" ())
        (module #f M ((nat-valued a) b)
          (struct #t frob () [q (tfield)])
          (struct #t pair ()
            [x (tfield)]
            [y (tvector (type-size-ref a) (type-ref b))])
          (circuit #t #f slicer () ([v (tvector 10 (tfield))])
               (tvector 5 (tfield))
            (block (return (tuple-slice v 3 5)))))
        (enum #f PublicState setup commit reveal final)
        (import M (5 (topaque "sisters")) "M$")
        (circuit #t #t foo () ([a (tboolean)] [b (tfield)])
             (tboolean)
          (block (return #f)))
        (circuit #t #f bar () ([a (tboolean)] [b (tboolean)])
             (type-ref M$frob)
          (block
            (const ([x (tundeclared) (call foo #t 17)]))
            (const ([y (tundeclared) (if a (if b 3 2) (if b 1 0))]))
            (const ([w (tboolean) (if a #t #f)]))
            (const ([v
                     (tundeclared)
                     (if a #f (fold foo #t (tuple-ref (tuple (tuple)) 0)))]))
            (if a
                (if b
                    (assert a "a should be true")
                    (if b (assert a "a should be true") (tuple)))
                (tuple))
            (if a
                (block (if b (assert a "a should be true") (tuple)))
                (block
                  (const ([v (tundeclared) a]))
                  (if b (assert v "a should be false") (tuple))))
            (fold (circuit ([b (tboolean)] [c (tboolean)] [d (tfield)])
                       (tboolean)
                    (block (return (if (and a b) c #f))))
              #t
              (tuple #f #t #t #f)
              (tuple 0 1 2 3))
            (tuple-ref (tuple 1 2 3 4) 2)
            (map foo (tuple #f #f #t #f) (tuple 1 2 3 4))
            (assert
              (== (elt-call kernel self) (elt-call kernel2 self))
              "oops")
            (return (new (type-ref M$frob) (elt-call x0 read)))))
        (witness #f C () ([a (tboolean)] [b (tbytes 10)])
             (tbytes 20))
        (witness #f W () ([a (tvector 7 (tvector 9 (tfield)))]
                          [b (topaque "bogeytype")])
             (ttuple))
        (circuit #t #f baz () ([b (tboolean)])
             (tunsigned 10)
          (block (return (disclose (cast (tunsigned 10) b)))))
        (circuit #t #f nullX () ()
             (tboolean)
          (block (return (default (tboolean)))))
        (public-ledger-declaration #f #f kernel2 (type-ref Kernel))
        (public-ledger-declaration #f #f x0 (tfield))
        (public-ledger-declaration #f #t x1 (type-ref Set (tfield)))
        (public-ledger-declaration #f #f x2 (type-ref Counter))
        (public-ledger-declaration #f #f
          x3
          (type-ref List (tfield)))
        (public-ledger-declaration #f #f
          x4
          (type-ref Map (tfield) (tboolean)))
        (public-ledger-declaration #f #f
          x5
          (type-ref MerkleTree 32 (tfield)))
        (public-ledger-declaration #f #f
          x6
          (type-ref HistoricMerkleTree 10 (tfield)))
        (public-ledger-declaration #f #f
          x7
          (type-ref CoinInfo))
        (public-ledger-declaration #f #f
          x10
          (type-ref MerkleTreeDigest))
        (public-ledger-declaration #f #f
          x11
          (type-ref QualifiedCoinInfo))
        (public-ledger-declaration #f #f
          x13
          (type-ref ContractAddress))
        (public-ledger-declaration #f #f authority (tbytes 32))
        (public-ledger-declaration #f #f
          state
          (type-ref PublicState))
        (public-ledger-declaration #f #f
          topic
          (type-ref Maybe (topaque "string")))
        (public-ledger-declaration #f #f
          tally_yes
          (type-ref Counter))
        (public-ledger-declaration #f #f
          committed_votes
          (type-ref MerkleTree 10 (tbytes 32)))
        (public-ledger-declaration #f #f
          committed
          (type-ref Set (tbytes 32)))
        (public-ledger-declaration #f #f
          ciphertexts
          (topaque "Uint8Array"))
        (constructor ([state (tfield)])
          (block (for i (tuple) (+ state 1))))
        (circuit #f #f foosbar () ()
             (ttuple)
          (block (for i (tuple 3 2 1) (+ i 1))))
        (circuit #f #f ballot_repr () ()
             (tbytes 32)
          (block
            (return
              #vu8(121 101 115 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 0 0 0 0 0))))
        (circuit #f #f check_rel_ops () ([x (tunsigned 16)])
             (tboolean)
          (block
            (return
              (or (or (or (or (< x 100) (<= x 10)) (> x 40)) (>= x 45))
                  (!= x 10)))))))
    )

  (test ; just see if it parses
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it parses
    "examples/election.compact"
    (succeeds))


  (test
    '(
      "3"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "parse error: found ~a looking for~?" ("\"3\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a program element" "end of file"))))
    )

  (test
    '(
      ";"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "parse error: found ~a looking for~?" ("\";\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a program element" "end of file"))))
    )

  (test
    '(
       " /"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 2" "parse error: found ~a looking for~?" ("\"/\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a program element" "end of file"))))
    )

  (test
    '(
       " /"
       ""
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 2" "parse error: found ~a looking for~?" ("\"/\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a program element" "end of file"))))
    )

  (test
    '(
       " /*"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 4" "unexpected ~a" ("end of file"))))

  (test
    '(
       " /* *"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 6" "unexpected ~a" ("end of file"))))

  (test
    '(
       "//"
       )
    (returns (program)))

  (test
    '(
       " \""
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 3" "unexpected ~a" ("end of file")))
    )

  (test
    '(
       " \""
       ""
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "unexpected ~a" ("end of file")))
    )

  (test
    '(
       " \"\\"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 4" "unexpected ~a" ("end of file")))
    )

  (test
    '(
      " blah"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 2" "parse error: found ~a looking for~?" ("\"blah\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a program element" "end of file"))))
    )

  (test
    '(
       " circuit C (a:Field) : Boolean;"
       )
    (returns
      (program (external #f C () ([a (tfield)]) (tboolean)))))

  (test
    '(
       "export circuit C (a:Field) : Boolean;"
       )
    (returns
      (program (external #t C () ([a (tfield)]) (tboolean)))))

  (test
    '(
       " pure circuit C (a:Field) : Boolean { return 0; }"
       )
    (returns
      (program
        (circuit #f #t C () ([a (tfield)])
             (tboolean)
          (block (return 0))))))

  (test
    '(
       " export pure circuit C (a:Field) : Boolean { return 0; }"
       )
    (returns
      (program
        (circuit #t #t C () ([a (tfield)])
             (tboolean)
          (block (return 0))))))

  (test
    '(
       " pure export circuit C (a:Field) : Boolean { return 0; }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 7" "parse error: found ~a looking for~?" ("\"export\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\"circuit\""))))
    )

  (test
    '(
       " impure circuit C (a:Field) : Boolean { return 0; }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 2" "parse error: found ~a looking for~?" ("\"impure\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a program element" "end of file"))))
    )

  (test
    '(
       "export ledger foo: Counter;"
       "constructor() {}"
       )
    (returns
      (program
        (public-ledger-declaration #t #f foo (type-ref Counter))
        (constructor () (block))))
    )

  (test
    '(
      "ledger {foo: Counter; constructor() {}}" ;; old ledger syntax disallowed
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 8" "parse error: found ~a looking for~?" ("\"{\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an identifier"))))
    )

  (test
    '(
       "export ledger foo: Counter;"
       "constructor() {}"
       "ledger some_field: Counter;"
       )
    (returns
      (program
        (public-ledger-declaration #t #f foo (type-ref Counter))
        (constructor () (block))
        (public-ledger-declaration #f #f some_field (type-ref Counter))))
    )

  (test
    '(
       "ledger first_field: Counter;"
       "export ledger foo: Counter;"
       "constructor() {}"
       "ledger some_field: Counter;"
       )
    (returns
      (program
        (public-ledger-declaration #f #f first_field (type-ref Counter))
        (public-ledger-declaration #t #f foo (type-ref Counter))
        (constructor () (block))
        (public-ledger-declaration #f #f some_field (type-ref Counter))))
    )

  (test
    '(
       "ledger foo: Counter;"
       "constructor() {}"
       )
    (returns
      (program
        (public-ledger-declaration #f #f foo (type-ref Counter))
        (constructor () (block))))
    )

  (test
    '(
       "constructor() {}"
       "ledger foo: Counter;"
       )
    (returns
      (program
        (constructor () (block))
        (public-ledger-declaration #f #f foo (type-ref Counter))))
    )

  (test
    '(
      "/* nested /* block comments */ are not allowed */"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 11" "attempt to nest block comment" ())))

  (test
    '(
      "/* nested // //* block comments */ are not allowed */"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 15" "attempt to nest block comment" ())))

  (test
    '(
      "/* nested /"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 12" "unexpected ~a" ("end of file")))
    )

  (test
    '(
      "circuit foo() : Field { return 0; }"
      )
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 0))))))

  (test
    '(
      "circuit foo() : Field { return 0"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 33" "parse error: found ~a looking for~?" ("end of file" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\";\"" "\",\"" "\"||\"" "\"&&\"" "\"==\"" "\"!=\"" "\"as\"" "\"+\"" "\"-\"" "\"*\"" "\"[\"" "\".\"" "\"?\"" "\"=\"" "\"+=\"" "\"-=\"" "\"<\"" "\"<=\"" "\">=\"" "\">\""))))
    )

  (test
    '(
      "circuit foo() : Field { return 0b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected ~a" ("character ';'")))
    )

  (test
    '(
      "circuit foo() : Field { return 0b2; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected digit ~a (expected 0 or 1)" (#\2)))
    )

  (test
    '(
      "circuit foo() : Field { return 0Ba; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected ~a" ("character 'a'")))
    )

  (test
    '(
      "circuit foo() : Field { return 0b017; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 36" "unexpected digit ~a (expected 0 or 1)" (#\7)))
    )

  (test
    '(
      "circuit foo() : Field { return 0B01a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 36" "parse error: found ~a looking for~?" ("\"a\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\";\"" "\",\"" "\"||\"" "\"&&\"" "\"==\"" "\"!=\"" "\"as\"" "\"+\"" "\"-\"" "\"*\"" "\"[\"" "\".\"" "\"?\"" "\"=\"" "\"+=\"" "\"-=\"" "\"<\"" "\"<=\"" "\">=\"" "\">\""))))
    )

  (test
    '(
      "circuit foo() : Field { return 0177; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 32" "unsupported numeric syntax syntax: leading 0 must be followed by b, B, o, O, x, X" ()))
    )

  (test
    '(
      "circuit foo() : Field { return 0o; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected ~a" ("character ';'")))
    )

  (test
    '(
      "circuit foo() : Field { return 0O; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected ~a" ("character ';'")))
    )

  (test
    '(
      "circuit foo() : Field { return 0o8; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected digit ~a (expected 0 through 7)" (#\8)))
    )

  (test
    '(
      "circuit foo() : Field { return 0Oa; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected ~a" ("character 'a'")))
    )

  (test
    '(
      "circuit foo() : Field { return 0o069; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 36" "unexpected digit ~a (expected 0 through 7)" (#\9)))
    )

  (test
    '(
      "circuit foo() : Field { return 0B06a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 35" "unexpected digit ~a (expected 0 or 1)" (#\6)))
    )

  (test
    '(
      "circuit foo() : Field { return 0x; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected ~a" ("character ';'")))
    )

  (test
    '(
      "circuit foo() : Field { return 0x"
      "; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected ~a" ("newline")))
    )

  (test
    '(
      "circuit foo() : Field { return 0X; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 34" "unexpected ~a" ("character ';'")))
    )

  (test
    '(
      "circuit foo(a : Vector<10, Boolean>) : Boolean { return a[3]; }"
      )
    (returns
      (program
        (circuit #f #f foo () ([a (tvector 10 (tboolean))])
             (tboolean)
          (block (return (tuple-ref a 3)))))))

  (test
    '(
      "circuit foo(a : Vector[10, Boolean]) : Boolean { return a[3]; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "parse error: found ~a looking for~?" ("\"[\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\"<\""))))
    )

  (test
    '(
      "circuit foo(a : Vector<10, Vector<5, Boolean>>) : Boolean { return !a[3][2]; }"
      )
    (returns
      (program
        (circuit #f #f foo () ([a (tvector
                                    10
                                    (tvector 5 (tboolean)))])
             (tboolean)
          (block (return (not (tuple-ref (tuple-ref a 3) 2))))))))

  (test
    '(
      "circuit foo(a : A) : Boolean { return !a.y.z; }"
      )
    (returns
      (program
        (circuit #f #f foo () ([a (type-ref A)])
             (tboolean)
          (block (return (not (elt-ref (elt-ref a y) z))))))))

  (test
    '(
      "circuit foo(x : Field) : Boolean { return (A{a: x, b: 7}).b; }"
      )
    (returns
      (program
        (circuit #f #f foo () ([x (tfield)])
             (tboolean)
          (block (return (elt-ref (new (type-ref A) (a x) (b 7)) b)))))))

  (test
    '(
      "circuit foo(x : Field) : Boolean { return x + x * 3 - 4 == 17 || x == 5 && !(x * 3 + x == 8); }"
      )
    (returns
      (program
        (circuit #f #f foo () ([x (tfield)])
             (tboolean)
          (block
            (return
              (or (== (- (+ x (* x 3)) 4) 17)
                  (and (== x 5) (not (== (+ (* x 3) x) 8))))))))))

  (test
   '(
     "circuit foo (): Field {"
     "  const x : Field = 10, y : Field = 20, z = 30;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (const ([x (tfield) 10] [y (tfield) 20]
                    [z (tundeclared) 30]))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const x = 10, y = 20;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (const ([x (tundeclared) 10] [y (tundeclared) 20]))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const x = 10, y : Field = 20;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (const ([x (tundeclared) 10] [y (tfield) 20]))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const x = 10, [y] = [20];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (const ([x (tundeclared) 10]
                    [(y) (tundeclared) (tuple 20)]))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const x = 10, [y] : [Field] = 20;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (const ([x (tundeclared) 10] [(y) (ttuple (tfield)) 20]))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const [x, y] : [Field, Field] = [10, 20];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (const ([(x y) (ttuple (tfield) (tfield)) (tuple 10 20)]))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const [x, y] = [10, 20];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (const ([(x y) (tundeclared) (tuple 10 20)]))
            (return y)))))
   )

  (test
    '(
      "circuit foo() : Field { const x : Field ="
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 42" "parse error: found ~a looking for~?" ("end of file" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression"))))
    )

  (test
    '(
      "circuit foo() : Field { const x=7; return x; }"
      )
    (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block (const ([x (tundeclared) 7])) (return x))))))

  (test
    '(
      "circuit foo(x: Field) : Boolean { return x == 0 &|"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 50" "unexpected ~a" ("character '|'"))))

  (test
    '(
      "circuit foo(x: Field) : Boolean { return x == 0 |&"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 50" "unexpected ~a" ("character '&'"))))

  (test
    '(
      "circuit foo(x: Field) : Boolean { return x == 0 &"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 50" "unexpected ~a" ("end of file")))
    )

  (test
    '(
      "circuit foo(x: Field) : Boolean { return x == 0 |"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 50" "unexpected ~a" ("end of file")))
    )

  (test
    '(
      "circuit foo() : Bytes<20> { return 'bob\\'s \"fish\"\\r\\0\\b\\f\\t\\v'; }"
      )
    (returns
      (program
        (circuit #f #f foo () ()
             (tbytes 20)
          (block
            (return ,(string->utf8 "bob's \"fish\"\r\x0;\b\f\t\v"))))))
    )

  (test
    '(
      "circuit foo() : Bytes<20> { return 'bob\\'s \"fish\"\\r\\0\\b\\q\\t\\v'; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 57" "unexpected ~a" ("character 'q'"))))

  (test
    '(
      "circuit foo() : [] { return; }"
      )
    (returns
      (program
        (circuit #f #f foo () () (ttuple) (block (return (tuple)))))))

  (test
    '(
      "module A<n, t> { export circuit foo(v : Vector<n, t>, b : Bytes<n>): Field { return 17; } }"
      "module B {"
      "  export circuit foo(x : Field): Field { return x + 1; }"
      "  circuit bar(x : Field): Field { return x - 1; }"
      "  import A<7, Field>;"
      "  import A<30, Boolean> prefix AA;"
      "}"
      "import B;"
      "import B prefix BB;"
      "import B<> prefix BBB;"
      )
    (returns
      (program
        (module #f A (n t)
          (circuit #t #f foo () ([v (tvector
                                      (type-size-ref n)
                                      (type-ref t))]
                                 [b (tbytes (type-size-ref n))])
               (tfield)
            (block (return 17))))
        (module #f B ()
          (circuit #t #f foo () ([x (tfield)])
               (tfield)
            (block (return (+ x 1))))
          (circuit #f #f bar () ([x (tfield)])
               (tfield)
            (block (return (- x 1))))
          (import A (7 (tfield)) "")
          (import A (30 (tboolean)) "AA"))
        (import B () "")
        (import B () "BB")
        (import B () "BBB"))))

  (test
    '(
      "module A<n, t> { export circuit foo(v : Vector<n, t>, b : Bytes<n>): Field { return 17; } }"
      "module B {"
      "  export circuit foo(x : Field): Field { return x + 1; }"
      "  circuit bar(x : Field): Field { return x - 1; }"
      "  import A<7, Field>;"
      "  import A<30, Boolean> prefix AA;"
      "}"
      "import B;"
      "import B prefix BB;"
      "import B[] prefix BBB;" ;; parse error introduced
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 9" "parse error: found ~a looking for~?" ("\"[\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a generic argument list" "an import prefix" "\";\""))))
    )

  (test
    '(
      "module A[n, t] { export circuit foo(v : Vector<n, t>, b : Bytes<n>): Field { return 17; } }" ;; parse error introduced
      "module B {"
      "  export circuit foo(x : Field): Field { return x + 1; }"
      "  circuit bar(x : Field): Field { return x - 1; }"
      "  import A<7, Field>;"
      "  import A<30, Boolean> prefix AA;"
      "}"
      "import B;"
      "import B prefix BB;"
      "import B<> prefix BBB;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 9" "parse error: found ~a looking for~?" ("\"[\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a generic parameter list" "\"{\""))))
    )

  (test
    `(
      "circuit C(b: Boolean, n: Field): Field {"
      "  assert(b, n);"
      "  return n;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 13" "parse error: found ~a looking for~?" ("\"n\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a string"))))
    )

  (test
    '(
      "circuit foo(b: Boolean) : Field { return bar(3, b); }"
      "module Foo<A> {"
      "  module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  export {bar, foo}"
      "  circuit foo(a: A) : A { return a; }"
      "}"
      "import Foo<Field>;"
      )
    (returns
      (program
        (circuit #f #f foo () ([b (tboolean)])
             (tfield)
          (block (return (call bar 3 b))))
        (module #f Foo (A)
          (module #f Bar (B)
            (circuit #t #f bar () ([a (type-ref A)] [b (type-ref B)])
                 (type-ref A)
              (block (return (call foo a)))))
          (import Bar ((tboolean)) "")
          (export bar foo)
          (circuit #f #f foo () ([a (type-ref A)])
               (type-ref A)
            (block (return a))))
        (import Foo ((tfield)) "")))
    )

  (test
    '(
      "circuit foo(b: Boolean) : Field { return bar(3, b); }"
      "module Foo<A> {"
      "  module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  export {bar, foo}"
      "  circuit foo(a: A) : A { return a; }"
      "}"
      "import Foo[Field];" ;; parse error introduced
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 11" "parse error: found ~a looking for~?" ("\"[\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a generic argument list" "an import prefix" "\";\""))))
    )

  (test
    '(
      "circuit foo(b: Boolean) : Field { return bar(3, b); }"
      "module Foo<#A> {"
      "  module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  export {bar, foo}"
      "  circuit foo(a: A) : A { return a; }"
      "}"
      "import Foo<Field>;"
      )
    (returns
      (program
        (circuit #f #f foo () ([b (tboolean)])
             (tfield)
          (block (return (call bar 3 b))))
        (module #f Foo ((nat-valued A))
          (module #f Bar (B)
            (circuit #t #f bar () ([a (type-ref A)] [b (type-ref B)])
                 (type-ref A)
              (block (return (call foo a)))))
          (import Bar ((tboolean)) "")
          (export bar foo)
          (circuit #f #f foo () ([a (type-ref A)])
               (type-ref A)
            (block (return a))))
        (import Foo ((tfield)) "")))
    )

  (test ; tests that circuit isn't valid syntax for anonymous circuits
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold("
      "             circuit (b: Boolean, x: Field): Boolean => {"
      "               {"
      "                 return b && x == 0;"
      "               }"
      "             },"
      "             true,"
      "             v);"
      "  }"
      "}"
      "import M<0>;"
      "circuit bar1() : [] {"
      "  assert(C([]), 'oops 0');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 14" "parse error: found ~a looking for~?" ("\"circuit\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a function"))))
    )

  (test ; tests that anonymous circuit requires => syntax
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold("
      "             (b: Boolean, x: Field): Boolean {"
      "               {"
      "                 return b && x == 0;"
      "               }"
      "             },"
      "             true,"
      "             v);"
      "  }"
      "}"
      "import M<0>;"
      "circuit bar1() : [] {"
      "  assert(C([]), 'oops 0');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 46" "parse error: found ~a looking for~?" ("\"{\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\"=>\""))))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold("
      "             (b: Boolean, x: Field): Boolean => {"
      "               {"
      "                 return b && x == 0;"
      "               }"
      "             },"
      "             true,"
      "             v);"
      "  }"
      "}"
      "import M<0>;"
      "import M<1>;"
      "import M<2>;"
      "circuit bar1() : [] {"
      "  assert(C([]), 'oops 0');"
      "  assert(C([7]), 'oops 1');"
      "  assert(C([23, 57]), 'oops 2');"
      "}"
      )
    (returns
      (program
        (module #f M ((nat-valued n))
          (circuit #t #f C () ([v (tvector
                                    (type-size-ref n)
                                    (tfield))])
               (tboolean)
            (block
              (return
                (fold (circuit ([b (tboolean)] [x (tfield)])
                           (tboolean)
                        (block (block (return (and b (== x 0))))))
                  #t
                  v)))))
        (import M (0) "")
        (import M (1) "")
        (import M (2) "")
        (circuit #f #f bar1 () ()
             (ttuple)
          (block
            (assert (call C (tuple)) "oops 0")
            (assert (call C (tuple 7)) "oops 1")
            (assert (call C (tuple 23 57)) "oops 2")))))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<#n, Field>): Boolean {"
      "    return fold("
      "             circuit (b: Boolean, x: Field): Boolean {"
      "               {"
      "                 return b && x == 0;"
      "               }"
      "             },"
      "             true,"
      "             v);"
      "  }"
      "}"
      "import M<0>;"
      "import M<1>;"
      "import M<2>;"
      "circuit bar1() : [] {"
      "  assert(C([]), 'oops 0');"
      "  assert(C([7]), 'oops 1');"
      "  assert(C([23, 57]), 'oops 2');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 30" "parse error: found ~a looking for~?" ("\"#\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a type size"))))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold("
      "             (b: Boolean, x: Field): Boolean => {"
      "               {"
      "                 return b && x == 0;"
      "               }"
      "             },"
      "             true,"
      "             v);"
      "  }"
      "}"
      "import M<#0>;" ;; parse error introduced here.
      "import M<1>;"
      "import M<2>;"
      "circuit bar1() : [] {"
      "  assert(C([]), 'oops 0');"
      "  assert(C([7]), 'oops 1');"
      "  assert(C([23, 57]), 'oops 2');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 13 char 10" "parse error: found ~a looking for~?" ("\"#\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a generic argument" "\">\""))))
    )

  (test
    `(
      "module M<n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold("
      "             (b: Boolean, x: Field): Boolean => {"
      "               {"
      "                 return b && x == 0;"
      "               }"
      "             },"
      "             true,"
      "             v);"
      "  }"
      "}"
      "import M<0>;"
      "import M<1>;"
      "import M<2>;"
      "circuit bar1() : [] {"
      "  assert(C([]), 'oops 0');"
      "  assert(C([7]), 'oops 1');"
      "  assert(C([23, 57]), 'oops 2');"
      "}"
      )
    (returns
      (program
        (module #f M (n)
          (circuit #t #f C () ([v (tvector
                                    (type-size-ref n)
                                    (tfield))])
               (tboolean)
            (block
              (return
                (fold (circuit ([b (tboolean)] [x (tfield)])
                           (tboolean)
                        (block (block (return (and b (== x 0))))))
                  #t
                  v)))))
        (import M (0) "")
        (import M (1) "")
        (import M (2) "")
        (circuit #f #f bar1 () ()
             (ttuple)
          (block
            (assert (call C (tuple)) "oops 0")
            (assert (call C (tuple 7)) "oops 1")
            (assert (call C (tuple 23 57)) "oops 2")))))
    )

  (test
    '(
      "circuit foo(arg: Boolean) : Boolean { return !!arg; }"
      )
    (returns
      (program
        (circuit #f #f foo () ([arg (tboolean)])
             (tboolean)
          (block (return (not (not arg)))))))
  )

  (test
    '(
      "enum names { bill, sally, fred, george, }"
      )
    (returns (program (enum #f names bill sally fred george)))
    )

  (test
    '(
      "enum names {}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 13" "parse error: found ~a looking for~?" ("\"}\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an identifier"))))
  )

  (test
    '(
      "enum names { 1, sally, fred, george }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 14" "parse error: found ~a looking for~?" ("\"1\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an identifier"))))
  )

  (test
    '(
      "enum {}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 6" "parse error: found ~a looking for~?" ("\"{\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an identifier"))))
  )

  (test
    '(
      "enum 'names' {}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 6" "parse error: found ~a looking for~?" ("\"'names'\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an identifier"))))
  )

  (test
    '(
      "enum \"names\" {}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 6" "parse error: found ~a looking for~?" ("\"\\\"names\\\"\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an identifier"))))
  )

  (test
    '(
      "enum names { bill = 'overdue' }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 19" "parse error: found ~a looking for~?" ("\"=\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\",\"" "\"}\""))))
  )

  (test
    `(
      "circuit foo(n: Field): Boolean {"
      ,(format "  return n == ~d;" (max-field))
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tboolean)
          (block
            (return
              (== n ,(max-field)))))))
  )

  (test
    `(
      "circuit foo(n: Field): Boolean {"
      ,(format "  return n == ~d;" (+ (max-field) 1))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 15" "~s is out of Field range" (,(+ (max-field) 1))))
  )

  (test
      '(
         "circuit foo(arg: Bytes<20>) : Field { return arg as Field; }"
       )
    (returns
      (program
        (circuit #f #f foo () ([arg (tbytes 20)])
             (tfield)
          (block (return (cast (tfield) arg))))))
  )

  (test
      '(
         "export circuit foo(arg: Field) : Bytes<20> { return arg as Bytes<20>; }"
       )
    (returns
      (program
        (circuit #t #f foo () ([arg (tfield)])
             (tbytes 20)
          (block (return (cast (tbytes 20) arg))))))
  )

  (test
    '(
      "circuit foo(): Bytes<10> {"
      "  return \"abc\x1234;def\";"
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () ()
             (tbytes 10)
          (block (return #vu8(97 98 99 225 136 180 100 101 102))))))
    )

  (test
    '(
      "circuit foo(): Bytes<10> {"
      "  return \"abc\xDC;def\";"
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () ()
             (tbytes 10)
          (block (return #vu8(97 98 99 195 156 100 101 102))))))
    )

  (test
    '(
      "circuit foo(): Bytes<10> {"
      "  return \"abc\\u1234def\";"
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () ()
             (tbytes 10)
          (block (return #vu8(97 98 99 225 136 180 100 101 102))))))
    )

  (test
    '(
      "circuit foo(): Bytes<10> {"
      "  return \"abc\\xDCdef\";"
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () ()
             (tbytes 10)
          (block (return #vu8(97 98 99 195 156 100 101 102))))))
    )

  (test
    '(
      "export circuit foo(b: Boolean): [] {"
      "  assert(b, 'abc\\u1234def');"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([b (tboolean)])
             (ttuple)
          (block (assert b "abcሴdef")))))
    )

  (test
    '(
      "export circuit foo(b: Boolean): [] {"
      "  assert(b, 'abc\\xDCdef');"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([b (tboolean)])
             (ttuple)
          (block (assert b "abcÜdef")))))
    )

  (test
    '(
      "export circuit foo(x : Field) : Field { return x + 3 - x + 4; }"
      )
    (returns
      (program
        (circuit #t #f foo () ([x (tfield)])
             (tfield)
          (block (return (+ (- (+ x 3) x) 4))))))
    )

  (test
    '(
      "export circuit foo(x : Boolean, y: Boolean) : Field {"
      "  return x ? 3 + 4 : y ? 5 + 6 : 7;"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([x (tboolean)] [y (tboolean)])
             (tfield)
          (block (return (if x (+ 3 4) (if y (+ 5 6) 7)))))))
    )

  (test
    '(
      "export circuit foo(): Bytes<10> {"
      "  return pad(10, 'abcdefghij');"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ()
             (tbytes 10)
          (block
            (return #vu8(97 98 99 100 101 102 103 104 105 106))))))
    )

  (test
    '(
      "export circuit foo(): Bytes<10> {"
      "  return pad(10, 'abcdefghijkl');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "cannot pad ~s to length ~s since its utf8-equivalent already exceeds that length" ("abcdefghijkl" 10)))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  for (const i of 3..3) i + 1;"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ()
             (ttuple)
          (block (for i (tuple) (+ i 1))))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  for (const i of 4..3) i + 1;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "end bound ~d is less than start bound ~s" (3 4)))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  for (const i of 3..1003) i + 1;"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ()
             (ttuple)
          (block
            (for i (tuple 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
                    21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
                    39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56
                    57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74
                    75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92
                    93 94 95 96 97 98 99 100 101 102 103 104 105 106 107
                    108 109 110 111 112 113 114 115 116 117 118 119 120 121
                    122 123 124 125 126 127 128 129 130 131 132 133 134 135
                    136 137 138 139 140 141 142 143 144 145 146 147 148 149
                    150 151 152 153 154 155 156 157 158 159 160 161 162 163
                    164 165 166 167 168 169 170 171 172 173 174 175 176 177
                    178 179 180 181 182 183 184 185 186 187 188 189 190 191
                    192 193 194 195 196 197 198 199 200 201 202 203 204 205
                    206 207 208 209 210 211 212 213 214 215 216 217 218 219
                    220 221 222 223 224 225 226 227 228 229 230 231 232 233
                    234 235 236 237 238 239 240 241 242 243 244 245 246 247
                    248 249 250 251 252 253 254 255 256 257 258 259 260 261
                    262 263 264 265 266 267 268 269 270 271 272 273 274 275
                    276 277 278 279 280 281 282 283 284 285 286 287 288 289
                    290 291 292 293 294 295 296 297 298 299 300 301 302 303
                    304 305 306 307 308 309 310 311 312 313 314 315 316 317
                    318 319 320 321 322 323 324 325 326 327 328 329 330 331
                    332 333 334 335 336 337 338 339 340 341 342 343 344 345
                    346 347 348 349 350 351 352 353 354 355 356 357 358 359
                    360 361 362 363 364 365 366 367 368 369 370 371 372 373
                    374 375 376 377 378 379 380 381 382 383 384 385 386 387
                    388 389 390 391 392 393 394 395 396 397 398 399 400 401
                    402 403 404 405 406 407 408 409 410 411 412 413 414 415
                    416 417 418 419 420 421 422 423 424 425 426 427 428 429
                    430 431 432 433 434 435 436 437 438 439 440 441 442 443
                    444 445 446 447 448 449 450 451 452 453 454 455 456 457
                    458 459 460 461 462 463 464 465 466 467 468 469 470 471
                    472 473 474 475 476 477 478 479 480 481 482 483 484 485
                    486 487 488 489 490 491 492 493 494 495 496 497 498 499
                    500 501 502 503 504 505 506 507 508 509 510 511 512 513
                    514 515 516 517 518 519 520 521 522 523 524 525 526 527
                    528 529 530 531 532 533 534 535 536 537 538 539 540 541
                    542 543 544 545 546 547 548 549 550 551 552 553 554 555
                    556 557 558 559 560 561 562 563 564 565 566 567 568 569
                    570 571 572 573 574 575 576 577 578 579 580 581 582 583
                    584 585 586 587 588 589 590 591 592 593 594 595 596 597
                    598 599 600 601 602 603 604 605 606 607 608 609 610 611
                    612 613 614 615 616 617 618 619 620 621 622 623 624 625
                    626 627 628 629 630 631 632 633 634 635 636 637 638 639
                    640 641 642 643 644 645 646 647 648 649 650 651 652 653
                    654 655 656 657 658 659 660 661 662 663 664 665 666 667
                    668 669 670 671 672 673 674 675 676 677 678 679 680 681
                    682 683 684 685 686 687 688 689 690 691 692 693 694 695
                    696 697 698 699 700 701 702 703 704 705 706 707 708 709
                    710 711 712 713 714 715 716 717 718 719 720 721 722 723
                    724 725 726 727 728 729 730 731 732 733 734 735 736 737
                    738 739 740 741 742 743 744 745 746 747 748 749 750 751
                    752 753 754 755 756 757 758 759 760 761 762 763 764 765
                    766 767 768 769 770 771 772 773 774 775 776 777 778 779
                    780 781 782 783 784 785 786 787 788 789 790 791 792 793
                    794 795 796 797 798 799 800 801 802 803 804 805 806 807
                    808 809 810 811 812 813 814 815 816 817 818 819 820 821
                    822 823 824 825 826 827 828 829 830 831 832 833 834 835
                    836 837 838 839 840 841 842 843 844 845 846 847 848 849
                    850 851 852 853 854 855 856 857 858 859 860 861 862 863
                    864 865 866 867 868 869 870 871 872 873 874 875 876 877
                    878 879 880 881 882 883 884 885 886 887 888 889 890 891
                    892 893 894 895 896 897 898 899 900 901 902 903 904 905
                    906 907 908 909 910 911 912 913 914 915 916 917 918 919
                    920 921 922 923 924 925 926 927 928 929 930 931 932 933
                    934 935 936 937 938 939 940 941 942 943 944 945 946 947
                    948 949 950 951 952 953 954 955 956 957 958 959 960 961
                    962 963 964 965 966 967 968 969 970 971 972 973 974 975
                    976 977 978 979 980 981 982 983 984 985 986 987 988 989
                    990 991 992 993 994 995 996 997 998 999 1000 1001 1002)
              (+ i 1))))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  for (const i of 3..1004) i + 1;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "difference ~s between end and start bounds is greater than the arbitrary compiler limit of ~s; use 'for ... in' syntax instead" (1001 1000)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(): [] { return default<[]>; }"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (circuit #t #f foo () ()
             (ttuple)
          (block (return (default (ttuple)))))))
    )

  (test ; TODO improve error message. PM-19118
    '(
      "pragma language_version 0.0.0;"
      ""
      "import CompactStandardLibrary;"
      ""
      "export circuit bar(): Field {"
      "  return 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 1" "~a version ~a mismatch" (language ,language-version-string)))
    )

  (test
    '(
      "pragma language_version 0.4.0 && 0.4.1;"
      ""
      "import CompactStandardLibrary;"
      ""
      "export circuit bar(): Field {"
      "  return 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 1" "~a version ~a mismatch" (language ,language-version-string)))
    )

  (test
    '(
      "pragma language_version 0.4.0 && !0.4.0;"
      ""
      "import CompactStandardLibrary;"
      ""
      "export circuit bar(): Field {"
      "  return 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 1" "~a version ~a mismatch" (language ,language-version-string)))
    )

  (test
    '(
      "pragma language_version <= 1 || >= 1;"
      ""
      "import CompactStandardLibrary;"
      ""
      "export circuit bar(): Field {"
      "  return 3;"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (circuit #t #f bar () () (tfield) (block (return 3)))))
    )

  (test
    '(
      "pragma compiler_version > 0.2.0;"
      ""
      "import CompactStandardLibrary;"
      ""
      "export circuit bar(): Field {"
      "  return 3;"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (circuit #t #f bar () () (tfield) (block (return 3)))))
    )

  (test
    '(
      "pragma compiler_version 0.3.5 || (> 0.2.0 && < 0.3.0);"
      ""
      "import CompactStandardLibrary;"
      ""
      "export circuit bar(): Field {"
      "  return 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 1" "~a version ~a mismatch" (compiler ,compiler-version-string)))
    )

  (test
    '(
      "pragma compact >= 0.0.0;"
      ""
      "import CompactStandardLibrary;"
      ""
      "export circuit bar(): Field {"
      "  return 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "unrecognized pragma setting ~s" (compact)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger modifiable_set: Set<Field>;"
      ""
      "circuit foo(): Field {"
      "  return 0;"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (public-ledger-declaration #f #f
          modifiable_set
          (type-ref Set (tfield)))
        (circuit #f #f foo () () (tfield) (block (return 0)))))
    )

  ;; tests that the parser accepts random types for ledger fields
  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger modifiable_set: Nonsense<Cell<Blarney>>;"
      ""
      "circuit foo(): Field {"
      "  return 0;"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (public-ledger-declaration #f #f
          modifiable_set
          (type-ref Nonsense (type-ref Cell (type-ref Blarney))))
        (circuit #f #f foo () () (tfield) (block (return 0)))))
    )

  (test
    '(
      "ledger mapmap: Map<Boolean, Map<Boolean, Field>>;"
      ""
      "circuit foo(): Field {"
      "  return 0;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration #f #f
          mapmap (type-ref Map (tboolean) (type-ref Map (tboolean) (tfield))))
        (circuit #f #f foo () () (tfield) (block (return 0)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "circuit foo(): Field {"
      "  field1.insert(true, default<Counter>);"
      "  field1.lookup(true).increment(1);"
      "  return field1.lookup(true).read();"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (public-ledger-declaration #f #f
          field1
          (type-ref Map (tboolean) (type-ref Counter)))
        (circuit #f #f foo () ()
             (tfield)
          (block
            (elt-call field1 insert #t (default (type-ref Counter)))
            (elt-call (elt-call field1 lookup #t) increment 1)
            (return (elt-call (elt-call field1 lookup #t) read))))))
    )

  (test
    '(
      "circuit foo() : Bytes<20> { return 'Hello\\\r wor\\\r\nld!'; }\r"
      )
    (returns
      (program
        (circuit #f #f foo () ()
            (tbytes 20)
          (block (return ,(string->utf8 "Hello world!"))))))
    )

  (test
    '(
      "circuit foo(x : Uint <16>) : Boolean { return x >= 17 || x <= 30;}"
      )
    (returns
      (program
        (circuit #f #f foo () ([x (tunsigned 16)])
             (tboolean)
          (block
            (return (or (>= x 17)
                        (<= x 30))))))))

  (test
    '(
      "circuit foo(x : Uint <16>) : Boolean { return x < 17;}"
      )
    (returns
      (program
        (circuit #f #f foo () ([x (tunsigned 16)])
             (tboolean)
          (block
            (return (< x 17)))))))

  (test
    '(
      "circuit foo(x : Uint <16>) : Boolean { return x > 17;}"
      )
    (returns
      (program
        (circuit #f #f foo () ([x (tunsigned 16)])
             (tboolean)
          (block
            (return (> x 17)))))))

  (test
    '(
      "ledger foo: Counter;"
      "constructor() {}}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 17" "parse error: found ~a looking for~?" ("\"}\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a program element" "end of file"))))
    )

  (test
    '(
      "module M {"
      "  sealed export ledger q: Field;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "parse error: found ~a looking for~?" ("\"export\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\"ledger\""))))
    )

  (test
    '(
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { ledger.q = n; }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 39" "parse error: found ~a looking for~?" ("\"ledger\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a statement" "\"}\""))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  import CompactStandardLibrary;"
      "  export { kernel };"
      "}"
      "import M prefix $;"
      "ledger kernelA: Kernel;"
      "ledger kernelB: Kernel;"
      "export circuit foo(): Vector<4, ContractAddress> {"
      "  return [ledger.self(), $kernel.self(), kernelA.self(), kernelB.self()];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 11" "parse error: found ~a looking for~?" ("\"ledger\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a tuple argument" "\"]\""))))
    )

  (test
    '(
      "contract C {"
      "  circuit foo(x: Bytes<32>): [];"
      "  pure circuit bar(): Bytes<32>;"
      "}"
      "ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (returns
      (program
        (external-contract #f C
          (#f foo ([x (tbytes 32)]) (ttuple))
          (#t bar () (tbytes 32)))
        (public-ledger-declaration #f #f contract_c (type-ref C))
        (constructor ([c (type-ref C)]) (block (= contract_c (disclose c))))
        (circuit #t #f hello () ()
             (ttuple)
          (block
            (return
              (elt-call contract_c foo (elt-call contract_c bar)))))))
    )

  (test
    '(
      "contract C {"
      "  export circuit foo(x: A): [];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "parse error: found ~a looking for~?" ("\"export\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an external contract circuit" "\"}\""))))
    )

  (test
    '(
      "contract C {"
      "  circuit foo<A>(x: A): [];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 14" "parse error: found ~a looking for~?" ("\"<\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a simple parameter list"))))
    )

  (test
    '(
      "contract C {"
      "  circuit foo(x: Field): []"
      "}")
    (returns
      (program
        (external-contract #f C (#f foo ([x (tfield)]) (ttuple)))))
    )

  (test
    '(
      "contract C {"
      "  circuit foo(x: Field): [],"
      "}")
    (returns
      (program
        (external-contract #f C (#f foo ([x (tfield)]) (ttuple)))))
    )

  (test
    '(
      "export circuit foo(): Field { return (, 0); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 39" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a function" "an expression sequence" "an optionally typed pattern" "\")\""))))
    )

  (test
    '(
      "export circuit foo(): Field { return (0 ,); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 42" "parse error: found ~a looking for~?" ("\")\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression"))))
    )

  (test
    '(
      "export circuit foo(): Field { return (, 0 , 0); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 39" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a function" "an expression sequence" "an optionally typed pattern" "\")\""))))
    )

  (test
    '(
      "export circuit foo(): Field { return (0 , , 0); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 43" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression"))))
    )

  (test
    '(
      "export circuit foo(): Field { return (0 , 0 ,); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 46" "parse error: found ~a looking for~?" ("\")\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression"))))
    )

  (test
    '(
      "export circuit foo(): Field { return (, 0 , 0 , 0); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 39" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a function" "an expression sequence" "an optionally typed pattern" "\")\""))))
    )

  (test
    '(
      "export circuit foo(): Field { return (0 , 0 , 0 ,); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 50" "parse error: found ~a looking for~?" ("\")\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression"))))
    )

  (test
    '(
      "export circuit foo(): Field { return (0 , 0 , , 0); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 47" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression"))))
    )

  (test
    '(
      "export circuit foo(): Field { return (0) + (1 , 2 , , 3); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 53" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression"))))
    )

  (test
    '(
      "export circuit foo(): Field { return (0) + (1, 2) + (3, 4, 5) + (6, 7, 8, 9); }"
      )
    (returns
      (program
        (circuit #t #f foo () ()
             (tfield)
          (block
            (return
              (+ (+ (+ 0 (seq 1 2)) (seq 3 4 5)) (seq 6 7 8 9)))))))
    )

  (test
    '(
      "contract C {"
      "  circuit foo(x: Bytes<32>): [];"
      "  pure circuit bar(): Bytes<32>;"
      "}"
      "ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.read().foo(contract_c.read().bar()); }"
      )
    (returns
      (program
        (external-contract #f C
          (#f foo ([x (tbytes 32)]) (ttuple))
          (#t bar () (tbytes 32)))
        (public-ledger-declaration #f #f contract_c (type-ref C))
        (constructor ([c (type-ref C)]) (block (= contract_c (disclose c))))
        (circuit #t #f hello () ()
             (ttuple)
          (block
            (return
              (elt-call
                (elt-call contract_c read)
                foo
                (elt-call (elt-call contract_c read) bar)))))))
    )

  (test
    '(
      "module m<A> {"
      "  contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "}"
      "import m<Bytes<32>>;"
      "ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (returns
      (program
        (module #f m (A)
          (external-contract #f C
            (#f foo ([x (type-ref A)]) (ttuple))
            (#t bar () (type-ref A))))
        (import m ((tbytes 32)) "")
        (public-ledger-declaration #f #f contract_c (type-ref C))
        (constructor ([c (type-ref C)]) (block (= contract_c (disclose c))))
        (circuit #t #f hello () ()
             (ttuple)
          (block
            (return
              (elt-call contract_c foo (elt-call contract_c bar)))))))
    )

  (test
    '(
      "module m<A> {"
      "  contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "  export ledger contract_c: C;"
      "}"
      "import m<Bytes<32>>;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (returns
      (program
        (module #f m (A)
          (external-contract #f C
            (#f foo ([x (type-ref A)]) (ttuple))
            (#t bar () (type-ref A)))
          (public-ledger-declaration #t #f contract_c (type-ref C)))
        (import m ((tbytes 32)) "")
        (constructor ([c (type-ref C)]) (block (= contract_c (disclose c))))
        (circuit #t #f hello () ()
             (ttuple)
          (block
            (return
              (elt-call contract_c foo (elt-call contract_c bar)))))))
    )

  (test
    '(
      "module m<A> {"
      "  contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "  export ledger contract_c: C;"
      "  constructor (c: C) { contract_c = disclose(c); }"
      "}"
      "import m<Bytes<32>>;"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (returns
      (program
        (module #f m (A)
          (external-contract #f C
            (#f foo ([x (type-ref A)]) (ttuple))
            (#t bar () (type-ref A)))
          (public-ledger-declaration #t #f contract_c (type-ref C))
          (constructor ([c (type-ref C)]) (block (= contract_c (disclose c)))))
        (import m ((tbytes 32)) "")
        (circuit #t #f hello () ()
             (ttuple)
          (block
            (return
              (elt-call contract_c foo (elt-call contract_c bar)))))))
    )

  (test
    '(
      "module m<A> {"
      "  contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "}"
      "import m<Bytes<32>> prefix $;"
      "export ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (returns
      (program
        (module #f m (A)
          (external-contract #f C
            (#f foo ([x (type-ref A)]) (ttuple))
            (#t bar () (type-ref A))))
        (import m ((tbytes 32)) "$")
        (public-ledger-declaration #t #f contract_c (type-ref C))
        (constructor ([c (type-ref C)]) (block (= contract_c (disclose c))))
        (circuit #t #f hello () ()
             (ttuple)
          (block
            (return
              (elt-call contract_c foo (elt-call contract_c bar)))))))
    )

  (test
    '(
      "module m<A> {"
      "  contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "  export ledger contract_c: C;"
      "}"
      "import m<Bytes<32>> prefix $;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (returns
      (program
        (module #f m (A)
          (external-contract #f C
            (#f foo ([x (type-ref A)]) (ttuple))
            (#t bar () (type-ref A)))
          (public-ledger-declaration #t #f contract_c (type-ref C)))
        (import m ((tbytes 32)) "$")
        (constructor ([c (type-ref C)]) (block (= contract_c (disclose c))))
        (circuit #t #f hello () ()
             (ttuple)
          (block
            (return
              (elt-call contract_c foo (elt-call contract_c bar)))))))
    )

  (test
    "compiler/testdir/testfile.compact"
    (oops
      message: "error ~a: ~a"
      irritants: '("opening source file" "failed for compiler/testdir/testfile.compact: no such file or directory"))
    )

  (test
    "compiler/testdir"
    (oops
      message: "error ~a: ~a"
      irritants: '("opening source file" "compiler/testdir is a directory"))
    )

  (test-group
    ((create-file "testfile.compact" '())
     (custom-check
       (lambda (pass-name x)
         (chmod "compiler/testdir/testfile.compact" 000)
         #t))
     )
    ((source-file "compiler/testdir/testfile.compact")
     (oops
       message: "error ~a: ~a"
       irritants: '("opening source file" "failed for compiler/testdir/testfile.compact: permission denied"))
     )
    )

  (test
    '(
      "circuit A(x: Field, y: Field, z: Boolean, w: Boolean): Boolean {"
      "  return x == y == z == w;"
      "}"
      )
    (returns
      (program
        (circuit #f #f A () ([x (tfield)]
                             [y (tfield)]
                             [z (tboolean)]
                             [w (tboolean)])
             (tboolean)
          (block (return (== (== (== x y) z) w))))))
    )

  (test
    '(
      "circuit A(): [] {"
      "  return x < y == y <= z;"
      "}"
      )
    (returns
      (program
        (circuit #f #f A () ()
             (ttuple)
          (block (return (== (< x y) (<= y z)))))))
    )

  (test
    '(
      "circuit A(): [] {"
      "  return x < y <= z;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 16" "parse error: found ~a looking for~?" ("\"<=\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\";\"" "\"||\"" "\"&&\"" "\"==\"" "\"!=\"" "\"as\"" "\"+\"" "\"-\"" "\"*\"" "\"[\"" "\".\"" "\"?\"" "\"=\"" "\"+=\"" "\"-=\"" "\"(\"" "\"{\"" "\",\"" "\">\"" "a generic argument list"))))
    )

  (test
    '(
      "circuit A(): [] {"
      "  return A<B>(C);"
      "}"
      )
    (returns
      (program
        (circuit #f #f A () ()
             (ttuple)
          (block (return (call (fref A (type-ref B)) C))))))
    )

  (test
    '(
      "circuit A(): [] {"
      "  return B(C<D, E>(F));"
      "}"
      )
    (returns
      (program
        (circuit #f #f A () ()
             (ttuple)
          (block
            (return
              (call B (call (fref C (type-ref D) (type-ref E)) F)))))))
    )

  (test
    '(
      "circuit A(): [] {"
      "  if (a) if (b) c; else d;"
      "}"
      )
    (returns
      (program
        (circuit #f #f A () ()
             (ttuple)
          (block (if a (if b c d) (tuple))))))
    )

  (test
    '(
      "circuit A(): Field {"
      "  const t1 : Uint<0..38> = 25, t2 : Uint< 0..38> = t1, t3 : Uint<0 ..38> = t2, t4 : Uint< 0 ..38> = t3, t5 : Uint<0.. 38> = t4, t6 : Uint< 0.. 38> = t5, t7 : Uint<0 .. 38> = t6, t8 : Uint< 0 .. 38> = t7, t9 : Uint<0..38 > = t8, t10 : Uint< 0..38 > = t9, t11 : Uint<0 ..38 > = t10, t12 : Uint< 0 ..38 > = t11, t13 : Uint<0.. 38 > = t12, t14 : Uint< 0.. 38 > = t13, t15 : Uint<0 .. 38 > = t14, t16 : Uint< 0 .. 38 > = t15;"
      "  return t16;"
      "}"
      )
    (returns
      (program
        (circuit #f #f A () ()
             (tfield)
          (block
            (const ([t1 (tunsigned 0 38) 25]
                    [t2 (tunsigned 0 38) t1]
                    [t3 (tunsigned 0 38) t2]
                    [t4 (tunsigned 0 38) t3]
                    [t5 (tunsigned 0 38) t4]
                    [t6 (tunsigned 0 38) t5]
                    [t7 (tunsigned 0 38) t6]
                    [t8 (tunsigned 0 38) t7]
                    [t9 (tunsigned 0 38) t8]
                    [t10 (tunsigned 0 38) t9]
                    [t11 (tunsigned 0 38) t10]
                    [t12 (tunsigned 0 38) t11]
                    [t13 (tunsigned 0 38) t12]
                    [t14 (tunsigned 0 38) t13]
                    [t15 (tunsigned 0 38) t14]
                    [t16 (tunsigned 0 38) t15]))
            (return t16)))))
    )

  (test
    '(
      "circuit A(): Field {"
      "  const t1 : Uint<0..38> = 25;"
      "  const t2 : Uint< 0..38> = t1;"
      "  const t3 : Uint<0 ..38> = t2;"
      "  const t4 : Uint< 0 ..38> = t3;"
      "  const t5 : Uint<0.. 38> = t4;"
      "  const t6 : Uint< 0.. 38> = t5;"
      "  const t7 : Uint<0 .. 38> = t6;"
      "  const t8 : Uint< 0 .. 38> = t7;"
      "  const t9 : Uint<0..38 > = t8;"
      "  const t10 : Uint< 0..38 > = t9;"
      "  const t11 : Uint<0 ..38 > = t10;"
      "  const t12 : Uint< 0 ..38 > = t11;"
      "  const t13 : Uint<0.. 38 > = t12;"
      "  const t14 : Uint< 0.. 38 > = t13;"
      "  const t15 : Uint<0 .. 38 > = t14;"
      "  const t16 : Uint< 0 .. 38 > = t15;"
      "  return t16;"
      "}"
      )
    (returns
      (program
        (circuit #f #f A () ()
             (tfield)
          (block
            (const ([t1 (tunsigned 0 38) 25]))
            (const ([t2 (tunsigned 0 38) t1]))
            (const ([t3 (tunsigned 0 38) t2]))
            (const ([t4 (tunsigned 0 38) t3]))
            (const ([t5 (tunsigned 0 38) t4]))
            (const ([t6 (tunsigned 0 38) t5]))
            (const ([t7 (tunsigned 0 38) t6]))
            (const ([t8 (tunsigned 0 38) t7]))
            (const ([t9 (tunsigned 0 38) t8]))
            (const ([t10 (tunsigned 0 38) t9]))
            (const ([t11 (tunsigned 0 38) t10]))
            (const ([t12 (tunsigned 0 38) t11]))
            (const ([t13 (tunsigned 0 38) t12]))
            (const ([t14 (tunsigned 0 38) t13]))
            (const ([t15 (tunsigned 0 38) t14]))
            (const ([t16 (tunsigned 0 38) t15]))
            (return t16)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const [{a: [a, b], b: b1}, b2] = bar(x1, x2, y, z);"
      "  return [b1 ? a : 2 * a, b2 ? b : 'hello!'];"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (struct #f S ()
          [a (ttuple (tfield) (tbytes 6))]
          [b (tboolean)])
        (circuit #f #f bar () ([x1 (tboolean)]
                               [x2 (tboolean)]
                               [y (tfield)]
                               [z (tbytes 6)])
             (ttuple (type-ref S) (tboolean))
          (block
            (return (tuple (new (type-ref S) (tuple y z) x1) x2))))
        (circuit #t #f foo () ([x1 (tboolean)]
                               [x2 (tboolean)]
                               [y (tfield)]
                               [z (tbytes 6)])
             (ttuple (tfield) (tbytes 6))
          (block
            (const ([((((a b) a) (b1 b)) b2)
                     (tundeclared)
                     (call bar x1 x2 y z)]))
            (return
              (tuple
                (if b1 a (* 2 a))
                (if b2 b ,(string->utf8 "hello!"))))))))
    )

  (test
    '(
      "export ledger field1: Counter;"
      "circuit foo(state: Uint<16>) : Uint<16> { field1 += state; field1 -= state; return 0; }"
      )
    (returns
      (program
        (public-ledger-declaration #t #f field1 (type-ref Counter))
        (circuit #f #f foo () ([state (tunsigned 16)])
             (tunsigned 16)
          (block
            (+= field1 state)
            (-= field1 state)
            (return 0)))))
    )

  (test
    "examples/bugs/pm-15405.compact"
    (succeeds))

  (test
    '(
      "circuit example("
      "    amountA: Uint<64>,"
      "    reserveB: Uint<64>,"
      "    reserveA: Uint<64>"
      "): Uint<64> {"
      "    const result = amountA * reserveB / reserveA; // Error here"
      "    return result;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 39" "parse error: found ~a looking for~?" ("\"/\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\",\"" "\";\"" "\"||\"" "\"&&\"" "\"==\"" "\"!=\"" "\"as\"" "\"+\"" "\"-\"" "\"*\"" "\"[\"" "\".\"" "\"<\"" "\"<=\"" "\">=\"" "\">\"" "\"?\"" "\"=\"" "\"+=\"" "\"-=\"" "\"(\"" "\"{\"" "a generic argument list"))))
    )

  (test
    '(
      "ledger f1: Bytes<17>;"
      "ledger f2: Counter;"
      "export circuit ~foo(): [] {"
      "  f1 = pad(32, 'hello');"
      "  f2 += 3;"
      "  f2 -= 2;"
      "  return;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 16" "unexpected ~a" ("character '~'")))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  assert(false, '\\uARGH')"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 21" "unexpected ~a" ("character 'R'")))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  assert(false, '\\uARGH')"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 21" "unexpected ~a" ("character 'R'")))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  const k: Uint<0.3>;"
      "  return;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 17" "parse error: found ~a looking for~?" ("\"0.3\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a type size"))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  const k: Uint<0.!3>;"
      "  return;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 19" "unexpected ~a" ("character '!'")))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  const k: Uint<0..T> = 0;"
      "  return;"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ()
             (ttuple)
          (block
            (const ([k (tunsigned 0 (type-size-ref T)) 0]))
            (return (tuple))))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  const k: Uint<0.2.T> = 0;"
      "  return;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 21" "unexpected ~a" ("character 'T'")))
    )

  (test
    '(
      "pragma compiler_version >= 0.0 && (!0.0.1 || < 3 || <= 4 && > 5) || 2.2.22.222;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 75" "parse error: found ~a looking for~?" ("\".\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\";\"" "\"||\"" "\"&&\""))))
    )

  (test
    '(
      "/* never ending comment"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 24" "unexpected ~a" ("end of file")))
    )

  (test
    '(
      "/* never ending comment *"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 26" "unexpected ~a" ("end of file")))
    )

  (test
    '(
      "     /* never ending"
      "        comment"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 16" "unexpected ~a" ("end of file")))
    )

  (test
    '(
      "     /* never ending comment"
      "\t \t"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 4" "unexpected ~a" ("end of file")))
    )

  ; adopted test from the fuzzer
  (test
   `(
     "constructor(){"
     ,(format "const bob : Uint<~d..168891327912723648> = 28;" (+ (max-field) 1))
     "assert(bob, 'pArBeAMjgTo');"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 18" "~s is out of Field range" (,(+ (max-field) 1))))
   )

  (test
   `(
     "constructor(){"
     ,(format "const bob : Uint<~d> = 28;" (+ (max-field) 1))
     "assert(bob, 'pArBeAMjgTo');"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 18" "~s is out of Field range" (,(+ (max-field) 1))))
   )

  (test
   '(
     "circuit bar<T>(x: T): Field {"
     "  return x[0];"
     "}"
     "export circuit foo(x: Vector<102211695604070082112571065507755096754575920209623522239390234855480569854275933742834077002685857629445612735086326265689167708028928, Field>): Field {"
     "  return bar<Vector<102211695604070082112571065507755096754575920209623522239390234855480569854275933742834077002685857629445612735086326265689167708028928, Field>>(x);"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 30" "~s is out of Field range" (102211695604070082112571065507755096754575920209623522239390234855480569854275933742834077002685857629445612735086326265689167708028928)))
   )

  (test
   `(
     "circuit bar<T>(x: T): Field {"
     "  return x[0];"
     "}"
     ,(format "export circuit foo(x: Vector<~d, Field>): Field {" (+ (max-field) 1))
     "  return bar<Vector<102211695604070082112571065507755096754575920209623522239390234855480569854275933742834077002685857629445612735086326265689167708028928, Field>>(x);"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 4 char 30" "~s is out of Field range" (,(+ (max-field) 1))))
   )

  (test
   '(
     "constructor(){"
     "  for (const bob of 43590753987470154073008687018949015693739732443847914451724382048030858970499737771427492556824041757676506525608660929336420019966319688777990144..75450365599981963904548864) {"
     "    assert(bob, '1 ,º6º6@6ª¶≠4');"
     "  }"
     "}")
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 21" "~s is out of Field range" (43590753987470154073008687018949015693739732443847914451724382048030858970499737771427492556824041757676506525608660929336420019966319688777990144)))
   )

  (test
   `(
     "constructor(){"
     ,(format "  for (const bob of 75450365599981963904548864..~d) {" (+ (max-field) 1))
     "    assert(bob, '1 ,º6º6@6ª¶≠4');"
     "  }"
     "}")
   (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 49" "~s is out of Field range" (,(+ (max-field) 1))))
   )

  (test
   `(
     "import CompactStandardLibrary;"
     ,(format "export ledger OVphehfcaalYE갖ntW: Map<MerkleTree<4017361411, Vector<2232531320, Opaque<'Uint8Array'>>>, Uint<~d..600095776>>;" (+ (max-field) 1)))
   (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 109" "~s is out of Field range" (,(+ (max-field) 1))))
   )

  ; pm-15798
  (test
    '(
      "pragma language_version >= 0.14.0 && !>= 0.14.0;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 39" "parse error: found ~a looking for~?" ("\">=\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a version atom"))))
    )

  ; pm-16349
  (test
    '(
      "pragma compiler_version  !  <3.0.5>  *  1,2,3,4,5,6,7,8,9,10,11,12  >  (1.7.8)  ,,  self  -=  <1.4.2>  >=  1,2,3,4,5,6,7,8,9,10,11,12,13  ==  pragma;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 29" "parse error: found ~a looking for~?" ("\"<\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a version atom"))))
    )

  ; pm-17347
  (test
    '(
      "7๓ؒNJe& include"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "parse error: found ~a looking for~?" ("\"7\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a program element" "end of file"))))
    )

  (test
    '(
      "๓ؒNJe& include"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "unexpected ~a" ("character '๓'")))
    )

  (test
    '(
      "abc๓ؒNJe"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "parse error: found ~a looking for~?" ("\"abc\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a program element" "end of file"))))
    )

  (test
    '(
      "pragma language_version >= 0.๓ؒNJe"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 30" "unexpected ~a" ("character '๓'")))
    )

  (test
    '(
      "pragma language_version >= 0.4๓ؒNJe"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 31" "unexpected ~a" ("character '๓'")))
    )

  (test
    '(
      "pragma language_version >= 0.4.๓ؒNJe"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 32" "unexpected ~a" ("character '๓'")))
    )

  (test
    '(
      "pragma language_version >= 0.4.7๓ؒNJe"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 33" "unexpected ~a" ("character '๓'")))
    )
)

(run-tests resolve-includes
  (test
    "test-center/compact/simple.compact"
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 42)))))
    )

  (with-compact-path
    (cons "test-center" (compact-path))
    (test
      '(
        "include 'compact/simple';"
        )
      (returns
        (program
          (circuit #f #f foo () () (tfield) (block (return 42)))))
      ))

  (with-compact-path
    (cons* "test-center/compact" "test-center/compact2" (compact-path))
    (test
      '(
        "include 'foo';"
        )
      (returns
        (program
          (circuit #f #f foo () () (tfield) (block (return 42)))))
      ))

  (with-compact-path
    (cons* "test-center/compact2" "test-center/compact" (compact-path))
    (test
      '(
        "include 'foo';"
        )
      (returns
        (program
          (circuit #f #f foo () ([x (tfield)])
                   (tboolean)
                   (block (return (== x 0))))))
      ))

  (test
    `(
      ,(format "include '~a/test-center/compact/foo';" (current-directory))
      )
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 42)))))
    )

  (with-compact-path
    (cons "test-center/compact" (compact-path))
    (test
      '(
        "// presumably not present..."
        "include '/foo';"
        )
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 2 char 1" "failed to locate file ~s" ("/foo.compact")))
      ))

  (test
    "test-center/compact/multiple.compact"
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 42)))
        (circuit #f #f foo () () (tfield) (block (return 42)))))
    )

  (test
    '(
      "// presumably not present..."
      "include 'not-found';"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "failed to locate file ~s" ("not-found.compact")))
    )

  (test
    "test-center/compact/invalid-extension.compact"
    (oops
      message: "~a:\n  ~?"
      irritants: '("invalid-extension.compact line 16 char 1" "failed to locate file ~s" ("test-center/compact/foo.compact.compact")))
    )

  (test
    "test-center/compact/loop.compact"
    (oops
      message: "~a:\n  ~?"
      irritants: '("test-center/compact/loop.compact line 16 char 1" "include cycle involving ~s" ("test-center/compact/loop.compact")))
    )

  (test
    '(
      "include 'test-center/compact/loop';"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("loop.compact line 16 char 1" "include cycle involving ~s" ("test-center/compact/loop.compact")))
    )

  (test
    '(
      "module M {"
      "  include 'test-center/compact/loop';"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("loop.compact line 16 char 1" "include cycle involving ~s" ("test-center/compact/loop.compact")))
    )

  (test
    '(
      "module M {"
      "  include 'test-center/compact/foo';"
      "  export { foo };"
      "}"
      )
    (returns
      (program
        (module #f M ()
          (circuit #f #f foo () () (tfield) (block (return 42)))
          (export foo))))
    )

  (test
    '(
      "include 'test-center/compact/foo';"
      "module M {"
      "  include 'test-center/compact/foo';"
      "  export { foo };"
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () () (tfield) (block (return 42)))
        (module #f M ()
          (circuit #f #f foo () () (tfield) (block (return 42)))
          (export foo))))
    )

  (test
    '(
      "module M {"
      "  include 'test-center/compact/foo';"
      "  export { foo };"
      "}"
      "include 'test-center/compact/foo';"
      )
    (returns
      (program
        (module #f M ()
          (circuit #f #f foo () () (tfield) (block (return 42)))
          (export foo))
        (circuit #f #f foo () () (tfield) (block (return 42)))))
    )

  (test-group
    ((create-file "included.compact" '())
     (succeeds)
     )
    ((create-file "including.compact"
       '(
         "include 'compiler/testdir/included';"
         ))
     (returns (program))))

  (test-group
    ((create-file "included.compact" '())
     (succeeds)
     )
    ((create-file "including.compact"
       '(
         "include 'included';"
         ))
     (returns (program))))

  (test-group
    ((create-file "included.compact" '())
     (custom-check
       (lambda (pass-name x)
         (chmod "compiler/testdir/included.compact" 000)
         #t))
     )
    ((create-file "including.compact"
       '(
         "include 'compiler/testdir/included';"
         ))
     (oops
       message: "error ~a: ~a"
       irritants: '("opening source file" "failed for compiler/testdir/included.compact: permission denied"))
     ))

  ; verify that std.compact no longer exists
  (test
    '(
      "include 'std';"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "failed to locate file ~s: possibly replace include with import CompactStandardLibrary" ("std.compact")))
    )
)

(run-tests expand-const
  ; this pass doesn't compalin about an identifier being referenced before it is assigned
  ; this is caught by expand-modules-and-types
  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const [a, b] = [1, a];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (const (a b) (tundeclared) (tuple 1 a))
            (return y)))))
   )

  ; this pass doesn't compalin about an identifier being referenced before it is assigned
  ; this is caught by expand-modules-and-types
  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const [x, y] = [a, 12], [a, b] = [1, 2];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq
              (const (x y) (tundeclared) (tuple a 12))
              (const (a b) (tundeclared) (tuple 1 2)))
            (return y)))))
   )

  ; this pass doesn't compalin about an identifier being referenced before it is assigned
  ; this is caught by expand-modules-and-types
  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const [x, y] = [a, b], [a, b] = [1, 2];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq
              (const (x y) (tundeclared) (tuple a b))
              (const (a b) (tundeclared) (tuple 1 2)))
            (return y)))))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const [a, b] = [1, 2], [x, y] = [a, b];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq
              (const (a b) (tundeclared) (tuple 1 2))
              (const (x y) (tundeclared) (tuple a b)))
            (return y)))))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const x = 10, y = 20;"
     "  const [a, b] = [x, y];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq (const x (tundeclared) 10)
                 (const y (tundeclared) 20))
            (const (a b) (tundeclared) (tuple x y))
            (return y)))))
   )

  ; the double binding of y is caught in infer-types
  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const y = n, x = n + y;"
     "  const y = x;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq
              (const y (tundeclared) n)
              (const x (tundeclared) (+ n y)))
            (const y (tundeclared) x)
            (return y)))))
   )

  ; this pass doesn't compalin about an identifier being referenced before it is assigned
  ; this is caught by expand-modules-and-types
  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const z = x, x = 10;"
     "  const y = n, x = n + y;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq (const z (tundeclared) x)
                 (const x (tundeclared) 10))
            (seq
              (const y (tundeclared) n)
              (const x (tundeclared) (+ n y)))
            (return y)))))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const z = x;"
     "  const y = n, x = n + y;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (const z (tundeclared) x)
            (seq
              (const y (tundeclared) n)
              (const x (tundeclared) (+ n y)))
            (return y)))))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const y = n, x = n + y;"
     "  const z = x;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq
              (const y (tundeclared) n)
              (const x (tundeclared) (+ n y)))
            (const z (tundeclared) x)
            (return y)))))
   )

  ; this pass doesn't compalin about an identifier being referenced before it is assigned
  ; this is caught by expand-modules-and-types
  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const x = n + y, y = n;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq
              (const x (tundeclared) (+ n y))
              (const y (tundeclared) n))
            (return y)))))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const y = n, x = n + y;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq
              (const y (tundeclared) n)
              (const x (tundeclared) (+ n y)))
            (return y)))))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const y = n, x = 30;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ([n (tfield)])
             (tfield)
          (block
            (seq (const y (tundeclared) n)
                 (const x (tundeclared) 30))
            (return y)))))
   )

  ; this pass doesn't compalin about an identifier being referenced before it is assigned
  ; this is caught by expand-modules-and-types
  (test
   '(
     "circuit foo (): Field {"
     "  const y = x, x = 30;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (seq (const y (tundeclared) x)
                 (const x (tundeclared) 30))
            (return y)))))
   )

  ; this pass doesn't complain about multiple bindings of identifiers.
  ; this is caught by expand-modules-and-types
  (test
   '(
     "circuit foo (): Field {"
     "  const [x, a] = [10, 11], y = x, z = y, x = z;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (seq
              (const (x a) (tundeclared) (tuple 10 11))
              (const y (tundeclared) x)
              (const z (tundeclared) y)
              (const x (tundeclared) z))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const [x, a] = [10, 11], y = x, z = y;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (seq
              (const (x a) (tundeclared) (tuple 10 11))
              (const y (tundeclared) x)
              (const z (tundeclared) y))
            (return y)))))
   )

  ; this pass doesn't complain about multiple bindings of x.
  ; this is caught by expand-modules-and-types
  (test
   '(
     "circuit foo (): Field {"
     "  const x = 10, y = x, x = y;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (seq
              (const x (tundeclared) 10)
              (const y (tundeclared) x)
              (const x (tundeclared) y))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const x = 10, y = x;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (seq (const x (tundeclared) 10)
                 (const y (tundeclared) x))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const x : Field = 10, y : Field = 20, z = 30;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (seq
              (const x (tfield) 10)
              (const y (tfield) 20)
              (const z (tundeclared) 30))
            (return y)))))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const [x, y] : [Field, Field] = [10, 20];"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (const (x y) (ttuple (tfield) (tfield)) (tuple 10 20))
            (return y)))))
   )

  (test
    '(
      "circuit A(): Field {"
      "  const t1 : Uint<0..38> = 25, t2 : Uint< 0..38> = t1, t3 : Uint<0 ..38> = t2, t4 : Uint< 0 ..38> = t3, t5 : Uint<0.. 38> = t4, t6 : Uint< 0.. 38> = t5, t7 : Uint<0 .. 38> = t6, t8 : Uint< 0 .. 38> = t7, t9 : Uint<0..38 > = t8, t10 : Uint< 0..38 > = t9, t11 : Uint<0 ..38 > = t10, t12 : Uint< 0 ..38 > = t11, t13 : Uint<0.. 38 > = t12, t14 : Uint< 0.. 38 > = t13, t15 : Uint<0 .. 38 > = t14, t16 : Uint< 0 .. 38 > = t15;"
      "  return t16;"
      "}"
      )
    (returns
      (program
        (circuit #f #f A () ()
             (tfield)
          (block
            (seq
              (const t1 (tunsigned 0 38) 25)
              (const t2 (tunsigned 0 38) t1)
              (const t3 (tunsigned 0 38) t2)
              (const t4 (tunsigned 0 38) t3)
              (const t5 (tunsigned 0 38) t4)
              (const t6 (tunsigned 0 38) t5)
              (const t7 (tunsigned 0 38) t6)
              (const t8 (tunsigned 0 38) t7)
              (const t9 (tunsigned 0 38) t8)
              (const t10 (tunsigned 0 38) t9)
              (const t11 (tunsigned 0 38) t10)
              (const t12 (tunsigned 0 38) t11)
              (const t13 (tunsigned 0 38) t12)
              (const t14 (tunsigned 0 38) t13)
              (const t15 (tunsigned 0 38) t14)
              (const t16 (tunsigned 0 38) t15))
            (return t16)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): [Field, Boolean] {"
      "  return [y, x];"
      "}"
      "export circuit foo(): Field {"
      "  const [a, b] = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (circuit #f #f bar () ([x (tboolean)] [y (tfield)])
             (ttuple (tfield) (tboolean))
          (block (return (tuple y x))))
        (circuit #t #f foo () ()
             (tfield)
          (block
            (const (a b) (tundeclared) (call bar #t 17))
            (return (if b a (* 2 a)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const {a, b} = bar(true, 17), z = a;"
      "  return b ? a : 2 * z;"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (struct #f S () [a (tfield)] [b (tboolean)])
        (circuit #f #f bar () ([x (tboolean)] [y (tfield)])
             (type-ref S)
          (block (return (new (type-ref S) y x))))
        (circuit #t #f foo () ()
             (tfield)
          (block
            (seq
              (const ((a a) (b b)) (tundeclared) (call bar #t 17))
              (const z (tundeclared) a))
            (return (if b a (* 2 z)))))))
    )

  ; this pass doesn't compalin about an identifier being referenced before it is assigned
  ; this is caught by expand-modules-and-types
  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const z = a, {a, b} = bar(true, 17);"
      "  return b ? a : 2 * z;"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (struct #f S () [a (tfield)] [b (tboolean)])
        (circuit #f #f bar () ([x (tboolean)] [y (tfield)])
             (type-ref S)
          (block (return (new (type-ref S) y x))))
        (circuit #t #f foo () ()
             (tfield)
          (block
            (seq
              (const z (tundeclared) a)
              (const ((a a) (b b)) (tundeclared) (call bar #t 17)))
            (return (if b a (* 2 z)))))))
    )
  )

(run-tests expand-patterns
  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const {a, b} = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (struct #f S () [a (tfield)] [b (tboolean)])
        (circuit #f #f bar () ([x (tboolean)] [y (tfield)])
             (type-ref S)
          (block (return (new (type-ref S) y x))))
        (circuit #t #f foo () ()
             (tfield)
          (block
            (seq
              (const
                __compact_pattern_tmp1
                (tundeclared)
                (call bar #t 17))
              (const a (tundeclared) (elt-ref __compact_pattern_tmp1 a))
              (const b (tundeclared) (elt-ref __compact_pattern_tmp1 b)))
            (return (if b a (* 2 a)))))))
    )

  (test
    '(
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, [x2, y] : [Boolean, Field], z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      )
    (returns
      (program
        (struct #f S ()
          [a (ttuple (tfield) (tbytes 6))]
          [b (tboolean)])
        (circuit #f #f bar () ([x1 (tboolean)]
                               [__compact_pattern_tmp1 (ttuple
                                                         (tboolean)
                                                         (tfield))]
                               [z (tbytes 6)])
             (ttuple (type-ref S) (tboolean))
          (block
            (const
              x2
              (tundeclared)
              (tuple-ref __compact_pattern_tmp1 0))
            (const y (tundeclared) (tuple-ref __compact_pattern_tmp1 1))
            (block
              (return (tuple (new (type-ref S) (tuple y z) x1) x2)))))))
    )

  (test
    '(
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, [x2, y] : [Boolean, Field], z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "circuit go([{a: [a, b], b: b1}, b2] : [S, Boolean]): [Field, Bytes<6>] {"
      "  return [b1 ? a : 2 * a, b2 ? b : 'hello!'];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const t = bar(x1, [x2, y], z);"
      "  return go(t);"
      "}"
      )
    (returns
      (program
        (struct #f S ()
          [a (ttuple (tfield) (tbytes 6))]
          [b (tboolean)])
        (circuit #f #f bar () ([x1 (tboolean)]
                               [__compact_pattern_tmp4 (ttuple
                                                         (tboolean)
                                                         (tfield))]
                               [z (tbytes 6)])
             (ttuple (type-ref S) (tboolean))
          (block
            (const
              x2
              (tundeclared)
              (tuple-ref __compact_pattern_tmp4 0))
            (const y (tundeclared) (tuple-ref __compact_pattern_tmp4 1))
            (block
              (return (tuple (new (type-ref S) (tuple y z) x1) x2)))))
        (circuit #f #f go () ([__compact_pattern_tmp1 (ttuple
                                                        (type-ref S)
                                                        (tboolean))])
             (ttuple (tfield) (tbytes 6))
          (block
            (const
              __compact_pattern_tmp2
              (tundeclared)
              (tuple-ref __compact_pattern_tmp1 0))
            (const
              __compact_pattern_tmp3
              (tundeclared)
              (elt-ref __compact_pattern_tmp2 a))
            (const a (tundeclared) (tuple-ref __compact_pattern_tmp3 0))
            (const b (tundeclared) (tuple-ref __compact_pattern_tmp3 1))
            (const b1 (tundeclared) (elt-ref __compact_pattern_tmp2 b))
            (const
              b2
              (tundeclared)
              (tuple-ref __compact_pattern_tmp1 1))
            (block
              (return
                (tuple
                  (if b1 a (* 2 a))
                  (if b2 b #vu8(104 101 108 108 111 33)))))))
        (circuit #t #f foo () ([x1 (tboolean)]
                               [x2 (tboolean)]
                               [y (tfield)]
                               [z (tbytes 6)])
             (ttuple (tfield) (tbytes 6))
          (block
            (const t (tundeclared) (call bar x1 (tuple x2 y) z))
            (return (call go t))))))
    )

  (test
    '(
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, [x2, y] : [Boolean, Field], z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const t = bar(x1, [x2, y], z);"
      "  return (([{a: [a, b], b: b1}, b2]) => [b1 ? a : 2 * a, b2 ? b : 'hello!'])(t);"
      "}"
      )
    (returns
      (program
        (struct #f S ()
          [a (ttuple (tfield) (tbytes 6))]
          [b (tboolean)])
        (circuit #f #f bar () ([x1 (tboolean)]
                               [__compact_pattern_tmp4 (ttuple
                                                         (tboolean)
                                                         (tfield))]
                               [z (tbytes 6)])
             (ttuple (type-ref S) (tboolean))
          (block
            (const
              x2
              (tundeclared)
              (tuple-ref __compact_pattern_tmp4 0))
            (const y (tundeclared) (tuple-ref __compact_pattern_tmp4 1))
            (block
              (return (tuple (new (type-ref S) (tuple y z) x1) x2)))))
        (circuit #t #f foo () ([x1 (tboolean)]
                               [x2 (tboolean)]
                               [y (tfield)]
                               [z (tbytes 6)])
             (ttuple (tfield) (tbytes 6))
          (block
            (const t (tundeclared) (call bar x1 (tuple x2 y) z))
            (return
              (call (circuit ([__compact_pattern_tmp1 (tundeclared)])
                         (tundeclared)
                      (block
                        (const
                          __compact_pattern_tmp2
                          (tundeclared)
                          (tuple-ref __compact_pattern_tmp1 0))
                        (const
                          __compact_pattern_tmp3
                          (tundeclared)
                          (elt-ref __compact_pattern_tmp2 a))
                        (const
                          a
                          (tundeclared)
                          (tuple-ref __compact_pattern_tmp3 0))
                        (const
                          b
                          (tundeclared)
                          (tuple-ref __compact_pattern_tmp3 1))
                        (const
                          b1
                          (tundeclared)
                          (elt-ref __compact_pattern_tmp2 b))
                        (const
                          b2
                          (tundeclared)
                          (tuple-ref __compact_pattern_tmp1 1))
                        (return
                          (tuple
                            (if b1 a (* 2 a))
                            (if b2 b #vu8(104 101 108 108 111 33))))))
                t))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const {a, b} = bar(true, 17), z = a;"
      "  return b ? a : 2 * z;"
      "}"
      )
    (returns
      (program
        (import CompactStandardLibrary () "")
        (struct #f S () [a (tfield)] [b (tboolean)])
        (circuit #f #f bar () ([x (tboolean)] [y (tfield)])
             (type-ref S)
          (block (return (new (type-ref S) y x))))
        (circuit #t #f foo () ()
             (tfield)
          (block
            (seq
              (seq
                (const
                  __compact_pattern_tmp1
                  (tundeclared)
                  (call bar #t 17))
                (const a (tundeclared) (elt-ref __compact_pattern_tmp1 a))
                (const b (tundeclared) (elt-ref __compact_pattern_tmp1 b)))
              (const z (tundeclared) a))
            (return (if b a (* 2 z)))))))
    )

  (test
   '(
     "circuit foo (): Field {"
     "  const [x, a] = [10, 11], y = x, z = y;"
     "  return y;"
     "}"
     )
   (returns
      (program
        (circuit #f #f foo () ()
             (tfield)
          (block
            (seq
              (seq
                (const __compact_pattern_tmp1 (tundeclared) (tuple 10 11))
                (const x (tundeclared) (tuple-ref __compact_pattern_tmp1 0))
                (const
                  a
                  (tundeclared)
                  (tuple-ref __compact_pattern_tmp1 1)))
              (const y (tundeclared) x)
              (const z (tundeclared) y))
            (return y)))))
   )
  )

(run-tests report-unreachable
  (test
    '(
      "circuit foo() : Bytes<20> { const x = 5; return 'Hello world!'; }"
      )
    (returns
      (program
        (circuit #f #f foo ()
            ()
          (tbytes 20)
          (block
            (const x (tundeclared) 5)
            (return ,(string->utf8 "Hello world!"))))))
    )

  (test
    '(
      "export ledger field1: Counter;"
      "circuit foo(state: Uint<16>) : Uint<16> { return state; field1 += state; }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 57" "unreachable statement" ()))
    )

  (test
    '(
      "export ledger field1: Counter;"
      "circuit foo(state: Uint<16>) : Uint<16> { return state; field1 -= state; }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 57" "unreachable statement" ()))
    )

  (test
    '(
      "export ledger field1: Counter;"
      "circuit foo(state: Uint<16>) : Uint<16> { return state; field1 = state; }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 57" "unreachable statement" ()))
    )

  (test
    '(
      "circuit foo() : Bytes<20> {"
      "   assert(true, 'oops');"
      "   return 'Hello world!';"
      "   const x = 5;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 10" "unreachable statement" ()))
    )

  (test
    '(
      "circuit foo() : Bytes<20> {"
      "   return 'Hello world!';"
      "   return 'Hello world!';"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 4" "unreachable statement" ()))
    )

  (test
    '(
      "circuit foo() : Bytes<20> {"
      "   return 'Hello world!';"
      "   assert(true, 'true is true');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 4" "unreachable statement" ()))
    )

  (test
    '(
      "circuit foo() : Bytes<20> {"
      "   return 'Hello world!';"
      "   { const x = 5; }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 4" "unreachable statement" ()))
    )

  (test
    '(
      "ledger bar: Bytes<20>;"
      "circuit foo() : Bytes<20> {"
      "   return 'Hello world!';"
      "   bar.read();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 4" "unreachable statement" ()))
    )

  (test
    '(
      "circuit foo(b: Boolean) : Bytes<20> {"
      "   if (b) return 'Hello world!';"
      "   const x = 5;"
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () ([b (tboolean)])
             (tbytes 20)
          (block
            (if b (return ,(string->utf8 "Hello world!")) (tuple))
            (const x (tundeclared) 5)))))
    )

  (test
    '(
      "circuit foo(b: Boolean) : Bytes<20> {"
      "   if (b) return 'Hello world!';"
      "   else return 'Hola Mundo!';"
      "   if (b) assert(b, 'oops');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 4" "unreachable statement" ()))
    )

  (test
    '(
      "circuit foo(b: Boolean) : Bytes<20> {"
      "   if (b) return 'Hello world!';"
      "   else if (!b) return 'Hola Mundo!';"
      "   else assert(b, 'oops');"
      "   const x = 5;"
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () ([b (tboolean)])
             (tbytes 20)
          (block
            (if b
                (return ,(string->utf8 "Hello world!"))
                (if (not b)
                    (return ,(string->utf8 "Hola Mundo!"))
                    (assert b "oops")))
            (const x (tundeclared) 5)))))
    )

  (test
    '(
       "circuit foo(arg: Bytes<20>) : Field { return arg as Field; }"
     )
    (returns
      (program
        (circuit #f #f foo () ([arg (tbytes 20)])
             (tfield)
          (block (return (cast (tfield) arg))))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  return;"
      "  for (const i of 3..3) i + 1;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 3" "unreachable statement" ()))
    )

  ; pm-16183
  (test
    '(
      "constructor() {"
      "  for (const i of 1..10) {"
      "    for (const i of 1..10) {"
      "      return [];"
      "      return false;"
      "      return default<Uint<32>>;"
      "    }"
      "    return [];"
      "    return false;"
      "  }"
      "  "
      "  return;"
      "  return;"
      "  assert(true == false, 'bob');"
      "  return true;"
      "  return;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 7" "unreachable statement" ()))
    )

  ; pm-16183
  (test
    '(
      "export circuit tom(b: Boolean, c: Boolean): Uint<32> {"
      "    return ((b: Boolean, c: Boolean) : Uint<32> => {"
      "      if(b != c) {"
      "        {"
      "          return (1 * (b as Uint<8>)) as Uint<16>;"
      "        }"
      "        return false;"
      "      } else {"
      "        return (1 * (c as Uint<16>)) as Uint<32>;"
      "        {"
      "          return true;"
      "        }"
      "        return false;"
      "      }"
      "    })(b, c);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 9" "unreachable statement" ()))
    )
)

(run-tests hoist-local-variables
  (test
    '(
      "circuit foo() : Bytes<20> { return 'Hello world!'; }"
      )
    (returns
      (program
        (circuit #f #f foo () ()
            (tbytes 20)
          (block () (return ,(string->utf8 "Hello world!")))))))

  (test
    '(
      "circuit foo() : Field { if (true) const q = 10; return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 41" "const binding found in a single-statement context" ()))
    )

  (test
    '(
      "circuit foo() : Field { const q = 10; const q = 11; return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 45" "found multiple bindings for ~s in the same block" (q))))

  (test
    '(
       "circuit foo(arg: Bytes<20>) : Field { return arg as Field; }"
      )
    (returns
      (program
        (circuit #f #f foo () ([arg (tbytes 20)])
             (tfield)
          (block () (return (cast (tfield) arg))))))
    )

  (test ;; FIXME uncomment composable contract
    "test-center/compact/test.compact"
    (returns
      (program
        (import CompactStandardLibrary () "")
        (import CompactStandardLibrary () "" ())
        (module #f M ((nat-valued a) b)
          (struct #t frob () [q (tfield)])
          (struct #t pair ()
            [x (tfield)]
            [y (tvector (type-size-ref a) (type-ref b))])
          (circuit #t #f slicer () ([v (tvector 10 (tfield))])
               (tvector 5 (tfield))
            (block () (return (tuple-slice v 3 5)))))
        (enum #f PublicState setup commit reveal final)
        (import M (5 (topaque "sisters")) "M$")
        (circuit #t #t foo () ([a (tboolean)] [b (tfield)])
             (tboolean)
          (block () (return #f)))
        (circuit #t #f bar () ([a (tboolean)] [b (tboolean)])
             (type-ref M$frob)
          (block (v w x y)
            (= x (tundeclared) (call foo #t 17))
            (= y (tundeclared) (if a (if b 3 2) (if b 1 0)))
            (= w (tboolean) (if a #t #f))
            (= v
               (tundeclared)
               (if a #f (fold foo #t (tuple-ref (tuple (tuple)) 0))))
            (if a
                (if b
                    (assert a "a should be true")
                    (if b (assert a "a should be true") (tuple)))
                (tuple))
            (if a
                (block () (if b (assert a "a should be true") (tuple)))
                (block (v)
                  (= v (tundeclared) a)
                  (if b (assert v "a should be false") (tuple))))
            (fold (circuit ([b (tboolean)] [c (tboolean)] [d (tfield)])
                       (tboolean)
                    (block () (return (if (and a b) c #f))))
              #t
              (tuple #f #t #t #f)
              (tuple 0 1 2 3))
            (tuple-ref (tuple 1 2 3 4) 2)
            (map foo (tuple #f #f #t #f) (tuple 1 2 3 4))
            (assert
              (== (elt-call kernel self) (elt-call kernel2 self))
              "oops")
            (return (new (type-ref M$frob) (elt-call x0 read)))))
        (witness #f C () ([a (tboolean)] [b (tbytes 10)])
             (tbytes 20))
        (witness #f W () ([a (tvector 7 (tvector 9 (tfield)))]
                          [b (topaque "bogeytype")])
             (ttuple))
        (circuit #t #f baz () ([b (tboolean)])
             (tunsigned 10)
          (block () (return (disclose (cast (tunsigned 10) b)))))
        (circuit #t #f nullX () ()
             (tboolean)
          (block () (return (default (tboolean)))))
        (public-ledger-declaration #f #f kernel2 (type-ref Kernel))
        (public-ledger-declaration #f #f x0 (tfield))
        (public-ledger-declaration #f #t x1 (type-ref Set (tfield)))
        (public-ledger-declaration #f #f x2 (type-ref Counter))
        (public-ledger-declaration #f #f
          x3
          (type-ref List (tfield)))
        (public-ledger-declaration #f #f
          x4
          (type-ref Map (tfield) (tboolean)))
        (public-ledger-declaration #f #f
          x5
          (type-ref MerkleTree 32 (tfield)))
        (public-ledger-declaration #f #f
          x6
          (type-ref HistoricMerkleTree 10 (tfield)))
        (public-ledger-declaration #f #f x7 (type-ref CoinInfo))
        (public-ledger-declaration #f #f
          x10
          (type-ref MerkleTreeDigest))
        (public-ledger-declaration #f #f
          x11
          (type-ref QualifiedCoinInfo))
        (public-ledger-declaration #f #f
          x13
          (type-ref ContractAddress))
        (public-ledger-declaration #f #f authority (tbytes 32))
        (public-ledger-declaration #f #f
          state
          (type-ref PublicState))
        (public-ledger-declaration #f #f
          topic
          (type-ref Maybe (topaque "string")))
        (public-ledger-declaration #f #f
          tally_yes
          (type-ref Counter))
        (public-ledger-declaration #f #f
          committed_votes
          (type-ref MerkleTree 10 (tbytes 32)))
        (public-ledger-declaration #f #f
          committed
          (type-ref Set (tbytes 32)))
        (public-ledger-declaration #f #f
          ciphertexts
          (topaque "Uint8Array"))
        (constructor ([state (tfield)])
          (block () (for i (tuple) (+ state 1))))
        (circuit #f #f foosbar () ()
             (ttuple)
          (block () (for i (tuple 3 2 1) (+ i 1))))
        (circuit #f #f ballot_repr () ()
             (tbytes 32)
          (block ()
            (return
              #vu8(121 101 115 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 0 0 0 0 0))))
        (circuit #f #f check_rel_ops () ([x (tunsigned 16)])
             (tboolean)
          (block ()
            (return
              (or (or (or (or (< x 100) (<= x 10)) (> x 40)) (>= x 45))
                  (!= x 10)))))))
    )

  (test ; just see if it succeeds
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it succeeds
    "examples/election.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/counter/contract/src/counter.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/welcome/contract/src/welcome.compact"
    (succeeds))

  (test
    '(
      "export circuit foo(b: Boolean): Uint<16> {"
      "  if (b) const x = 0, y = 1;"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 16" "const binding found in a single-statement context" ()))
    )

  (test
    '(
      "export circuit foo(b: Boolean, v: Vector<3, Field>): Uint<16> {"
      "  if (b) const [x, y] = v;"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 16" "const binding found in a single-statement context" ()))
    )

  (test
    '(
      "export circuit foo(b: Boolean, v: Vector<3, Field>): Uint<16> {"
      "  if (b) const [] = v;"
      "  return 17;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 16" "const binding found in a single-statement context" ()))
    )
)

(run-tests reject-duplicate-bindings
  (test
    '(
      "module M<A, A> {"
      "}"
      "import M<17, 23>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "duplicate ~a ~s" ("generic parameter name" A))))

  (test
    '(
      "struct S<A, A> {}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "duplicate ~a ~s" ("generic parameter name" A))))

  (test
    '(
      "export circuit foo<A, A>(x: A) : A { return x; }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "duplicate ~a ~s" ("generic parameter name" A)))
    )

  (test
    '(
      "circuit foo<A, A>(x: A) : A { return x; }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "duplicate ~a ~s" ("generic parameter name" A)))
    )

  (test
    '(
      "struct S { x: Field; x: Field; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "duplicate ~a ~s" ("field name" x))))

  (test
    '(
      "circuit C(x: Boolean, x: Field) : Boolean { return x; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "duplicate ~a ~s" ("parameter name" x))))

  (test
    '(
      "circuit C() : [] { const x = 5; const x = 6; return x; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 39" "found multiple bindings for ~s in the same block" (x))))

  (test
    '(
      "circuit C(x: Boolean, x: Field) : Boolean;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "duplicate ~a ~s" ("parameter name" x))))

  (test
    '(
      "witness W(x: Boolean, x: Field) : Boolean;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "duplicate ~a ~s" ("parameter name" x))))

  (test
    '(
      "circuit foo(): [] {"
      "  map((x: Field, x: Boolean): Field => x,"
      "  [1, 2, 3],"
      "  [true, false, true]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 7" "duplicate ~a ~s" ("parameter name" x))))

  (test
    '(
      "module M<A> {"
      "  export struct S<A> {}"
      "}"
      "import M<Field>;"
      "circuit foo() : S<Boolean> { return S<Boolean> { }; }"
      )
    (returns
      (program
        (module #f M (A) (struct #t S (A)))
        (import M ((tfield)) "")
        (circuit #f #f foo () ()
             (type-ref S (tboolean))
          (block () (return (new (type-ref S (tboolean)))))))))

  (test
      '(
         "enum names { bill, sally, fred, george, }"
       )
    (returns
      (program
        (enum #f names bill sally fred george)))
  )

  (test
      '(
         "enum names { bill, sally, bill, george, }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "duplicate ~a ~s" ("element name" bill)))
  )
)

(run-tests eliminate-statements
  (test
    '(
      "export circuit foo(): [] {}"
      )
    (returns
      (program
        (circuit #t #f foo () () (ttuple) (tuple))))
    )

  (test
    '(
      "export circuit foo(bar: Field): [] {"
      "  if (bar == 0) {"
      "  } else {"
      "  }"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([bar (tfield)])
             (ttuple)
          (seq (if (== bar 0) (tuple) (tuple)) (tuple)))))
    )

  (test
    '(
      "export circuit foo(bar: Field): [] {"
      "  if (bar == 0) {"
      "  } else {"
      "  }"
      "  assert(true, 'just true');"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([bar (tfield)])
             (ttuple)
          (seq
            (if (== bar 0) (tuple) (tuple))
            (assert #t "just true")
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(bar: Field): [] {"
      "  if (bar == 0) {"
      "    assert(bar == 0, 'oops');"
      "  } else {"
      "  }"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([bar (tfield)])
             (ttuple)
          (seq
            (if (== bar 0) (assert (== bar 0) "oops") (tuple))
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(bar: Field): [] {"
      "  if (bar == 0) {"
      "  } else {"
      "    assert(bar == 0, 'oops');"
      "  }"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([bar (tfield)])
             (ttuple)
          (seq
            (if (== bar 0) (tuple) (assert (== bar 0) "oops"))
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(bar: Field): [] {"
      "  if (bar == 0) {"
      "    assert(true, 'just true');"
      "  } else {"
      "    assert(false, 'just false');"
      "  }"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([bar (tfield)])
             (ttuple)
          (seq
            (if (== bar 0)
                (assert #t "just true")
                (assert #f "just false"))
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(bar: Field): [] {"
      "  if (bar == 0) {"
      "  } else {"
      "    assert(bar == 0, 'oops');"
      "  }"
      "  assert(true, 'just true');"
      "}"
      )
    (returns
      (program
        (circuit #t #f foo () ([bar (tfield)])
             (ttuple)
          (seq
            (if (== bar 0) (tuple) (assert (== bar 0) "oops"))
            (assert #t "just true")
            (tuple)))))
    )

  (test
    '(
      "circuit foo() : Bytes<20> { return 'Hello world!'; }"
      )
    (returns
      (program
        (circuit #f #f foo () ()
            (tbytes 20)
          ,(string->utf8 "Hello world!"))))
  )

  (test
    '(
       "circuit bar (a: Boolean, b: Boolean): Boolean {"
       "  if (a) return !b || b ;"
       "  return a; }"
       )
    (returns
      (program
        (circuit #f #f bar () ([a (tboolean)] [b (tboolean)])
             (tboolean)
          (if a (or (not b) b) a)))))

    (test
      '(
         "circuit bar (a: Boolean, b: Boolean): Boolean {"
         "  const ab1 : Boolean = a && b;"
         "  const ab2 : Boolean = a || b;"
         "  return ab1 || ab2;"
         "}"
         )
      (returns
      (program
        (circuit #f #f bar () ([a (tboolean)] [b (tboolean)])
             (tboolean)
          (block (ab1 ab2)
            (let* ([(ab1 (tboolean)) (and a b)])
              (let* ([(ab2 (tboolean)) (or a b)]) (or ab1 ab2)))))))
      )

  (test
    '(
       "circuit bar (a: Boolean, b: Boolean): Boolean {"
       "  const ab1 : Boolean = a && b;"
       "  const ab2 : Boolean = a || b;"
       "  if (ab1) return a;"
       "  return ab2; }"
     )
    (returns
      (program
        (circuit #f #f bar () ([a (tboolean)] [b (tboolean)])
             (tboolean)
          (block (ab1 ab2)
            (let* ([(ab1 (tboolean)) (and a b)])
              (let* ([(ab2 (tboolean)) (or a b)]) (if ab1 a ab2)))))))
    )

  (test
    '(
      "circuit foo(b: Boolean) : Bytes<20> {"
      "  if (b) {"
      "    const x : Field = 5;"
      "    assert(x == 0, 'oops 1');"
      "  } else {"
      "    assert(b, 'oops 2');"
      "  }"
      "  assert(true, 'oops 3');"
      "  return 'Hello world!';"
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () ([b (tboolean)])
             (tbytes 20)
          (seq
            (if b
                (block (x)
                  (let* ([(x (tfield)) 5]) (assert (== x 0) "oops 1")))
                (assert b "oops 2"))
            (assert #t "oops 3")
            ,(string->utf8 "Hello world!")))))
    )

  (test
    '(
       "circuit foo(arg: Bytes<20>) : Field { return arg as Field; }"
      )
    (returns
      (program
        (circuit #f #f foo () ([arg (tbytes 20)])
             (tfield)
          (cast (tfield) arg)))))

  (test ;; FIXME uncomment composable contract
    "test-center/compact/test.compact"
    (returns
      (program
        (import CompactStandardLibrary () "")
        (import CompactStandardLibrary () "" ())
        (module #f M ((nat-valued a) b)
          (struct #t frob () [q (tfield)])
          (struct #t pair ()
            [x (tfield)]
            [y (tvector (type-size-ref a) (type-ref b))])
          (circuit #t #f slicer () ([v (tvector 10 (tfield))])
               (tvector 5 (tfield))
            (tuple-slice v 3 5)))
        (enum #f PublicState setup commit reveal final)
        (import M (5 (topaque "sisters")) "M$")
        (circuit #t #t foo () ([a (tboolean)] [b (tfield)])
             (tboolean)
          #f)
        (circuit #t #f bar () ([a (tboolean)] [b (tboolean)])
             (type-ref M$frob)
          (block (v w x y)
            (let* ([[x (tundeclared)] (call foo #t 17)])
              (let* ([[y (tundeclared)] (if a (if b 3 2) (if b 1 0))])
                (let* ([[w (tboolean)] (if a #t #f)])
                  (let* ([[v (tundeclared)]
                          (if a
                              #f
                              (fold foo #t (tuple-ref (tuple (tuple)) 0)))])
                    (seq
                      (if a
                          (if b
                              (assert a "a should be true")
                              (if b (assert a "a should be true") (tuple)))
                          (tuple))
                      (if a
                          (if b (assert a "a should be true") (tuple))
                          (block (v)
                            (let* ([[v (tundeclared)] a])
                              (if b (assert v "a should be false") (tuple)))))
                      (fold (circuit ([b (tboolean)]
                                      [c (tboolean)]
                                      [d (tfield)])
                                 (tboolean)
                              (if (and a b) c #f))
                        #t
                        (tuple #f #t #t #f)
                        (tuple 0 1 2 3))
                      (tuple-ref (tuple 1 2 3 4) 2)
                      (map foo (tuple #f #f #t #f) (tuple 1 2 3 4))
                      (assert
                        (== (elt-call kernel self) (elt-call kernel2 self))
                        "oops")
                      (new (type-ref M$frob) (elt-call x0 read)))))))))
        (witness #f C () ([a (tboolean)] [b (tbytes 10)])
             (tbytes 20))
        (witness #f W () ([a (tvector 7 (tvector 9 (tfield)))]
                          [b (topaque "bogeytype")])
             (ttuple))
        (circuit #t #f baz () ([b (tboolean)])
             (tunsigned 10)
          (disclose (cast (tunsigned 10) b)))
        (circuit #t #f nullX () () (tboolean) (default (tboolean)))
        (public-ledger-declaration #f #f kernel2 (type-ref Kernel))
        (public-ledger-declaration #f #f x0 (tfield))
        (public-ledger-declaration #f #t x1 (type-ref Set (tfield)))
        (public-ledger-declaration #f #f x2 (type-ref Counter))
        (public-ledger-declaration #f #f
          x3
          (type-ref List (tfield)))
        (public-ledger-declaration #f #f
          x4
          (type-ref Map (tfield) (tboolean)))
        (public-ledger-declaration #f #f
          x5
          (type-ref MerkleTree 32 (tfield)))
        (public-ledger-declaration #f #f
          x6
          (type-ref HistoricMerkleTree 10 (tfield)))
        (public-ledger-declaration #f #f x7 (type-ref CoinInfo))
        (public-ledger-declaration #f #f
          x10
          (type-ref MerkleTreeDigest))
        (public-ledger-declaration #f #f
          x11
          (type-ref QualifiedCoinInfo))
        (public-ledger-declaration #f #f
          x13
          (type-ref ContractAddress))
        (public-ledger-declaration #f #f authority (tbytes 32))
        (public-ledger-declaration #f #f
          state
          (type-ref PublicState))
        (public-ledger-declaration #f #f
          topic
          (type-ref Maybe (topaque "string")))
        (public-ledger-declaration #f #f
          tally_yes
          (type-ref Counter))
        (public-ledger-declaration #f #f
          committed_votes
          (type-ref MerkleTree 10 (tbytes 32)))
        (public-ledger-declaration #f #f
          committed
          (type-ref Set (tbytes 32)))
        (public-ledger-declaration #f #f
          ciphertexts
          (topaque "Uint8Array"))
        (constructor ([state (tfield)])
          (seq (for i (tuple) (seq (+ state 1) (tuple))) (tuple)))
        (circuit #f #f foosbar () ()
             (ttuple)
          (seq (for i (tuple 3 2 1) (seq (+ i 1) (tuple))) (tuple)))
        (circuit #f #f ballot_repr () ()
             (tbytes 32)
          #vu8(121 101 115 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
               0 0 0 0 0 0 0))
        (circuit #f #f check_rel_ops () ([x (tunsigned 16)])
             (tboolean)
          (or (or (or (or (< x 100) (<= x 10)) (> x 40)) (>= x 45))
              (!= x 10)))))
    )

  (test ; just see if it succeeds
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it succeeds
    "examples/election.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/counter/contract/src/counter.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/welcome/contract/src/welcome.compact"
    (succeeds))

  (test
    '(
      "circuit foo(v: Vector<10, Field>): Boolean {"
      "  return fold("
      "          (b: Boolean, x: Field): Boolean => {"
      "            const y = x;"
      "            {"
      "              return b && x == 0;"
      "              const x = y * 1;"
      "            }"
      "          },"
      "          true,"
      "          v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 21" "unreachable statement" ()))
  )

  (test
    '(
      "circuit foo(v: Vector<10, Field>): Boolean {"
      "  return fold("
      "          (b: Boolean, x: Field): Boolean => {"
      "            const y = x;"
      "            {"
      "              const k = 0;"
      "              return b && x == k;"
      "            }"
      "          },"
      "          true,"
      "          v);"
      "}"
      )
    (returns
      (program
        (circuit #f #f foo () ([v (tvector 10 (tfield))])
             (tboolean)
          (fold (circuit ([b (tboolean)] [x (tfield)])
                     (tboolean)
                  (block (y)
                    (let* ([[y (tundeclared)] x])
                      (block (k)
                        (let* ([[k (tundeclared)] 0]) (and b (== x k)))))))
            #t
            v))))
  )

  (test
    '(
      "export ledger field1: Counter;"
      "circuit foo(state: Uint<16>) : Uint<16> { field1 += state; field1 -= state; return 0; }"
      )
    (returns
      (program
        (public-ledger-declaration #t #f field1 (type-ref Counter))
        (circuit #f #f foo () ([state (tunsigned 16)])
             (tunsigned 16)
          (seq (+= field1 state) (-= field1 state) 0))))
    )
)

(run-tests eliminate-boolean-connectives
  (test
    '(
       "module Foo<n> {"
       "circuit cand(a: Boolean, b: Boolean): Boolean { return a && b; }"
       "circuit cor(a: Boolean, b: Boolean): Boolean { return a || b; }"
       "circuit cnot(a: Boolean): Boolean { return !a; }"
       "}"
    )
    (returns
      (program
        (module #f Foo (n)
          (circuit #f #f cand () ([a (tboolean)] [b (tboolean)])
               (tboolean)
            (if a b #f))
          (circuit #f #f cor () ([a (tboolean)] [b (tboolean)])
               (tboolean)
            (if a #t b))
          (circuit #f #f cnot () ([a (tboolean)])
               (tboolean)
            (if a #f #t)))))
    )

  (test
    '(
      "circuit foo(b: Boolean) : Boolean { return !(!a && a || a && a); }"
      )
    (returns
      (program
        (circuit #f #f foo () ([b (tboolean)])
             (tboolean)
          (if (if (if (if a #f #t) a #f) #t (if a a #f)) #f #t))))
    )

  (test
    '(
       "circuit foo(arg: Bytes<20>) : Field { return arg as Field; }"
      )
    (returns
      (program
        (circuit #f #f foo () ([arg (tbytes 20)])
             (tfield)
          (cast (tfield) arg)))))

  (test ;; FIXME uncomment composable contract
    "test-center/compact/test.compact"
    (returns
      (program
        (import CompactStandardLibrary () "")
        (import CompactStandardLibrary () "" ())
        (module #f M ((nat-valued a) b)
          (struct #t frob () [q (tfield)])
          (struct #t pair ()
            [x (tfield)]
            [y (tvector (type-size-ref a) (type-ref b))])
          (circuit #t #f slicer () ([v (tvector 10 (tfield))])
               (tvector 5 (tfield))
            (tuple-slice v 3 5)))
        (enum #f PublicState setup commit reveal final)
        (import M (5 (topaque "sisters")) "M$")
        (circuit #t #t foo () ([a (tboolean)] [b (tfield)])
             (tboolean)
          #f)
        (circuit #t #f bar () ([a (tboolean)] [b (tboolean)])
             (type-ref M$frob)
          (block (v w x y)
            (let* ([[x (tundeclared)] (call foo #t 17)])
              (let* ([[y (tundeclared)] (if a (if b 3 2) (if b 1 0))])
                (let* ([[w (tboolean)] (if a #t #f)])
                  (let* ([[v (tundeclared)]
                          (if a
                              #f
                              (fold foo #t (tuple-ref (tuple (tuple)) 0)))])
                    (seq
                      (if a
                          (if b
                              (assert a "a should be true")
                              (if b (assert a "a should be true") (tuple)))
                          (tuple))
                      (if a
                          (if b (assert a "a should be true") (tuple))
                          (block (v)
                            (let* ([[v (tundeclared)] a])
                              (if b (assert v "a should be false") (tuple)))))
                      (fold (circuit ([b (tboolean)]
                                      [c (tboolean)]
                                      [d (tfield)])
                                 (tboolean)
                              (if (if a b #f) c #f))
                        #t
                        (tuple #f #t #t #f)
                        (tuple 0 1 2 3))
                      (tuple-ref (tuple 1 2 3 4) 2)
                      (map foo (tuple #f #f #t #f) (tuple 1 2 3 4))
                      (assert
                        (== (elt-call kernel self) (elt-call kernel2 self))
                        "oops")
                      (new (type-ref M$frob) (elt-call x0 read)))))))))
        (witness #f C () ([a (tboolean)] [b (tbytes 10)])
             (tbytes 20))
        (witness #f W () ([a (tvector 7 (tvector 9 (tfield)))]
                          [b (topaque "bogeytype")])
             (ttuple))
        (circuit #t #f baz () ([b (tboolean)])
             (tunsigned 10)
          (disclose (cast (tunsigned 10) b)))
        (circuit #t #f nullX () () (tboolean) (default (tboolean)))
        (public-ledger-declaration #f #f kernel2 (type-ref Kernel))
        (public-ledger-declaration #f #f x0 (tfield))
        (public-ledger-declaration #f #t x1 (type-ref Set (tfield)))
        (public-ledger-declaration #f #f x2 (type-ref Counter))
        (public-ledger-declaration #f #f
          x3
          (type-ref List (tfield)))
        (public-ledger-declaration #f #f
          x4
          (type-ref Map (tfield) (tboolean)))
        (public-ledger-declaration #f #f
          x5
          (type-ref MerkleTree 32 (tfield)))
        (public-ledger-declaration #f #f
          x6
          (type-ref HistoricMerkleTree 10 (tfield)))
        (public-ledger-declaration #f #f x7 (type-ref CoinInfo))
        (public-ledger-declaration #f #f
          x10
          (type-ref MerkleTreeDigest))
        (public-ledger-declaration #f #f
          x11
          (type-ref QualifiedCoinInfo))
        (public-ledger-declaration #f #f
          x13
          (type-ref ContractAddress))
        (public-ledger-declaration #f #f authority (tbytes 32))
        (public-ledger-declaration #f #f
          state
          (type-ref PublicState))
        (public-ledger-declaration #f #f
          topic
          (type-ref Maybe (topaque "string")))
        (public-ledger-declaration #f #f
          tally_yes
          (type-ref Counter))
        (public-ledger-declaration #f #f
          committed_votes
          (type-ref MerkleTree 10 (tbytes 32)))
        (public-ledger-declaration #f #f
          committed
          (type-ref Set (tbytes 32)))
        (public-ledger-declaration #f #f
          ciphertexts
          (topaque "Uint8Array"))
        (constructor ([state (tfield)])
          (seq (for i (tuple) (seq (+ state 1) (tuple))) (tuple)))
        (circuit #f #f foosbar () ()
             (ttuple)
          (seq (for i (tuple 3 2 1) (seq (+ i 1) (tuple))) (tuple)))
        (circuit #f #f ballot_repr () ()
             (tbytes 32)
          #vu8(121 101 115 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
               0 0 0 0 0 0 0))
        (circuit #f #f check_rel_ops () ([x (tunsigned 16)])
             (tboolean)
          (if (if (if (if (< x 100) #t (<= x 10)) #t (> x 40))
                  #t
                  (>= x 45))
              #t
              (!= x 10)))))
    )

  (test ; just see if it succeeds
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it succeeds
    "examples/election.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/counter/contract/src/counter.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/welcome/contract/src/welcome.compact"
    (succeeds))

  (test
    '(
      "module M { struct A {} }"
      "import M<1>;"
      "circuit foo(a: A) : Boolean { return true; }"
      )
    (returns
      (program
        (module #f M () (struct #f A ()))
        (import M (1) "")
        (circuit #f #f foo () ([a (type-ref A)]) (tboolean) #t))))

  (test
    '(
      "circuit foo(a: A) : Boolean { return true; }"
      "module M { struct A {} }"
      "import M<1>;"
      )
    (returns
      (program
        (circuit #f #f foo () ([a (type-ref A)]) (tboolean) #t)
        (module #f M () (struct #f A ()))
        (import M (1) ""))))
)

(run-tests expand-modules-and-types
  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return true; }"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%a.1 (tboolean)]) (tboolean) #t))))

  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return 3; }"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%a.1 (tboolean)]) (tboolean) 3))))

  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return a; }"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%a.1 (tboolean)]) (tboolean) %a.1))))

  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return !(!a && a || a && a); }"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%a.1 (tboolean)])
             (tboolean)
          (if (if (if (if %a.1 #f #t) %a.1 #f) #t (if %a.1 %a.1 #f))
              #f
              #t))))
    )

  (test
    '(
      "export circuit foo(a: foo) : Boolean { return 3; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "invalid context for reference to ~a name ~s" ("function" foo))))

  (test
    '(
      "struct A { x: Field; }"
      "export circuit foo(a: A) : Field { return a.x; }"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%a.1 (tstruct A (x (tfield)))])
             (tfield)
          (elt-ref %a.1 x)))))

  (test
    '(
      "module M {"
      "  export circuit foo(n: Field): Field { return n; }"
      "}"
      "import M;"
      "export circuit bar(m: Field): Field { return foo(m); }"
      )
    (returns
      (program ((bar %bar.0))
        (circuit %foo.0 ([%n.1 (tfield)]) (tfield) %n.1)
        (circuit %bar.2 ([%m.3 (tfield)])
             (tfield)
          (call (fref ((%foo.0))) %m.3)))))

  (test
    '(
      "struct A { x: Field; };"
      "export circuit foo(a: A) : Field { return A; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 43" "invalid context for reference to ~a name ~s" ("struct" A))))

  (test
    '(
      "module M { struct A {} }"
      "import M<1>;"
      "export circuit foo(a: Boolean) : Boolean { return true; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "mismatch between actual number ~s and declared number ~s of import generic parameters for ~s" (1 0 M)))
    )

  (test
    '(
      "module M<a> {"
      "  export struct A { x: Vector<7, a>; }"
      "}"
      "import M<Field>;"
      "export circuit foo(a: A) : Boolean { return a.x[0]; }"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%a.1 (tstruct A
                                 (x (tvector 7 (tfield))))])
             (tboolean)
          (tuple-ref (elt-ref %a.1 x) 0)))))

  (test ; forward reference to imported struct
    '(
      "export circuit foo(a: A) : Boolean { return a.x[0]; }"
      "module M<a> {"
      "  export struct A { x: Vector<7, a>; }"
      "}"
      "import M<Field>;"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%a.1 (tstruct A
                                 (x (tvector 7 (tfield))))])
             (tboolean)
          (tuple-ref (elt-ref %a.1 x) 0)))))

  (test
    '(
      "import CompactStandardLibrary;"
      "witness private_key(): Bytes<32>;"
      "circuit set(val: Field): [] {"
      "  const sk = private_key();"
      "  const apk = public_key(sk);"
      "  const private_key = apk;"
      "}"
      "circuit public_key(sk: Bytes<32>): Bytes<32> {"
      "return persistentHash<Vector<2, Bytes<32>>>([pad(32, 'lares:tiny:pk:'), sk]);"
      "}")
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 14" "invalid context for reference to ~a name ~s" ("variable" private_key)))
    )

  (test
    '(
      "module M<a> {"
      "  export struct A { x: Vector<a, Boolean>; }"
      "}"
      "import M<Field>;"
      "export circuit foo(a: A) : Boolean { return a.x[0]; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 31" "invalid context for reference to ~a name ~s" ("type" a))))

  (test
    '(
      "module M<a> {"
      "  export struct A { x: Vector<7, a>; }"
      "}"
      "import M<3>;"
      "export circuit foo(a: A) : Boolean { return a.x[0]; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 10" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("type" "size" a "line 1 char 10")))
    )

  (test
    '(
      "circuit foo(b: Boolean) : Field { return bar(3, b); }"
      "module Foo<#A> {"
      "  module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  export {bar, foo}"
      "  circuit foo(a: A) : A { return a; }"
      "}"
      "import Foo<Field>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 12" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("size" "type" A "line 2 char 12")))
    )

  (test
    `(
      "module M<n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold((b, x) => b && x == 0, true, v);"
      "  }"
      "}"
      "import M<0>;"
      "import M<1>;"
      "import M<2>;"
      "circuit bar1() : [] {"
      "  assert(C([]), 'oops 0');"
      "  assert(C([7]), 'oops 1');"
      "  assert(C([23, 57]), 'oops 2');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 10" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("type" "size" n "line 1 char 10")))
    )

  (test
    '(
      "struct A { x: Field; }"
      "struct B { x: Vector<A, Boolean>; }"
      "export circuit foo(a: B) : Boolean { return 3; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 22" "invalid context for reference to ~a name ~s" ("struct" A))))

  (test
    '(
      "ledger fld: Counter;"
      "export circuit foo() : Field { return fld; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 13" "unbound identifier ~s" (Counter)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger fld: Counter;"
      "export circuit foo() : Field { return fld; }"
      )
    (returns
      (program ((foo %foo.0))
        (public-ledger-declaration %kernel.1 (Kernel))
        (public-ledger-declaration %fld.2 (Counter))
        (circuit %foo.0 () (tfield) %fld.2)))
    )

  (test
    "test-center/compact/test.compact"
    (returns
      (program ((bar %bar.0)
                (baz %baz.1)
                (foo %foo.2)
                (nullX %nullX.3))
        (public-ledger-declaration %kernel.4 (Kernel))
        (circuit %foo.2 ([%a.5 (tboolean)] [%b.6 (tfield)])
             (tboolean)
          #f)
        (circuit %bar.0 ([%a.7 (tboolean)] [%b.8 (tboolean)])
             (tstruct frob (q (tfield)))
          (let* ([[%x.9 (tundeclared)]
                  (call (fref ((%foo.2))) #t 17)])
            (let* ([[%y.10 (tundeclared)]
                    (if %a.7 (if %b.8 3 2) (if %b.8 1 0))])
              (let* ([[%w.11 (tboolean)] (if %a.7 #t #f)])
                (let* ([[%v.12 (tundeclared)]
                        (if %a.7
                            #f
                            (fold (fref ((%foo.2)))
                              #t
                              (tuple-ref (tuple (tuple)) 0)))])
                  (seq
                    (if %a.7
                        (if %b.8
                            (assert %a.7 "a should be true")
                            (if %b.8 (assert %a.7 "a should be true") (tuple)))
                        (tuple))
                    (if %a.7
                        (if %b.8 (assert %a.7 "a should be true") (tuple))
                        (let* ([[%v.13 (tundeclared)] %a.7])
                          (if %b.8 (assert %v.13 "a should be false") (tuple))))
                    (fold (circuit ([%b.14 (tboolean)]
                                    [%c.15 (tboolean)]
                                    [%d.16 (tfield)])
                               (tboolean)
                            (if (if %a.7 %b.14 #f) %c.15 #f))
                      #t
                      (tuple #f #t #t #f)
                      (tuple 0 1 2 3))
                    (tuple-ref (tuple 1 2 3 4) 2)
                    (map (fref ((%foo.2)))
                      (tuple #f #f #t #f)
                      (tuple 1 2 3 4))
                    (assert
                      (== (elt-call %kernel.4 self)
                          (elt-call %kernel2.17 self))
                      "oops")
                    (new (tstruct frob (q (tfield)))
                      (elt-call %x0.18 read))))))))
        (circuit %baz.1 ([%b.19 (tboolean)])
             (tunsigned 1023)
          (disclose (cast (tunsigned 1023) %b.19)))
        (circuit %nullX.3 () (tboolean) (default (tboolean)))
        (public-ledger-declaration %kernel2.17 (Kernel))
        (public-ledger-declaration %x0.18 (__compact_Cell (tfield)))
        (public-ledger-declaration %x1.20 (Set (tfield)))
        (public-ledger-declaration %x2.21 (Counter))
        (public-ledger-declaration %x3.22 (List (tfield)))
        (public-ledger-declaration %x4.23 (Map (tfield) (tboolean)))
        (public-ledger-declaration %x5.24 (MerkleTree 32 (tfield)))
        (public-ledger-declaration
          %x6.25
          (HistoricMerkleTree 10 (tfield)))
        (public-ledger-declaration
          %x7.26
          (__compact_Cell
            (tstruct CoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned
                       340282366920938463463374607431768211455)))))
        (public-ledger-declaration
          %x10.27
          (__compact_Cell
            (tstruct MerkleTreeDigest (field (tfield)))))
        (public-ledger-declaration
          %x11.28
          (__compact_Cell
            (tstruct QualifiedCoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned 340282366920938463463374607431768211455))
              (mt_index (tunsigned 18446744073709551615)))))
        (public-ledger-declaration
          %x13.29
          (__compact_Cell
            (tstruct ContractAddress (bytes (tbytes 32)))))
        (public-ledger-declaration
          %authority.30
          (__compact_Cell (tbytes 32)))
        (public-ledger-declaration
          %state.31
          (__compact_Cell
            (tenum PublicState setup commit reveal final)))
        (public-ledger-declaration
          %topic.32
          (__compact_Cell
            (tstruct Maybe
              (is_some (tboolean))
              (value (topaque "string")))))
        (public-ledger-declaration %tallyYes.33 (Counter))
        (public-ledger-declaration
          %committedVotes.34
          (MerkleTree 10 (tbytes 32)))
        (public-ledger-declaration %committed.35 (Set (tbytes 32)))
        (public-ledger-declaration
          %ciphertexts.36
          (__compact_Cell (topaque "Uint8Array")))
        (constructor ([%state.37 (tfield)])
          (seq
            (for %i.38 (tuple) (seq (+ %state.37 1) (tuple)))
            (tuple)))))
    )

  (test ; just see if it succeeds
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it succeeds
    "examples/election.compact"
    (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
   (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
   (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
   (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/counter/contract/src/counter.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/welcome/contract/src/welcome.compact"
    (succeeds))

  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return !(!a && a || a && a); }"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%a.1 (tboolean)])
             (tboolean)
          (if (if (if (if %a.1 #f #t) %a.1 #f) #t (if %a.1 %a.1 #f))
              #f
              #t))))
    )

  (test
    '(
       "export circuit foo(b: Boolean) : Boolean { return a; }"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 51" "unbound identifier ~s" (a))))

  (test
    '(
      "export circuit foo(b: Boolean) : Boolean { return !(!b && b || b && a); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 69" "unbound identifier ~s" (a))))

  (test
    '(
      "module M {}"
      "export circuit foo() : [] { M(); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 29" "invalid context for reference to ~a name ~s" ("module" M))))

  (test
    '(
      "export circuit foo() : [] { return 3; }"
      "import foo;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "invalid context for reference to ~a name ~s" ("function" foo))))

  (test
    '(
      "module M<A> {"
      "  import A;"
      "}"
      "import M<3>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 10" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("type" "size" A "line 1 char 10")))
    )

  (test
    '(
      "module M<#A> {"
      "  import A;"
      "}"
      "import M<Field>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 10" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("size" "type" A "line 1 char 10")))
    )

  (test
    '(
      "module M<#A> {"
      "  import A;"
      "}"
      "import M<3>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "invalid context for reference to ~a name ~s" ("size" A)))
    )

  (test
    '(
      "module M<A> {"
      "  import A;"
      "}"
      "import M<Field>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "invalid context for reference to ~a name ~s" ("type" A)))
    )

  (test
    '(
      "struct S {}"
      "import S;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "invalid context for reference to ~a name ~s" ("struct" S)))
    )

  (test
    '(
      "module M<A> {"
      " export {A}"
      "}"
      "import M<Field>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "attempt to export ~a name ~s" ("generic parameter" A)))
    )

  (test
    '(
      "module M<#A> {"
      " export {A}"
      "}"
      "import M<17>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "attempt to export ~a name ~s" ("generic parameter" A)))
    )

  (test
    '(
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      "module Foo<A> {"
      "  module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  export {bar}"
      "  circuit foo(a: A) : A { return a; }"
      "}"
      "import Foo<Field>;"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tfield)
          (call (fref ((%bar.2))) 3 %b.1))
        (circuit %bar.2 ([%a.3 (tfield)] [%b.4 (tboolean)])
             (tfield)
          (call (fref ((%foo.5) (%foo.0))) %a.3))
        (circuit %foo.5 ([%a.6 (tfield)]) (tfield) %a.6)))
    )

  (test
    '(
      "module Foo<A> {"
      "  export circuit bar() : A { return A{ a: 1, d: 2}; }"
      "}"
      "struct pr { a: Field; d: Field; }"
      "import Foo<pr>;"
      "export {bar}"
      )
    (returns
      (program ((bar %bar.0))
        (circuit %bar.0 ()
             (tstruct pr (a (tfield)) (d (tfield)))
          (new (tstruct pr (a (tfield)) (d (tfield))) (a 1) (d 2))))))

  (test
    '(
      "struct S<A> { x: Boolean, y: A }"
      "circuit foo(q: S<Boolean>, r: S<Field>) : S<Field> { return r; }"
      "circuit bar() : S<Field> {"
      "  return foo(S<Boolean>{x: true, y: false}, S<Field>{x: false, y: 17});"
      "}"
      "export {foo, bar}"
      )
    (returns
      (program ((bar %bar.3) (foo %foo.0))
        (circuit %foo.0 ([%q.1 (tstruct S
                                 (x (tboolean))
                                 (y (tboolean)))]
                         [%r.2 (tstruct S (x (tboolean)) (y (tfield)))])
             (tstruct S (x (tboolean)) (y (tfield)))
          %r.2)
        (circuit %bar.3 ()
             (tstruct S (x (tboolean)) (y (tfield)))
          (call (fref ((%foo.0)))
            (new (tstruct S (x (tboolean)) (y (tboolean))) (x #t) (y #f))
            (new (tstruct S (x (tboolean)) (y (tfield))) (x #f) (y 17)))))))

  (test
    '(
      "module M<B> {"
      "  export struct S<A> { x: B; y: A }"
      "}"
      "import M<Boolean>;"
      "export circuit foo(q: S<Boolean>, r: S<Field>) : S<Field> { return r; }"
      "export circuit bar() : S<Field> {"
      "  return foo(S<Boolean>{x: true, y: false}, S<Field>{x: false, y: 17});"
      "}"
      )
    (returns
      (program ((bar %bar.0) (foo %foo.1))
        (circuit %foo.1 ([%q.2 (tstruct S
                                 (x (tboolean))
                                 (y (tboolean)))]
                         [%r.3 (tstruct S (x (tboolean)) (y (tfield)))])
             (tstruct S (x (tboolean)) (y (tfield)))
          %r.3)
        (circuit %bar.0 ()
             (tstruct S (x (tboolean)) (y (tfield)))
          (call (fref ((%foo.1)))
            (new (tstruct S (x (tboolean)) (y (tboolean)))
              (x #t)
              (y #f))
            (new (tstruct S (x (tboolean)) (y (tfield)))
              (x #f)
              (y 17))))))
    )

  (test
    '(
      "module M<S> {"
      "  export struct Q<A> { x: S<A>; }"
      "}"
      "struct D<E> { y: E; }"
      "import M<D>;"
      "export circuit foo(q: Q<Field>): Q<Field> { return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 10" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 1 D)))
    )

   (test
    '(
      "export struct S<A> {"
      "  x: A<Field>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 A)))
    )

  (test
    '(
      "export circuit blah () : [] {return;}"
      "export circuit mlah (x: blah) : [] {return;}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 25" "invalid context for reference to ~a name ~s" ("function" blah)))
    )

  (test
    '(
      "circuit blah<T>():[] {return;}"
      "export circuit mlah(): [] {blah<blah>();}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 33" "invalid context for reference to ~a name ~s" ("function" blah)))
    )

  (test
    '(
      "module M<S> {"
      "  export struct Q<A> { x: S<A>; }"
      "}"
      "struct D<E> { y: E; }"
      "import M<D<Field>>;"
      "export circuit foo(q: Q<Field>): Q<Field> { return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 27" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 S)))
    )

  (test
    '(
      "module M<S> {"
      "  export struct Q<A> { x: S<A, A>; }"
      "}"
      "struct D<E> { y: E; }"
      "import M<D>;"
      "export circuit foo(q: Q<Field>): Q<Field> { return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 10" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 1 D)))
    )

  (test
    '(
      "module M<S> {"
      "  export struct Q<A> { x: S<A, A>; }"
      "}"
      "import M<Field>;"
      "export circuit foo(q: Q<Field>): Q<Field> { return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 27" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (2 0 S))))

  (test
    '(
      "module M<#n> {"
      "  export struct Q { x: n; }"
      "}"
      "module N<#m> {"
      "  import M<m>;"
      "  export {Q}"
      "}"
      "import N<20>;"
      "export circuit foo(q: Q): Boolean { return true; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 24" "invalid context for reference to ~a name ~s" ("size" n)))
    )

  (test
    '(
      "module M<#n> {"
      "  export struct Q { x: n; }"
      "}"
      "module N<m> {"
      "  import M<m>;"
      "  export {Q}"
      "}"
      "import N<20>;"
      "export circuit foo(q: Q): Boolean { return true; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 10" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("type" "size" m "line 4 char 10")))
    )

  (test
    '(
      "module M<#n> {"
      "  export struct Q { x: Bytes<n>; }"
      "}"
      "module N<m> {"
      "  import M<m>;"
      "  export {Q}"
      "}"
      "import N<20>;"
      "export circuit foo(q: Q): Boolean { return true; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 10" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("type" "size" m "line 4 char 10")))
    )

  (test
    '(
      "module M<#n> {"
      "  export struct Q { x: Bytes<n>; }"
      "}"
      "module N<#m> {"
      "  import M<m>;"
      "  export {Q}"
      "}"
      "import N<20>;"
      "export circuit foo(q: Q): Boolean { return true; }"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%q.1 (tstruct Q (x (tbytes 20)))])
             (tboolean)
          #t))))

  (test
    '(
      "module M<#n> {"
      "  export struct Q { x: Bytes<n>; }"
      "}"
      "module N<#m> {"
      "  import M<m>;"
      "  export {Q}"
      "}"
      "struct S { a: Field }"
      "import N<S>;"
      "export circuit foo(q: Q): Boolean { return true; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 10" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("size" "type" m "line 4 char 10")))
    )

  (test
    '(
      "module M<#n> {"
      "  export struct Q { x: Bytes<n>; }"
      "}"
      "module N<m> {"
      "  import M<#m>;"
      "  export {Q}"
      "}"
      "struct S { a: Field }"
      "import N<S>;"
      "export circuit foo(q: Q): Boolean { return true; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 12" "parse error: found ~a looking for~?" ("\"#\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a generic argument" "\">\""))))
    )

  (test
    '(
      "module M<#n> {"
      "  export struct Q { x: Bytes<n>; }"
      "}"
      "module N<m> {"
      "  import M<m>;"
      "  export {Q}"
      "}"
      "import N<M>;"
      "export circuit foo(q: Q): Boolean { return true; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 10" "invalid context for reference to ~a name ~s" ("module" M)))
    )

  (test
    '(
      "export circuit foo(v: Vector<10, Field>): Boolean {"
      "  return fold((b, x) => {"
      "                const y = x;"
      "                {"
      "                  const x = y * 1;"
      "                  return b && x == 0;"
      "                }"
      "              },"
      "              true,"
      "              v);"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%v.1 (tvector 10 (tfield))])
             (tboolean)
          (fold (circuit ([%b.2 (tundeclared)] [%x.3 (tundeclared)])
                     (tundeclared)
                  (let* ([[%y.4 (tundeclared)] %x.3])
                    (let* ([[%x.5 (tundeclared)] (* %y.4 1)])
                      (if %b.2 (== %x.5 0) #f))))
            #t
            %v.1))))
  )

  (test
    '(
      "export circuit foo(v: Vector<10, Field>): Boolean {"
      "  return fold((b, x) => {"
      "                const y = x;"
      "                {"
      "                  const z = b && x == 0;"
      "                  const x = y * 1;"
      "                  return z;"
      "                }"
      "              },"
      "              true,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 34" "identifier ~s might be referenced before it is assigned" (x)))
  )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "export circuit S(q: Field): Field { return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "another binding found for ~s in the same scope at ~a" (S "line 1 char 1")))
  )

  (test
    '(
      "export circuit S(q: Field): Field { return q; }"
      "struct S { x: Field; y: Field; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "another binding found for ~s in the same scope at ~a" (S "line 1 char 1")))
  )

  (test
    '(
      "witness S(): [];"
      "module M {"
      "  circuit S(q: Field): Field { return q; }"
      "  export circuit T(q: Field): Field { return S(q); }"
      "}"
      "import M;"
      "export {T}"
      )
    (returns
      (program ((T %T.3))
        (witness %S.0 () (ttuple))
        (circuit %S.1 ([%q.2 (tfield)]) (tfield) %q.2)
        (circuit %T.3 ([%q.4 (tfield)])
             (tfield)
          (call (fref ((%S.1) (%S.0))) %q.4))))
  )

  (test
    '(
      "witness S(): [];"
      "module M {"
      "  export circuit S(q: Field): Field { return q; }"
      "  export circuit T(q: Field): Field { return S(q); }"
      "}"
      "import M;"
      "export {S, T}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 9" "cannot export ~s (~s) from the top level" (witness S)))
  )

  (test
    '(
      "witness S(): [];"
      "export circuit S(q: Field): Field { return q; }"
      "export circuit T(q: Field): Field { return S(q); }"
      "export {S, T}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 9" "cannot export ~s (~s) from the top level" (witness S)))
  )

  (test
    '(
      "export circuit S(q: Field): Field { return q; }"
      "export circuit T(q: Field): Field { return S(q); }"
      "witness S(): [];"
      "export {S, T}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 9" "cannot export ~s (~s) from the top level" (witness S)))
  )

  (test
    '(
      "circuit S(q: Field): Field { return q; }"
      "export circuit T(q: Field): Field { return S(q); }"
      "witness S(): [];"
      "export {S, T}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 9" "cannot export ~s (~s) from the top level" (witness S)))
  )

  (test
    '(
      "witness S(): [];"
      "export circuit S(q: Field): Field { return q; }"
      "export circuit T(q: Field): Field { return S(q); }"
      )
    (returns
      (program ((S %S.0) (T %T.1))
        (witness %S.2 () (ttuple))
        (circuit %S.0 ([%q.3 (tfield)]) (tfield) %q.3)
        (circuit %T.1 ([%q.4 (tfield)])
             (tfield)
          (call (fref ((%S.2 %S.0))) %q.4))))
  )

  (test
    '(
      "witness S(d: Field): Field;"
      "module M {"
      "  circuit S(q: Field): Field { return q; }"
      "  export circuit T(q: Field): Field { return S(q); }"
      "}"
      "import M;"
      "export {T}"
      )
    (returns
      (program ((T %T.0))
        (witness %S.1 ([%d.2 (tfield)]) (tfield))
        (circuit %S.3 ([%q.4 (tfield)]) (tfield) %q.4)
        (circuit %T.0 ([%q.5 (tfield)])
             (tfield)
          (call (fref ((%S.3) (%S.1))) %q.5))))
  )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M {"
      "  circuit S(q: Field): Field { return q; }"
      "  export circuit T(q: Field): Field { return S(q); }"
      "}"
      "import M;"
      "export {T}"
      )
    (returns
      (program ((T %T.2))
        (circuit %S.0 ([%q.1 (tfield)]) (tfield) %q.1)
        (circuit %T.2 ([%q.3 (tfield)])
             (tfield)
          (call (fref ((%S.0))) %q.3))))
  )

  (test
    '(
      "circuit C() : [];"
      "export circuit D(q: Field): Field {"
      "  C();"
      "  const C = 5;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 3" "invalid context for reference to ~a name ~s" ("variable" C)))
  )

  (test
    '(
      "witness P<#D, E>(x: E): Vector<D, E>;"
      "export circuit foo(n: Field): Vector<2, Field> {"
      "  return P<2, Field>(n);"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (witness %P.1 ([%x.2 (tfield)]) (tvector 2 (tfield)))
        (circuit %foo.0 ([%n.3 (tfield)])
             (tvector 2 (tfield))
          (call (fref ((%P.1))) %n.3))))
    )

  (test
    '(
      "circuit last<#D, E>(v: Vector<D, E>, dflt: E): E {"
      "  return fold((a: E, e: E) => e, dflt, v);"
      "}"
      "export circuit foo(v: Vector<3, Field>): Field {"
      "  return last<3, Field>(v);"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %last.1 ([%v.2 (tvector 3 (tfield))]
                          [%dflt.3 (tfield)])
             (tfield)
          (fold (circuit ([%a.4 (tfield)] [%e.5 (tfield)])
                     (tundeclared)
                  %e.5)
            %dflt.3
            %v.2))
        (circuit %foo.0 ([%v.6 (tvector 3 (tfield))])
             (tfield)
          (call (fref ((%last.1))) %v.6))))
    )

  (test
    '(
      "module M {"
      "  export circuit last<#D, E>(v: Vector<D, E>, dflt: E): E {"
      "    return fold((a: E, e: E) => e, dflt, v);"
      "  }"
      "}"
      "import M;"
      "export circuit foo(v: Vector<3, Field>): Field {"
      "  return last<3, Field>(v);"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %last.1 ([%v.2 (tvector 3 (tfield))]
                          [%dflt.3 (tfield)])
             (tfield)
          (fold (circuit ([%a.4 (tfield)] [%e.5 (tfield)])
                     (tundeclared)
                  %e.5)
            %dflt.3
            %v.2))
        (circuit %foo.0 ([%v.6 (tvector 3 (tfield))])
             (tfield)
          (call (fref ((%last.1))) %v.6))))
    )

  (test
    '(
      "export circuit last<#D, E>(v: Vector<D, E>, dflt: E): E {"
      "  return fold((a: E, e: E) => e, dflt, v);"
      "}"
      "export circuit foo(v: Vector<3, Field>): Field {"
      "  return last<3, Field>(v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "cannot export type-parameterized function (~s) from the top level" (last)))
    )

  (test
    '(
      "witness P<D, E>(x: E): Vector<D, E>;"
      "export circuit foo(n: Field): Vector<2, Field> {"
      "  return P<2, Field, Boolean>(n);"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%n.1 (tfield)])
             (tvector 2 (tfield))
          (call (fref ()) %n.1))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return W<B>(S(q)); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program ((foo1 %foo1.0)
                (foo2 %foo2.1)
                (foo3 %foo3.2)
                (foo4 %foo4.3))
        (witness %W.4 ([%x.5 (tboolean)]) (tboolean))
        (witness %W.6 ([%x.7 (tfield)]) (tboolean))
        (witness %W.8 ([%x.9 (tboolean)]) (tfield))
        (witness %W.10 ([%x.11 (tfield)]) (tfield))
        (circuit %S.12 ([%q.13 (tboolean)]) (tboolean) %q.13)
        (circuit %S.14 ([%q.15 (tfield)]) (tfield) %q.15)
        (circuit %T.16 ([%q.17 (tboolean)])
             (tboolean)
          (call (fref ((%W.4))) (call (fref ((%S.12))) %q.17)))
        (circuit %T.18 ([%q.19 (tfield)])
             (tboolean)
          (call (fref ((%W.6))) (call (fref ((%S.14))) %q.19)))
        (circuit %T.20 ([%q.21 (tboolean)])
             (tfield)
          (call (fref ((%W.8))) (call (fref ((%S.12))) %q.21)))
        (circuit %T.22 ([%q.23 (tfield)])
             (tfield)
          (call (fref ((%W.10))) (call (fref ((%S.14))) %q.23)))
        (circuit %foo1.0 ([%x.24 (tfield)])
             (tboolean)
          (call (fref ((%T.18 %T.16))) %x.24))
        (circuit %foo2.1 ([%x.25 (tfield)])
             (tfield)
          (call (fref ((%T.22 %T.20))) %x.25))
        (circuit %foo3.2 ([%x.26 (tboolean)])
             (tboolean)
          (call (fref ((%T.18 %T.16))) %x.26))
        (circuit %foo4.3 ([%x.27 (tboolean)])
             (tfield)
          (call (fref ((%T.22 %T.20))) %x.27))))
    )

  (test
    '(
      "struct S<X, Y> { x: X; y: Y; }"
      "module M<A> {"
      "  export witness W<S, B, C>(x: S<B, C>): A;"
      "  export witness P<#D, E>(x: A) : Vector<D, E>;"
      "}"
      "import M<Field>;"
      "export circuit foo(b: Boolean, n: Field): Field {"
      "  return W<S, Boolean, Field>(S<Boolean, Field>{x: b, y: P<3, Field>(n)});"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 12" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 2 S)))
    )

  (test
    '(
      "struct S<X, Y> { x: X; y: Y; }"
      "module M<A> {"
      "  export witness W<S, B, C>(x: S<B, C>): A;"
      "  export witness P<#D, E>(x: A) : Vector<D, E>;"
      "}"
      "import M<Field>;"
      "export circuit foo(b: Boolean, n: Field): Field {"
      "  return W<S<Boolean, Field>, Boolean, Field>(S<Boolean, Field>{ x: b, y: P<3, Field>(n) });"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 32" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (2 0 S)))
    )

  (test
    '(
      "struct S<X, Y> { x: X; y: Y; }"
      "module M<A> {"
      "  export witness W<S<B, C>, B, C>(x: S<B, C>): A;"
      "  export witness P<D, E>(x: A) : Vector<D, E>;"
      "}"
      "import M<Field>;"
      "export circuit foo(b: Boolean, n: Field): Field {"
      "  return W<S<Boolean, Field>, Boolean, Field>(S<Boolean, Field>{ x: b, y: P<3, Field>(n) });"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 21" "parse error: found ~a looking for~?" ("\"<\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\",\"" "\">\""))))
    )

  (test
    '(
      "export struct S<X, Y> { x: X; y: Y; }"
      )
    (returns
      (program ()
        (type-definition S (X Y) (tstruct S (x X) (y Y)))))
    )

  (test
    '(
      "module M<X> {"
      "  export struct S { x: X; y: Field; }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 1" "another binding found for ~s in the same scope at ~a" (S "line 4 char 1")))
    )

  (test
    '(
      "// can't export module from program"
      "export module M {"
      "  circuit S(q: Field): Field { return q; }"
      "  export circuit T(q: Field): Field { return S(q); }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "cannot export ~a (~s) from the top level" ("module" M)))
    )

  (test
    '(
      "export enum names { bill, sally, fred, george, }"
      )
    (returns
      (program ()
        (type-definition names ()
          (tenum names bill sally fred george))))
    )

  (test
    '(
      "struct S<X, Y> { x: X; y: Y; }"
      "witness bar<Q>(x: Q): Field;"
      "export circuit foo(b: Boolean, n: Field): Field {"
      "  return bar<S<Boolean, Field>>(S<Boolean, Field>{x: b, y: n});"
      "}"
      )
    (returns
      (program ((foo %foo.2))
        (witness %bar.0 ([%x.1 (tstruct S
                                 (x (tboolean))
                                 (y (tfield)))])
             (tfield))
        (circuit %foo.2 ([%b.3 (tboolean)] [%n.4 (tfield)])
             (tfield)
          (call (fref ((%bar.0)))
            (new (tstruct S (x (tboolean)) (y (tfield))) (x %b.3) (y %n.4))))))
    )

  (test
    '(
      "struct S<X, Y> { x: X; y: Y; }"
      "witness bar<Q>(x: Q): Field;"
      "export circuit foo(b: Boolean, n: Field): Field {"
      "  return bar<S<Boolean>>(S<Boolean, Field>{ x: b, y: n });"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 14" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 2 S)))
    )

  (test
    '(
      "witness bar<Q>(x: Q): Field;"
      "module M<A> {"
      "  export circuit foo(b: Boolean, n: Field): Field {"
      "    return bar<A<>>(b);"
      "  }"
      "}"
      "import M<Boolean>;"
      "export {foo}"
      )
    (returns
      (program ((foo %foo.2))
        (witness %bar.0 ([%x.1 (tboolean)]) (tfield))
        (circuit %foo.2 ([%b.3 (tboolean)] [%n.4 (tfield)])
             (tfield)
          (call (fref ((%bar.0))) %b.3))))
    )

  (test
    '(
      "witness bar<Q>(x: Q): Field;"
      "module M<A> {"
      "  export circuit foo(b: Boolean, n: Field): Field {"
      "    return bar<A<3>>(b);"
      "  }"
      "}"
      "import M<Boolean>;"
      "export {foo}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 16" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 A)))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, };"
      "export circuit foo(): Names<Field> {"
      "  return Names.bill;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 23" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 Names)))
    )

  (test
    '(
      "contract C {"
      "  circuit id (x: Boolean): Boolean;"
      "}"
      "export circuit foo(c: C<Field>): [] {"
      "  return;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 C)))
    )

  (test
    '(
      "export enum Names { bill, sally, fred, george, }"
      "module M<A> {}"
      "import M<Names<Field>>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 Names)))
    )

  (test
    '(
      "export struct S<A> { x: Vector<3, A<3>>; }"
      "export circuit foo(): [] {"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 35" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 A)))
    )

  (test
    '(
      "export struct S<A, B> { x: Vector<3, A<B<3>>>; }"
      "export circuit foo(): [] {"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 40" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 B)))
    )

  (test
    '(
      "export struct S<A, B> { x: Vector<3, A<B>>; }"
      "export circuit foo(): [] {"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 38" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 A)))
    )

  (test
    '(
      "witness bar<#Q>(x: Vector<Q, Field>): Field;"
      "module M<#A> {"
      "  export circuit foo(v: Vector<A, Field>): Field {"
      "    return bar<A>(v);"
      "  }"
      "}"
      "import M<3>;"
      "export {foo}"
      )
    (returns
      (program ((foo %foo.2))
        (witness %bar.0 ([%x.1 (tvector 3 (tfield))]) (tfield))
        (circuit %foo.2 ([%v.3 (tvector 3 (tfield))])
             (tfield)
          (call (fref ((%bar.0))) %v.3))))
    )

  (test
    '(
      "witness bar<Q>(x: Vector<Q, Field>): Field;"
      "module M<A> {"
      "  export circuit foo(v: Vector<A, Field>): Field {"
      "    return bar<A<Boolean>>(v);"
      "  }"
      "}"
      "import M<3>;"
      "export {foo}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 10" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("type" "size" A "line 2 char 10")))
    )

  (test
    '(
      "module M<#A> {"
      "  witness bar<Q>(x: Vector<A, Field>): Field;"
      "  export circuit foo(v: Vector<A, Field>): Field {"
      "    return bar<Field>(v);"
      "  }"
      "}"
      "import M<3>;"
      "export {foo}"
      )
    (returns
      (program ((foo %foo.2))
        (witness %bar.0 ([%x.1 (tvector 3 (tfield))]) (tfield))
        (circuit %foo.2 ([%v.3 (tvector 3 (tfield))])
             (tfield)
          (call (fref ((%bar.0))) %v.3))))
    )

  (test
    '(
      "module M<A> {"
      "  witness bar<Q>(x: Vector<A, Field>): Field;"
      "  export circuit foo(v: Vector<A, Field>): Field {"
      "    return bar<Field<3>>(v);"
      "  }"
      "}"
      "import M<3>;"
      "export {foo}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 21" "parse error: found ~a looking for~?" ("\"<\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\",\"" "\">\""))))
    )

  (test
    '(
      "witness bar<Q>(x: Q): Field;"
      "circuit foo(v: Vector<3, Field>): Field {"
      "  return bar<Vector<3, Field>>(v);"
      "}"
      "export {foo}"
      )
    (returns
      (program ((foo %foo.2))
        (witness %bar.0 ([%x.1 (tvector 3 (tfield))]) (tfield))
        (circuit %foo.2 ([%v.3 (tvector 3 (tfield))])
             (tfield)
          (call (fref ((%bar.0))) %v.3))))
    )

  (test
    '(
      "export circuit foo(v: Vector<3, Field>): Field {"
      "  return bar<Vector<3, Field>>(v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "unbound identifier ~s" (bar)))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "export circuit foo(x: Names): Boolean {"
      "  return x == Names.bill;"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%x.1 (tenum Names
                                 bill
                                 sally
                                 fred
                                 george)])
             (tboolean)
          (== %x.1
              (enum-ref (tenum Names bill sally fred george) bill)))))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "circuit foo(x: Names): Boolean {"
      "  return x == Names.bill;"
      "}"
      "export circuit rats(): Boolean {"
      "  return foo(Names.bill);"
      "}"
      "export circuit mice(): Boolean {"
      "  return foo(Names.fred);"
      "}"
      )
    (returns
      (program ((mice %mice.3) (rats %rats.2))
        (circuit %foo.0 ([%x.1 (tenum Names
                                 bill
                                 sally
                                 fred
                                 george)])
             (tboolean)
          (== %x.1
              (enum-ref (tenum Names bill sally fred george) bill)))
        (circuit %rats.2 ()
             (tboolean)
          (call (fref ((%foo.0)))
            (enum-ref (tenum Names bill sally fred george) bill)))
        (circuit %mice.3 ()
             (tboolean)
          (call (fref ((%foo.0)))
            (enum-ref (tenum Names bill sally fred george) fred)))))
    )

  (test
    '(
      "circuit foo<A>(): Boolean {"
      "  return A.bill;"
      "}"
      "export circuit bar(): Boolean {"
      "  return foo<Field>();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "invalid context for reference to ~a name ~s" ("type" A)))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "circuit foo<A>(): Names {"
      "  return A.bill;"
      "}"
      "export circuit bar(): Names {"
      "  return foo<Names>();"
      "}"
      )
    (returns
      (program ((bar %bar.1))
        (circuit %foo.0 ()
             (tenum Names bill sally fred george)
          (enum-ref (tenum Names bill sally fred george) bill))
        (circuit %bar.1 ()
             (tenum Names bill sally fred george)
          (call (fref ((%foo.0)))))))
    )

  (test
    '(
      "contract C {"
      "  circuit id (x: Boolean): Boolean;"
      "}"
      "circuit foo<A>(): Boolean{"
      "  A.id(true);"
      "}"
      "export circuit bar(): Boolean {"
      "  foo<C>();"
      "}")
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 3" "invalid context for reference to ~a name ~s" ("type" A)))
    )


  (test-group
    ((create-file "C.compact"
       '(
         "export circuit id(x: Boolean): Boolean { return x; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit id (x: Boolean): Boolean;"
         "}"
         "ledger contract_c: C;"
         "circuit foo<A>(): Boolean{"
          "  contract_c.id(true);"
          "}"
          "export circuit bar(): Boolean {"
          "  foo<C>();"
          "}"
         ))
     (returns
       (program ((bar %bar.3))
         (public-ledger-declaration %kernel.0 (Kernel))
         (public-ledger-declaration
           %contract_c.1
           (__compact_Cell (tcontract C (id #f ((tboolean)) (tboolean)))))
         (circuit %foo.2 ()
              (tboolean)
           (seq (elt-call %contract_c.1 id #t) (tuple)))
         (circuit %bar.3 ()
              (tboolean)
           (seq (call (fref ((%foo.2)))) (tuple)))))
     ))

  (test
    '(
      "export circuit foo(arg: Bytes<20>) : Field { return arg as Field; }"
     )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%arg.1 (tbytes 20)])
             (tfield)
          (cast (tfield) %arg.1)))))

  (test
    '(
      "circuit foo<a>(arg: a) : a { return arg; }"
      "export circuit bar1(x: Boolean): Boolean { return !foo<Boolean>(x); }"
      "export circuit bar2(x: Boolean): Boolean { return foo<Boolean>(x); }"
      "export circuit bar3(x: Field): Field { return foo<Field>(x) + 1; }"
     )
    (returns
      (program ((bar1 %bar1.0) (bar2 %bar2.1) (bar3 %bar3.2))
        (circuit %foo.3 ([%arg.4 (tboolean)]) (tboolean) %arg.4)
        (circuit %foo.5 ([%arg.6 (tfield)]) (tfield) %arg.6)
        (circuit %bar1.0 ([%x.7 (tboolean)])
             (tboolean)
          (if (call (fref ((%foo.3))) %x.7) #f #t))
        (circuit %bar2.1 ([%x.8 (tboolean)])
             (tboolean)
          (call (fref ((%foo.3))) %x.8))
        (circuit %bar3.2 ([%x.9 (tfield)])
             (tfield)
          (+ (call (fref ((%foo.5))) %x.9) 1))))
    )

  (test
    '(
      "module M<b, #n> {"
      "  export circuit foo<a>(x: a, y: Vector<n, b>) : Field { return x as Field; }"
      "  export circuit bar1(x: Bytes<10>): Field { return foo<Bytes<10>>(x, [1, 2, 3]) + 1; }"
      "  export circuit bar2(x: Bytes<10>): Field { return foo<Bytes<10>>(x, [1, 2, 3]) + 2; }"
      "  export circuit bar3(x: Bytes<11>): Field { return foo<Bytes<11>>(x, [1, 2, 3]) + 3; }"
      "}"
      "import M<Field, 3>;"
      "export { bar1, bar2, bar3 }"
     )
    (returns
      (program ((bar1 %bar1.6) (bar2 %bar2.8) (bar3 %bar3.10))
        (circuit %foo.0 ([%x.1 (tbytes 10)]
                         [%y.2 (tvector 3 (tfield))])
             (tfield)
          (cast (tfield) %x.1))
        (circuit %foo.3 ([%x.4 (tbytes 11)]
                         [%y.5 (tvector 3 (tfield))])
             (tfield)
          (cast (tfield) %x.4))
        (circuit %bar1.6 ([%x.7 (tbytes 10)])
             (tfield)
          (+ (call (fref ((%foo.0) (%foo.0))) %x.7 (tuple 1 2 3)) 1))
        (circuit %bar2.8 ([%x.9 (tbytes 10)])
             (tfield)
          (+ (call (fref ((%foo.0) (%foo.0))) %x.9 (tuple 1 2 3)) 2))
        (circuit %bar3.10 ([%x.11 (tbytes 11)])
             (tfield)
          (+ (call (fref ((%foo.3) (%foo.3))) %x.11 (tuple 1 2 3))
             3))))
    )

  (test
    '(
      "struct S<a> { p: a, q: Field }"
      "module M<#n, b> {"
      "  export circuit foo<a, b>(x: a, y: b) : a { return x; }"
      "  export circuit bar1(x: Bytes<10>): S<Bytes<10>> { return S<Bytes<10>>{p: foo<Bytes<10>, Vector<n, b>>(x, [1, 2, 3]), q: 1}; }"
      "  export circuit bar2(x: Bytes<10>): S<Bytes<10>> { return S<Bytes<10>>{p: foo<Bytes<10>, Vector<n, b>>(x, [1, 2, 3]), q: 2}; }"
      "  export circuit bar3(x: Bytes<11>): S<Bytes<11>> { return S<Bytes<11>>{p: foo<Bytes<11>, Vector<n, b>>(x, [1, 2, 3]), q: 3}; }"
      "}"
      "import M<3, Field>;"
      "export { bar1, bar2, bar3 }"
     )
    (returns
      (program ((bar1 %bar1.6) (bar2 %bar2.8) (bar3 %bar3.10))
        (circuit %foo.0 ([%x.1 (tbytes 10)]
                         [%y.2 (tvector 3 (tfield))])
             (tbytes 10)
          %x.1)
        (circuit %foo.3 ([%x.4 (tbytes 11)]
                         [%y.5 (tvector 3 (tfield))])
             (tbytes 11)
          %x.4)
        (circuit %bar1.6 ([%x.7 (tbytes 10)])
             (tstruct S (p (tbytes 10)) (q (tfield)))
          (new (tstruct S (p (tbytes 10)) (q (tfield)))
            (p (call (fref ((%foo.0) (%foo.0))) %x.7 (tuple 1 2 3)))
            (q 1)))
        (circuit %bar2.8 ([%x.9 (tbytes 10)])
             (tstruct S (p (tbytes 10)) (q (tfield)))
          (new (tstruct S (p (tbytes 10)) (q (tfield)))
            (p (call (fref ((%foo.0) (%foo.0))) %x.9 (tuple 1 2 3)))
            (q 2)))
        (circuit %bar3.10 ([%x.11 (tbytes 11)])
             (tstruct S (p (tbytes 11)) (q (tfield)))
          (new (tstruct S (p (tbytes 11)) (q (tfield)))
            (p (call (fref ((%foo.3) (%foo.3))) %x.11 (tuple 1 2 3)))
            (q 3)))))
    )

  (test
    '(
      "struct Q<a, #n> { x: a, y: Vector<n, a> }"
      "module M<QQ, n, b> {"
      "  export circuit foo<a, b>(x: a, y: b) : Field { return x as Field; }"
      "  export circuit bar1(x: Bytes<10>): Field {"
      "    const q = Q<Field, 3>{ x: 23, y: [1, 2, 3] };"
      "    return foo<Bytes<10>, Vector<n, QQ<b, 3>>>(x, [q, q, q]) + 1;"
      "  }"
      "  export circuit bar2(x: Bytes<10>): Field {"
      "    const q = Q<Field, 3>{ x: 23, y: [1, 2, 3] };"
      "    return foo<Bytes<10>, Vector<n, QQ<b, 3>>>(x, [q, q, q]) + 2;"
      "  }"
      "  export circuit bar3(x: Bytes<11>): Field {"
      "    const q = Q<Field, 3>{x: 23, y: [1, 2, 3]};"
      "    return foo<Bytes<11>, Vector<n, QQ<b, 3>>>(x, [q, q, q]) + 3;"
      "  }"
      "}"
      "import M<Q, 3, Field>;"
      "export { bar1, bar2, bar3 }"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 17 char 10" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 2 Q)))
    )

  (test
    '(
      "struct Q<a, #n> { x: a, y: Vector<n, a> }"
      "module M<QQ, n, b> {"
      "  export circuit foo<a, b>(x: a, y: b) : a { return x; }"
      "  export circuit bar1(x: Bytes<10>): QQ<Bytes<10>, n> {"
      "    return foo<QQ<Bytes<10>, n>, Vector<n, b>>(QQ<Bytes<10>, n>{ x: x, y: [x, x, x] }, [1, 2, 3]);"
      "  }"
      "  export circuit bar2(x: Bytes<10>): QQ<Bytes<10>, n> {"
      "    return foo<QQ<Bytes<10>, n>, Vector<n, b>>(QQ<Bytes<10>, n>{ x: x, y: [x, x, x] }, [4, 5, 6]);"
      "  }"
      "  export circuit bar3(x: Bytes<11>): QQ<Bytes<11>, n> {"
      "    return foo<QQ<Bytes<11>, n>, Vector<n, b>>(QQ<Bytes<11>, n>{ x: x, y: [x, x, x] }, [7, 8, 9]);"
      "  }"
      "}"
      "import M<Q, 3, Field>;"
      "export { bar1, bar2, bar3 }"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 14 char 10" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 2 Q)))
    )

  (test
    '(
      "struct S<a> { p: a, q: Field }"
      "circuit foo<a>(x: a) : a { return x; }"
      "export circuit bar1(x: Opaque<'frob'>): S<Opaque<'frob'>> { return S<Opaque<'frob'>>{ p: foo<Opaque<'frob'>>(x), q: 1 }; }"
      "export circuit bar2(x: Opaque<'frob'>): S<Opaque<'frob'>> { return S<Opaque<'frob'>>{ p: foo<Opaque<'frob'>>(x), q: 2 }; }"
      "export circuit bar3(x: Opaque<'string'>): S<Opaque<'string'>> { return S<Opaque<'string'>>{ p: foo<Opaque<'string'>>(x), q: 3 }; }"
     )
    (returns
      (program ((bar1 %bar1.4) (bar2 %bar2.6) (bar3 %bar3.8))
        (circuit %foo.0 ([%x.1 (topaque "frob")])
             (topaque "frob")
          %x.1)
        (circuit %foo.2 ([%x.3 (topaque "string")])
             (topaque "string")
          %x.3)
        (circuit %bar1.4 ([%x.5 (topaque "frob")])
             (tstruct S (p (topaque "frob")) (q (tfield)))
          (new (tstruct S (p (topaque "frob")) (q (tfield)))
            (p (call (fref ((%foo.0))) %x.5))
            (q 1)))
        (circuit %bar2.6 ([%x.7 (topaque "frob")])
             (tstruct S (p (topaque "frob")) (q (tfield)))
          (new (tstruct S (p (topaque "frob")) (q (tfield)))
            (p (call (fref ((%foo.0))) %x.7))
            (q 2)))
        (circuit %bar3.8 ([%x.9 (topaque "string")])
             (tstruct S (p (topaque "string")) (q (tfield)))
          (new (tstruct S (p (topaque "string")) (q (tfield)))
            (p (call (fref ((%foo.2))) %x.9))
            (q 3)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export enum Names { bill, sally, fred, george, }"
       )
    (returns
      (program ()
        (type-definition Names ()
          (tenum Names bill sally fred george))
        (public-ledger-declaration %kernel.0 (Kernel)))))

  (test
    '(
      "import CompactStandardLibrary;"
      "enum Names { bill, sally, fred, george, }"
      "export {Names}"
       )
    (returns
      (program ()
        (type-definition Names ()
          (tenum Names bill sally fred george))
        (public-ledger-declaration %kernel.0 (Kernel)))))

  (test
    '(
      "import CompactStandardLibrary;"
      "enum Names { bill, sally, fred, george, }"
      "circuit foo() : [] { return Names(); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 29" "invalid context for reference to ~a name ~s" ("enum" Names)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "contract C {"
      "  circuit foo(x: Bytes<32>): [];"
      "  pure circuit bar(): Bytes<32>;"
      "}"
      "ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (returns
      (program ((hello %hello.2))
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %contract_c.0
          (__compact_Cell
            (tcontract C
              (foo #f ((tbytes 32)) (ttuple))
              (bar #t () (tbytes 32)))))
        (constructor ([%c.1 (tcontract C
                              (foo #f ((tbytes 32)) (ttuple))
                              (bar #t () (tbytes 32)))])
          (seq (= %contract_c.0 (disclose %c.1)) (tuple)))
        (circuit %hello.2 ()
             (ttuple)
          (elt-call %contract_c.0 foo (elt-call %contract_c.0 bar)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "contract C {"
      "  circuit foo(x: Bytes<32>): [];"
      "  pure circuit bar(): Bytes<32>;"
      "  circuit blah(x: Field, y: Boolean): Boolean;"
      "}"
      "ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(x: Field, y: Boolean): [] { return contract_c.read().blah(x, y); }"
      )
    (returns
      (program ((hello %hello.2))
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %contract_c.0
          (__compact_Cell
            (tcontract C
              (foo #f ((tbytes 32)) (ttuple))
              (bar #t () (tbytes 32))
              (blah #f ((tfield) (tboolean)) (tboolean)))))
        (constructor ([%c.1 (tcontract C
                              (foo #f ((tbytes 32)) (ttuple))
                              (bar #t () (tbytes 32))
                              (blah #f ((tfield) (tboolean)) (tboolean)))])
          (seq (= %contract_c.0 (disclose %c.1)) (tuple)))
        (circuit %hello.2 ([%x.3 (tfield)] [%y.4 (tboolean)])
             (ttuple)
          (elt-call (elt-call %contract_c.0 read) blah %x.3 %y.4))))
    )

  (test
    '(
      "contract C {"
      "  circuit foo(x: Bytes<32>): [];"
      "  pure circuit bar(): Bytes<32>;"
      "}"
      "ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.read().foo(contract_c.read().bar()); }"
      "import CompactStandardLibrary;"
      )
    (returns
      (program ((hello %hello.2))
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %contract_c.0
          (__compact_Cell
            (tcontract C
              (foo #f ((tbytes 32)) (ttuple))
              (bar #t () (tbytes 32)))))
        (constructor ([%c.1 (tcontract C
                              (foo #f ((tbytes 32)) (ttuple))
                              (bar #t () (tbytes 32)))])
          (seq (= %contract_c.0 (disclose %c.1)) (tuple)))
        (circuit %hello.2 ()
             (ttuple)
          (elt-call
            (elt-call %contract_c.0 read)
            foo
            (elt-call (elt-call %contract_c.0 read) bar)))))
    )

  (test
    '(
      "module m<A> {"
      "  contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "}"
      "import m<Bytes<32>>;"
      "ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      "import CompactStandardLibrary;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 17" "unbound identifier ~s" (C)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module m<A> {"
      "  export contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "}"
      "import m<Bytes<32>>;"
      "ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (returns
      (program ((hello %hello.2))
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %contract_c.0
          (__compact_Cell
            (tcontract C
              (foo #f ((tbytes 32)) (ttuple))
              (bar #t () (tbytes 32)))))
        (constructor ([%c.1 (tcontract C
                              (foo #f ((tbytes 32)) (ttuple))
                              (bar #t () (tbytes 32)))])
          (seq (= %contract_c.0 (disclose %c.1)) (tuple)))
        (circuit %hello.2 ()
             (ttuple)
          (elt-call %contract_c.0 foo (elt-call %contract_c.0 bar)))))
    )

  (test
    '(
      "module m<A> {"
      "  contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "}"
      "import m<Bytes<32>> prefix $;"
      "export ledger contract_c: C;"
      "constructor (c: C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 17" "unbound identifier ~s" (C)))
    )

  (test
    '(
      "module m<A> {"
      "  export contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "}"
      "import m<Bytes<32>> prefix $;"
      "import CompactStandardLibrary;"
      "export ledger contract_c: $C;"
      "constructor (c: $C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (returns
      (program ((contract_c %contract_c.0) (hello %hello.2))
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %contract_c.0
          (__compact_Cell
            (tcontract C
              (foo #f ((tbytes 32)) (ttuple))
              (bar #t () (tbytes 32)))))
        (constructor ([%c.1 (tcontract C
                              (foo #f ((tbytes 32)) (ttuple))
                              (bar #t () (tbytes 32)))])
          (seq (= %contract_c.0 (disclose %c.1)) (tuple)))
        (circuit %hello.2 ()
             (ttuple)
          (elt-call %contract_c.0 foo (elt-call %contract_c.0 bar)))))
    )

  (test
    '(
      "module m<A> {"
      "  export contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "  import CompactStandardLibrary;"
      "  export ledger contract_c: C;"
      "}"
      "import m<Bytes<32>> prefix $;"
      "constructor (c: $C) { contract_c = disclose(c); }"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 11 char 52" "unbound identifier ~s" (contract_c)))
    )

  (test
    '(
      "module m<A> {"
      "  export contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "  import CompactStandardLibrary;"
      "  export ledger contract_c: C;"
      "}"
      "import m<Bytes<32>> prefix $;"
      "constructor (c: $C) { $contract_c = disclose(c); }"
      "export circuit hello(): [] { return $contract_c.foo($contract_c.bar()); }"
      )
    (returns
      (program ((hello %hello.2))
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %contract_c.0
          (__compact_Cell
            (tcontract C
              (foo #f ((tbytes 32)) (ttuple))
              (bar #t () (tbytes 32)))))
        (constructor ([%c.1 (tcontract C
                              (foo #f ((tbytes 32)) (ttuple))
                              (bar #t () (tbytes 32)))])
          (seq (= %contract_c.0 (disclose %c.1)) (tuple)))
        (circuit %hello.2 ()
             (ttuple)
          (elt-call %contract_c.0 foo (elt-call %contract_c.0 bar)))))
    )

  (test
    '(
      "module m<A> {"
      "  contract C {"
      "    circuit foo(x: A): [];"
      "    pure circuit bar(): A;"
      "  }"
      "  export ledger contract_c: C;"
      "  constructor (c: C) { contract_c = disclose(c); }"
      "}"
      "import m<Bytes<32>>;"
      "export circuit hello(): [] { return contract_c.foo(contract_c.bar()); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 3" "misplaced constructor: should appear only at the top level of a program" ()))
    )

  (test
    '(
      "module M<T> {"
      "  export struct S {"
      "    v: T;"
      "  }"
      "}"
      "import M<S>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 10" "unbound identifier ~s" (S)))
    )

  (test
    '(
      "export struct S<T> {"
      "  x: T;"
      "}"
      "export circuit foo(s: S<S<Field>>): S<Field> {"
      "  return s.x;"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (type-definition S (T) (tstruct S (x T)))
        (circuit %foo.0 ([%s.1 (tstruct S
                                 (x (tstruct S (x (tfield)))))])
             (tstruct S (x (tfield)))
          (elt-ref %s.1 x))))
    )

  (test
    '(
      "contract C1 {"
      "  circuit foo(x: C2): [];"
      "}"
      ""
      "contract C2 {"
      " circuit bar(): [];"
      "}"
       )
    (returns (program ())))

  (test
    `(
      "contract C1 {"
      "  circuit foo(x: C2): [];"
      "}"
      ""
      "contract C2 {"
      " circuit bar(): C1;"
      "}")
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 17" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (C2 C1))))
    )

  (test
    `(
      "contract C {"
      "  circuit foo(x: S): [];"
      "}"
      ""
      "struct S {"
      " x: Vector<1, C>,"
      "}")
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 18" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (C S))))
    )

  (test
    '(
      "module M {"
      "  import M;"
      "}"
      "import M;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M))))
    )

  (test
    '(
      "module O {"
      "  export module M {"
      "    import pM;"
      "  }"
      "}"
      "import O prefix p;"
      "import pM;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 5" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (pM))))
    )

  (test
    '(
      "module M {"
      "  export circuit foo(): Field { return 3; }"
      "}"
      "module M1 {"
      "  import M;"
      "  export circuit rats(): Field { return foo(); }"
      "}"
      "module M2 {"
      "  import M prefix p1;"
      "  import M prefix p2;"
      "  export circuit mice(): Field { return p1foo() * p2foo(); }"
      "}"
      "import M1;"
      "import M2;"
      "export { rats, mice }"
      )
    (returns
      (program ((mice %mice.0) (rats %rats.1))
        (circuit %foo.2 () (tfield) 3)
        (circuit %rats.1 () (tfield) (call (fref ((%foo.2)))))
        (circuit %mice.0 ()
             (tfield)
          (* (call (fref ((%foo.2)))) (call (fref ((%foo.2))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export ledger fld: Counter;"
      "}"
      "import M prefix p1;"
      "import M prefix p2;"
      "export { p1fld, p2fld }"
      )
    (returns
      (program ((p1fld %fld.0) (p2fld %fld.0))
        (public-ledger-declaration %kernel.1 (Kernel))
        (public-ledger-declaration %fld.0 (Counter))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger fld: Counter;"
      "export { fld, fld };"
      )
    (returns
      (program ((fld %fld.0))
        (public-ledger-declaration %kernel.1 (Kernel))
        (public-ledger-declaration %fld.0 (Counter))))
    )

  (test
    '(
      "module M {"
      "  export circuit foo(): Field { return 3; }"
      "}"
      "import M prefix p1;"
      "import M prefix p2;"
      "export {p1foo, p2foo};"
      )
    (returns
      (program ((p1foo %foo.0) (p2foo %foo.0))
        (circuit %foo.0 () (tfield) 3)))
    )

  (test
    '(
      "contract C {"
      "  circuit foo(x: C): [];"
      "  pure circuit bar(): A;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 18" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (C))))
    )

  (test
    '(
      "contract C1 {"
      "  circuit foo(x: C2): [];"
      "  pure circuit bar(): A;"
      "}"
      "contract C2 {"
      "  circuit check(x: C1): [];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 20" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (C2 C1))))
    )

  (test
    '(
      "contract C1 {"
      "  circuit foo(x: C2): [];"
      "  pure circuit bar(): A;"
      "}"
      "contract C2 {"
      "  circuit check(x: S): [];"
      "}"
      "struct S {"
      "  a: C1;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 20" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (C2 C1 S))))
    )

  (test
    '(
      "contract C {"
      "  circuit foo(x: S): [];"
      "  pure circuit bar(): A;"
      "}"
      "struct S {"
      "  a: C;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 18" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (C S))))
    )

  (test
    '(
      "module M {"
      "  import M;"
      "}"
      "import M;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M))))
    )

  (test
    '(
      "module M1 {"
      "  import M2;"
      "}"
      "module M2 {"
      "  import M1;"
      "}"
      "import M1;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M2 M1))))
    )

  (test
    '(
      "module M1 {"
      "  import M2;"
      "}"
      "module M2 {"
      "  import M1;"
      "}"
      "import M2;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M1 M2))))
    )

  (test
    '(
      "module M1 {"
      "  import M2;"
      "}"
      "module M2 {"
      "  import M3;"
      "}"
      "module M3 {"
      "  import M1;"
      "}"
      "import M1;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M3 M2 M1))))
    )

  (test
    '(
      "module M1 {"
      "  import M2;"
      "}"
      "module M2 {"
      "  import M3;"
      "}"
      "module M3 {"
      "  import M4;"
      "}"
      "module M4 {"
      "  import M1;"
      "}"
      "import M1;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 11 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M4 M3 M2 M1))))
    )

  (test
    '(
      "module O {"
      "  export module M {"
      "    import pM;"
      "  }"
      "}"
      "import O prefix p;"
      "import pM;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 5" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (pM))))
    )

  (test
    '(
      "module M {"
      "  export circuit foo(): Field { return 3; }"
      "}"
      "import M prefix p1;"
      "import M prefix p2;"
      "export {p1foo, p2foo};"
      )
    (returns
      (program ((p1foo %foo.0) (p2foo %foo.0))
        (circuit %foo.0 () (tfield) 3)))
    )

  (test
    '(
      "contract C {"
      "  circuit foo(x: C): [];"
      "  pure circuit bar(): A;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 18" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (C))))
    )

  (test
    '(
      "module M {"
      "  import M;"
      "}"
      "import M;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M))))
    )

  (test
    '(
      "module M1 {"
      "  import M2;"
      "}"
      "module M2 {"
      "  import M1;"
      "}"
      "import M1;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M2 M1))))
    )

  (test
    '(
      "module M1 {"
      "  import M2;"
      "}"
      "module M2 {"
      "  import M1;"
      "}"
      "import M2;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M1 M2))))
    )

  (test
    '(
      "module M1 {"
      "  import M2;"
      "}"
      "module M2 {"
      "  import M3;"
      "}"
      "module M3 {"
      "  import M1;"
      "}"
      "import M1;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M3 M2 M1))))
    )

  (test
    '(
      "module M1 {"
      "  import M2;"
      "}"
      "module M2 {"
      "  import M3;"
      "}"
      "module M3 {"
      "  import M4;"
      "}"
      "module M4 {"
      "  import M1;"
      "}"
      "import M1;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 11 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M4 M3 M2 M1))))
    )

  (test
    '(
      "module M<T> {"
      "  export struct S {"
      "    v: T;"
      "  }"
      "  import M<S>;"
      "}"
      "import M<Field>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M))))
    )

  (test ; cycle check should not be based on identifier names
    '(
      "module M<T> {"
      "  module M<T> {"
      "    export struct S {"
      "      v: T;"
      "    }"
      " }"
      " import M<Vector<3, T>>;"
      " export { S };"
      "}"
      "import M<Field>;"
      "export circuit foo(s: S): [] {"
      "  return;"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%s.1 (tstruct S
                                 (v (tvector 3 (tfield))))])
             (ttuple)
          (tuple))))
    )

  (test
    '(
      "struct A {"
      "  x: A;"
      "}"
      "export circuit foo(a: A): [] { return; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (A))))
    )

  (test
    '(
      "struct A {"
      "  x: B;"
      "}"
      "struct B {"
      "  x: A;"
      "}"
      "export circuit foo(a: A): [] { return; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (B A))))
    )

  (test
    '(
      "struct A {"
      "  x: B;"
      "}"
      "struct B {"
      "  x: C;"
      "}"
      "struct C {"
      "  x: A;"
      "}"
      "export circuit foo(a: A): [] { return; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (C B A))))
    )

  (test
    '(
      "struct A {"
      "  x: B;"
      "}"
      "struct B {"
      "  x: C;"
      "}"
      "struct C {"
      "  x: D;"
      "}"
      "struct D {"
      "  x: A;"
      "}"
      "export circuit foo(a: A): [] { return; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 11 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (D C B A))))
    )

  (test
    '(
      "export struct A {"
      "  x: A;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (A))))
    )

  (test
    '(
      "export struct A {"
      "  x: B;"
      "}"
      "export struct B {"
      "  x: A;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (A B))))
    )

  (test
    '(
      "export struct A {"
      "  x: B;"
      "}"
      "export struct B {"
      "  x: C;"
      "}"
      "export struct C {"
      "  x: A;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (A C B))))
    )

  (test
    '(
      "export struct A<T> {"
      "  x: B<T>;"
      "}"
      "export struct B<T> {"
      "  x: C<3, T>;"
      "}"
      "export struct C<#n, T> {"
      "  x: Vector<n, T>;"
      "}"
      "export circuit foo(x: C<3, A<Field>>): [] { return; }"
      )
    (returns
      (program ((foo %foo.0))
        (type-definition A (T)
          (tstruct A
            (x (tstruct B (x (tstruct C (x (tvector 3 T))))))))
        (type-definition B (T)
          (tstruct B (x (tstruct C (x (tvector 3 T))))))
        (type-definition C (T) (tstruct C (x (tvector 0 T))))
        (circuit %foo.0 ([%x.1 (tstruct C
                                 (x (tvector
                                      3
                                      (tstruct A
                                        (x (tstruct B
                                             (x (tstruct C
                                                  (x (tvector
                                                       3
                                                       (tfield)))))))))))])
             (ttuple)
          (tuple))))
    )

  (test
    '(
      "export struct A {"
      "  x: B;"
      "}"
      "export struct B {"
      "  x: C<3, A>;"
      "}"
      "export struct C<#n, T> {"
      "  x: Vector<n, T>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (A B))))
    )

  (test
    '(
      "export struct A {"
      "  x: B;"
      "}"
      "export struct B {"
      "  x: C<A, A>;"
      "}"
      "export struct C<#n, T> {"
      "  x: Vector<n, T>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (A B))))
    )

  (test
    '(
      "export struct A {"
      "  x: B;"
      "}"
      "export struct B {"
      "  x: C<A, A>;"
      "}"
      "export struct C<n, T> {"
      "  x: Vector<n, T>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (A B))))
    )

  (test
    '(
      "export struct A {"
      "  x: B;"
      "}"
      "export struct B {"
      "  x: C<B, A>;"
      "}"
      "export struct C<#n, T> {"
      "  x: Vector<n, T>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 8" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (B))))
    )

  (test
    '(
      "export struct A {"
      "  x: B;"
      "}"
      "export struct B {"
      "  x: C;"
      "}"
      "export struct C {"
      "  x: D;"
      "}"
      "export struct D {"
      "  x: A;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (A D C B))))
    )

  (test
    '(
      "export struct A {"
      "  x: B;"
      "}"
      "export struct B {"
      "  x: C;"
      "}"
      "export struct C {"
      "  x: D;"
      "}"
      "export struct D {"
      "  x: A;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 6" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (A D C B))))
    )

  (test
    '(
      "struct Maybe<a> {"
      "  is_some: Boolean;"
      "  value: a;"
      "}"
      ""
      "export struct Pair<S> {"
      "  head: S;"
      "  tail: Maybe<Pair<S>>;"
      "}"
      ""
      "export circuit foo(p: Pair<Field>): Field {"
      "  return p.head + p.tail.value.head;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 15" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (Pair))))
    )

  (test
    '(
      "struct Just<a> {"
      "  value: a;"
      "}"
      ""
      "struct Maybe<a> {"
      "  nothing: Boolean;"
      "  just: Just<a>;"
      "}"
      ""
      "export struct Pair<S> {"
      "  head: S;"
      "  tail: Maybe<Pair<S>>;"
      "}"
      ""
      "export circuit foo(p: Pair<Field>): Field {"
      "  return p.head + p.tail.just.value.head;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 12 char 15" "cycle involving ~a~?" ("type" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (Pair))))
    )

  (test
    '(
      "struct A<T> {"
      "  x: T<Field>;"
      "}"
      ""
      "struct B<T> {"
      "  x: T;"
      "}"
      ""
      "export circuit foo(s: A<B>): A<B> {"
      "  return s;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 25" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 1 B)))
    )

  (test
    '(
      "struct Maybe<a> {"
      "  is_some: Boolean;"
      "  value: a;"
      "}"
      ""
      "struct Pair<S, T> {"
      "  first: S;"
      "  second: T;"
      "}"
      ""
      "struct MyList<T, L> {"
      "  head: Maybe<Pair<T, L<T, L>>>;"
      "}"
      ""
      "export circuit append(ls0: MyList<Field, MyList>, ls1: MyList<Field, MyList>): MyList<Field, MyList> {"
      "  if (!ls0.head.is_some) return ls1;"
      "  return MyList<Field, MyList>{ head: ls0.head.value.first, tail: append(ls0.head.value.second, ls1) };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 15 char 42" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 2 MyList)))
    )

  (test
    '(
      "export struct S<T> {"
      "  x: Field;"
      "}"
      ""
      "export circuit foo(s: S<S>): S<S> {"
      "  return s;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 25" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 1 S)))
    )

  (test
    '(
      "export struct S<T> {"
      "  x: Field;"
      "}"
      ""
      "export circuit foo(s: S<S<Field>>): Field {"
      "  return s.x;"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (type-definition S (T) (tstruct S (x (tfield))))
        (circuit %foo.0 ([%s.1 (tstruct S (x (tfield)))])
             (tfield)
          (elt-ref %s.1 x))))
    )

  (test
    '(
      "export struct S<T> {"
      "  x: T;"
      "}"
      ""
      "export circuit foo(s: S<S>): S<S> {"
      "  return s;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 25" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 1 S)))
    )

  (test
    '(
      "struct A<T> {"
      "  x: T<B>;"
      "}"
      ""
      "struct B<T> {"
      "  x: Field;"
      "}"
      ""
      "export circuit foo(s: A<B>): A<B> {"
      "  return s;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 25" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 1 B)))
    )

  (test
    '(
      "export struct A<T> {"
      "  x: T<B>;"
      "}"
      ""
      "struct B<T> {"
      "  x: Field;"
      "}"
      ""
      "export circuit foo(s: A<B>): A<B> {"
      "  return s;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 8" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 1 B)))
    )

  (test
    '(
      "struct A<T> {"
      "  x: T<B>;"
      "}"
      ""
      "export struct B<T> {"
      "  x: Field;"
      "}"
      ""
      "export circuit foo(s: A<A>): A<A> {"
      "  return s;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 25" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 1 A)))
    )

  (test
    '(
      "export struct A<T> {"
      "  x: T<B>;"
      "}"
      ""
      "export struct B<T> {"
      "  x: Field;"
      "}"
      ""
      "export circuit foo(s: A<A>): A<A> {"
      "  return s;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 8" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 1 B)))
    )

  (test
    '(
      "circuit foo<#t>(x: Uint<0..t>): Uint<0..t> {"
      "  return x + 1 as Uint<0..t>;"
      "}"
      "export circuit bar(): Field {"
      "  return foo<22>(20);"
      "}"
      )
    (returns
      (program ((bar %bar.0))
        (circuit %foo.1 ([%x.2 (tunsigned 21)])
             (tunsigned 21)
          (cast (tunsigned 21) (+ %x.2 1)))
        (circuit %bar.0 () (tfield) (call (fref ((%foo.1))) 20))))
    )

  (test
    '(
      "struct S<#t> {"
      "  x: Uint<0..t>;"
      "  y: Uint<t>;"
      "}"
      "circuit foo<#t>(s: S<t>): S<t> {"
      "  return S<t>{x: s.x + 1 as Uint<0..t>,"
      "              y: s.y + 1 as Uint<t>};"
      "}"
      "export circuit bar(): Field {"
      "  return foo<17>(S<17>{ x: 7, y: 11 });"
      "}"
      )
    (returns
      (program ((bar %bar.2))
        (circuit %foo.0 ([%s.1 (tstruct S
                                 (x (tunsigned 16))
                                 (y (tunsigned 131071)))])
             (tstruct S (x (tunsigned 16)) (y (tunsigned 131071)))
          (new (tstruct S (x (tunsigned 16)) (y (tunsigned 131071)))
            (x (cast (tunsigned 16) (+ (elt-ref %s.1 x) 1)))
            (y (cast (tunsigned 131071) (+ (elt-ref %s.1 y) 1)))))
        (circuit %bar.2 ()
             (tfield)
          (call (fref ((%foo.0)))
            (new (tstruct S (x (tunsigned 16)) (y (tunsigned 131071)))
              (x 7)
              (y 11))))))
    )

  (test
    '(
      "circuit A(x: Uint<1..37>): Field {"
      "  return x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 14" "range start for Uint type is ~d but must be 0" (1)))
    )

  (test
    '(
      "circuit A(x: Uint<0...37>): Field {"
      "  return x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 20" "parse error: found ~a looking for~?" ("\"...\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\">\"" "\"..\""))))
    )

  (test
    '(
      "circuit A(x: Uint<0....37>): Field {"
      "  return x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "unexpected ~a" ("character '.'")))
    )

  (test
    '(
      "struct S<#t> {"
      "  x: Uint<0..t>;"
      "  y: Uint<t>;"
      "}"
      "circuit foo<t>(s: t): Field {"
      "  return s.x * 2 + s.y;"
      "}"
      "export circuit bar(): Field {"
      "  return foo<S<17>>(S<17>{ x: 7, y: 11 });"
      "}"
      )
    (returns
      (program ((bar %bar.2))
        (circuit %foo.0 ([%s.1 (tstruct S
                                 (x (tunsigned 16))
                                 (y (tunsigned 131071)))])
             (tfield)
          (+ (* (elt-ref %s.1 x) 2) (elt-ref %s.1 y)))
        (circuit %bar.2 ()
             (tfield)
          (call (fref ((%foo.0)))
            (new (tstruct S (x (tunsigned 16)) (y (tunsigned 131071)))
              (x 7)
              (y 11))))))
    )

  (test
    '(
      "circuit A(x: Uint<..37>): Field {"
      "  return x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 19" "parse error: found ~a looking for~?" ("\"..\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a type size"))))
    )

  (test
    '(
      "circuit A<#t>(x: Uint<0..t>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<12>(x);"
      "}"
      )
    (returns
      (program ((B %B.0))
        (circuit %A.1 ([%x.2 (tunsigned 11)]) (tfield) %x.2)
        (circuit %B.0 ([%x.3 (tunsigned 7)])
             (tfield)
          (call (fref ((%A.1))) %x.3))))
    )

  (test
    '(
      "circuit A<#t>(x: Uint<0..t>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<12>(x);"
      "}"
      )
    (returns
      (program ((B %B.2))
        (circuit %A.0 ([%x.1 (tunsigned 11)]) (tfield) %x.1)
        (circuit %B.2 ([%x.3 (tunsigned 7)])
             (tfield)
          (call (fref ((%A.0))) %x.3))))
    )

  (test
    '(
      "circuit A<#t>(x: Uint<t..38>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<0>(x);"
      "}"
      )
    (returns
      (program ((B %B.2))
        (circuit %A.0 ([%x.1 (tunsigned 37)]) (tfield) %x.1)
        (circuit %B.2 ([%x.3 (tunsigned 7)])
             (tfield)
          (call (fref ((%A.0))) %x.3))))
    )

  (test
    '(
      "circuit A<#t>(x: Uint<t..37>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<1>(x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 18" "range start for Uint type is ~d but must be 0" (1)))
    )

  (test
    '(
      "circuit A<#t>(x: Uint<t..37>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<Boolean>(x);"
      "}"
      )
    (returns
      (program ((B %B.0))
        (circuit %B.0 ([%x.1 (tunsigned 7)])
             (tfield)
          (call (fref ()) %x.1))))
    )

    (test
    '(
      "import CompactStandardLibrary;"
      "export ledger field1: QualifiedCoinInfo;"
      "export circuit foo(b: Boolean): [] {"
      "  if (b) {"
      "    field1 = null(QualifiedCoinInfo);"
      "  }"
      "}")
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 14" "unbound identifier ~s" (null))))

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger field1: QualifiedCoinInfo;"
      "export circuit foo(b: Boolean): [] {"
      "  if (b) {"
      "    field1 = blah(QualifiedCoinInfo);"
      "  }"
      "}")
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 14" "unbound identifier ~s" (blah))))

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger field1: Counter;"
      "export circuit foo(b: Boolean): [] {"
      "  if (b) {"
      "    field1 = default[Counter];"
      "  }"
      "}")
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 21" "parse error: found ~a looking for~?" ("\"[\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\"<\""))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger field1: Field;"
      "export circuit foo(b: Boolean): [] {"
      "  if (b) {"
      "    field1 = null(Field);"
      "  }"
      "}")
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 19" "parse error: found ~a looking for~?" ("\"Field\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression" "\")\""))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger c: QualifiedCoinInfo;"
      ""
      "export circuit resetToDefault(): [] {"
      "  c.resetToDefault();"
      "}"
      ""
      "export circuit write(value: QualifiedCoinInfo): [] {"
      "  return c.write(value);"
      "}"
      ""
      "export circuit writeCoin(coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): [] {"
      "  return c.writeCoin(coin, recipient);"
      "}"
       )
    (succeeds))

  (test
    '(
      "module M1 {"
      ;"  import CompactStandardLibrary;"
      "  export circuit foo1(x: Field): Field {"
      "    return x;" ; persistentHash<Field>(x);"
      "  }"
      "}"
      "module M2 {"
      "  import M1;"
      "  export circuit foo2(x: Field): Field {"
      "    return foo1(x + 1);"
      "  }"
      "}"
      "module M3 {"
      "  import M1;"
      "  export circuit foo3(x: Field): Field {"
      "    return foo1(x + 2);"
      "  }"
      "}"
      "import M2;"
      "import M3;"
      "export { foo2, foo3 };"
      )
    (returns
      (program ((foo2 %foo2.2) (foo3 %foo3.3))
        (circuit %foo1.0 ([%x.4 (tfield)]) (tfield) %x.4)
        (circuit %foo2.2 ([%x.1 (tfield)])
             (tfield)
          (call (fref ((%foo1.0))) (+ %x.1 1)))
        (circuit %foo3.3 ([%x.5 (tfield)])
             (tfield)
          (call (fref ((%foo1.0))) (+ %x.5 2)))))
    )

  (test
    '(
      "module M1 {"
      "  import CompactStandardLibrary;"
      "  export circuit foo1(x: Field): Bytes<32> {"
      "    return persistentHash<Field>(x);"
      "  }"
      "}"
      "module M2 {"
      "  import CompactStandardLibrary;"
      "  export circuit foo2(x: Field): Bytes<32> {"
      "    return persistentHash<Field>(x);"
      "  }"
      "}"
      "import M1;"
      "import M2;"
      "export { foo1, foo2 };"
      )
    (returns
      (program ((foo1 %foo1.0) (foo2 %foo2.1))
        (public-ledger-declaration %kernel.2 (Kernel))
        (external %persistentHash.3 ([%value.4 (tfield)])
             (tbytes 32))
        (circuit %foo1.0 ([%x.5 (tfield)])
             (tbytes 32)
          (call (fref ((%persistentHash.3))) %x.5))
        (circuit %foo2.1 ([%x.6 (tfield)])
             (tbytes 32)
          (call (fref ((%persistentHash.3))) %x.6))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit CompactStandardLibrary(x: Field): Bytes<32> {"
      " return persistentHash<Field>(x);"
      "}"
      )
    (returns
      (program ((CompactStandardLibrary %CompactStandardLibrary.3))
        (public-ledger-declaration %kernel.0 (Kernel))
        (external %persistentHash.1 ([%value.2 (tfield)])
             (tbytes 32))
        (circuit %CompactStandardLibrary.3 ([%x.4 (tfield)])
             (tbytes 32)
          (call (fref ((%persistentHash.1))) %x.4))))
    )

  (test
    '(
      "export circuit foo(): Field {"
      " return CompactStandardLibrary();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "unbound identifier ~s" (CompactStandardLibrary)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(): Field {"
      " return CompactStandardLibrary();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 9" "unbound identifier ~s" (CompactStandardLibrary)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(): Field {"
      " return CompactStandardLibrary();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 9" "unbound identifier ~s" (CompactStandardLibrary)))
    )

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (returns
       (program ((foo %foo.0))
         (circuit %foo.0 ([%x.1 (tfield)]) (tfield) (* %x.1 2))))
     ))

  (test-group
    ((create-file "A/M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "A/M1.compact"
       '(
         "module M1 {"
         "  import M;"
         "  export { foo }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import 'A/M1';"
         "export { foo }"
         ))
     (returns
       (program ((foo %foo.0))
         (circuit %foo.0 ([%x.1 (tfield)]) (tfield) (* %x.1 2))))
     ))

  (test-group
    ((create-file "A/M.compact"
       '(
         "module M {"
         "  import M1;"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         )))
    ((create-file "A/M1.compact"
       '(
         "module M1 {"
         "  import M;"
         "  export { foo }"
         "}"
         )))
    ((create-file "testfile.compact"
       '(
         "import 'A/M1';"
         "export { foo }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("M.compact line 2 char 3" "cycle involving ~a~?" ("module" "~#[~; ~a~;s ~a and ~a~:;s~@{~#[~; and~] ~a~^,~}~]" (M "A/M1"))))
     ))

  (test-group
    ((create-file "A/M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit bar(x: Field): Field { return x * 7; }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import 'M';"
         "export { bar }"
         ))
     (returns
       (program ((bar %bar.0))
         (circuit %bar.0 ([%x.1 (tfield)]) (tfield) (* %x.1 7))))
     ))

  (test-group
    ((create-file "A/M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit bar(x: Field): Field { return x * 7; }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import 'M';"
         "export { foo }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 2 char 10" "unbound identifier ~s" (foo)))
     ))

  (test-group
    ((create-file "A/M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit bar(x: Field): Field { return x * 7; }"
         "}"
         ))
     (succeeds))
    ((create-file "A/testfile.compact"
       '(
         "import 'M';"
         "export { foo }"
         ))
     (returns
       (program ((foo %foo.0))
         (circuit %foo.0 ([%x.1 (tfield)]) (tfield) (* %x.1 2))))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module M {"
         "  export circuit bar(x: Field): Field { return x * 7; }"
         "}"
         "import 'M';"
         "export { foo, bar }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 5 char 15" "unbound identifier ~s" (bar)))
     ))

  ; when Compactc looks in the file system to find a module instead of the current program
  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module M {"
         "  export circuit bar(x: Field): Field { return x * 7; }"
         "}"
         "import M;"
         "export { foo, bar }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 5 char 10" "unbound identifier ~s" (foo)))
     ))

  (test-group
    ((create-file "testfile.compact"
       '(
         "module M {"
         "  export circuit bar(x: Field): Field { return x * 7; }"
         "}"
         "import 'M';"
         "export { bar }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 1" "failed to locate file ~s" ("M.compact")))
     ))

  (test-group
    ((create-file "A/M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "A/M1.compact"
       '(
         "module M1 {"
         "  import M;"
         "  export { foo }"
         "}"
         ))
     (succeeds))
    ((create-file "B/M.compact"
       '(
         "module M {"
         "  export circuit bar(x: Field): Field { return x * 7; }"
         "}"
         ))
     (succeeds))
    ((create-file "B/M1.compact"
       '(
         "module M1 {"
         "  import M;"
         "  export { bar }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import 'A/M1';"
         "import 'B/M1';"
         "export { foo, bar }"
         ))
     (returns
       (program ((bar %bar.0) (foo %foo.1))
         (circuit %foo.1 ([%x.2 (tfield)]) (tfield) (* %x.2 2))
         (circuit %bar.0 ([%x.3 (tfield)]) (tfield) (* %x.3 7))))
     ))

  (test-group
    ((create-file "A/M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "A/M1.compact"
       '(
         "module M1 {"
         "  import M;"
         "  export { foo }"
         "}"
         ))
     (succeeds))
    ((create-file "B/M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 7; }"
         "}"
         ))
     (succeeds))
    ((create-file "B/M1.compact"
       '(
         "module M1 {"
         "  import M;"
         "  export { foo }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import 'A/M1' prefix A;"
         "import 'B/M1' prefix B;"
         "export { Afoo, Bfoo }"
         ))
     (returns
       (program ((Afoo %foo.0) (Bfoo %foo.1))
         (circuit %foo.0 ([%x.2 (tfield)]) (tfield) (* %x.2 2))
         (circuit %foo.1 ([%x.3 (tfield)]) (tfield) (* %x.3 7))))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field {;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("M.compact line 2 char 40" "parse error: found ~a looking for~?" ("\";\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a statement" "\"}\""))))
     )
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("M.compact line 2 char 40" "parse error: found ~a looking for~?" ("\";\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a statement" "\"}\""))))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module NotM {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "~a defines module ~s rather than expected module ~s" ("compiler/testdir/M.compact" NotM M)))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         "witness W(): [];"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "~a does not contain a (single) module defintion" ("compiler/testdir/M.compact")))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "~a does not contain a (single) module defintion" ("compiler/testdir/M.compact")))
     ))

  (test-group
    ((create-file "silly/M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "failed to locate file ~s" ("M.compact")))
     ))

  (test
    '(
      "module M {"
      "  struct B { b: Field }"
      "  export struct S<A> { x: A, y: B }"
      "}"
      "struct B { c: Uint<32>, d: Uint<16> }"
      "import M;"
      "export circuit foo(s: S<Boolean>): S<Boolean> {"
      "  return S<Boolean> { ...s, a: true };"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %foo.0 ([%s.1 (tstruct S
                                 (x (tboolean))
                                 (y (tstruct B (b (tfield)))))])
             (tstruct S (x (tboolean)) (y (tstruct B (b (tfield)))))
          (new (tstruct S (x (tboolean)) (y (tstruct B (b (tfield)))))
            (spread %s.1)
            (a #t)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export { degradeToTransient }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "cannot export ~s (~s) from the top level" (external degradeToTransient)))
    )

  (test
    '(
      "export witness w(): [];"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "cannot export ~s (~s) from the top level" (witness w)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M<T> {"
      "  export ledger fld: T;"
      "}"
      "import M<Counter> prefix M1$;"
      "import M<Counter> prefix M2$;"
      "import M<Set<Field>> prefix M3$;"
      "import M<Field> prefix M4$;"
      "import M<Map<Uint<0..10>, Map<Uint<8>, List<Boolean>>>> prefix M5$;"
      "import M<Map<Uint<0..10>, Map<Uint<8>, List<Boolean>>>> prefix M6$;"
      "export circuit foo(): Vector<5, Field> {"
      "  M1$fld += 1;"
      "  M2$fld += 2;"
      "  M5$fld.insert(3, default<Map<Uint<8>, List<Boolean>>>);"
      "  M5$fld.lookup(3).insert(4, default<List<Boolean>>);"
      "  M5$fld.lookup(3).lookup(4).pushFront(true);"
      "  return [M1$fld, M2$fld, M3$fld.size(), M4$fld, M6$fld.lookup(3).lookup(4).head().value as Field];"
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (public-ledger-declaration %kernel.1 (Kernel))
        (public-ledger-declaration %fld.2 (Counter))
        (public-ledger-declaration %fld.3 (Set (tfield)))
        (public-ledger-declaration %fld.4 (__compact_Cell (tfield)))
        (public-ledger-declaration
          %fld.5
          (Map (tunsigned 9) (Map (tunsigned 255) (List (tboolean)))))
        (circuit %foo.0 ()
             (tvector 5 (tfield))
          (seq
            (+= %fld.2 1)
            (+= %fld.2 2)
            (elt-call
              %fld.5
              insert
              3
              (default (Map (tunsigned 255) (List (tboolean)))))
            (elt-call
              (elt-call %fld.5 lookup 3)
              insert
              4
              (default (List (tboolean))))
            (elt-call
              (elt-call (elt-call %fld.5 lookup 3) lookup 4)
              pushFront
              #t)
            (tuple %fld.2 %fld.2 (elt-call %fld.3 size) %fld.4
              (cast (tfield)
                (elt-ref
                  (elt-call
                    (elt-call (elt-call %fld.5 lookup 3) lookup 4)
                    head)
                  value)))))))
    )

  (test
    '(
      "module M {"
      "  ledger fld: Field;"
      "  export circuit foo(x: Field) : Field { fld = fld + x; return fld; }"
      "  export { foo }"
      "}"
      "module M1 {"
      "  import M;"
      "  export { foo }"
      "}"
      "import M1;"
      "import M1 prefix M1$;"
      "import M;"
      "import M;"
      "export { foo, M1$foo }"
      )
    ; look ma, just one copy each of fld and foo, and no complaints about duplicates!
    (returns
      (program ((M1$foo %foo.0) (foo %foo.0))
        (public-ledger-declaration %kernel.1 (Kernel))
        (public-ledger-declaration %fld.2 (__compact_Cell (tfield)))
        (circuit %foo.0 ([%x.3 (tfield)])
             (tfield)
          (seq (= %fld.2 (+ %fld.2 %x.3)) %fld.2))))
    )

  (test
    '(
      "module M {"
      "  export struct S { x: Field, y: Boolean }"
      "  export enum E { gad, arly, xtra };"
      "}"
      "import M;"
      "import M;"
      "export { S, E }"
      )
    (returns
      (program ()
        (type-definition S ()
          (tstruct S (x (tfield)) (y (tboolean))))
        (type-definition E () (tenum E gad arly xtra))))
    )

  (test
    '(
      "module M1 {"
      "  export struct S { x: Field, y: Boolean }"
      "  export enum E { gad, arly, xtra };"
      "}"
      "module M2 {"
      "  export struct S { x: Field, y: Boolean }"
      "  export enum E { gad, arly, xtra };"
      "}"
      "import M1;"
      "import M2;"
      "export { S, E }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 1" "another binding found for ~s in the same scope at ~a" (E "line 9 char 1")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M<T, #N> {"
      "  export ledger F: MerkleTree<N, T>;"
      "}"
      "import M<Field, 3>;"
      )
    (returns
      (program ()
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %F.1 (MerkleTree 3 (tfield)))))
    )

  (test
    `(
      "circuit bar<T>(x: T): Field {"
      "  return x[0];"
      "}"
      ,(format "export circuit foo(x: Vector<~d, Field>): Field {" (max-bytes/vector-length))
      ,(format "  return bar<Vector<~d, Field>>(x);" (max-bytes/vector-length))
      "}"
      )
    (returns
      (program ((foo %foo.0))
        (circuit %bar.1 ([%x.2 (tvector
                                 ,(max-bytes/vector-length)
                                 (tfield))])
             (tfield)
          (tuple-ref %x.2 0))
        (circuit %foo.0 ([%x.3 (tvector
                                 ,(max-bytes/vector-length)
                                 (tfield))])
             (tfield)
          (call (fref ((%bar.1))) %x.3))))
    )


  (test
    '(
      "import CompactStandardLibrary;"
      "import CompactStandardLibrary;"
      )
    (returns
      (program () (public-ledger-declaration %kernel.0 (Kernel))))
    )

  ; tests that ledger fields defined and exported in standard library cannot be redefined
  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger kernel: Kernel;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "another binding found for ~s in the same scope at ~a" (kernel "line 1 char 1")))
  )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit ecAdd(a: CurvePoint, b: CurvePoint): CurvePoint;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "cannot export ~s (~s) from the top level" (external ecAdd)))
  )

  ; tests that declared and exported types in standard library cannot be redefined
  (test
    '(
      "import CompactStandardLibrary;"
      "export struct Either<a, b> {"
      "  is_left: Boolean;"
      "  left: a;"
      "  right: b;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "another binding found for ~s in the same scope at ~a" (Either "line 1 char 1")))
  )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit left<a, b>(value: a): Either<a, b> {"
      "  return Either<a, b>{ is_left: true, left: value, right: default<b> };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "cannot export type-parameterized function (~s) from the top level" (left)))
  )

  ; tests that defined and exported non-parametrized circuits in standard library can be redefined
  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit tokenType(domain_sep: Bytes<32>, contract_address: ContractAddress): Bytes<32> {"
      "  return persistentCommit<Vector<2, Bytes<32>>>([domain_sep, contract_address.bytes], pad(32, 'midnight:derive_token'));"
      "}"
      )
    (succeeds)
  )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const z = a, {a, b} = bar(true, 17);"
      "  return b ? a : 2 * z;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 13" "identifier ~s might be referenced before it is assigned" (a)))
    )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const y = n, x = n + y;"
     "  const y = x;"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 9" "found multiple bindings for ~s in the same block" (y)))
   )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const z = a, {a, b} = bar(true, 17);"
      "  return b ? a : 2 * z;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 13" "identifier ~s might be referenced before it is assigned" (a)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const z = b, {a, b} = bar(true, 17);"
      "  return b ? a : 2 * z;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 13" "identifier ~s might be referenced before it is assigned" (b)))
    )

  (test
   '(
     "circuit foo (): Field {"
     "  const x = 10, y = x, x = y;"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 24" "found multiple bindings for ~s in the same block" (x)))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const [x, a] = [10, 11], y = x, z = y, x = z;"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 42" "found multiple bindings for ~s in the same block" (x)))
   )

  (test
   '(
     "circuit foo (): Field {"
     "  const y = x, x = 30;"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 13" "identifier ~s might be referenced before it is assigned" (x)))

   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const [x, y] = [a, b], [a, b] = [1, 2];"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 19" "identifier ~s might be referenced before it is assigned" (a)))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const z = x, x = 10;"
     "  const y = n, x = n + y;"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 16" "found multiple bindings for ~s in the same block" (x)))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const z = a, a = 10;"
     "  const y = n, x = n + y;"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 13" "identifier ~s might be referenced before it is assigned" (a)))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const [a, b] = [1, a];"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 22" "identifier ~s might be referenced before it is assigned" (a)))
   )

  (test
   '(
     "circuit foo (n: Field): Field {"
     "  const [x, y] = [a, 12], [a, b] = [1, 2];"
     "  return y;"
     "}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 19" "identifier ~s might be referenced before it is assigned" (a)))
   )

  (test
    '(
      "module Test {"
      "  export circuit test(var: Field): Field {"
      "    return var;"
      "  }"
      "}"
      ""
      "import { test as t, t as test } from Test;"
      ""
      "export { t, T$t };"
      ""
      "export circuit test1(): Field {"
      "  const a = t(1) + T$t(1);"
      "  return a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 21" "no export named ~a in module ~a" (t Test)))
    )

  (test
    '(
      "export circuit foo(x: Uint<0..0>): [] {"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "range end for Uint type is ~d but must be at least 1 (the range end is exclusive)" (0)))
    )
)

(run-tests infer-types
  (test
    '("import CompactStandardLibrary;")
    (returns
      (program (public-ledger-declaration %kernel.0 (Kernel))))
    )

  (test ;; FIXME uncomment the composable contract call in test.compact
    "test-center/compact/test.compact"
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %foo.1 ([%a.2 (tboolean)] [%b.3 (tfield)])
             (tboolean)
          #f)
        (circuit %bar.4 ([%a.5 (tboolean)] [%b.6 (tboolean)])
             (tstruct frob (q (tfield)))
          (let* ([[%x.7 (tboolean)]
                  (call %foo.1 #t (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%y.8 (tunsigned 3)]
                    (if %a.5
                        (if %b.6 3 (safe-cast (tunsigned 3) (tunsigned 2) 2))
                        (safe-cast (tunsigned 3)
                                   (tunsigned 1)
                          (if %b.6
                              1
                              (safe-cast (tunsigned 1) (tunsigned 0) 0))))])
              (let* ([[%w.9 (tboolean)] (if %a.5 #t #f)])
                (let* ([[%v.10 (tboolean)]
                        (if %a.5
                            #f
                            (fold
                              %foo.1
                              #t
                              (tuple-ref (tuple (tuple)) 0)))])
                  (seq
                    (if %a.5
                        (if %b.6
                            (assert %a.5 "a should be true")
                            (if %b.6 (assert %a.5 "a should be true") (tuple)))
                        (tuple))
                    (if %a.5
                        (if %b.6 (assert %a.5 "a should be true") (tuple))
                        (let* ([[%v.11 (tboolean)] %a.5])
                          (if %b.6 (assert %v.11 "a should be false") (tuple))))
                    (fold
                      (circuit ([%b.12 (tboolean)]
                                [%c.13 (tboolean)]
                                [%d.14 (tfield)])
                           (tboolean)
                        (if (if %a.5 %b.12 #f) %c.13 #f))
                      #t
                      (tuple #f #t #t #f)
                      (tuple 0 1 2 3))
                    (tuple-ref (tuple 1 2 3 4) 2)
                    (map
                      %foo.1
                      (tuple #f #f #t #f)
                      (tuple 1 2 3 4))
                    (assert
                      (== (ledger-call self %kernel.0)
                          (ledger-call self %kernel2.15))
                      "oops")
                    (new (tstruct frob (q (tfield)))
                      (ledger-call read %x0.16))))))))
        (circuit %baz.17 ([%b.18 (tboolean)])
             (tunsigned 1023)
          (disclose
            (if %b.18
                (safe-cast (tunsigned 1023) (tunsigned 1) 1)
                (safe-cast (tunsigned 1023) (tunsigned 0) 0))))
        (circuit %nullX.19 () (tboolean) (default (tboolean)))
        (public-ledger-declaration %kernel2.15 (Kernel))
        (public-ledger-declaration %x0.16 (__compact_Cell (tfield)))
        (public-ledger-declaration %x1.20 (Set (tfield)))
        (public-ledger-declaration %x2.21 (Counter))
        (public-ledger-declaration %x3.22 (List (tfield)))
        (public-ledger-declaration %x4.23 (Map (tfield) (tboolean)))
        (public-ledger-declaration %x5.24 (MerkleTree 32 (tfield)))
        (public-ledger-declaration
          %x6.25
          (HistoricMerkleTree 10 (tfield)))
        (public-ledger-declaration
          %x7.26
          (__compact_Cell
            (tstruct CoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned
                       340282366920938463463374607431768211455)))))
        (public-ledger-declaration
          %x10.27
          (__compact_Cell
            (tstruct MerkleTreeDigest (field (tfield)))))
        (public-ledger-declaration
          %x11.28
          (__compact_Cell
            (tstruct QualifiedCoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned 340282366920938463463374607431768211455))
              (mt_index (tunsigned 18446744073709551615)))))
        (public-ledger-declaration
          %x13.29
          (__compact_Cell
            (tstruct ContractAddress (bytes (tbytes 32)))))
        (public-ledger-declaration
          %authority.30
          (__compact_Cell (tbytes 32)))
        (public-ledger-declaration
          %state.31
          (__compact_Cell
            (tenum PublicState setup commit reveal final)))
        (public-ledger-declaration
          %topic.32
          (__compact_Cell
            (tstruct Maybe
              (is_some (tboolean))
              (value (topaque "string")))))
        (public-ledger-declaration %tallyYes.33 (Counter))
        (public-ledger-declaration
          %committedVotes.34
          (MerkleTree 10 (tbytes 32)))
        (public-ledger-declaration %committed.35 (Set (tbytes 32)))
        (public-ledger-declaration
          %ciphertexts.36
          (__compact_Cell (topaque "Uint8Array")))
        (constructor ([%state.37 (tfield)])
          (seq
            (fold
              (circuit ([%t.38 (ttuple)] [%i.39 (tunknown)])
                   (ttuple)
                (seq
                  (seq
                    (+ #f %state.37 (safe-cast (tfield) (tunsigned 1) 1))
                    (tuple))
                  %t.38))
              (tuple)
              (tuple))
            (tuple)))))
    )

  (test
    '(
       "export circuit bar() : Vector<0, Field> { return []; }"
     )
    (returns
      (program
        (circuit %bar.0 ()
             (tvector 0 (tfield))
             (tuple))))
    )

  (test
    '(
       "module A {"
       "  export witness w(a: Field): Boolean;"
       "}"
       "import A;"
       "witness w(a: Field, b: Field): Boolean;"
       "export circuit foo(a : Field) : Boolean { return w(a); }"
       )
    (returns
      (program
        (witness %w.0 ([%a.1 (tfield)]) (tboolean))
        (witness %w.2 ([%a.3 (tfield)] [%b.4 (tfield)]) (tboolean))
        (circuit %foo.5 ([%a.6 (tfield)])
             (tboolean)
          (call %w.0 %a.6)))))

  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return true; }"
      )
    (returns
      (program
        (circuit %foo.0 ([%a.1 (tboolean)]) (tboolean) #t))))

  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return 3; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 44" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<2>" "Boolean" "circuit foo")))
    )

  (test
    '(
       "export circuit foo() : Bytes<6> { return 'żółtko'; }"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 35" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Bytes<9>" "Bytes<6>" "circuit foo"))))

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  return ((x: Boolean): Boolean => 0)(!x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 11" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<0..1>" "Boolean" "anonymous circuit")))
    )

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  return ((x) => 0)(!x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<0..1>" "Boolean" "circuit foo")))
    )

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  const y = ((x: Boolean): Boolean => 0)(!x);"
      "  return x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 14" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<0..1>" "Boolean" "anonymous circuit")))
    )

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  const y = ((x: Boolean): Boolean => 0)(!x);"
      "  return x;"
      "}"
      "export circuit bar(n: Uint<0..65>): Uint<0..65> {"
      "  return foo(n) ? n -1 : n - 2;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 14" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<0..1>" "Boolean" "anonymous circuit")))
    )

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  return ((x: Boolean): Boolean => x && n <= 0)(!x);"
      "}"
      "export circuit bar(n: Uint<0..65>): Uint<0..65> {"
      "  return foo(n) ? n -1 : n + 2;"
      "}"
      "export circuit ban(x: Field): Boolean {"
      "  return ((x: Field): Boolean => x)(x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<0..67>" "Uint<0..65>" "circuit bar")))
    )

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  return ((x: Boolean): Boolean => x && n <= 0)(!x);"
      "}"
      "export circuit bar(n: Uint<0..65>): Uint<0..65> {"
      "  return foo(n) ? n -1 : n - 2;"
      "}"
      "export circuit ban(x: Field): Boolean {"
      "  return ((x: Field): Boolean => x)(x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 11" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Field" "Boolean" "anonymous circuit")))
    )

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  const y = ((x: Boolean): Boolean => 0)(!x);"
      "  return x;"
      "}"
      "export circuit bar(n: Uint<0..65>): Uint<0..65> {"
      "  return foo(n) ? n -1 : n + 2;"
      "}"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 14" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<0..1>" "Boolean" "anonymous circuit")))
    )

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  return ((x: Boolean): Boolean => x && n <= 0)(!x);"
      "}"
      "export circuit bar(n: Uint<0..65>): Uint<0..65> {"
      "  return foo(n) ? ((x: Uint<0..65>) : Uint<0..65> => x + 1)(n) : n + 2;"
      "}"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 20" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<0..66>" "Uint<0..65>" "anonymous circuit")))
    )

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  return ((x: Boolean): Boolean => x && n <= 0)(!x);"
      "}"
      "export circuit bar(n: Uint<0..65>): Uint<0..65> {"
      "  return foo(n) ? n + 2 : ((x: Uint<0..65>) : Uint<0..65> => x + 1)(n);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 28" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<0..66>" "Uint<0..65>" "anonymous circuit")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger field1: Counter;"
      "constructor(state: Uint<16>) { field1 += state; }"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %field1.1 (Counter))
        (constructor ([%state.2 (tunsigned 65535)])
          (seq (ledger-call increment %field1.1 %state.2) (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger field1: Counter;"
      "constructor(state: Uint<16>) { field1 += state; return state; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 49" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<16>" "[]" "ledger constructor")))
    )

  (test
    '(
      "module Foo {"
      "  export circuit foo(x: Field): Field { return x != 0 ; }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 41" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo")))
    )

  (test
    '(
      "circuit iszero<T>(x: T): Boolean { return x + 0; }"
      "module Foo {"
      "  export circuit foo(x: Field): Boolean { return iszero<Field>(x); }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 36" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Field" "Boolean" "circuit iszero")))
    )

  (test
    '(
      "circuit iszero<T>(x: T): Boolean { return x + 0; }"
      "module Foo {"
      "  export circuit foo(x: Field): Boolean { return iszero<Uint<16>>(x); }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 36" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<16>" "Boolean" "circuit iszero")))
    )

  (test
    '(
      "circuit iszero<T>(x: T): Boolean { return x == 0; }"
      "module Foo {"
      "  export circuit foo(x: Field): Boolean { return iszero<Uint<16>>(x); }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 50" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (iszero #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        (Field)\n      declared argument types for function at line 1 char 1:\n        (Uint<16>)" #f)))
    )

  (test
    '(
      "module Foo<A> {"
      "  export circuit foo(x: Field): Field { return x != 0 ; }"
      "}"
      )
    (returns (program))
    )

  (test
    '(
      "module Foo {"
      "  export circuit foo(x: Field): Field { return x != 0 ; }"
      "}"
      "import Foo prefix $;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 41" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo")))
    )

  (test
    '(
      "module Foo {"
      "  circuit foo(x: Field): Field { return x != 0 ; }"
      "}"
      "import Foo prefix $;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 34" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo")))
    )

  (test
    '(
      "module Foo {"
      "  export circuit foo(x: Field): Field { return x != 0 ; }"
      "}"
      "import Foo prefix $;"
       "export circuit foo(a: Boolean, b: Field): Boolean { return a && $foo(b); }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 41" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo")))
    )

  (test-group
    ((create-file "Foo.compact"
       '(
         "module Foo {"
         "  export circuit foo(x: Field): Field { return x != 0 ; }"
         "}"
       ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("Foo.compact line 2 char 41" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo"))))
    )

  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return !(!a && a || a && a); }"
      )
    (returns
      (program
        (circuit %foo.0 ([%a.1 (tboolean)])
             (tboolean)
          (if (if (if (if %a.1 #f #t) %a.1 #f) #t (if %a.1 %a.1 #f))
              #f
              #t))))
    )

  (test
    '(
      "export circuit foo(a: Boolean) : Field { const x = 7; if (a) return x+1; return x-1; }"
      )
    (returns
      (program
        (circuit %foo.0 ([%a.1 (tboolean)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned 8)
            (let* ([[%x.2 (tunsigned 7)] 7])
              (if %a.1
                  (+ 4
                     (safe-cast (tunsigned 8) (tunsigned 7) %x.2)
                     (safe-cast (tunsigned 8) (tunsigned 1) 1))
                  (safe-cast (tunsigned 8)
                             (tunsigned 7)
                    (seq
                      (assert
                        (if (< %x.2 (safe-cast (tunsigned 7) (tunsigned 1) 1))
                            #f
                            #t)
                        "result of subtraction would be negative")
                      (- 3 %x.2 (safe-cast (tunsigned 7) (tunsigned 1) 1))))))))))
    )

  (test
    '(
      "export circuit foo(a: Bytes<20>, i: Field) : Boolean { return a == [pad(20,'a'), pad(20,'b'), pad(20,'c')][1]; }"
      )
    (returns
      (program
        (circuit %foo.0 ([%a.1 (tbytes 20)] [%i.2 (tfield)])
             (tboolean)
          (== %a.1
              (tuple-ref
                (tuple
                  #vu8(97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                  #vu8(98 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                  #vu8(99 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))
                1)))))
    )

  (test
    '(
      "export circuit foo(a: Vector<0, Boolean>, i: Field) : Boolean { return a == [[],[],[]][0]; }"
      )
    (returns
      (program
        (circuit %foo.0 ([%a.1 (tvector 0 (tboolean))]
                         [%i.2 (tfield)])
             (tboolean)
          (== %a.1
              (tuple-ref
                (tuple (tuple) (tuple) (tuple))
                0)))))
    )

  (test
    '(
      "export circuit foo() : Field { return ['a',3]; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 32" "mismatch between actual return type ~a and declared return type ~a of ~a" ("[Bytes<1>, Uint<2>]" "Field" "circuit foo")))
    )

  (test
    '(
      "struct foo {}"
      "export circuit foo() : Field { return foo; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "another binding found for ~s in the same scope at ~a" (foo "line 1 char 1")))
    )

  (test
    '(
      "export circuit foo(x: []) : [] { return x; }"
      "export circuit bar(x: Field) : [] { return foo(x); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 44" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        (Field)\n      declared argument types for function at line 1 char 1:\n        ([])" #f)))
    )

  (test
    '(
      "export circuit foo(x: []) : [] { return x; }"
      "export circuit bar(x: Field) : [] { return foo; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 44" "invalid context for reference to ~a name ~s" ("function" foo)))
    )

  (test
    '(
      "export circuit bar(x: Field) : [] { return x * false; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 44" "~a requires its ~a operand to be a Field or Uint; the actual type is ~a" (* "right" "Boolean")))
    )

  (test
    '(
      "export circuit bar(x: Field, y: Bytes<20>) : Field { return y - x; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 61" "~a requires its ~a operand to be a Field or Uint; the actual type is ~a" (- "left" "Bytes<20>")))
    )

  (test
    '(
      "export circuit bar() : Field { return; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 32" "mismatch between actual return type ~a and declared return type ~a of ~a" ("[]" "Field" "circuit bar"))))

  (test
    '(
      "export circuit bar(a: Field) : Field { const x = a; x * x; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between actual return type ~a and declared return type ~a of ~a" ("[]" "Field" "circuit bar"))))

  (test
    '(
      "export circuit bar(a: Field) : Field { if (a == 0) a; else return; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 60" "mismatch between actual return type ~a and declared return type ~a of ~a" ("[]" "Field" "circuit bar"))))

  (test
    '(
      "circuit foo(x: []) : [] { return x; }"
      "export circuit bar(x: Field) : [] { return foo(x-1, x+1); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 44" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        (Field, Field)\n      declared argument types for function at line 1 char 1:\n        ([])" #f)))
  )

  (test
    '(
      "circuit foo(a: Field, b: Field) : Field { return a * b; }"
      "export circuit bar(x: Field) : Field { return foo(x-1, x+1); }"
      )
    (returns
      (program
        (circuit %foo.0 ([%a.1 (tfield)] [%b.2 (tfield)])
             (tfield)
          (* #f %a.1 %b.2))
        (circuit %bar.3 ([%x.4 (tfield)])
             (tfield)
          (call %foo.0
            (- #f %x.4 (safe-cast (tfield) (tunsigned 1) 1))
            (+ #f %x.4 (safe-cast (tfield) (tunsigned 1) 1))))))
  )

  (test
    '(
      "export circuit bar(x: Field) : [] { assert(x == 0 ? x + 1 : x + x, 'oops'); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 37" "expected test to have type Boolean, received ~a" ("Field")))
  )

  (test
    '(
      "export circuit bar(x: Field) : [] { if (x + 1) assert(x - 1, 'oops 1'); else assert(x + x, 'oops 2'); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 37" "expected test to have type Boolean, received ~a" ("Field")))
  )

  (test
    '(
      "circuit foo(x: Field, y: Bytes<20>) : Field { return x; }"
      "export circuit bar(x: Field) : [] { return foo(x-1, x+1); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 44" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        (Field, Field)\n      declared argument types for function at line 1 char 1:\n        (Field, Bytes<20>)" #f)))
  )

  (test
    '(
      "circuit foo(x: Field, y: Bytes<20>) : Field { return x; }"
      "export circuit bar(x: Field) : [] { return map(x, [1, 2, 3, 4], ['a','b','c','d']); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 48" "invalid context for reference to ~a name ~s" ("variable" x))))

  (test
    '(
      "circuit foo(x: Field, y: Bytes<20>) : Field { return x; }"
      "export circuit bar(x: Field) : [] { return fold(x, 17, [1, 2, 3, 4], ['a','b','c','d']); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 49" "invalid context for reference to ~a name ~s" ("variable" x))))

  (test
    '(
      "circuit foo(x: Field, y: Bytes<20>) : Field { return x; }"
      "export circuit bar(x: Field) : [] { return x(5, 7); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 44" "invalid context for reference to ~a name ~s" ("variable" x))))

  (test
    '(
      "circuit foo(x: Field, y: Bytes<20>) : Field { return x; }"
      "export circuit bar() : [] { return map(foo, [1, 2, 3, 4], ['a','b','c']); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 36" "mismatch in ~s-argument vector lengths" (map)))
    )

  (test
    '(
      "circuit foo(x: Field, y: Bytes<20>) : Field { return x; }"
      "export circuit bar() : [] { return map(foo, [1, 2, 3, 4], 12); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 36" "~a should be a vector, tuple, or Bytes but has type ~a" ("map third argument" "Uint<0..13>")))
    )

  (test
    '(
      "circuit foo(x: Field, y: Bytes<20>) : Field { return x; }"
      "export circuit bar() : [] { const q = foo; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 39" "invalid context for reference to ~a name ~s" ("function" foo))))

  (test
    '(
      "export circuit bar() : Field { const q : Field = 'foo'; return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 38" "mismatch between actual type ~a and declared type ~a of const binding" ("Bytes<3>" "Field"))))

  (test
    '(
      "export circuit bar(a: Field) : Field { return a == 0 ? a : false; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 47" "mismatch between type ~a and type ~a of condition branches" ("Field" "Boolean"))))

  (test
    '(
      "export circuit bar(a: Field, v: Vector<0, Boolean>) : Vector<0, Boolean> { return a == 0 ? v : []; }"
      )
    (returns
      (program
        (circuit %bar.0 ([%a.1 (tfield)]
                         [%v.2 (tvector 0 (tboolean))])
             (tvector 0 (tboolean))
          (if (== %a.1 (safe-cast (tfield) (tunsigned 0) 0))
              %v.2
              (tuple)))))
    )

  (test
    '(
      "struct foo {}"
      "export circuit bar(a: Field) : Field { return foo{}.rats * a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 52" "structure ~s has no field named ~s" (foo rats)))
    )

  (test
    '(
      "struct foo {}"
      "export circuit bar(a: Field) : Field { return foo {}.rats * a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 53" "structure ~s has no field named ~s" (foo rats)))
    )

  (test
    '(
      "struct foo {}"
      "export circuit bar(a: Field) : Field { return a.rats * a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 48" "expected structure type, received ~a" ("Field")))
    )

  (test
    '(
      "circuit foo() : Vector<3, Field> { return [5, 13, 53]; }"
      "export circuit bar(a: Field) : Field { return foo()[1]; }"
      )
    (returns
      (program
        (circuit %foo.0 ()
             (tvector 3 (tfield))
          (safe-cast (tvector 3 (tfield))
                     (ttuple (tunsigned 5) (tunsigned 13) (tunsigned 53))
            (tuple 5 13 53)))
        (circuit %bar.1 ([%a.2 (tfield)])
             (tfield)
          (tuple-ref (call %foo.0) 1))))
    )

  (test
    '(
      "circuit foo() : Vector<3, Field> { return [5, 13, 53]; }"
      "export circuit bar(a: Field, b: Boolean) : Field { return foo()[5]; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 59" "index ~d is out-of-bounds for a ~a of length ~d" (5 "vector" 3))))

  (test
    '(
      "circuit foo() : [Field, Field, Field] { return [5, 13, 53]; }"
      "export circuit bar(a: Field, b: Boolean) : Field { return foo()[5]; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 59" "index ~d is out-of-bounds for a ~a of length ~d" (5 "tuple" 3))))

  (test
    '(
      "circuit foo() : Field { return 23; }"
      "export circuit bar(a: Field) : Field { return foo()[5]; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 47" "expected a tuple, Vector, or Bytes type, received ~a" ("Field"))))

  (test
    '(
      "export circuit bar(a: Field, b: Bytes<10>) : Boolean { return a == b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 63" "incompatible types ~a and ~a for equality operator" ("Field" "Bytes<10>"))))

  (test
    '(
      "export circuit bar(a: Field, b: Bytes<10>) : Boolean { return a != b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 63" "incompatible types ~a and ~a for equality operator" ("Field" "Bytes<10>"))))

  (test
    '(
      "export circuit bar(a: Uint<16>) : Boolean { return a < 1; }"
      )
    (returns
      (program
        (circuit %bar.0 ([%a.1 (tunsigned 65535)])
             (tboolean)
          (< %a.1 (safe-cast (tunsigned 65535) (tunsigned 1) 1))))))

  (test
    '(
      "export circuit bar(a: Uint<16>, b: Bytes<10>) : Boolean { return a < b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 66" "incompatible combination of types ~a and ~a for relational operator" ("Uint<16>" "Bytes<10>"))))

  (test
    '(
      "export circuit bar(a: Uint<16>, b: Boolean) : Boolean { return a > b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 64" "incompatible combination of types ~a and ~a for relational operator" ("Uint<16>" "Boolean"))))

  (test
    '(
      "export circuit bar(a: Uint<16>, b: Field) : Boolean { return a > b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 62" "incompatible combination of types ~a and ~a for relational operator" ("Uint<16>" "Field"))))

  (test
    '(
      "export circuit bar(a: Field, b: Uint<16>) : Boolean { return a > b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 62" "incompatible combination of types ~a and ~a for relational operator" ("Field" "Uint<16>"))))

  (test
    '(
      "export circuit bar(a: Field, b: Uint<16>) : Boolean { return a <= b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 62" "incompatible combination of types ~a and ~a for relational operator" ("Field" "Uint<16>"))))

  (test
    '(
      "export circuit bar(a: Field, b: Uint<16>) : Boolean { return a >= b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 62" "incompatible combination of types ~a and ~a for relational operator" ("Field" "Uint<16>"))))

  (test
    '(
      "export circuit bar(a: Uint<16>, b: Uint<16>) : Boolean { return a < b; }"
      )
    (returns
      (program
        (circuit %bar.0 ([%a.1 (tunsigned 65535)]
                         [%b.2 (tunsigned 65535)])
             (tboolean)
          (< %a.1 %b.2)))))

  (test
    '(
      "export circuit bar(a: Uint<16>, b: Uint<32>) : Boolean { return a >= b; }"
      )
    (returns
      (program
        (circuit %bar.0 ([%a.1 (tunsigned 65535)]
                         [%b.2 (tunsigned 4294967295)])
             (tboolean)
          (>= (safe-cast (tunsigned 4294967295) (tunsigned 65535)
                %a.1)
              %b.2))))
    )

  (test
    '(
      "export circuit bar(a: Uint<16>, b: Uint<32>) : Boolean { return b <= a; }"
      )
    (returns
      (program
        (circuit %bar.1 ([%a.0 (tunsigned 65535)]
                         [%b.2 (tunsigned 4294967295)])
             (tboolean)
          (<= %b.2
              (safe-cast (tunsigned 4294967295) (tunsigned 65535) %a.0)))))
    )

  (test
    '(
      "export circuit bar(a: Uint<16>, b: Uint<32>) : [] { assert((a < b || b > a + a), 'oops'); }"
      )
    (returns
      (program
        (circuit %bar.0 ([%a.1 (tunsigned 65535)]
                         [%b.2 (tunsigned 4294967295)])
             (ttuple)
          (seq
            (assert
              (if (< (safe-cast (tunsigned 4294967295) (tunsigned 65535)
                       %a.1)
                     %b.2)
                  #t
                  (> %b.2
                     (safe-cast (tunsigned 4294967295) (tunsigned 131070)
                       (+ 17
                          (safe-cast (tunsigned 131070) (tunsigned 65535) %a.1)
                          (safe-cast (tunsigned 131070) (tunsigned 65535) %a.1)))))
              "oops")
            (tuple)))))
    )

  (test
    '(
      "module Foo<A> {"
      "  struct foo { x: A; }"
      "}"
      "import Foo<Field>;"
      "export circuit bar(a: foo) : Field { return a.x; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 23" "unbound identifier ~s" (foo))))

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field>;"
      "export circuit bar(a: foo) : Field { return a.x; }"
      )
    (returns
      (program
        (circuit %bar.0 ([%a.1 (tstruct foo (x (tfield)))])
             (tfield)
          (elt-ref %a.1 x 0)))))

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field> prefix $;"
      "export circuit bar(a: Field) : $foo { return $foo{x: a}; }"
      )
    (returns
      (program
        (circuit %bar.0 ([%a.1 (tfield)])
             (tstruct foo (x (tfield)))
          (new (tstruct foo (x (tfield))) %a.1)))))

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field> prefix $;"
      "export circuit bar(a: Field) : $foo { return $foo { x: a }; }"
      )
    (returns
      (program
        (circuit %bar.0 ([%a.1 (tfield)])
             (tstruct foo (x (tfield)))
          (new (tstruct foo (x (tfield))) %a.1)))))

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field> prefix $;"
      "export circuit bar(a: Field) : foo { return $foo{ x: a }; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 32" "unbound identifier ~s" (foo))))

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field> prefix $;"
      "export circuit bar(a: Field) : $foo { return $foo{ x: a, y: a }; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 58" "value for unrecognized field named ~a appears in creation syntax for ~a" (y "struct foo<x: Field>")))
    )

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field> prefix $;"
      "export circuit bar(a: Field) : $foo { return $foo{x: a, x: a}; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 57" "value of field ~s is already given at ~a" (x "line 5 char 51")))
    )

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field> prefix $;"
      "export circuit bar(a: Field) : $foo { return $foo{x: a, y: a}; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 57" "value for unrecognized field named ~a appears in creation syntax for ~a" (y "struct foo<x: Field>")))
    )

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field> prefix $;"
      "export circuit bar(a: Field) : $foo { return $foo{x: a, y: a, z: a, w: a}; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 57" "value for unrecognized field named ~a appears in creation syntax for ~a" (y "struct foo<x: Field>")))
    )

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field>;"
      "export circuit bar(a: Boolean) : foo { return foo{ x: a }; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 47" "mismatch between actual type ~a and declared type ~a for field ~s of ~a" ("Boolean" "Field" x "struct foo<x: Field>")))
    )

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field>;"
      "export circuit bar(a: Boolean) : foo { return foo { x: a }; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 47" "mismatch between actual type ~a and declared type ~a for field ~s of ~a" ("Boolean" "Field" x "struct foo<x: Field>")))
    )

  (test ; just see if it succeeds
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it succeeds
    "examples/election.compact"
    (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
   (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
   (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
   (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/counter/contract/src/counter.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/welcome/contract/src/welcome.compact"
    (succeeds))

  (test
    '(
      "module Foo<A> {"
      "  export module Bar<B> {"
      "    export struct bar { a: A; b: B;}"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit rat(b: Boolean) : bar { return bar{a: 3, b: b}; }"
      )
    (returns
      (program
        (circuit %rat.0 ([%b.1 (tboolean)])
             (tstruct bar (a (tfield)) (b (tboolean)))
          (new (tstruct bar (a (tfield)) (b (tboolean)))
            (safe-cast (tfield) (tunsigned 3) 3)
            %b.1))))
    )

  (test
    '(
      "module Foo<A> {"
      "  circuit foo(a: A) : A { return a; }"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      )
    (returns
      (program
        (circuit %foo.0 ([%a.1 (tfield)]) (tfield) %a.1)
        (circuit %bar.2 ([%a.3 (tfield)] [%b.4 (tboolean)])
             (tfield)
          (call %foo.0 %a.3))
        (circuit %foo.5 ([%b.6 (tboolean)])
             (tfield)
          (call %bar.2 (safe-cast (tfield) (tunsigned 3) 3) %b.6))))
    )

  (test
    '(
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      "module Foo<A> {"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  circuit foo(a: A) : A { return a; }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      )
    (returns
      (program
        (circuit %foo.1 ([%b.2 (tboolean)])
             (tfield)
          (call %bar.3 (safe-cast (tfield) (tunsigned 3) 3) %b.2))
        (circuit %bar.3 ([%a.4 (tfield)] [%b.0 (tboolean)])
             (tfield)
          (call %foo.5 %a.4))
        (circuit %foo.5 ([%a.6 (tfield)]) (tfield) %a.6)))
    )

  (test
    '(
      "module Foo<A> {"
      "  export circuit foo(a: A) : A { return a; }"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return b; }"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foo(b: Boolean) : Boolean { return bar(3, b); }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 42" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit bar")))
    )

  (test
    '(
      "module Foo<A> {"
      "  export circuit foo(a: A) : A { return a; }"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foo(b: Boolean) : Boolean { return bar(3, b); }"
      "export circuit foofoo(a: Field): Boolean {return foo(a);}"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 44" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Field" "Boolean" "circuit foo")))
    )

  (test
    '(
      "module Foo<A> {"
      "  export circuit foo(a: A) : A { return a; }"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foofoo(a: Field): Boolean {return foo(a);}"
      "export circuit foo(b: Boolean) : Boolean { return bar(3, b); }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 43" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Field" "Boolean" "circuit foofoo")))
    )

  (test
    '(
      "module Foo<A> {"
      "  export circuit foo(a: A) : A { return true; }"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return b; }"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foofoo(a: Field): Field {return foo(a);}"
      "export circuit foo(b: Boolean) : Boolean { return bar(3, b); }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 34" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo")))
    )

  (test
    '(
      "module Foo<A> {"
      "  export circuit foo(a: A) : A { return true; }"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return b; }"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foo(b: Boolean) : Boolean { return bar(3, b); }"
      "export circuit foofoo(a: Field): Field {return foo(a);}"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 34" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo")))
    )

  (test
    '(
      "module Foo<A> {"
      "  circuit foo(a: A) : A { return true; }"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foo(b: Boolean) : Boolean { return bar(3, b); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 27" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo")))
    )

  (test
    '(
      "module Foo<A> {"
      "  circuit foo(a: A) : A { return a; }"
      "  module Bar<B> {"
      "    circuit bar(a: A, b: B) : A { return foo(a); }"
      "    export {bar}"
      "  }"
      "  export {Bar}"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      )
    (returns
      (program
        (circuit %foo.0 ([%a.1 (tfield)]) (tfield) %a.1)
        (circuit %bar.2 ([%a.3 (tfield)] [%b.4 (tboolean)])
             (tfield)
          (call %foo.0 %a.3))
        (circuit %foo.5 ([%b.6 (tboolean)])
             (tfield)
          (call %bar.2 (safe-cast (tfield) (tunsigned 3) 3) %b.6))))
    )

  (test
    '(
      "module Foo<A> {"
      "  circuit foo(a: A) : A { return a; }"
      "  module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  export {bar}"
      "}"
      "import Foo<Field>;"
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      )
    (returns
      (program
        (circuit %foo.0 ([%a.1 (tfield)]) (tfield) %a.1)
        (circuit %bar.2 ([%a.3 (tfield)] [%b.4 (tboolean)])
             (tfield)
          (call %foo.0 %a.3))
        (circuit %foo.5 ([%b.6 (tboolean)])
             (tfield)
          (call %bar.2 (safe-cast (tfield) (tunsigned 3) 3) %b.6))))
    )

  (test
    '(
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      "module Foo<A> {"
      "  export {bar}"
      "  module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  circuit foo(a: A) : A { return a; }"
      "}"
      "import Foo<Field>;"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tfield)
          (call %bar.2 (safe-cast (tfield) (tunsigned 3) 3) %b.1))
        (circuit %bar.2 ([%a.3 (tfield)] [%b.4 (tboolean)])
             (tfield)
          (call %foo.5 %a.3))
        (circuit %foo.5 ([%a.6 (tfield)]) (tfield) %a.6)))
    )

  (test
    '(
      "module Foo<A> {"
      "  circuit foo(a: A) : A { return a; }"
      "  module Bar<B> {"
      "    circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  export {bar}"
      "}"
      "import Foo<Field>;"
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 11" "unbound identifier ~s" (bar))))

  (test
    '(
      "module Foo<A> {"
      "  export circuit bar() : A { return A{a: 1, d: 2}; }"
      "}"
      "struct pr { a: Field; d: Field; };"
      "import Foo<pr>;"
      "export {bar}"
      )
    (returns
      (program
        (circuit %bar.0 ()
             (tstruct pr (a (tfield)) (d (tfield)))
          (new (tstruct pr (a (tfield)) (d (tfield)))
            (safe-cast (tfield) (tunsigned 1) 1)
            (safe-cast (tfield) (tunsigned 2) 2)))))
    )

  (test
    '(
      "module A {"
      "  struct pr { a: Field; d: Field; c: Field}"
      "  export circuit bar(x: pr) : Field { return x.c; }"
      "}"
      "import A;"
      "struct pr { a: Field; d: Field}"
      "export circuit foo(): Field { return bar(pr { a: 1, d: 2 }); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 38" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (bar #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        (struct pr<a: Field, d: Field>)\n      declared argument types for function at line 3 char 3:\n        (struct pr<a: Field, d: Field, c: Field>)" #f)))
    )

  (test
    '(
      "module Foo<A> {"
      "  export circuit bar() : A { const x = A{}; return x; }"
      "}"
      "import Foo<Field>;"
      "export {bar}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 40" "expected structure type, received ~a" ("Field"))))

  (test
    '(
      "circuit foo() : Boolean { return true; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      )
    (returns
      (program
        (circuit %foo.0 () (tboolean) #t)
        (circuit %foo.1 ([%a.2 (tfield)]) (tfield) %a.2)
        (circuit %foo.3 ([%b.4 (tboolean)]) (tboolean) %b.4)
        (circuit %bar.5 ([%n.6 (tfield)])
             (tfield)
          (if (call %foo.0)
              (call %foo.1 %n.6)
              (safe-cast (tfield) (tunsigned 17) 17)))))
    )

  (test
    '(
      "export circuit foo() : Boolean { return true; }"
      "export circuit foo(a: Field) : Field { return a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "multiple top-level exports for ~s" (foo)))
    )

  (test
    '(
      "module M {"
      "  export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      "  export circuit foo() : Boolean { return true; }"
      "  export circuit foo(b: Boolean) : Boolean { return b; }"
      "}"
      "import M;"
      "circuit foo() : Boolean { return false; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export {foo, bar}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 9" "multiple top-level exports for ~s" (foo)))
    )

  (test
    '(
      "module M {"
      "  export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      "  export circuit foo() : Boolean { return true; }"
      "  export circuit foo(b: Boolean) : Boolean { return b; }"
      "}"
      "import M;"
      "circuit foo() : Boolean { return false; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export {bar}"
      )
    (returns
      (program
        (circuit %bar.0 ([%n.1 (tfield)])
             (tfield)
          (if (call %foo.2)
              (call %foo.3 %n.1)
              (safe-cast (tfield) (tunsigned 17) 17)))
        (circuit %foo.2 () (tboolean) #t)
        (circuit %foo.4 ([%b.5 (tboolean)]) (tboolean) %b.5)
        (circuit %foo.6 () (tboolean) #f)
        (circuit %foo.3 ([%a.7 (tfield)]) (tfield) %a.7)
        (circuit %foo.8 ([%b.9 (tboolean)]) (tboolean) %b.9)))
    )

  (test
    '(
      "circuit foo() : Boolean { return true; }"
      "circuit foo(a: Vector<3,Boolean>) : Boolean { return a[1]; }"
      "export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 55" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    two functions are incompatible with the supplied argument types\n      supplied argument types:\n        (Field)\n      declared argument types for function at line 1 char 1:\n        ()\n      declared argument types for function at line 2 char 1:\n        (Vector<3, Boolean>)" #f)))
  )

  (test
    '(
      "struct willy { wonka: Vector<3,Boolean>; chocolate: Bytes<20>; }"
      "circuit foo() : Boolean { return true; }"
      "circuit foo(a: willy) : Boolean { return a.wonka[1]; }"
      "export circuit bar(n: Field) : Field { return foo() ? foo([]) : 17; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 55" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    two functions are incompatible with the supplied argument types\n      supplied argument types:\n        ([])\n      declared argument types for function at line 2 char 1:\n        ()\n      declared argument types for function at line 3 char 1:\n        (struct willy<wonka: Vector<3, Boolean>, chocolate: Bytes<20>>)" #f)))
  )

  (test
    '(
      "circuit foo() : Boolean { return true; }"
      "circuit foo(a: Field, b: Boolean) : Field { return a; }"
      "export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 55" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    two functions are incompatible with the supplied argument types\n      supplied argument types:\n        (Field)\n      declared argument types for function at line 1 char 1:\n        ()\n      declared argument types for function at line 2 char 1:\n        (Field, Boolean)" #f)))
  )

  (test
    '(
      "module M { export circuit foo() : Field { return 10; } }"
      "import M;"
      "circuit foo() : Boolean { return true; }"
      "circuit foo(a: Field) : Field { return a; }"
      "export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 47" "call site ambiguity (multiple compatible functions) in call to ~a\n    supplied argument types:\n      (~{~a~^, ~})\n    compatible functions:~{\n      ~a~}" (foo () ("line 1 char 12" "line 3 char 1"))))
  )

  (test
    '(
      "module M { export circuit foo() : Boolean { return false; } }"
      "import M;"
      "circuit foo() : Boolean { return true; }"
      "circuit foo(a: Field) : Field { return a; }"
      "export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 47" "call site ambiguity (multiple compatible functions) in call to ~a\n    supplied argument types:\n      (~{~a~^, ~})\n    compatible functions:~{\n      ~a~}" (foo () ("line 1 char 12" "line 3 char 1"))))
  )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a: Field, n: Field): Field => a + n,"
      "              0,"
      "              v);"
      "}"
      )
    (returns
      (program
        (circuit %sum.0 ([%v.1 (tvector 10 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.2 (tfield)] [%n.3 (tfield)])
                 (tfield)
              (+ #f %a.2 %n.3))
            (safe-cast (tfield) (tunsigned 0) 0)
            %v.1))))
  )

  (test
    '(
      "// test w/all three overloading faiures for fold"
      "witness foo(a: Field, n: Field): Field;"
      "circuit foo(a: Boolean, n: Field): Field { return a ? n : n - 1; }"
      "circuit foo<t>(a: t, n: Field): t { return t; }"
      "circuit foo(v: Vector<7, Field>, n: Field): Field { return n + v[3]; }"
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold(foo, true, v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 10" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo "\n    one function is incomptable with the supplied generic values\n      supplied generic values:\n        <>\n      declared generics for function at line 4 char 1:\n        <type>" "\n    two functions are incompatible with the supplied argument types\n      supplied argument types:\n        (Boolean, Field)\n      declared argument types for function at line 2 char 1:\n        (Field, Field)\n      declared argument types for function at line 5 char 1:\n        (Vector<7, Field>, Field)" "\n    one function is incompatible because fold requires the return type and the first argument type to be the same\n      declared first-argument and return types for function at line 3 char 1:\n        Boolean\n        Field")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a: Boolean, n: Field): Field => a ? n : n - 1,"
      "              true,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#t "Boolean" #t "Field")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a: Boolean, n: Field) => a ? n : n - 1,"
      "              true,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#t "Boolean" #f "Field")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a, n): Field => a ? n : n - 1,"
      "              true,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#f "Boolean" #t "Field")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a, n) => a ? n : n - 1,"
      "              true,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#f "Boolean" #f "Field")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a, n) => a + n - 1,"
      "              17 as Field,"
      "              v);"
      "}"
      )
    (returns
      (program
        (circuit %sum.0 ([%v.1 (tvector 10 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.2 (tfield)] [%n.3 (tfield)])
                 (tfield)
              (- #f (+ #f %a.2 %n.3) (safe-cast (tfield) (tunsigned 1) 1)))
            (safe-cast (tfield) (tunsigned 17) 17)
            %v.1))))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a: Field, n) => a + n - 1,"
      "              17,"
      "              v);"
      "}"
      )
    (returns
      (program
        (circuit %sum.0 ([%v.1 (tvector 10 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.2 (tfield)] [%n.3 (tfield)])
                 (tfield)
              (- #f (+ #f %a.2 %n.3) (safe-cast (tfield) (tunsigned 1) 1)))
            (safe-cast (tfield) (tunsigned 17) 17)
            %v.1))))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a, n): Field => a + n - 1,"
      "              17,"
      "              v);"
      "}"
      )
    (returns
      (program
        (circuit %sum.0 ([%v.1 (tvector 10 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.2 (tfield)] [%n.3 (tfield)])
                 (tfield)
              (- #f (+ #f %a.2 %n.3) (safe-cast (tfield) (tunsigned 1) 1)))
            (safe-cast (tfield) (tunsigned 17) 17)
            %v.1))))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a, n) => a + n - 1,"
      "              17,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#f "Uint<0..18>" #f "Field")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a, n) => a + n - 1 as Uint<32>,"
      "              v[0],"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#f "Field" #f "Uint<32>")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10, Uint<32>>) : Uint<32> {"
      "  return fold((a: Uint<64>, n: Uint<32>): Uint<32> => a + n as Uint<32>,"
      "              0,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#t "Uint<64>" #t "Uint<32>")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10, Uint<64>>) : Uint<32> {"
      "  return fold((a: Uint<32>, n: Uint<64>): Uint<64> => a + n as Uint<64>,"
      "              0,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#t "Uint<32>" #t "Uint<64>")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a: Field, b: Field, n: Field): Field => a + n,"
      "              0,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<0..1>" "Field") ("Field" "Field" "Field"))))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a: Field, n: Opaque<'string'>): Field => a + n,"
      "              0,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<0..1>" "Field") ("Field" "Opaque<\"string\">"))))
    )

  (test
    '(
      "export circuit sum(v: Vector<10, Uint<8>>) : Field {"
      "  return fold((a, n): Uint<8> => a + n - 1 as Uint<8>,"
      "              256,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#f "Uint<0..257>" #t "Uint<8>")))
    )

  (test
    '(
      "export circuit sum(v: Vector<10, Field>) : Field {"
      "  return fold((a, n): Field => a + n - 1,"
      "              true,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#f "Boolean" #t "Field")))
    )

  (test
    '(
      "module M<#n> {"
      "  export circuit sum(v: Vector<n, Field>) : Field {"
      "    return fold((a: Field, n: Field): Field => a + n,"
      "                0,"
      "                v);"
      "  }"
      "}"
      "import M<10>;"
      "import M<20>;"
      "circuit foo(u: Vector<10, Field>): Field { return sum(u); }"
      "circuit foo(w: Vector<20, Field>): Field { return sum(w); }"
      "export circuit bar(u: Vector<10, Field>, v: Vector<20, Field>): Field {"
      "  return foo(u) + foo(v);"
      "}"
      )
    (returns
      (program
        (circuit %sum.0 ([%v.1 (tvector 20 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.2 (tfield)] [%n.3 (tfield)])
                 (tfield)
              (+ #f %a.2 %n.3))
            (safe-cast (tfield) (tunsigned 0) 0)
            %v.1))
        (circuit %sum.4 ([%v.5 (tvector 10 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.6 (tfield)] [%n.7 (tfield)])
                 (tfield)
              (+ #f %a.6 %n.7))
            (safe-cast (tfield) (tunsigned 0) 0)
            %v.5))
        (circuit %foo.8 ([%u.9 (tvector 10 (tfield))])
             (tfield)
          (call %sum.4 %u.9))
        (circuit %foo.10 ([%w.11 (tvector 20 (tfield))])
             (tfield)
          (call %sum.0 %w.11))
        (circuit %bar.12 ([%u.13 (tvector 10 (tfield))]
                          [%v.14 (tvector 20 (tfield))])
             (tfield)
          (+ #f (call %foo.8 %u.13) (call %foo.10 %v.14)))))
  )

  (test
    '(
      "module M<#n> {"
      "  export witness foo(v: Vector<n, Field>) : Field;"
      "}"
      "import M<10>;"
      "import M<20>;"
      "export circuit bar10(u: Vector<10, Field>): Field { return foo(u); }"
      "export circuit bar20(w: Vector<20, Field>): Field { return foo(w); }"
      )
    (returns
      (program
        (witness %foo.0 ([%v.1 (tvector 20 (tfield))]) (tfield))
        (witness %foo.2 ([%v.3 (tvector 10 (tfield))]) (tfield))
        (circuit %bar10.4 ([%u.5 (tvector 10 (tfield))])
             (tfield)
          (call %foo.2 %u.5))
        (circuit %bar20.6 ([%w.7 (tvector 20 (tfield))])
             (tfield)
          (call %foo.0 %w.7))))
  )

  (test
    '(
      "export circuit foo(v: Vector<10, Field>): Boolean {"
      "  return fold((b: Boolean, x: Field): Boolean => {"
      "                const y = x;"
      "                {"
      "                  const x = y * 1;"
      "                  return b && x == 0;"
      "                }"
      "              },"
      "              true,"
      "              v);"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%v.1 (tvector 10 (tfield))])
             (tboolean)
          (fold
            (circuit ([%b.2 (tboolean)] [%x.3 (tfield)])
                 (tboolean)
              (let* ([[%y.4 (tfield)] %x.3])
                (let* ([[%x.5 (tfield)] (* #f
                                           %y.4
                                           (safe-cast (tfield) (tunsigned 1)
                                             1))])
                  (if %b.2
                      (== %x.5 (safe-cast (tfield) (tunsigned 0) 0))
                      #f))))
            #t
            %v.1))))
  )

  (test
    '(
      "export circuit foo(v: Vector<10, Field>): Boolean {"
      "  return fold((b: Boolean, x: Field): Boolean => {"
      "                const y = x;"
      "                {"
      "                  const z = b && x == 0;"
      "                  const x = y * 1;"
      "                  return z;"
      "                }"
      "              },"
      "              true,"
      "              v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 34" "identifier ~s might be referenced before it is assigned" (x)))
  )

  (test
    '(
      "export circuit C(x: Field, y: Field): Field {"
      "  if (x == 2) return y + 7;"
      "  assert(!(x == 2), 'oops 1');"
      "  if (x == 3) {"
      "    if (y == 0)"
      "       assert(y == 0, 'oops 2');"
      "    else"
      "       return y + 9;"
      "  }"
      "  assert(!(x == 3), 'oops 3');"
      "  return y + 11;"
      "}"
      )
    (returns
      (program
        (circuit %C.0 ([%x.1 (tfield)] [%y.2 (tfield)])
             (tfield)
          (if (== %x.1 (safe-cast (tfield) (tunsigned 2) 2))
              (+ #f %y.2 (safe-cast (tfield) (tunsigned 7) 7))
              (seq
                (assert
                  (if (== %x.1 (safe-cast (tfield) (tunsigned 2) 2)) #f #t)
                  "oops 1")
                (if (== %x.1 (safe-cast (tfield) (tunsigned 3) 3))
                    (if (== %y.2 (safe-cast (tfield) (tunsigned 0) 0))
                        (seq
                          (assert
                            (== %y.2 (safe-cast (tfield) (tunsigned 0) 0))
                            "oops 2")
                          (assert
                            (if (== %x.1 (safe-cast (tfield) (tunsigned 3) 3))
                                #f
                                #t)
                            "oops 3")
                          (+ #f %y.2 (safe-cast (tfield) (tunsigned 11) 11)))
                        (+ #f %y.2 (safe-cast (tfield) (tunsigned 9) 9)))
                    (seq
                      (assert
                        (if (== %x.1 (safe-cast (tfield) (tunsigned 3) 3))
                            #f
                            #t)
                        "oops 3")
                      (+ #f
                         %y.2
                         (safe-cast (tfield) (tunsigned 11) 11)))))))))
  )

  (test
    `(
      "witness foo(b: Boolean, x: Field): Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold(foo, true, v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (witness %foo.0 ([%b.1 (tboolean)] [%x.2 (tfield)])
             (tboolean))
        (circuit %X$C.3 ([%v.4 (tvector 0 (tfield))])
             (tboolean)
          (fold
            %foo.0
            #t
            %v.4))
        (circuit %Y$C.5 ([%v.6 (tvector 1 (tfield))])
             (tboolean)
          (fold
            %foo.0
            #t
            %v.6))
        (circuit %Z$C.7 ([%v.8 (tvector 2 (tfield))])
             (tboolean)
          (fold
            %foo.0
            #t
            %v.8))))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold((b: Boolean, x: Field): Boolean => b && x == 0,"
      "                true,"
      "                v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (circuit %X$C.0 ([%v.1 (tvector 0 (tfield))])
             (tboolean)
          (fold
            (circuit ([%b.2 (tboolean)] [%x.3 (tfield)])
                 (tboolean)
              (if %b.2 (== %x.3 (safe-cast (tfield) (tunsigned 0) 0)) #f))
            #t
            %v.1))
        (circuit %Y$C.4 ([%v.5 (tvector 1 (tfield))])
             (tboolean)
          (fold
            (circuit ([%b.6 (tboolean)] [%x.7 (tfield)])
                 (tboolean)
              (if %b.6 (== %x.7 (safe-cast (tfield) (tunsigned 0) 0)) #f))
            #t
            %v.5))
        (circuit %Z$C.8 ([%v.9 (tvector 2 (tfield))])
             (tboolean)
          (fold
            (circuit ([%b.10 (tboolean)] [%x.11 (tfield)])
                 (tboolean)
              (if %b.10 (== %x.11 (safe-cast (tfield) (tunsigned 0) 0)) #f))
            #t
            %v.9))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    return map(foo, v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %X$C.2 ([%v.3 (tvector 0 (tfield))])
             (tvector 0 (tboolean))
          (map %foo.0 %v.3))
        (circuit %Y$C.4 ([%v.5 (tvector 1 (tfield))])
             (tvector 1 (tboolean))
          (map %foo.0 %v.5))
        (circuit %Z$C.6 ([%v.7 (tvector 2 (tfield))])
             (tvector 2 (tboolean))
          (map %foo.0 %v.7))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    return map((x: Field): Boolean => foo(x + 1),"
      "               v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %X$C.2 ([%v.3 (tvector 0 (tfield))])
             (tvector 0 (tboolean))
          (map
            (circuit ([%x.4 (tfield)])
                 (tboolean)
              (call %foo.0 (+ #f %x.4 (safe-cast (tfield) (tunsigned 1) 1))))
            %v.3))
        (circuit %Y$C.5 ([%v.6 (tvector 1 (tfield))])
             (tvector 1 (tboolean))
          (map
            (circuit ([%x.7 (tfield)])
                 (tboolean)
              (call %foo.0 (+ #f %x.7 (safe-cast (tfield) (tunsigned 1) 1))))
            %v.6))
        (circuit %Z$C.8 ([%v.9 (tvector 2 (tfield))])
             (tvector 2 (tboolean))
          (map
            (circuit ([%x.10 (tfield)])
                 (tboolean)
              (call %foo.0
                (+ #f %x.10 (safe-cast (tfield) (tunsigned 1) 1))))
            %v.9))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return W<B>(S(q)); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (witness %W.0 ([%x.1 (tboolean)]) (tboolean))
        (witness %W.2 ([%x.3 (tfield)]) (tboolean))
        (witness %W.4 ([%x.5 (tboolean)]) (tfield))
        (witness %W.6 ([%x.7 (tfield)]) (tfield))
        (circuit %S.8 ([%q.9 (tboolean)]) (tboolean) %q.9)
        (circuit %S.10 ([%q.11 (tfield)]) (tfield) %q.11)
        (circuit %T.12 ([%q.13 (tboolean)])
             (tboolean)
          (call %W.0 (call %S.8 %q.13)))
        (circuit %T.14 ([%q.15 (tfield)])
             (tboolean)
          (call %W.2 (call %S.10 %q.15)))
        (circuit %T.16 ([%q.17 (tboolean)])
             (tfield)
          (call %W.4 (call %S.8 %q.17)))
        (circuit %T.18 ([%q.19 (tfield)])
             (tfield)
          (call %W.6 (call %S.10 %q.19)))
        (circuit %foo1.20 ([%x.21 (tfield)])
             (tboolean)
          (call %T.14 %x.21))
        (circuit %foo2.22 ([%x.23 (tfield)])
             (tfield)
          (call %T.18 %x.23))
        (circuit %foo3.24 ([%x.25 (tboolean)])
             (tboolean)
          (call %T.12 %x.25))
        (circuit %foo4.26 ([%x.27 (tboolean)])
             (tfield)
          (call %T.16 %x.27))))
    )

  (test
    `(
      "export circuit foo(n: Field): [] {"
      "  if (n) return;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "expected test to have type Boolean, received ~a" ("Field")))
    )

  (test
    '(
      "module A {"
      "  export enum Names { bill, sally, fred, george }"
      "}"
      "import A;"
      "module M<T> {"
      "  export circuit enumid(x: T): T {"
      "    return x;"
      "  }"
      "}"
      "import M<Names>;"
      "export circuit foo(x: Names): Boolean {"
      "  return x == Names.bill;"
      "}"
      "export circuit rats(): Boolean {"
      "  return foo(Names.bill);"
      "}"
      "export circuit mice(): Boolean {"
      "  return foo(enumid(Names.george));"
      "}"
      )
    (returns
      (program
        (circuit %enumid.0 ([%x.1 (tenum Names
                                    bill
                                    sally
                                    fred
                                    george)])
             (tenum Names bill sally fred george)
          %x.1)
        (circuit %foo.2 ([%x.3 (tenum Names
                                 bill
                                 sally
                                 fred
                                 george)])
             (tboolean)
          (== %x.3
              (enum-ref (tenum Names bill sally fred george) bill)))
        (circuit %rats.4 ()
             (tboolean)
          (call %foo.2
            (enum-ref (tenum Names bill sally fred george) bill)))
        (circuit %mice.5 ()
             (tboolean)
          (call %foo.2
            (call %enumid.0
              (enum-ref (tenum Names bill sally fred george) george))))))
    )

  (test
    '(
      "module A {"
      "  enum Names { bill, sally, fred, george, }"
      "}"
      "import A;"
      "module M<T> {"
      "  export circuit enumid(x: T): T {"
      "    return x;"
      "  }"
      "}"
      "import M<Names>;"
      "export circuit foo(x: Names): Boolean {"
      "  return x == Names.bill;"
      "}"
      "export circuit rats(): Boolean {"
      "  return foo(Names.bill);"
      "}"
      "export circuit mice(): Boolean {"
      "  return foo(enumid(Names.george));"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 10" "unbound identifier ~s" (Names)))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "export circuit foo(x: Names): Boolean {"
      "  return x == 1;"
      "}"
      "export circuit rats(): Boolean {"
      "  return foo(Names.bill);"
      "}"
      "export circuit mice(): Boolean {"
      "  return foo(Names.george);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "incompatible types ~a and ~a for equality operator" ("Enum<Names, bill, sally, fred, george>" "Uint<1>")))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "export circuit foo(x: Names): Boolean {"
      "  return x == Names.bill;"
      "}"
      "export circuit rats(): Boolean {"
      "  return foo(Names.bill);"
      "}"
      "export circuit mice(): Boolean {"
      "  return foo(6);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 10" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        (Uint<0..7>)\n      declared argument types for function at line 2 char 1:\n        (Enum<Names, bill, sally, fred, george>)" #f)))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "export circuit foo(x: Field) : Names {"
      "  return x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Field" "Enum<Names, bill, sally, fred, george>" "circuit foo")))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "export circuit foo() : Names {"
      "  return Names.trudy;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 15" "enum ~s has no field named ~s" (Names trudy)))
    )

  (test
    '(
      "export circuit foo() : Vector<2, Bytes<80>> {"
      "  const x = [pad(80, 'hello!'), pad(80, 'four score and seven years ago our fathers brought forth')];"
      "  const y = [pad(80, 'four score and seven years ago our fathers brought forth'), pad(80, 'hello!')];"
      "  assert(x == y, 'oops');"
      "  return x;"
      "}"
    )
    (returns
      (program
        (circuit %foo.0 ()
             (tvector 2 (tbytes 80))
          (let* ([[%x.1 (ttuple (tbytes 80) (tbytes 80))]
                  (tuple
                    #vu8(104 101 108 108 111 33 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0)
                    #vu8(102 111 117 114 32 115 99 111 114 101 32 97 110 100 32
                         115 101 118 101 110 32 121 101 97 114 115 32 97 103
                         111 32 111 117 114 32 102 97 116 104 101 114 115 32 98
                         114 111 117 103 104 116 32 102 111 114 116 104 0 0 0 0
                         0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))])
            (let* ([[%y.2 (ttuple (tbytes 80) (tbytes 80))]
                    (tuple
                      #vu8(102 111 117 114 32 115 99 111 114 101 32 97 110 100
                           32 115 101 118 101 110 32 121 101 97 114 115 32 97
                           103 111 32 111 117 114 32 102 97 116 104 101 114 115
                           32 98 114 111 117 103 104 116 32 102 111 114 116 104
                           0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                      #vu8(104 101 108 108 111 33 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                           0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                           0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                           0 0 0 0 0 0 0))])
              (seq (assert (== %x.1 %y.2) "oops") %x.1))))))
    )

  (test
    '(
      "export circuit foo(arg: Bytes<20>) : Field { return arg as Field; }"
      )
    (returns
      (program
        (circuit %foo.0 ([%arg.1 (tbytes 20)])
             (tfield)
          (cast-from-bytes (tfield) 20 %arg.1)))))

  (test
    '(
      "export circuit foo(arg: Field) : Bytes<20> { return arg as Bytes<20>; }"
      )
    (returns
      (program
        (circuit %foo.0 ([%arg.1 (tfield)])
             (tbytes 20)
          (field->bytes 20 %arg.1))))
    )

  (test
    '(
      "export circuit baz(b1: Field) : Bytes<10> { return (b1 == b1) as Bytes<10>; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 52" "cannot cast from type ~a to type ~a" ("Boolean" "Bytes<10>")))
    )

  (test
    '(
      "export circuit baz(b: Boolean) : Field { return !(!b && b || b && b) as Field; }"
      )
    (returns
      (program
        (circuit %baz.0 ([%b.1 (tboolean)])
             (tfield)
          (if (if (if (if (if %b.1 #f #t) %b.1 #f)
                      #t
                      (if %b.1 %b.1 #f))
                  #f
                  #t)
              (safe-cast (tfield) (tunsigned 1) 1)
              (safe-cast (tfield) (tunsigned 0) 0)))))
    )

  (test
    '(
      "enum E { a, b, c }"
      "export circuit baz(b: E) : Field { return E.b as Field; }"
      )
    (returns
      (program
        (circuit %baz.0 ([%b.1 (tenum E a b c)])
             (tfield)
          (cast-from-enum (tfield) (tenum E a b c)
            (enum-ref (tenum E a b c) b)))))
    )

  (test
    '(
      "export circuit baz(x: Field) : Boolean { return x + 1 as Boolean; }"
      )
    (returns
      (program
        (circuit %baz.0 ([%x.1 (tfield)])
             (tboolean)
          (if (== (+ #f %x.1 (safe-cast (tfield) (tunsigned 1) 1))
                  (safe-cast (tfield) (tunsigned 0) 0))
              #f
              #t))))
    )

  (test
    '(
      "witness foo1(): [];"
      "witness foo2(): [];"
      "export circuit bar() : Boolean { return foo1() == foo2(); }"
      )
    (returns
      (program
        (witness %foo1.0 () (ttuple))
        (witness %foo2.1 () (ttuple))
        (circuit %bar.2 ()
             (tboolean)
          (== (call %foo1.0) (call %foo2.1)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1.read();"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %field1.0 (Counter))
        (circuit %foo.1 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (ledger-call read %field1.0)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "witness merkle_path_root(foo: Foo): MerkleTreeDigest;"
      ""
      "ledger field1: Map<Field, Foo>;"
      "ledger field2: HistoricMerkleTree<10, Foo>;"
      "ledger field3: Boolean;"
      ""
      "export circuit foo(n: Field, foo: Foo): Boolean {"
      "  field3.write(field1.lookup(n).baz);"
      "  const q = field1.lookup(n);"
      "  assert(!(q == default<Foo>), 'entry not found');"
      "  return field2.checkRoot(merkle_path_root(q));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (witness %merklePathRoot.1 ([%foo.2 (tstruct Foo
                                                (bar (tbytes 32))
                                                (baz (tboolean)))])
             (tstruct MerkleTreeDigest (field (tfield))))
        (public-ledger-declaration
          %field1.3
          (Map
            (tfield)
            (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
        (public-ledger-declaration
          %field2.4
          (HistoricMerkleTree
            10
            (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
        (public-ledger-declaration %field3.5 (__compact_Cell (tboolean)))
        (circuit %foo.6 ([%n.7 (tfield)]
                         [%foo.8 (tstruct Foo
                                   (bar (tbytes 32))
                                   (baz (tboolean)))])
             (tboolean)
          (seq
            (ledger-call write
              %field3.5
              (elt-ref (ledger-call lookup %field1.3 %n.7) baz 1))
            (let* ([[%q.9 (tstruct Foo
                            (bar (tbytes 32))
                            (baz (tboolean)))]
                    (ledger-call lookup %field1.3 %n.7)])
              (seq
                (assert
                  (if (== %q.9
                          (default
                            (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
                      #f
                      #t)
                  "entry not found")
                (ledger-call checkRoot
                  %field2.4
                  (call %merklePathRoot.1 %q.9))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "ledger field0: Counter;"
      "ledger field1: Boolean;"
      "ledger field2: Set<Field>;"
      "ledger field3: Map<Field, Foo>;"
      "ledger field4: List<Foo>;"
      "ledger field5: MerkleTree<10, Foo>;"
      "ledger field6: HistoricMerkleTree<10, Field>;"
      "ledger field7: QualifiedCoinInfo;"
      "ledger field8: Set<QualifiedCoinInfo>;"
      "ledger field9: Map<Field, QualifiedCoinInfo>;"
      "ledger field10: List<QualifiedCoinInfo>;"
      ""
      "export circuit foo(x: Field, ci: CoinInfo): Boolean {"
      "  field0.resetToDefault();"
      "  field0.increment(5);"
      "  field0.decrement(2);"
      "  assert(field0.lessThan(4), 'oops 1');"
      "  field1.write(true);"
      "  const b = field1.read();"
      "  field2.resetToDefault();"
      "  assert(field2.isEmpty(), 'oops 2a');"
      "  assert(field2.size() == 0, 'oops 2b');"
      "  assert(!field2.member(x), 'oops 2c');"
      "  field2.insert(x);"
      "  field2.insert(x + 1);"
      "  field2.insert(x + 2);"
      "  field2.insert(x + 1);"
      "  assert(field2.size() == 3, 'oops 2d');"
      "  field2.remove(x + 1);"
      "  assert(field2.size() == 2, 'oops 2e');"
      "  assert(!field2.isEmpty(), 'oops 2f');"
      "  assert(field2.member(x), 'oops 2g');"
      "  assert(!field2.member(x + 1), 'oops 2h');"
      "  assert(field2.member(x + 2), 'oops 2i');"
      "  field3.resetToDefault();"
      "  field4.resetToDefault();"
      "  field5.resetToDefault();"
      "  field6.resetToDefault();"
      "  field7.writeCoin(ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  const q2 = field7.read();"
      "  field8.resetToDefault();"
      "  field8.insertCoin(ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  assert(field8.member(q2), 'oops 8a');"
      "  field8.remove(q2);"
      "  assert(!field8.member(q2), 'oops 8b');"
      "  field9.resetToDefault();"
      "  field9.insertCoin(x, ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  const q4 = field9.lookup(x);"
      "  field10.resetToDefault();"
      "  field10.pushFrontCoin(ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  const q5 = field10.head();"
      "  return b;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %right.1 ([%value.2 (tstruct ContractAddress
                                       (bytes (tbytes 32)))])
             (tstruct Either
               (is_left (tboolean))
               (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
               (right (tstruct ContractAddress (bytes (tbytes 32)))))
          (new
            (tstruct Either
              (is_left (tboolean))
              (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
              (right (tstruct ContractAddress (bytes (tbytes 32)))))
            #f
            (default (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
            %value.2))
        (public-ledger-declaration %field0.3 (Counter))
        (public-ledger-declaration %field1.4 (__compact_Cell (tboolean)))
        (public-ledger-declaration %field2.5 (Set (tfield)))
        (public-ledger-declaration
          %field3.6
          (Map
            (tfield)
            (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
        (public-ledger-declaration
          %field4.7
          (List (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
        (public-ledger-declaration
          %field5.8
          (MerkleTree
            10
            (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
        (public-ledger-declaration
          %field6.9
          (HistoricMerkleTree 10 (tfield)))
        (public-ledger-declaration
          %field7.10
          (__compact_Cell
            (tstruct QualifiedCoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned 340282366920938463463374607431768211455))
              (mt_index (tunsigned 18446744073709551615)))))
        (public-ledger-declaration
          %field8.11
          (Set
            (tstruct QualifiedCoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned 340282366920938463463374607431768211455))
              (mt_index (tunsigned 18446744073709551615)))))
        (public-ledger-declaration
          %field9.12
          (Map
            (tfield)
            (tstruct QualifiedCoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned 340282366920938463463374607431768211455))
              (mt_index (tunsigned 18446744073709551615)))))
        (public-ledger-declaration
          %field10.13
          (List
            (tstruct QualifiedCoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned 340282366920938463463374607431768211455))
              (mt_index (tunsigned 18446744073709551615)))))
        (circuit %foo.14 ([%x.15 (tfield)]
                          [%ci.16 (tstruct CoinInfo
                                    (nonce (tbytes 32))
                                    (color (tbytes 32))
                                    (value (tunsigned
                                             340282366920938463463374607431768211455)))])
             (tboolean)
          (seq
            (ledger-call resetToDefault %field0.3)
            (ledger-call increment
              %field0.3
              (safe-cast (tunsigned 65535) (tunsigned 5) 5))
            (ledger-call decrement
              %field0.3
              (safe-cast (tunsigned 65535) (tunsigned 2) 2))
            (assert
              (ledger-call lessThan
                %field0.3
                (safe-cast (tunsigned 18446744073709551615) (tunsigned 4) 4))
              "oops 1")
            (ledger-call write %field1.4 #t)
            (let* ([[%b.17 (tboolean)] (ledger-call read %field1.4)])
              (seq
                (ledger-call resetToDefault %field2.5)
                (assert (ledger-call isEmpty %field2.5) "oops 2a")
                (assert
                  (== (ledger-call size %field2.5)
                      (safe-cast (tunsigned 18446744073709551615)
                                 (tunsigned 0)
                        0))
                  "oops 2b")
                (assert
                  (if (ledger-call member %field2.5 %x.15) #f #t)
                  "oops 2c")
                (ledger-call insert %field2.5 %x.15)
                (ledger-call insert
                  %field2.5
                  (+ #f %x.15 (safe-cast (tfield) (tunsigned 1) 1)))
                (ledger-call insert
                  %field2.5
                  (+ #f %x.15 (safe-cast (tfield) (tunsigned 2) 2)))
                (ledger-call insert
                  %field2.5
                  (+ #f %x.15 (safe-cast (tfield) (tunsigned 1) 1)))
                (assert
                  (== (ledger-call size %field2.5)
                      (safe-cast (tunsigned 18446744073709551615)
                                 (tunsigned 3)
                        3))
                  "oops 2d")
                (ledger-call remove
                  %field2.5
                  (+ #f %x.15 (safe-cast (tfield) (tunsigned 1) 1)))
                (assert
                  (== (ledger-call size %field2.5)
                      (safe-cast (tunsigned 18446744073709551615)
                                 (tunsigned 2)
                        2))
                  "oops 2e")
                (assert
                  (if (ledger-call isEmpty %field2.5) #f #t)
                  "oops 2f")
                (assert (ledger-call member %field2.5 %x.15) "oops 2g")
                (assert
                  (if (ledger-call member
                        %field2.5
                        (+ #f %x.15 (safe-cast (tfield) (tunsigned 1) 1)))
                      #f
                      #t)
                  "oops 2h")
                (assert
                  (ledger-call member
                    %field2.5
                    (+ #f %x.15 (safe-cast (tfield) (tunsigned 2) 2)))
                  "oops 2i")
                (ledger-call resetToDefault %field3.6)
                (ledger-call resetToDefault %field4.7)
                (ledger-call resetToDefault %field5.8)
                (ledger-call resetToDefault %field6.9)
                (ledger-call writeCoin
                  %field7.10
                  %ci.16
                  (call %right.1 (ledger-call self %kernel.0)))
                (let* ([[%q2.18 (tstruct QualifiedCoinInfo
                                  (nonce (tbytes 32))
                                  (color (tbytes 32))
                                  (value (tunsigned
                                           340282366920938463463374607431768211455))
                                  (mt_index (tunsigned 18446744073709551615)))]
                        (ledger-call read %field7.10)])
                  (seq
                    (ledger-call resetToDefault %field8.11)
                    (ledger-call insertCoin
                      %field8.11
                      %ci.16
                      (call %right.1 (ledger-call self %kernel.0)))
                    (assert (ledger-call member %field8.11 %q2.18) "oops 8a")
                    (ledger-call remove %field8.11 %q2.18)
                    (assert
                      (if (ledger-call member %field8.11 %q2.18) #f #t)
                      "oops 8b")
                    (ledger-call resetToDefault %field9.12)
                    (ledger-call insertCoin
                      %field9.12
                      %x.15
                      %ci.16
                      (call %right.1 (ledger-call self %kernel.0)))
                    (let* ([[%q4.19 (tstruct QualifiedCoinInfo
                                      (nonce (tbytes 32))
                                      (color (tbytes 32))
                                      (value (tunsigned
                                               340282366920938463463374607431768211455))
                                      (mt_index (tunsigned
                                                  18446744073709551615)))]
                            (ledger-call lookup %field9.12 %x.15)])
                      (seq
                        (ledger-call resetToDefault %field10.13)
                        (ledger-call pushFrontCoin
                          %field10.13
                          %ci.16
                          (call %right.1 (ledger-call self %kernel.0)))
                        (let* ([[%q5.20 (tstruct Maybe
                                          (is_some (tboolean))
                                          (value (tstruct QualifiedCoinInfo
                                                   (nonce (tbytes 32))
                                                   (color (tbytes 32))
                                                   (value (tunsigned
                                                            340282366920938463463374607431768211455))
                                                   (mt_index (tunsigned
                                                               18446744073709551615)))))]
                                (ledger-call head %field10.13)])
                          %b.17)))))))))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  for (const i of [3, 2, 1]) i + 1;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ()
             (ttuple)
          (seq
            (fold
              (circuit ([%t.1 (ttuple)] [%i.2 (tunsigned 3)])
                   (ttuple)
                (seq
                  (seq
                    (+ 3
                       (safe-cast (tunsigned 4) (tunsigned 3) %i.2)
                       (safe-cast (tunsigned 4) (tunsigned 1) 1))
                    (tuple))
                  %t.1))
              (tuple)
              (tuple 3 2 1))
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(v: Vector<10, Boolean>): [] {"
      "  for (const i of v) !i;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%v.1 (tvector 10 (tboolean))])
             (ttuple)
          (seq
            (fold
              (circuit ([%t.2 (ttuple)] [%i.3 (tboolean)])
                   (ttuple)
                (seq (seq (if %i.3 #f #t) (tuple)) %t.2))
              (tuple)
              %v.1)
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger x: Counter;"
      "export circuit foo(v: Vector<10, Boolean>): [] {"
      "  for (const i of v) if (i) x += 1;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %x.0 (Counter))
        (circuit %foo.1 ([%v.2 (tvector 10 (tboolean))])
             (ttuple)
          (seq
            (fold
              (circuit ([%t.3 (ttuple)] [%i.4 (tboolean)])
                   (ttuple)
                (seq
                  (seq
                    (if %i.4
                        (ledger-call increment
                          %x.0
                          (safe-cast (tunsigned 65535) (tunsigned 1) 1))
                        (tuple))
                    (tuple))
                  %t.3))
              (tuple)
              %v.2)
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  for (const i of 3..7) i + 1;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ()
             (ttuple)
          (seq
            (fold
              (circuit ([%t.1 (ttuple)] [%i.2 (tunsigned 6)])
                   (ttuple)
                (seq
                  (seq
                    (+ 3
                       (safe-cast (tunsigned 7) (tunsigned 6) %i.2)
                       (safe-cast (tunsigned 7) (tunsigned 1) 1))
                    (tuple))
                  %t.1))
              (tuple)
              (tuple 3 4 5 6))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger x: Counter;"
      "export circuit foo(): [] {"
      "  for (const i of 3..7) x += i;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %x.0 (Counter))
        (circuit %foo.1 ()
             (ttuple)
          (seq
            (fold
              (circuit ([%t.2 (ttuple)] [%i.3 (tunsigned 6)])
                   (ttuple)
                (seq
                  (seq
                    (ledger-call increment
                      %x.0
                      (safe-cast (tunsigned 65535) (tunsigned 6) %i.3))
                    (tuple))
                  %t.2))
              (tuple)
              (tuple 3 4 5 6))
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  for (const i of 7) !i;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "~a should be a vector, tuple, or Bytes but has type ~a" ("for 'of' expression" "Uint<3>")))
    )

  (test
    '(
      "export circuit foo(v: Bytes<10>): [] {"
      "  for (const i of v) !i;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 22" "expected test to have type Boolean, received ~a" ("Uint<8>")))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Uint<10>): Uint<10> {"
      "  return b ? x + 1023 as Uint<10> : 0;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tunsigned 1023)])
             (tunsigned 1023)
          (if %b.1
              (downcast-unsigned
                1023
                (+ 11
                   (safe-cast (tunsigned 2046) (tunsigned 1023) %x.2)
                   (safe-cast (tunsigned 2046) (tunsigned 1023) 1023)))
              (safe-cast (tunsigned 1023) (tunsigned 0) 0)))))
    )

  (test
    '(
      "export circuit foo(x: Uint<250>): Uint<250> {"
      "  return x * x as Uint<250>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "resulting value might exceed largest representable Uint value (for Field semantics, cast either operand to Field)" ()))
    )

  (test
    '(
      "export circuit foo(x: Uint<250>): Uint<250> {"
      "  return (x as Field) * x as Uint<250>;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%x.1 (tunsigned
                                 1809251394333065553493296640760748560207343510400633813116524750123642650623)])
             (tunsigned
               1809251394333065553493296640760748560207343510400633813116524750123642650623)
          (downcast-unsigned
            1809251394333065553493296640760748560207343510400633813116524750123642650623
            (* #f
               (safe-cast (tfield) (tunsigned
                                     1809251394333065553493296640760748560207343510400633813116524750123642650623)
                 %x.1)
               (safe-cast (tfield) (tunsigned
                                     1809251394333065553493296640760748560207343510400633813116524750123642650623)
                 %x.1))))))
    )

  (test
    '(
      "export circuit foo(b: Boolean): Uint<10> {"
      "  return b as Uint<10>;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tunsigned 1023)
          (if %b.1
              (safe-cast (tunsigned 1023) (tunsigned 1) 1)
              (safe-cast (tunsigned 1023) (tunsigned 0) 0)))))
    )

  (test
    '(
      "export circuit foo(b: Boolean): Uint<10> {"
      "  return b as Uint<1>;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tunsigned 1023)
          (safe-cast (tunsigned 1023) (tunsigned 1)
            (if %b.1 1 (safe-cast (tunsigned 1) (tunsigned 0) 0))))))
    )

  (test
    '(
      "export circuit foo(b: Boolean): Uint<10> {"
      "  return b as Uint<0>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 15" "Uint width ~d is not between 1 and the maximum Uint width ~d (inclusive)" (0 254)))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Field {"
      "  return b as Uint<1>;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned 1)
            (if %b.1 1 (safe-cast (tunsigned 1) (tunsigned 0) 0))))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Field {"
      "  return b as Uint<0>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 15" "Uint width ~d is not between 1 and the maximum Uint width ~d (inclusive)" (0 254)))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Field {"
      ,(format "  return b as Uint<~d>;" (unsigned-bits))
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned ,(- (expt 2 (unsigned-bits)) 1))
            (if %b.1
                (safe-cast (tunsigned ,(- (expt 2 (unsigned-bits)) 1))
                           (tunsigned 1)
                  1)
                (safe-cast (tunsigned ,(- (expt 2 (unsigned-bits)) 1))
                           (tunsigned 0)
                  0))))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Field {"
      ,(format "  return b as Uint<~d>;" (+ (unsigned-bits) 1))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 15" "Uint width ~d is not between 1 and the maximum Uint width ~d (inclusive)" (255 254)))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Field {"
      "  return b as Uint<0..2>;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned 1)
            (if %b.1 1 (safe-cast (tunsigned 1) (tunsigned 0) 0))))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Field {"
      "  return b as Uint<0..1>;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned 0)
            (if %b.1 (downcast-unsigned 0 1) 0)))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Field {"
      ,(format "  return b as Uint<0..~d>;" (+ (max-unsigned) 1))
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned
                       28948022309329048855892746252171976963317496166410141009864396001978282409983)
            (if %b.1
                (safe-cast (tunsigned
                             28948022309329048855892746252171976963317496166410141009864396001978282409983)
                           (tunsigned 1)
                  1)
                (safe-cast (tunsigned
                             28948022309329048855892746252171976963317496166410141009864396001978282409983)
                           (tunsigned 0)
                  0))))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Field {"
      ,(format "  return b as Uint<0 .. ~d>;" (+ (max-unsigned) 2))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 15" "range end\n    ~d\n  for Uint type exceeds the limit of\n    ~d (2^~d)\n  (the range end is exclusive)" (28948022309329048855892746252171976963317496166410141009864396001978282409985 28948022309329048855892746252171976963317496166410141009864396001978282409984 254)))
    )

  (test
    '(
      "export circuit foo(x: Uint<10>): Boolean {"
      "  return x as Boolean;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%x.1 (tunsigned 1023)])
             (tboolean)
          (if (== %x.1 (safe-cast (tunsigned 1023) (tunsigned 0) 0))
              #f
              #t))))
    )

  (test
    '(
      "export circuit foo(n: Uint<3>, v1: Vector<4, Field>, v2: Vector<4, Uint<8>>): Vector<4, Field> {"
      "  return map((x: Field, y: Uint<8>, z: Field): Field => x + y + z,"
      "             v1,"
      "             [n + 1, n * n, n + 10, n - 17],"
      "             v2);"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%n.1 (tunsigned 7)]
                         [%v1.2 (tvector 4 (tfield))]
                         [%v2.3 (tvector 4 (tunsigned 255))])
             (tvector 4 (tfield))
          (map
            (circuit ([%x.4 (tfield)]
                      [%y.5 (tunsigned 255)]
                      [%z.6 (tfield)])
                 (tfield)
              (+ #f
                 (+ #f %x.4 (safe-cast (tfield) (tunsigned 255) %y.5))
                 %z.6))
            %v1.2
            (tuple
              (+ 4
                 (safe-cast (tunsigned 8) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 8) (tunsigned 1) 1))
              (* 6
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1))
              (+ 5
                 (safe-cast (tunsigned 17) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 17) (tunsigned 10) 10))
              (seq
                (assert
                  (if (< (safe-cast (tunsigned 17) (tunsigned 7) %n.1) 17)
                      #f
                      #t)
                  "result of subtraction would be negative")
                (- 3 %n.1 (safe-cast (tunsigned 7) (tunsigned 17) 17))))
            %v2.3))))
    )

  (test
    '(
      "witness foo(x: Uint<5>): [];"
      "export circuit bar(a: Uint<4>, b: Uint<4>): [] {"
      "foo(a + b);"
      "}"
      )
    (returns
      (program
        (witness %foo.0 ([%x.1 (tunsigned 31)]) (ttuple))
        (circuit %bar.2 ([%a.3 (tunsigned 15)]
                         [%b.4 (tunsigned 15)])
             (ttuple)
          (seq
            (call %foo.0
              (safe-cast (tunsigned 31) (tunsigned 30)
                (+ 5
                   (safe-cast (tunsigned 30) (tunsigned 15) %a.3)
                   (safe-cast (tunsigned 30) (tunsigned 15) %b.4))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      "export circuit foo(): [] { return field2.write([1]); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 41" "expected ~:r argument of ~s to have type ~a but received ~a" (1 write "Field" "[Uint<1>]")))
    )

  (test
    '(
      "circuit bar(): [] { return foo(true); }"
      "export circuit foo(a: Field): [] { return; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 28" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        (Boolean)\n      declared argument types for function at line 2 char 1:\n        (Field)" #f)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(a : Uint<0..1>): Boolean { return a == 0; }"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %foo.0 ([%a.1 (tunsigned 0)])
             (tboolean)
          (== %a.1 0))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(a: Uint<0..1>): Boolean { return a == 0; }"
      "export circuit bar(b: Uint<32>): Boolean { return foo(b); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 51" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        (Uint<32>)\n      declared argument types for function at line 3 char 1:\n        (Uint<0..1>)" #f)))
    )

  (test
    '(
      "circuit transientHash<#n>(xs: Vector<n, Field>): Field;"
      "export circuit foo(): Field { return transientHash<1>([3]); }"
      )
    (returns
      (program
        (external %transientHash.0 ([%xs.2 (tvector 1 (tfield))]) (tfield))
        (circuit %foo.1 () (tfield)
          (call %transientHash.0
            (safe-cast
              (tvector 1 (tfield))
              (ttuple (tunsigned 3))
              (tuple 3))))))
    )

  (test
    '(
      "circuit persistentHash<a>(x: a): Bytes<32>;"
      "export circuit foo(x: Field): Bytes<32> { return persistentHash<Field>(x); }"
      )
    (returns
      (program
        (external %persistentHash.0 ([%x.1 (tfield)]) (tbytes 32))
        (circuit %foo.2 ([%x.3 (tfield)])
             (tbytes 32)
          (call %persistentHash.0 %x.3))))
    )

  (test
    '(
      "export circuit persistentHash<n>(x: Vector<n, Bytes<32>>): Bytes<32>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "cannot export ~s (~s) from the top level" (external persistentHash)))
    )

  (test
    '(
      "circuit persistentHash(x: Bytes<32>, y: Bytes<32>): Bytes<32>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared argument count ~s and expected argument count ~s for native ~s" (2 1 persistentHash)))
    )

  (test
    '(
      "circuit transientHash<#n>(x: Vector<n, Boolean>): Field;"
      "export circuit foo(): Field { return transientHash<1>([true]); }"
      )
    (returns
      (program
        (external %transientHash.0 ([%x.1 (tvector 1 (tboolean))])
             (tfield))
        (circuit %foo.2 ()
             (tfield)
          (call %transientHash.0 (tuple #t)))))
    )

  (test
    '(
      "circuit degradeToTransient<a>(x: a): Field;"
      "export circuit foo(): Field { return degradeToTransient<Field>([3]); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared type ~a and expected type ~a for ~:r argument of native ~s~@[ (~a)~]" ("Field" "Bytes<32>" 1 degradeToTransient #f)))
    )

  (test
    '(
      "circuit degradeToTransient<#n>(x: Vector<n, Boolean>): Field;"
      "export circuit foo(): Field { return degradeToTransient<1>([true]); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared type ~a and expected type ~a for ~:r argument of native ~s~@[ (~a)~]" ("Vector<1, Boolean>" "Bytes<32>" 1 degradeToTransient #f)))
    )

  (test
    '(
      "circuit transientHash<a>(x: a): Field;"
      "export circuit foo(): Field { return transientHash<Field>([3]); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 38" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (transientHash #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        ([Uint<2>])\n      declared argument types for function at line 1 char 1:\n        (Field)" #f)))
    )

  (test
    '(
      "circuit upgradeFromTransient(x: Field): Field;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared type ~a and expected type ~a for return value of native ~a~@[ (~a)~]" ("Field" "Bytes<32>" upgradeFromTransient #f)))
    )

  (test
    '(
      "circuit transientHash(x: Field, y: Field, z: Field): Field;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared argument count ~s and expected argument count ~s for native ~s" (3 1 transientHash)))
    )

  (test
    '(
      "circuit degradeToTransient<#n>(x: Bytes<n>): Bytes<n>;"
      "export circuit foo(): Bytes<30> { return degradeToTransient<32>([3]); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared type ~a and expected type ~a for return value of native ~a~@[ (~a)~]" ("Bytes<32>" "Field" degradeToTransient #f)))
    )

  (test
    '(
      "circuit persistentHash<#n>(x: Vector<n, Field>): Bytes<32>;"
      )
    (returns (program))
    )

  (test
    '(
      "circuit persistentHash<#n>(x: Vector<n, Field>): Bytes<32>;"
      "export circuit foo(): Bytes<32> { return persistentHash<1>([3]); }"
      )
    (returns
      (program
        (external %persistentHash.0 ([%x.1 (tvector 1 (tfield))])
             (tbytes 32))
        (circuit %foo.2 ()
             (tbytes 32)
          (call %persistentHash.0
            (safe-cast (tvector 1 (tfield))
                       (ttuple (tunsigned 3))
              (tuple 3))))))
    )

  (test
    '(
      "circuit degradeToTransient<#n>(x: Vector<n, Field>): Field;"
      "export circuit foo(): Bytes<32> { return degradeToTransient<1>([3]); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared type ~a and expected type ~a for ~:r argument of native ~s~@[ (~a)~]" ("Vector<1, Field>" "Bytes<32>" 1 degradeToTransient #f)))
    )

  (test
    '(
      "circuit upgradeFromTransient(x: Field): Field;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared type ~a and expected type ~a for return value of native ~a~@[ (~a)~]" ("Field" "Bytes<32>" upgradeFromTransient #f)))
    )

  (test
    '(
      "circuit degradeToTransient<a>(x: Field): Bytes<32>;"
      "export circuit foo(): Bytes<32> { return degradeToTransient<Bytes<32>>(42); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared type ~a and expected type ~a for ~:r argument of native ~s~@[ (~a)~]" ("Field" "Bytes<32>" 1 degradeToTransient #f)))
    )

  (test
    '(
      "circuit persistentHash<a>(x: a): Field;"
      "export circuit foo(): Field { return persistentHash<Bytes<32>>(42); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "mismatch between declared type ~a and expected type ~a for return value of native ~a~@[ (~a)~]" ("Field" "Bytes<32>" persistentHash #f)))
    )

  (test
    '(
      "export struct CurvePoint {"
      "  x: Field;"
      "  y: Field;"
      "}"
      "circuit ecAdd(x: Bytes<32>, y: CurvePoint): CurvePoint;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 1" "mismatch between declared type ~a and expected type ~a for ~:r argument of native ~s~@[ (~a)~]" ("Bytes<32>" "Struct<Field, Field>" 1 ecAdd #f)))
    )

  (test
    '(
      "export struct CurvePoint {"
      "  x: Field;"
      "  y: Field;"
      "}"
      "circuit ecAdd(x: CurvePoint, y: Boolean): CurvePoint;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 1" "mismatch between declared type ~a and expected type ~a for ~:r argument of native ~s~@[ (~a)~]" ("Boolean" "Struct<Field, Field>" 2 ecAdd #f)))
    )

  (test
    '(
      "export struct CurvePoint {"
      "  x: Field;"
      "  y: Field;"
      "}"
      "circuit ecAdd(x: CurvePoint, y: CurvePoint): Field;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 1" "mismatch between declared type ~a and expected type ~a for return value of native ~a~@[ (~a)~]" ("Field" "Struct<Field, Field>" ecAdd #f)))
    )

  #|
  ; the tests in this comment block should only be uncommented if the declaration of
  ; justfortesting is uncommented in midnight-natives.ss
  (test
    '(
      "export circuit justfortesting(x: Field, y: Field): Field;"
      )
    (returns
      (program
        (public-ledger-declaration
          (%kernel (Kernel))
          (constructor () (tuple)))
        (circuit %justfortesting.0 ((%x.1 (tfield)) (%y.2 (tfield))) (tfield))))
    )

  (test
    '(
      "export circuit justfortesting(x: Field, y: Boolean): Field;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "mismatch between declared type ~a and expected type ~a for ~:r argument of native ~s~@[ (~a)~]" ("Boolean" "A" 2 justfortesting "A previously matched to Field")))
    )

  (test
    '(
      "export circuit justfortesting(x: Field, y: Field): Bytes<32>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "mismatch between declared type ~a and expected type ~a for return value of native ~a~@[ (~a)~]" ("Bytes<32>" "A" justfortesting "A previously matched to Field")))
    )
  |#

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(c: CurvePoint): CurvePoint {"
      "  return ecAdd(c, ecMul(c, 3));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (external %ecAdd.1 ([%a.2 (tstruct CurvePoint
                                     (x (tfield))
                                     (y (tfield)))]
                             [%b.3 (tstruct CurvePoint
                                     (x (tfield))
                                     (y (tfield)))])
             (tstruct CurvePoint (x (tfield)) (y (tfield))))
        (external %ecMul.4 ([%a.5 (tstruct CurvePoint
                                     (x (tfield))
                                     (y (tfield)))]
                             [%b.6 (tfield)])
             (tstruct CurvePoint (x (tfield)) (y (tfield))))
        (circuit %foo.7 ([%c.8 (tstruct CurvePoint
                                 (x (tfield))
                                 (y (tfield)))])
             (tstruct CurvePoint (x (tfield)) (y (tfield)))
          (call %ecAdd.1
            %c.8
            (call %ecMul.4 %c.8 (safe-cast (tfield) (tunsigned 3) 3))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Uint<0..5>): Uint<0..16> {"
      "  const t = x + 1;"
      "  return t;"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %foo.1 ([%x.2 (tunsigned 4)])
             (tunsigned 15)
          (safe-cast (tunsigned 15) (tunsigned 5)
            (let* ([[%t.3 (tunsigned 5)] (+ 3
                                            (safe-cast (tunsigned 5) (tunsigned 4)
                                              %x.2)
                                            (safe-cast (tunsigned 5) (tunsigned 1)
                                              1))])
              %t.3)))))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "circuit foo<A>(): Names {"
      "  return A.bill;"
      "}"
      "export circuit bar(): Names {"
      "  return foo<Names>();"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ()
             (tenum Names bill sally fred george)
          (enum-ref (tenum Names bill sally fred george) bill))
        (circuit %bar.1 ()
             (tenum Names bill sally fred george)
          (call %foo.0))))
    )

  (test
    '(
      "export circuit foo(arg: Bytes<20>) : Field { return arg as Field; }"
     )
    (returns
      (program
        (circuit %foo.0 ([%arg.1 (tbytes 20)])
             (tfield)
          (cast-from-bytes (tfield) 20 %arg.1))))
    )

  (test
    '(
      "circuit foo<a>(arg: a) : a { return arg; }"
      "export circuit bar1(x: Boolean): Boolean { return !foo<Boolean>(x); }"
      "export circuit bar2(x: Boolean): Boolean { return foo<Boolean>(x); }"
      "export circuit bar3(x: Field): Field { return foo<Field>(x) + 1; }"
     )
    (returns
      (program
        (circuit %foo.0 ([%arg.1 (tboolean)]) (tboolean) %arg.1)
        (circuit %foo.2 ([%arg.3 (tfield)]) (tfield) %arg.3)
        (circuit %bar1.4 ([%x.5 (tboolean)])
             (tboolean)
          (if (call %foo.0 %x.5) #f #t))
        (circuit %bar2.6 ([%x.7 (tboolean)])
             (tboolean)
          (call %foo.0 %x.7))
        (circuit %bar3.8 ([%x.9 (tfield)])
             (tfield)
          (+ #f
             (call %foo.2 %x.9)
             (safe-cast (tfield) (tunsigned 1) 1)))))
    )

  (test
    '(
      "module M<b, #n> {"
      "  export circuit foo<a>(x: a, y: Vector<n, b>) : Field { return x as Field; }"
      "  export circuit bar1(x: Bytes<10>): Field { return foo<Bytes<10>>(x, [1, 2, 3]) + 1; }"
      "  export circuit bar2(x: Bytes<10>): Field { return foo<Bytes<10>>(x, [1, 2, 3]) + 2; }"
      "  export circuit bar3(x: Bytes<11>): Field { return foo<Bytes<11>>(x, [1, 2, 3]) + 3; }"
      "}"
      "import M<Field, 3>;"
      "export { bar1, bar2, bar3 }"
     )
    (returns
      (program
        (circuit %foo.0 ([%x.1 (tbytes 10)]
                         [%y.2 (tvector 3 (tfield))])
             (tfield)
          (cast-from-bytes (tfield) 10 %x.1))
        (circuit %foo.3 ([%x.4 (tbytes 11)]
                         [%y.5 (tvector 3 (tfield))])
             (tfield)
          (cast-from-bytes (tfield) 11 %x.4))
        (circuit %bar1.6 ([%x.7 (tbytes 10)])
             (tfield)
          (+ #f
             (call %foo.0
               %x.7
               (safe-cast (tvector 3 (tfield))
                          (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                 (tuple 1 2 3)))
             (safe-cast (tfield) (tunsigned 1) 1)))
        (circuit %bar2.8 ([%x.9 (tbytes 10)])
             (tfield)
          (+ #f
             (call %foo.0
               %x.9
               (safe-cast (tvector 3 (tfield))
                          (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                 (tuple 1 2 3)))
             (safe-cast (tfield) (tunsigned 2) 2)))
        (circuit %bar3.10 ([%x.11 (tbytes 11)])
             (tfield)
          (+ #f
             (call %foo.3
               %x.11
               (safe-cast (tvector 3 (tfield))
                          (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                 (tuple 1 2 3)))
             (safe-cast (tfield) (tunsigned 3) 3)))))
    )

  (test
    '(
      "struct S<a> { p: a, q: Field }"
      "module M<#n, b> {"
      "  export circuit foo<a, b>(x: a, y: b) : a { return x; }"
      "  export circuit bar1(x: Bytes<10>): S<Bytes<10>> { return S<Bytes<10>>{p: foo<Bytes<10>, Vector<n, b>>(x, [1, 2, 3]), q: 1}; }"
      "  export circuit bar2(x: Bytes<10>): S<Bytes<10>> { return S<Bytes<10>>{p: foo<Bytes<10>, Vector<n, b>>(x, [1, 2, 3]), q: 2}; }"
      "  export circuit bar3(x: Bytes<11>): S<Bytes<11>> { return S<Bytes<11>>{p: foo<Bytes<11>, Vector<n, b>>(x, [1, 2, 3]), q: 3}; }"
      "}"
      "import M<3, Field>;"
      "export { bar1, bar2, bar3 }"
     )
    (returns
      (program
        (circuit %foo.0 ([%x.1 (tbytes 10)]
                         [%y.2 (tvector 3 (tfield))])
             (tbytes 10)
          %x.1)
        (circuit %foo.3 ([%x.4 (tbytes 11)]
                         [%y.5 (tvector 3 (tfield))])
             (tbytes 11)
          %x.4)
        (circuit %bar1.6 ([%x.7 (tbytes 10)])
             (tstruct S (p (tbytes 10)) (q (tfield)))
          (new (tstruct S (p (tbytes 10)) (q (tfield)))
            (call %foo.0
              %x.7
              (safe-cast (tvector 3 (tfield))
                         (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                (tuple 1 2 3)))
            (safe-cast (tfield) (tunsigned 1) 1)))
        (circuit %bar2.8 ([%x.9 (tbytes 10)])
             (tstruct S (p (tbytes 10)) (q (tfield)))
          (new (tstruct S (p (tbytes 10)) (q (tfield)))
            (call %foo.0
              %x.9
              (safe-cast (tvector 3 (tfield))
                      (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                (tuple 1 2 3)))
            (safe-cast (tfield) (tunsigned 2) 2)))
        (circuit %bar3.10 ([%x.11 (tbytes 11)])
             (tstruct S (p (tbytes 11)) (q (tfield)))
          (new (tstruct S (p (tbytes 11)) (q (tfield)))
            (call %foo.3
              %x.11
              (safe-cast (tvector 3 (tfield))
                         (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                (tuple 1 2 3)))
            (safe-cast (tfield) (tunsigned 3) 3)))))
    )

  (test
    '(
      "struct Q<a, n> { x: a, y: Vector<n, a> }"
      "module M<QQ, n, b> {"
      "  export circuit foo<a, b>(x: a, y: b) : Field { return x as Field; }"
      "  export circuit bar1(x: Bytes<10>): Field {"
      "    const q = Q<Field, 3>{x: 23, y: [1, 2, 3]};"
      "    return foo<Bytes<10>, Vector<n, QQ<b, 3>>>(x, [q, q, q]) + 1;"
      "  }"
      "  export circuit bar2(x: Bytes<10>): Field {"
      "    const q = Q<Field, 3>{x: 23, y: [1, 2, 3]};"
      "    return foo<Bytes<10>, Vector<n, QQ<b, 3>>>(x, [q, q, q]) + 2;"
      "  }"
      "  export circuit bar3(x: Bytes<11>): Field {"
      "    const q = Q<Field, 3>{x: 23, y: [1, 2, 3]};"
      "    return foo<Bytes<11>, Vector<n, QQ<b, 3>>>(x, [q, q, q]) + 3;"
      "  }"
      "}"
      "import M<Q, 3, Field>;"
      "export { bar1, bar2, bar3 }"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 17 char 10" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 2 Q)))
    )

  (test
    '(
      "struct Q<a, n> { x: a, y: Vector<n, a> }"
      "module M<QQ, n, b> {"
      "  export circuit foo<a, b>(x: a, y: b) : a { return x; }"
      "  export circuit bar1(x: Bytes<10>): QQ<Bytes<10>, n> {"
      "    return foo<QQ<Bytes<10>, n>, Vector<n, b>>(QQ<Bytes<10>, n>{ x: x, y: [x, x, x] }, [1, 2, 3]);"
      "  }"
      "  export circuit bar2(x: Bytes<10>): QQ<Bytes<10>, n> {"
      "    return foo<QQ<Bytes<10>, n>, Vector<n, b>>(QQ<Bytes<10>, n>{ x: x, y: [x, x, x] }, [4, 5, 6]);"
      "  }"
      "  export circuit bar3(x: Bytes<11>): QQ<Bytes<11>, n> {"
      "    return foo<QQ<Bytes<11>, n>, Vector<n, b>>(QQ<Bytes<11>, n>{ x: x, y: [x, x, x] }, [7, 8, 9]);"
      "  }"
      "}"
      "import M<Q, 3, Field>;"
      "export { bar1, bar2, bar3 }"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 14 char 10" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (0 2 Q)))
    )

  (test
    '(
      "struct S<a> { p: a, q: Field }"
      "circuit foo<a>(x: a) : a { return x; }"
      "export circuit bar1(x: Opaque<'frob'>): S<Opaque<'frob'>> { return S<Opaque<'frob'>>{ p: foo<Opaque<'frob'>>(x), q: 1 }; }"
      "export circuit bar2(x: Opaque<'frob'>): S<Opaque<'frob'>> { return S<Opaque<'frob'>>{ p: foo<Opaque<'frob'>>(x), q: 2 }; }"
      "export circuit bar3(x: Opaque<'string'>): S<Opaque<'string'>> { return S<Opaque<'string'>>{ p: foo<Opaque<'string'>>(x), q: 3 }; }"
     )
    (returns
      (program
        (circuit %foo.0 ([%x.1 (topaque "frob")])
             (topaque "frob")
          %x.1)
        (circuit %foo.2 ([%x.3 (topaque "string")])
             (topaque "string")
          %x.3)
        (circuit %bar1.4 ([%x.5 (topaque "frob")])
             (tstruct S (p (topaque "frob")) (q (tfield)))
          (new (tstruct S (p (topaque "frob")) (q (tfield)))
            (call %foo.0 %x.5)
            (safe-cast (tfield) (tunsigned 1) 1)))
        (circuit %bar2.6 ([%x.7 (topaque "frob")])
             (tstruct S (p (topaque "frob")) (q (tfield)))
          (new (tstruct S (p (topaque "frob")) (q (tfield)))
            (call %foo.0 %x.7)
            (safe-cast (tfield) (tunsigned 2) 2)))
        (circuit %bar3.8 ([%x.9 (topaque "string")])
             (tstruct S (p (topaque "string")) (q (tfield)))
          (new (tstruct S (p (topaque "string")) (q (tfield)))
            (call %foo.2 %x.9)
            (safe-cast (tfield) (tunsigned 3) 3)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger mapmap: Map<Boolean, Map<Boolean, Field>>;"
      ""
      "export circuit foo(): Field {"
      "  return 0;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %mapmap.1
          (Map (tboolean) (Map (tboolean) (tfield))))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 0) 0))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger mapmap: Map<Boolean, Map<Boolean, Field>>;"
      ""
      "export circuit foo(): Field {"
      "  return mapmap.lookup(true).lookup(false);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %mapmap.1
          (Map (tboolean) (Map (tboolean) (tfield))))
        (circuit %foo.2 ()
             (tfield)
          (ledger-call lookup (ledger-call lookup %mapmap.1 #t) #f))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger mapmap: Map<Boolean, Map<Boolean, Counter>>;"
      ""
      "export circuit foo(): Field {"
      "  mapmap.lookup(true).lookup(false) += 11;"
      "  mapmap.lookup(true).lookup(false) -= 6;"
      "  return mapmap.lookup(true).lookup(false);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %mapmap.1
          (Map (tboolean) (Map (tboolean) (Counter))))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (seq
              (ledger-call increment
                (ledger-call lookup (ledger-call lookup %mapmap.1 #t) #f)
                (safe-cast (tunsigned 65535) (tunsigned 11) 11))
              (ledger-call decrement
                (ledger-call lookup (ledger-call lookup %mapmap.1 #t) #f)
                (safe-cast (tunsigned 65535) (tunsigned 6) 6))
              (ledger-call read
                (ledger-call lookup
                  (ledger-call lookup %mapmap.1 #t)
                  #f)))))))
    )

  (test ;; this must return an error since it doesn't have a full chain (look example above). the read comes from syntactic sugar in const t1 = mapmap;
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger mapmap: Map<Boolean, Map<Boolean, Field>>;"
      ""
      "export circuit foo(): Field {"
      "  const t1 = mapmap;"
      "  const t2 = t1.lookup(true);"
      "  const t3 = t2.lookup(false);"
      "  return t3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 14" "incomplete chain of ledger indirects: final result must be a regular type, but received ADT type ~a" ("Map<Boolean, Map<Boolean, Field>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "export circuit foo(): Field {"
      "  field1.insert(true, default<Counter>);"
      "  field1.lookup(true).increment(1);"
      "  return field1.lookup(true).read();"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %field1.1
          (Map (tboolean) (Counter)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (seq
              (ledger-call insert %field1.1 #t (default (Counter)))
              (ledger-call increment
                (ledger-call lookup %field1.1 #t)
                (safe-cast (tunsigned 65535) (tunsigned 1) 1))
              (ledger-call read (ledger-call lookup %field1.1 #t)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "export circuit foo(): Field {"
      "  field1.insert(true, default<Counter>);"
      "  field1.lookup(true) += 1;"
      "  return field1.lookup(true);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %field1.1
          (Map (tboolean) (Counter)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (seq
              (ledger-call insert %field1.1 #t (default (Counter)))
              (ledger-call increment
                (ledger-call lookup %field1.1 #t)
                (safe-cast (tunsigned 65535) (tunsigned 1) 1))
              (ledger-call read (ledger-call lookup %field1.1 #t)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "export circuit foo(): Field {"
      "  const q = default<Counter>;"
      "  field1.insert(true, q);"
      "  field1.lookup(true) += 1;"
      "  return field1.lookup(true);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %field1.1
          (Map (tboolean) (Counter)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (let* ([[%q.3 (Counter)] (default (Counter))])
              (seq
                (ledger-call insert %field1.1 #t %q.3)
                (ledger-call increment
                  (ledger-call lookup %field1.1 #t)
                  (safe-cast (tunsigned 65535) (tunsigned 1) 1))
                (ledger-call read (ledger-call lookup %field1.1 #t))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, MerkleTree<3, Field>>;"
      ""
      "export circuit foo(): Boolean {"
      "  const q: MerkleTree<3, Field> = default<MerkleTree<3, Field>>;"
      "  return field1.lookup(true).isFull();"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %field1.1
          (Map (tboolean) (MerkleTree 3 (tfield))))
        (circuit %foo.2 ()
             (tboolean)
          (let* ([[%q.3 (MerkleTree 3 (tfield))]
                  (default (MerkleTree 3 (tfield)))])
            (ledger-call isFull (ledger-call lookup %field1.1 #t))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "export circuit foo(): Field {"
      "  const q: Counter = default<Counter>;"
      "  field1.insert(true, q);"
      "  field1.lookup(true) += 1;"
      "  return field1.lookup(true);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %field1.1
          (Map (tboolean) (Counter)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (let* ([[%q.3 (Counter)] (default (Counter))])
              (seq
                (ledger-call insert %field1.1 #t %q.3)
                (ledger-call increment
                  (ledger-call lookup %field1.1 #t)
                  (safe-cast (tunsigned 65535) (tunsigned 1) 1))
                (ledger-call read (ledger-call lookup %field1.1 #t))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, MerkleTree<3, Field>>;"
      ""
      "export circuit foo(): Boolean {"
      "  const q: MerkleTree<3, Boolean> = default<MerkleTree<3, Field>>;"
      "  return field1.lookup(true).isFull();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("MerkleTree<3, Field>" "MerkleTree<3, Boolean>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, MerkleTree<3, Field>>;"
      ""
      "export circuit foo(): Boolean {"
      "  const q: MerkleTree<5, Boolean> = default<MerkleTree<3, Field>>;"
      "  return field1.lookup(true).isFull();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("MerkleTree<3, Field>" "MerkleTree<5, Boolean>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, MerkleTree<3, Field>>;"
      ""
      "export circuit foo(): Boolean {"
      "  const q: MerkleTree<3, 3> = default<MerkleTree<3, Field>>;"
      "  return field1.lookup(true).isFull();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 26" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("non-ADT type" "size" value_type "<standard library>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, MerkleTree<3, Field>>;"
      ""
      "export circuit foo(): Boolean {"
      "  const q: MerkleTree<Boolean, Boolean> = default<MerkleTree<3, Field>>;"
      "  return field1.lookup(true).isFull();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
        irritants: '("testfile.compact line 6 char 23" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("size" "type" nat "<standard library>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  import CompactStandardLibrary;"
      "  export { kernel };"
      "}"
      "import M prefix $;"
      "ledger kernelA: Kernel;"
      "ledger kernelB: Kernel;"
      "export circuit foo(): Vector<4, ContractAddress> {"
      "  return [kernel.self(), $kernel.self(), kernelA.self(), kernelB.self()];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %kernelA.1 (Kernel))
        (public-ledger-declaration %kernelB.2 (Kernel))
        (circuit %foo.3 ()
             (tvector 4 (tstruct ContractAddress (bytes (tbytes 32))))
          (tuple
            (ledger-call self %kernel.0)
            (ledger-call self %kernel.0)
            (ledger-call self %kernelA.1)
            (ledger-call self %kernelB.2)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(): [] {"
      "  const k = default<List<Field>>;"
      "  k.write(3);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 3" "expected a ledger field name at base of ledger access" ()))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "constructor() { default<Kernel>; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 17" "default is not defined for ADT type Kernel" ()))
    )

  (test
    '(
      "export circuit A(x: Field, y: Field, z: Boolean, w: Boolean): Boolean {"
      "  return x == y == z != w;"
      "}"
      )
    (returns
      (program
        (circuit %A.0 ([%x.1 (tfield)]
                       [%y.2 (tfield)]
                       [%z.3 (tboolean)]
                       [%w.4 (tboolean)])
             (tboolean)
          (!= (== (== %x.1 %y.2) %z.3) %w.4))))
    )

  (test
    '(
      "export circuit A(x: Field, y: Field, z: Field, w: Boolean): Boolean {"
      "  return x == y == z != w;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "incompatible types ~a and ~a for equality operator" ("Boolean" "Field")))
    )

  (test
    '(
      "export circuit A(x: Uint<32>, y: Uint<32>, z: Uint<32>): Boolean {"
      "  return x < y == y <= z;"
      "}"
      )
    (returns
      (program
        (circuit %A.0 ([%x.1 (tunsigned 4294967295)]
                       [%y.2 (tunsigned 4294967295)]
                       [%z.3 (tunsigned 4294967295)])
             (tboolean)
          (== (< %x.1 %y.2) (<= %y.2 %z.3)))))
    )

  (test
    '(
      "witness P<D, E>(x: E): Vector<D, E>;"
      "export circuit foo(n: Field): Vector<2, Field> {"
      "  return P<2, Field, Boolean>(n);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (P "\n    one function is incomptable with the supplied generic values\n      supplied generic values:\n        <size 2, type Field, type Boolean>\n      declared generics for function at line 1 char 1:\n        <type, type>" #f #f)))
    )

  (test
    '(
      "circuit A<t>(x: Uint<0..t>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<11>(x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 10" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (A "\n    one function is incomptable with the supplied generic values\n      supplied generic values:\n        <size 11>\n      declared generics for function at line 1 char 1:\n        <type>" #f #f)))
    )

  (test
    '(
      "circuit A<t1, t2>(x: t1): t2 {"
      "  return x as t2;"
      "}"
      "circuit A<#t>(x: Uint<t..37>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<Boolean>(x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 10" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (A "\n    two functions are incomptable with the supplied generic values\n      supplied generic values:\n        <type Boolean>\n      declared generics for function at line 1 char 1:\n        <type, type>\n      declared generics for function at line 4 char 1:\n        <size>" #f #f)))
    )

  (test
    '(
      "circuit A<t1, t2>(x: t1): t2 {"
      "  return x as t2;"
      "}"
      "circuit A<#t>(x: Uint<t..37>): Field {"
      "  return x;"
      "}"
      "circuit A<t>(x: t): Field {"
      "  return x ? 1 : 0;"
      "}"
      "circuit A<t>(x: Uint<16>, y: t): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<Boolean>(x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 14 char 10" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (A "\n    two functions are incomptable with the supplied generic values\n      supplied generic values:\n        <type Boolean>\n      declared generics for function at line 1 char 1:\n        <type, type>\n      declared generics for function at line 4 char 1:\n        <size>" "\n    two functions are incompatible with the supplied argument types\n      supplied argument types:\n        (Uint<3>)\n      declared argument types for function at line 7 char 1:\n        (Boolean)\n      declared argument types for function at line 10 char 1:\n        (Uint<16>, Boolean)" #f)))
    )

  (test
    '(
      "circuit A<t1, t2>(x: t1): t2 {"
      "  return x as t2;"
      "}"
      "circuit A<#t>(x: Uint<t..37>): Field {"
      "  return x;"
      "}"
      "circuit A<t>(x: t): Field {"
      "  return x ? 1 : 0;"
      "}"
      "circuit A<t>(x: Uint<16>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<Boolean>(x);"
      "}"
      )
    (returns
      (program
        (circuit %A.0 ([%x.1 (tboolean)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned 1)
            (if %x.1 1 (safe-cast (tunsigned 1) (tunsigned 0) 0))))
        (circuit %A.2 ([%x.3 (tunsigned 65535)])
             (tfield)
          (safe-cast (tfield) (tunsigned 65535) %x.3))
        (circuit %B.4 ([%x.5 (tunsigned 7)])
             (tfield)
          (call %A.2 (safe-cast (tunsigned 65535) (tunsigned 7) %x.5)))))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a: a, b: b, c: c };"
      "}"
      )
    (returns
      (program
        (circuit %F.0 ([%a.1 (tunsigned 4294967295)]
                       [%b.2 (tboolean)]
                       [%c.3 (tbytes 8)])
             (tstruct S
               (a (tunsigned 4294967295))
               (b (tboolean))
               (c (tbytes 8)))
          (new (tstruct S
                 (a (tunsigned 4294967295))
                 (b (tboolean))
                 (c (tbytes 8)))
            %a.1
            %b.2
            %c.3))))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  return S { c: c, a: a, b: b };"
      "}"
      )
    (returns
      (program
        (circuit %F.0 ([%a.1 (tunsigned 4294967295)]
                       [%b.2 (tboolean)]
                       [%c.3 (tbytes 8)])
             (tstruct S
               (a (tunsigned 4294967295))
               (b (tboolean))
               (c (tbytes 8)))
          (new (tstruct S
                 (a (tunsigned 4294967295))
                 (b (tboolean))
                 (c (tbytes 8)))
            %a.1
            %b.2
            %c.3))))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a: a, b: b, a: a };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 26" "value of field ~s is already given at ~a" (a "line 3 char 14")))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a: a, b: b, c: c, d: 0 };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 32" "value for unrecognized field named ~a appears in creation syntax for ~a" (d "struct S<a: Uint<32>, b: Boolean, c: Bytes<8>>")))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a: a, c: c };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "value for element ~s is missing in creation syntax for ~a" (b "struct S<a: Uint<32>, b: Boolean, c: Bytes<8>>")))
    )

  (test
    '(
      "struct S1 { a: Boolean }"
      "struct S2 { x: Field }"
      "circuit F<S, T>(b: T): S {"
      "  return S { b };"
      "}"
      "export circuit G(): Boolean {"
      "  return F<S1, Boolean>(true).a && F<S2, Field>(7).x != 0;"
      "}"
      )
    (returns
      (program
        (circuit %F.0 ([%b.1 (tfield)])
             (tstruct S2 (x (tfield)))
          (new (tstruct S2 (x (tfield))) %b.1))
        (circuit %F.2 ([%b.3 (tboolean)])
             (tstruct S1 (a (tboolean)))
          (new (tstruct S1 (a (tboolean))) %b.3))
        (circuit %G.4 ()
             (tboolean)
          (if (elt-ref (call %F.2 #t) a 0)
              (!= (elt-ref
                    (call %F.0 (safe-cast (tfield) (tunsigned 7) 7))
                    x
                    0)
                  (safe-cast (tfield) (tunsigned 0) 0))
              #f))))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  const s1 = S { c: c, a: a, b: b };"
      "  const s2 = S { ...s1, b: true };"
      "  const s3 = S { ...s2, c: 'abcdefgh' };"
      "  return s3;"
      "}"
      )
    (returns
      (program
        (circuit %F.0 ([%a.1 (tunsigned 4294967295)]
                       [%b.2 (tboolean)]
                       [%c.3 (tbytes 8)])
             (tstruct S
               (a (tunsigned 4294967295))
               (b (tboolean))
               (c (tbytes 8)))
          (let* ([[%s1.4 (tstruct S
                           (a (tunsigned 4294967295))
                           (b (tboolean))
                           (c (tbytes 8)))]
                  (new (tstruct S
                         (a (tunsigned 4294967295))
                         (b (tboolean))
                         (c (tbytes 8)))
                    %a.1
                    %b.2
                    %c.3)])
            (let* ([[%s2.5 (tstruct S
                             (a (tunsigned 4294967295))
                             (b (tboolean))
                             (c (tbytes 8)))]
                    (new (tstruct S
                           (a (tunsigned 4294967295))
                           (b (tboolean))
                           (c (tbytes 8)))
                      (elt-ref %s1.4 a 0)
                      #t
                      (elt-ref %s1.4 c 2))])
              (let* ([[%s3.6 (tstruct S
                               (a (tunsigned 4294967295))
                               (b (tboolean))
                               (c (tbytes 8)))]
                      (new (tstruct S
                             (a (tunsigned 4294967295))
                             (b (tboolean))
                             (c (tbytes 8)))
                        (elt-ref %s2.5 a 0)
                        (elt-ref %s2.5 b 1)
                        #vu8(97 98 99 100 101 102 103 104))])
                %s3.6))))))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "struct T { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  const t = T { c: c, a: a, b: b };"
      "  const s = S { ...t };"
      "  return s;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 17" "the type of the spread structure:\n    ~a\n  does match the declared type of the structure to be created:\n    ~a" ("struct T<a: Uint<32>, b: Boolean, c: Bytes<8>>" "struct S<a: Uint<32>, b: Boolean, c: Bytes<8>>")))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  const s1 = S { c: c, a: a, b: b };"
      "  const s2 = S { ...s1, d: true };"
      "  return s2;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 25" "value for unrecognized field named ~a appears in creation syntax for ~a" (d "struct S<a: Uint<32>, b: Boolean, c: Bytes<8>>")))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a, b, c };"
      "}"
      )
    (returns
      (program
        (circuit %F.0 ([%a.1 (tunsigned 4294967295)]
                       [%b.2 (tboolean)]
                       [%c.3 (tbytes 8)])
             (tstruct S
               (a (tunsigned 4294967295))
               (b (tboolean))
               (c (tbytes 8)))
          (new (tstruct S
                 (a (tunsigned 4294967295))
                 (b (tboolean))
                 (c (tbytes 8)))
            %a.1
            %b.2
            %c.3))))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<16>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a + 1, c: c, b: !b };"
      "}"
      )
    (returns
      (program
        (circuit %F.0 ([%a.1 (tunsigned 65535)]
                       [%b.2 (tboolean)]
                       [%c.3 (tbytes 8)])
             (tstruct S
               (a (tunsigned 4294967295))
               (b (tboolean))
               (c (tbytes 8)))
          (new (tstruct S
                 (a (tunsigned 4294967295))
                 (b (tboolean))
                 (c (tbytes 8)))
            (safe-cast (tunsigned 4294967295)
                       (tunsigned 65536)
              (+ 17
                 (safe-cast (tunsigned 65536) (tunsigned 65535) %a.1)
                 (safe-cast (tunsigned 65536) (tunsigned 1) 1)))
            (if %b.2 #f #t)
            %c.3))))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a, c };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "value for element ~s is missing in creation syntax for ~a" (c "struct S<a: Uint<32>, b: Boolean, c: Bytes<8>>")))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a, b, c, 3 };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "more positional initializers (~d) supplied than the number of fields (~d) of ~a" (4 3 "struct S<a: Uint<32>, b: Boolean, c: Bytes<8>>")))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<16>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a + 1, c: c, !b };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 27" "positional initializer found after spread or named initializer in struct creation syntax" ()))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<16>, b: Boolean, c: Bytes<8>): S {"
      "  return S { ... S { a, b, c }, a: a + 1, b: !b };"
      "}"
      )
    (returns
      (program
        (circuit %F.0 ([%a.1 (tunsigned 65535)]
                       [%b.2 (tboolean)]
                       [%c.3 (tbytes 8)])
             (tstruct S
               (a (tunsigned 4294967295))
               (b (tboolean))
               (c (tbytes 8)))
          (let* ([[%t.4 (tstruct S
                          (a (tunsigned 4294967295))
                          (b (tboolean))
                          (c (tbytes 8)))]
                  (new (tstruct S
                         (a (tunsigned 4294967295))
                         (b (tboolean))
                         (c (tbytes 8)))
                    (safe-cast (tunsigned 4294967295) (tunsigned 65535) %a.1)
                    %b.2
                    %c.3)])
            (new (tstruct S
                   (a (tunsigned 4294967295))
                   (b (tboolean))
                   (c (tbytes 8)))
              (safe-cast (tunsigned 4294967295)
                         (tunsigned 65536)
                (+ 17
                   (safe-cast (tunsigned 65536) (tunsigned 65535) %a.1)
                   (safe-cast (tunsigned 65536) (tunsigned 1) 1)))
              (if %b.2 #f #t)
              (elt-ref %t.4 c 2))))))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<16>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a + 1, !b, b: b, c: c };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 25" "value of field ~s is already specified positionally at ~a" (b "line 3 char 21")))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<16>, b: Boolean, c: Bytes<8>): S {"
      "  return S { ... S { a, b, c }, a + 1, !b };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 33" "positional initializer found after spread or named initializer in struct creation syntax" ()))
    )

  (test
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<16>, b: Boolean, c: Bytes<8>): S {"
      "  return S { ... S { a, b, c }, b: !b, a + 1 };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 40" "positional initializer found after spread or named initializer in struct creation syntax" ()))
    )

  (test ;; the positional and named struct constructions cannot be combined.
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  return S { a, c: c };"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "value for element ~s is missing in creation syntax for ~a" (b "struct S<a: Uint<32>, b: Boolean, c: Bytes<8>>")))
    )

  (test ;; the positional syntax cannot be used with spreads.
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  const s1 = S { c: c, a: a, b: b };"
      "  const s2 = S { ...s1, b: true };"
      "  const s3 = S { ...s2, 'abcdefgh' };"
      "  return s3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 25" "positional initializer found after spread or named initializer in struct creation syntax" ()))
    )

  (test ;; spread must come before all elements.
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  const s1 = S { c: c, a: a, b: b };"
      "  const s2 = S { b: true, ...s1};"
      "  const s3 = S { ...s2, c: 'abcdefgh' };"
      "  return s3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 27" "spread initializer found after positional or named initializers in struct creation syntax" ()))
    )

  (test ;; correct use of spread.
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  const s1 = S { c: c, a: a, b: b };"
      "  const s2 = S { ...s1, b: true, c: 'abcdefgh' };"
      "  return s2;"
      "}"
      )
    (returns
      (program
        (circuit %F.0 ([%a.1 (tunsigned 4294967295)]
                       [%b.2 (tboolean)]
                       [%c.3 (tbytes 8)])
             (tstruct S
               (a (tunsigned 4294967295))
               (b (tboolean))
               (c (tbytes 8)))
          (let* ([[%s1.4 (tstruct S
                           (a (tunsigned 4294967295))
                           (b (tboolean))
                           (c (tbytes 8)))]
                  (new (tstruct S
                         (a (tunsigned 4294967295))
                         (b (tboolean))
                         (c (tbytes 8)))
                    %a.1
                    %b.2
                    %c.3)])
            (let* ([[%s2.5 (tstruct S
                             (a (tunsigned 4294967295))
                             (b (tboolean))
                             (c (tbytes 8)))]
                    (new (tstruct S
                           (a (tunsigned 4294967295))
                           (b (tboolean))
                           (c (tbytes 8)))
                      (elt-ref %s1.4 a 0)
                      #t
                      #vu8(97 98 99 100 101 102 103 104))])
              %s2.5)))))
    )

  (test ;; new cannot be used to construct a struct anymore.
    '(
      "struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }"
      "export circuit F(a: Uint<32>, b: Boolean, c: Bytes<8>): S {"
      "  const s1 = new S( a, b, c);"
      "  const s2 = S { ...s1, b: true, c: 'abcdefgh' };"
      "  return s2;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 18" "parse error: found ~a looking for~?" ("\"S\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("\",\"" "\";\"" "\"||\"" "\"&&\"" "\"==\"" "\"!=\"" "\"as\"" "\"+\"" "\"-\"" "\"*\"" "\"[\"" "\".\"" "\"?\"" "\"=\"" "\"+=\"" "\"-=\"" "\"<\"" "\"<=\"" "\">=\"" "\">\"" "\"(\"" "\"{\"" "a generic argument list"))))
    )

  (test
    '(
      "export circuit foo(n: Uint<3>, v1: Vector<4, Field>, v2: Vector<4, Uint<8>>): Vector<4, Field> {"
      "  return map("
      "    (x: Field, y: Uint<8>, z: Field): Field => {"
      "      return x + y + z;"
      "    },"
      "    v1,"
      "    [n + 1, n * n, n + 10, n - 17],"
      "    v2);"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%n.1 (tunsigned 7)]
                         [%v1.2 (tvector 4 (tfield))]
                         [%v2.3 (tvector 4 (tunsigned 255))])
             (tvector 4 (tfield))
          (map
            (circuit ([%x.4 (tfield)]
                      [%y.5 (tunsigned 255)]
                      [%z.6 (tfield)])
                 (tfield)
              (+ #f
                 (+ #f %x.4 (safe-cast (tfield) (tunsigned 255) %y.5))
                 %z.6))
            %v1.2
            (tuple
              (+ 4
                 (safe-cast (tunsigned 8) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 8) (tunsigned 1) 1))
              (* 6
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1))
              (+ 5
                 (safe-cast (tunsigned 17) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 17) (tunsigned 10) 10))
              (seq
                (assert
                  (if (< (safe-cast (tunsigned 17) (tunsigned 7) %n.1) 17)
                      #f
                      #t)
                  "result of subtraction would be negative")
                (- 3 %n.1 (safe-cast (tunsigned 7) (tunsigned 17) 17))))
            %v2.3))))
    )

  (test
    '(
      "export circuit foo(n: Uint<3>, v1: Vector<4, Field>, v2: Vector<4, Uint<8>>): Vector<4, Field> {"
      "  return map("
      "    (x: Field, y: Uint<8>, z: Field) => {"
      "      return x + y + z;"
      "    },"
      "    v1,"
      "    [n + 1, n * n, n + 10, n - 17],"
      "    v2);"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%n.1 (tunsigned 7)]
                         [%v1.2 (tvector 4 (tfield))]
                         [%v2.3 (tvector 4 (tunsigned 255))])
             (tvector 4 (tfield))
          (map
            (circuit ([%x.4 (tfield)]
                      [%y.5 (tunsigned 255)]
                      [%z.6 (tfield)])
                 (tfield)
              (+ #f
                 (+ #f %x.4 (safe-cast (tfield) (tunsigned 255) %y.5))
                 %z.6))
            %v1.2
            (tuple
              (+ 4
                 (safe-cast (tunsigned 8) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 8) (tunsigned 1) 1))
              (* 6
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1))
              (+ 5
                 (safe-cast (tunsigned 17) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 17) (tunsigned 10) 10))
              (seq
                (assert
                  (if (< (safe-cast (tunsigned 17) (tunsigned 7) %n.1) 17)
                      #f
                      #t)
                  "result of subtraction would be negative")
                (- 3 %n.1 (safe-cast (tunsigned 7) (tunsigned 17) 17))))
            %v2.3))))
    )

  (test
    '(
      "export circuit foo(n: Uint<3>, v1: Vector<4, Field>, v2: Vector<4, Uint<8>>): Vector<4, Field> {"
      "  return map("
      "    (x, y, z) => {"
      "      return x + y + z;"
      "    },"
      "    v1,"
      "    [n + 1, n * n, n + 10, n - 17],"
      "    v2);"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%n.1 (tunsigned 7)]
                         [%v1.2 (tvector 4 (tfield))]
                         [%v2.3 (tvector 4 (tunsigned 255))])
             (tvector 4 (tfield))
          (map
            (circuit ([%x.4 (tfield)]
                      [%y.5 (tunsigned 49)]
                      [%z.6 (tunsigned 255)])
                 (tfield)
              (+ #f
                 (+ #f %x.4 (safe-cast (tfield) (tunsigned 49) %y.5))
                 (safe-cast (tfield) (tunsigned 255) %z.6)))
            %v1.2
            (tuple
              (+ 4
                 (safe-cast (tunsigned 8) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 8) (tunsigned 1) 1))
              (* 6
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1))
              (+ 5
                 (safe-cast (tunsigned 17) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 17) (tunsigned 10) 10))
              (seq
                (assert
                  (if (< (safe-cast (tunsigned 17) (tunsigned 7) %n.1) 17)
                      #f
                      #t)
                  "result of subtraction would be negative")
                (- 3 %n.1 (safe-cast (tunsigned 7) (tunsigned 17) 17))))
            %v2.3))))
    )

  (test
    '(
      "export circuit foo(x: Field, y: Boolean): Field {"
      "  return ((a: Field, b) => a)(y, y);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Boolean" "Boolean") ("Field" "Undeclared"))))
    )

  (test
    '(
      "export circuit foo(b: Boolean): [] {"
      "  return b ? (() => { return; })() : 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "mismatch between type ~a and type ~a of condition branches" ("[]" "Uint<2>")))
    )

  (test
    '(
      "export circuit foo(b: Boolean): [] {"
      "  const x = [(() => { return; })()];"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%b.1 (tboolean)])
             (ttuple)
          (seq
            (let* ([[%x.2 (ttuple (ttuple))]
                    (tuple (call (circuit () (ttuple) (tuple))))])
              (tuple))
            (tuple)))))
    )

  (test
    '(
      "export circuit post(message: Field): [] {"
      "  message = 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "expected left-hand side of ~a to have an ADT type, received ~a" ("=" "Field")))
    )

  (test
    '(
      "export circuit post(message: Field): [] {"
      "  message += 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "expected left-hand side of ~a to have an ADT type, received ~a" ("+=" "Field")))
    )

  (test
    '(
      "export circuit post(message: Field): [] {"
      "  message -= 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "expected left-hand side of ~a to have an ADT type, received ~a" ("-=" "Field")))
    )

  (test
    '(
      "export circuit post(message: Field): Field {"
      "  return message.read();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "expected left-hand side of ~a to have an ADT or contract type, received ~a" ("." "Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Field): Field {"
      "  return transientHash(x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (transientHash "\n    one function is incomptable with the supplied generic values\n      supplied generic values:\n        <>\n      declared generics for function at <standard library>:\n        <type>" #f #f)))
    )

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (returns
       (program
         (circuit %foo.0 ([%x.1 (tfield)])
              (tfield)
           (* #f %x.1 (safe-cast (tfield) (tunsigned 2) 2)))))
     ))

  (test-group
    ((create-file "I.compact"
       '(
         "export circuit foo(x: Field): Field { return x * 2; }"
         ))
     (succeeds))
    ((create-file "M.compact"
       '(
         "module M {"
         "  include 'I';"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (returns
       (program
         (circuit %foo.0 ([%x.1 (tfield)])
              (tfield)
           (* #f %x.1 (safe-cast (tfield) (tunsigned 2) 2)))))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return bar(x * 2); }"
         "}"
         )))
    ((create-file "testfile.compact"
       '(
         "circuit bar(x: Field): Field { return x * 2; }"
         "import M;"
         "export { foo }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("M.compact line 2 char 48" "unbound identifier ~s" (bar)))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Boolean { return x * 2; }"
         "}"
         )))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("M.compact line 2 char 43" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Field" "Boolean" "circuit foo")))
     ))

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger fld: List<QualifiedCoinInfo>;"
      "export circuit bar(): QualifiedCoinInfo {"
      "  const coin = CoinInfo { nonce: pad(32,'a'), color: pad(32, 'b'), value: 73 };"
      "  const rcpnt = Either<ZswapCoinPublicKey,ContractAddress> { is_left: true, left: default<ZswapCoinPublicKey>, right: default<ContractAddress> };"
      "  fld.pushFrontCoin(coin, rcpnt);"
      "  assert(!fld.isEmpty(), 'oops empty');"
      "  assert(fld.length() == 1, 'oops length');"
      "  return fld.head().value;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %fld.1
          (List
            (tstruct QualifiedCoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned 340282366920938463463374607431768211455))
              (mt_index (tunsigned 18446744073709551615)))))
        (circuit %bar.2 ()
             (tstruct QualifiedCoinInfo
               (nonce (tbytes 32))
               (color (tbytes 32))
               (value (tunsigned 340282366920938463463374607431768211455))
               (mt_index (tunsigned 18446744073709551615)))
          (let* ([[%coin.3 (tstruct CoinInfo
                             (nonce (tbytes 32))
                             (color (tbytes 32))
                             (value (tunsigned
                                      340282366920938463463374607431768211455)))]
                  (new (tstruct CoinInfo
                         (nonce (tbytes 32))
                         (color (tbytes 32))
                         (value (tunsigned
                                  340282366920938463463374607431768211455)))
                    #vu8(97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0 0)
                    #vu8(98 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0 0)
                    (safe-cast (tunsigned 340282366920938463463374607431768211455)
                               (tunsigned 73)
                      73))])
            (let* ([[%rcpnt.4 (tstruct Either
                                (is_left (tboolean))
                                (left (tstruct ZswapCoinPublicKey
                                        (bytes (tbytes 32))))
                                (right (tstruct ContractAddress
                                         (bytes (tbytes 32)))))]
                    (new (tstruct Either
                           (is_left (tboolean))
                           (left (tstruct ZswapCoinPublicKey
                                   (bytes (tbytes 32))))
                           (right (tstruct ContractAddress
                                    (bytes (tbytes 32)))))
                      #t
                      (default
                        (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
                      (default
                        (tstruct ContractAddress (bytes (tbytes 32)))))])
              (seq
                (ledger-call pushFrontCoin %fld.1 %coin.3 %rcpnt.4)
                (assert
                  (if (ledger-call isEmpty %fld.1) #f #t)
                  "oops empty")
                (assert
                  (== (ledger-call length %fld.1)
                      (safe-cast (tunsigned 18446744073709551615)
                                 (tunsigned 1)
                        1))
                  "oops length")
                (elt-ref (ledger-call head %fld.1) value 1)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  struct QualifiedCoinInfo {"
      "    nonce: Bytes<32>;"
      "    color: Bytes<32>;"
      "    value: Uint<128>;"
      "    mt_index: Uint<64>;"
      "  }"
      "  export ledger fld: List<QualifiedCoinInfo>;"
      "  export circuit bar(): QualifiedCoinInfo {"
      "    const coin = CoinInfo { nonce: pad(32,'a'), color: pad(32, 'b'), value: 73 };"
      "    const rcpnt = Either<ZswapCoinPublicKey,ContractAddress> { is_left: true, left: default<ZswapCoinPublicKey>, right: default<ContractAddress> };"
      "    fld.pushFrontCoin(coin, rcpnt);"
      "    assert(!fld.isEmpty(), 'oops empty');"
      "    assert(fld.length() == 1, 'oops length');"
      "    return fld.head().value;"
      "  }"
      "}"
      "import M;"
      "export { bar }"
      )
    ; should produce same output as above, since M's definition of  QualifiedCoinInfo
    ; matches the one from the CompactStandardLibrary
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %fld.1
          (List
            (tstruct QualifiedCoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned 340282366920938463463374607431768211455))
              (mt_index (tunsigned 18446744073709551615)))))
        (circuit %bar.2 ()
             (tstruct QualifiedCoinInfo
               (nonce (tbytes 32))
               (color (tbytes 32))
               (value (tunsigned 340282366920938463463374607431768211455))
               (mt_index (tunsigned 18446744073709551615)))
          (let* ([[%coin.3 (tstruct CoinInfo
                             (nonce (tbytes 32))
                             (color (tbytes 32))
                             (value (tunsigned
                                      340282366920938463463374607431768211455)))]
                  (new (tstruct CoinInfo
                         (nonce (tbytes 32))
                         (color (tbytes 32))
                         (value (tunsigned
                                  340282366920938463463374607431768211455)))
                    #vu8(97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0 0)
                    #vu8(98 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0 0)
                    (safe-cast (tunsigned 340282366920938463463374607431768211455)
                               (tunsigned 73)
                      73))])
            (let* ([[%rcpnt.4 (tstruct Either
                                (is_left (tboolean))
                                (left (tstruct ZswapCoinPublicKey
                                        (bytes (tbytes 32))))
                                (right (tstruct ContractAddress
                                         (bytes (tbytes 32)))))]
                    (new (tstruct Either
                           (is_left (tboolean))
                           (left (tstruct ZswapCoinPublicKey
                                   (bytes (tbytes 32))))
                           (right (tstruct ContractAddress
                                    (bytes (tbytes 32)))))
                      #t
                      (default
                        (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
                      (default
                        (tstruct ContractAddress (bytes (tbytes 32)))))])
              (seq
                (ledger-call pushFrontCoin %fld.1 %coin.3 %rcpnt.4)
                (assert
                  (if (ledger-call isEmpty %fld.1) #f #t)
                  "oops empty")
                (assert
                  (== (ledger-call length %fld.1)
                      (safe-cast (tunsigned 18446744073709551615)
                                 (tunsigned 1)
                        1))
                  "oops length")
                (elt-ref (ledger-call head %fld.1) value 1)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export ledger fld: List<CoinInfo>;"
      "  export circuit bar(): QualifiedCoinInfo {"
      "    const coin = CoinInfo { nonce: pad(32,'a'), color: pad(32, 'b'), value: 73 };"
      "    const rcpnt = Either<ZswapCoinPublicKey,ContractAddress> { is_left: true, left: default<ZswapCoinPublicKey>, right: default<ContractAddress> };"
      "    fld.pushFrontCoin(coin, rcpnt);"
      "    assert(!fld.isEmpty(), 'oops empty');"
      "    assert(fld.length() == 1, 'oops length');"
      "    return fld.head().value;"
      "  }"
      "}"
      "import M;"
      "export { bar }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 8" "operation ~a undefined for ledger field type ~a" (pushFrontCoin "List<struct CoinInfo<nonce: Bytes<32>, color: Bytes<32>, value: Uint<128>>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  struct QualifiedCoinInfo { nonce: Bytes<16>, color: Bytes<16>, Value: Field }"
      "  export ledger fld: List<QualifiedCoinInfo>;"
      "  export circuit bar(): QualifiedCoinInfo {"
      "    const coin = CoinInfo { nonce: pad(32,'a'), color: pad(32, 'b'), value: 73 };"
      "    const rcpnt = Either<ZswapCoinPublicKey,ContractAddress> { is_left: true, left: default<ZswapCoinPublicKey>, right: default<ContractAddress> };"
      "    fld.pushFrontCoin(coin, rcpnt);"
      "    assert(!fld.isEmpty(), 'oops empty');"
      "    assert(fld.length() == 1, 'oops length');"
      "    return fld.head().value;"
      "  }"
      "}"
      "import M;"
      "export { bar }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 8" "operation ~a undefined for ledger field type ~a" (pushFrontCoin "List<struct QualifiedCoinInfo<nonce: Bytes<16>, color: Bytes<16>, Value: Field>>")))
    )

  (test
    '(
      "export ledger fld: Vector<3, Field>;"
      "export circuit bar(n: Uint<0..3>): Field {"
      "  return n == 0 ? fld[0] : n == 1 ? fld[1] : fld[2];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %fld.1
          (__compact_Cell (tvector 3 (tfield))))
        (circuit %bar.2 ([%n.3 (tunsigned 2)])
             (tfield)
          (if (== %n.3 (safe-cast (tunsigned 2) (tunsigned 0) 0))
              (tuple-ref (ledger-call read %fld.1) 0)
              (if (== %n.3 (safe-cast (tunsigned 2) (tunsigned 1) 1))
                  (tuple-ref (ledger-call read %fld.1) 1)
                  (tuple-ref (ledger-call read %fld.1) 2))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger fld: QualifiedCoinInfo;"
      "export circuit bar(coin: CoinInfo): [] {"
      "  fld.insertCoin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 6" "operation ~a undefined for ledger field type ~a" (insertCoin "struct QualifiedCoinInfo<nonce: Bytes<32>, color: Bytes<32>, value: Uint<128>, mt_index: Uint<64>>")))
    )

  (test
    '(
      "module M<T> {"
      "  export circuit foo(x: T): T { return x; }"
      "}"
      "import M<S>;"
      "struct S { x: Field }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 10" "unbound identifier ~s" (S)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger fld: QualifiedCoinInfo;"
      "export circuit bar(coin: CoinInfo): [] {"
      "  fld.writeCoin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %right.1 ([%value.2 (tstruct ContractAddress
                                       (bytes (tbytes 32)))])
             (tstruct Either
               (is_left (tboolean))
               (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
               (right (tstruct ContractAddress (bytes (tbytes 32)))))
          (new (tstruct Either
                 (is_left (tboolean))
                 (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
                 (right (tstruct ContractAddress (bytes (tbytes 32)))))
            #f
            (default (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
            %value.2))
        (public-ledger-declaration
          %fld.3
          (__compact_Cell
            (tstruct QualifiedCoinInfo
              (nonce (tbytes 32))
              (color (tbytes 32))
              (value (tunsigned 340282366920938463463374607431768211455))
              (mt_index (tunsigned 18446744073709551615)))))
        (circuit %bar.4 ([%coin.5 (tstruct CoinInfo
                                    (nonce (tbytes 32))
                                    (color (tbytes 32))
                                    (value (tunsigned
                                             340282366920938463463374607431768211455)))])
             (ttuple)
          (seq
            (ledger-call writeCoin
              %fld.3
              %coin.5
              (call %right.1 (ledger-call self %kernel.0)))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Vector<2, Field>>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(b, default<Map<Uint<16>, Vector<2, Field>>>);"
      "  field1.lookup(b).insert(n, default<Vector<2, Field>>);"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %field1.1
          (Map
            (tboolean)
            (Map (tunsigned 65535) (tvector 2 (tfield)))))
        (circuit %init.2 ([%b.3 (tboolean)]
                          [%n.4 (tunsigned 65535)])
             (ttuple)
          (seq
            (ledger-call insert
              %field1.1
              %b.3
              (default (Map (tunsigned 65535) (tvector 2 (tfield)))))
            (ledger-call insert
              (ledger-call lookup %field1.1 %b.3)
              %n.4
              (default (tvector 2 (tfield))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger fld: Map<Boolean, Field>;"
      "export circuit foo(b: Boolean): [] {"
      "  fld.insert(b, b ? default<Uint<16>> : default<Uint<32>>);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %fld.1 (Map (tboolean) (tfield)))
        (circuit %foo.2 ([%b.3 (tboolean)])
             (ttuple)
          (seq
            (ledger-call insert
              %fld.1
              %b.3
              (safe-cast (tfield)
                         (tunsigned 4294967295)
                (if %b.3
                    (safe-cast (tunsigned 4294967295)
                               (tunsigned 65535)
                      (default (tunsigned 65535)))
                    (default (tunsigned 4294967295)))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger fld: Map<Boolean, Field>;"
      "export circuit foo(b: Boolean): [] {"
      "  fld.insert(b, b ? default<Uint<16>> : default<Uint<32>>);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %fld.1 (Map (tboolean) (tfield)))
        (circuit %foo.2 ([%b.3 (tboolean)])
             (ttuple)
          (seq
            (ledger-call insert
              %fld.1
              %b.3
              (safe-cast (tfield)
                         (tunsigned 4294967295)
                (if %b.3
                    (safe-cast (tunsigned 4294967295)
                               (tunsigned 65535)
                      (default (tunsigned 65535)))
                    (default (tunsigned 4294967295)))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct S { x: Boolean }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, S>>;"
      ""
      "export circuit foo(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(b).lookup(n) = default<S>;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 30" "expected left-hand side of = to have an ADT type, received ~a" ("struct S<x: Boolean>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct S { x: Boolean }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, S>>;"
      ""
      "export circuit foo(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(b).lookup(n) += 7;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 30" "expected left-hand side of += to have an ADT type, received ~a" ("struct S<x: Boolean>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct S { x: Boolean }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, S>>;"
      ""
      "export circuit foo(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(b).lookup(n) -= 7;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 30" "expected left-hand side of -= to have an ADT type, received ~a" ("struct S<x: Boolean>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M<T> {"
      "  export ledger fld: T;"
      "}"
      "import M<Counter> prefix M1$;"
      "import M<Counter> prefix M2$;"
      "import M<Set<Field>> prefix M3$;"
      "import M<Field> prefix M4$;"
      "import M<Map<Uint<0..10>, Map<Uint<8>, List<Boolean>>>> prefix M5$;"
      "import M<Map<Uint<0..10>, Map<Uint<8>, List<Boolean>>>> prefix M6$;"
      "export circuit foo(): Vector<5, Field> {"
      "  M1$fld += 1;"
      "  M2$fld += 2;"
      "  M5$fld.insert(3, default<Map<Uint<8>, List<Boolean>>>);"
      "  M5$fld.lookup(3).insert(4, default<List<Boolean>>);"
      "  M5$fld.lookup(3).lookup(4).pushFront(true);"
      "  return [M1$fld, M2$fld, M3$fld.size(), M4$fld, M6$fld.lookup(3).lookup(4).head().value as Field];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %fld.1 (Counter))
        (public-ledger-declaration %fld.2 (Set (tfield)))
        (public-ledger-declaration %fld.3 (__compact_Cell (tfield)))
        (public-ledger-declaration
          %fld.4
          (Map (tunsigned 9) (Map (tunsigned 255) (List (tboolean)))))
        (circuit %foo.5 ()
             (tvector 5 (tfield))
          (safe-cast (tvector 5 (tfield))
                     (ttuple
                       (tunsigned 18446744073709551615)
                       (tunsigned 18446744073709551615)
                       (tunsigned 18446744073709551615) (tfield) (tfield))
            (seq
              (ledger-call increment
                %fld.1
                (safe-cast (tunsigned 65535) (tunsigned 1) 1))
              (ledger-call increment
                %fld.1
                (safe-cast (tunsigned 65535) (tunsigned 2) 2))
              (ledger-call insert
                %fld.4
                (safe-cast (tunsigned 9) (tunsigned 3) 3)
                (default (Map (tunsigned 255) (List (tboolean)))))
              (ledger-call insert
                (ledger-call lookup
                  %fld.4
                  (safe-cast (tunsigned 9) (tunsigned 3) 3))
                (safe-cast (tunsigned 255) (tunsigned 4) 4)
                (default (List (tboolean))))
              (ledger-call pushFront
                (ledger-call lookup
                  (ledger-call lookup
                    %fld.4
                    (safe-cast (tunsigned 9) (tunsigned 3) 3))
                  (safe-cast (tunsigned 255) (tunsigned 4) 4))
                #t)
              (tuple
                (ledger-call read %fld.1)
                (ledger-call read %fld.1)
                (ledger-call size %fld.2)
                (ledger-call read %fld.3)
                (if (elt-ref
                      (ledger-call head
                        (ledger-call lookup
                          (ledger-call lookup
                            %fld.4
                            (safe-cast (tunsigned 9) (tunsigned 3) 3))
                          (safe-cast (tunsigned 255) (tunsigned 4) 4)))
                      value
                      1)
                    (safe-cast (tfield) (tunsigned 1) 1)
                    (safe-cast (tfield) (tunsigned 0) 0))))))))
    )

  (test
    '(
      "circuit foo<#N, T>(x: Vector<N, T>): T {"
      "  return fold((a: T, n) => a + n as T, 0, x);"
      "}"
      "export circuit bar(): Vector<3, Uint<32>> {"
      "  return [ foo<2, Uint<16>>([7, 39]), foo<3, Uint<8>>([1, 2, 3]), foo<0, Uint<32>>([]) ];"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%x.1 (tvector 0 (tunsigned 4294967295))])
             (tunsigned 4294967295)
          (fold
            (circuit ([%a.2 (tunsigned 4294967295)]
                      [%n.3 (tunsigned 4294967295)])
                 (tunsigned 4294967295)
              (downcast-unsigned
                4294967295
                (+ 33
                   (safe-cast (tunsigned 8589934590) (tunsigned 4294967295) %a.2)
                   (safe-cast (tunsigned 8589934590) (tunsigned 4294967295) %n.3))))
            (safe-cast (tunsigned 4294967295) (tunsigned 0) 0)
            %x.1))
        (circuit %foo.4 ([%x.5 (tvector 2 (tunsigned 65535))])
             (tunsigned 65535)
          (fold
            (circuit ([%a.6 (tunsigned 65535)] [%n.7 (tunsigned 65535)])
                 (tunsigned 65535)
              (downcast-unsigned
                65535
                (+ 17
                   (safe-cast (tunsigned 131070) (tunsigned 65535) %a.6)
                   (safe-cast (tunsigned 131070) (tunsigned 65535) %n.7))))
            (safe-cast (tunsigned 65535) (tunsigned 0) 0)
            %x.5))
        (circuit %foo.8 ([%x.9 (tvector 3 (tunsigned 255))])
             (tunsigned 255)
          (fold
            (circuit ([%a.10 (tunsigned 255)] [%n.11 (tunsigned 255)])
                 (tunsigned 255)
              (downcast-unsigned
                255
                (+ 9
                   (safe-cast (tunsigned 510) (tunsigned 255) %a.10)
                   (safe-cast (tunsigned 510) (tunsigned 255) %n.11))))
            (safe-cast (tunsigned 255) (tunsigned 0) 0)
            %x.9))
        (circuit %bar.12 ()
             (tvector 3 (tunsigned 4294967295))
          (safe-cast (tvector 3 (tunsigned 4294967295))
                     (ttuple
                       (tunsigned 65535)
                       (tunsigned 255)
                       (tunsigned 4294967295))
            (tuple
              (call %foo.4
                (safe-cast (tvector 2 (tunsigned 65535))
                           (ttuple (tunsigned 7) (tunsigned 39))
                  (tuple 7 39)))
              (call %foo.8
                (safe-cast (tvector 3 (tunsigned 255))
                           (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                  (tuple 1 2 3)))
              (call %foo.0 (tuple)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M<A> {"
      "  ledger F: A;"
      "}"
      "import M<MerkleTree<3, Bytes<32>>>;"
      "import M<MerkleTree<3, Bytes<32>>>;"
      "import M<MerkleTree<3, Uint<32>>>;"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %F.1 (MerkleTree 3 (tbytes 32)))
        (public-ledger-declaration
          %F.2
          (MerkleTree 3 (tunsigned 4294967295)))))
    )

  (test
    '(
      "enum E { paris, london, rome, prague };"
      "enum A { newyork, rio, mexicocity };"
      "module M<A> {"
      "  ledger F: A;"
      "}"
      "import M<E>;"
      "import M<E>;"
      "import M<A>;"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %F.1
          (__compact_Cell (tenum E paris london rome prague)))
        (public-ledger-declaration
          %F.2
          (__compact_Cell (tenum A newyork rio mexicocity)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export { MerkleTree }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "cannot export ~a (~s) from the top level" ("ledger ADT type" MerkleTree)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(): [] {"
      "  assert(MerkleTree, 'oops');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "invalid context for reference to ~a name ~s" ("ledger ADT type" MerkleTree)))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(x: F): [] {"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 23" "invalid context for reference to ~a name ~s" ("ledger field" F)))
    )

  (test
    '(
      "circuit baq<A>(x: A): [] { }"
      "circuit bar<#N>(): [] { baq<N<Field>>(3); }"
      "export circuit foo(): [] { return bar<7>(); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 29" "mismatch between actual number ~s and declared number ~s of generic parameters for ~s" (1 0 N)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger modifiable_set: Cell<Field>;"
      ""
      "circuit foo(): Field {"
      "  return 0;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 24" "unbound identifier ~s" (Cell)))
    )

  (test
    '(
      "ledger X: Uint<16>;"
      "export circuit foo(x: Uint<16>, y: Uint<16>): [] {"
      "  X = x * y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 5" "expected right-hand side of ~a to have type ~a but received ~a" ("=" "Uint<16>" "Uint<0..4294836226>")))
    )

  (test
    '(
      "ledger X: Uint<16>;"
      "export circuit foo(x: Uint<16>, y: Uint<16>): [] {"
      "  X.write(x * y);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 4" "expected ~:r argument of ~s to have type ~a but received ~a" (1 write "Uint<16>" "Uint<0..4294836226>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger X: Counter;"
      "export circuit foo(b: Boolean): [] {"
      "  X += b;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 5" "expected right-hand side of ~a to have type ~a but received ~a" ("+=" "Uint<16>" "Boolean")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger X: Counter;"
      "export circuit foo(b: Boolean): [] {"
      "  X.increment(b);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 4" "expected ~:r argument of ~s to have type ~a but received ~a" (1 increment "Uint<16>" "Boolean")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger X: Counter;"
      "export circuit foo(b: Boolean): [] {"
      "  X -= b;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 5" "expected right-hand side of ~a to have type ~a but received ~a" ("-=" "Uint<16>" "Boolean")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger X: Counter;"
      "export circuit foo(b: Boolean): [] {"
      "  X.decrement(b);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 4" "expected ~:r argument of ~s to have type ~a but received ~a" (1 decrement "Uint<16>" "Boolean")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(a: Field, b: Field): []{"
      "  if (a == 0) {"
      "    if (b == 0) {"
      "      ledger_counter.decrement(1);"
      "    } else {"
      "      7;"
      "    }"
      "  }"
      "}")
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %ledger_counter.1 (Counter))
        (circuit %minimal_error_circuit.2 ([%a.3 (tfield)]
                                           [%b.4 (tfield)])
             (ttuple)
          (seq
            (if (== %a.3 (safe-cast (tfield) (tunsigned 0) 0))
                (if (== %b.4 (safe-cast (tfield) (tunsigned 0) 0))
                    (ledger-call decrement
                      %ledger_counter.1
                      (safe-cast (tunsigned 65535) (tunsigned 1) 1))
                    7)
                (tuple))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(): []{"
      "  const a = 0;"
      "  const b = 0;"
      "  if (a == 0) {"
      "    if (b == 0) {"
      "      ledger_counter.decrement(1);"
      "    } else {"
      "      7;"
      "    }"
      "  }"
      "}")
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %ledger_counter.1 (Counter))
        (circuit %minimal_error_circuit.2 ()
             (ttuple)
          (seq
            (let* ([[%a.3 (tunsigned 0)] 0])
              (let* ([[%b.4 (tunsigned 0)] 0])
                (if (== %a.3 0)
                    (if (== %b.4 0)
                        (ledger-call decrement
                          %ledger_counter.1
                          (safe-cast (tunsigned 65535) (tunsigned 1) 1))
                        7)
                    (tuple))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(): []{"
      "  const a = 0;"
      "  const b = 0;"
      "  if (a == 0) {"
      "    if (b == 0) {"
      "      ledger_counter.decrement(1);"
      "    } else {"
      "      ledger_counter.read();"
      "    }"
      "  }"
      "}")
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %ledger_counter.1 (Counter))
        (circuit %minimal_error_circuit.2 ()
             (ttuple)
          (seq
            (let* ([[%a.3 (tunsigned 0)] 0])
              (let* ([[%b.4 (tunsigned 0)] 0])
                (if (== %a.3 0)
                    (if (== %b.4 0)
                        (ledger-call decrement
                          %ledger_counter.1
                          (safe-cast (tunsigned 65535) (tunsigned 1) 1))
                        (ledger-call read %ledger_counter.1))
                    (tuple))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger cedar: Set<[Uint<8>, Bytes<32>]>;"
      "export circuit willow(x: Uint<8>, y: Bytes<32>): [] {"
      "  cedar.insert([x, y]);"
      "}"
      "export circuit birch(a: [Uint<8>, Bytes<32>]): Boolean {"
      "  return cedar.member(a);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %cedar.1
          (Set (ttuple (tunsigned 255) (tbytes 32))))
        (circuit %willow.2 ([%x.3 (tunsigned 255)]
                            [%y.4 (tbytes 32)])
             (ttuple)
          (seq
            (ledger-call insert %cedar.1 (tuple %x.3 %y.4))
            (tuple)))
        (circuit %birch.5 ([%a.6 (ttuple
                                   (tunsigned 255)
                                   (tbytes 32))])
             (tboolean)
          (ledger-call member %cedar.1 %a.6))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit foo<T>(x: T): T {"
      "  return x;"
      "}"
      "export circuit bar(a: Uint<8>, b: [Boolean, Uint<16>]): Uint<32> {"
      "  return foo<[Boolean, Uint<16>]>(b)[1] + (foo<[Boolean, Uint<16>]>(b)[0] ? a : 0);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %foo.1 ([%x.2 (ttuple
                                 (tboolean)
                                 (tunsigned 65535))])
             (ttuple (tboolean) (tunsigned 65535))
          %x.2)
        (circuit %bar.3 ([%a.4 (tunsigned 255)]
                         [%b.5 (ttuple (tboolean) (tunsigned 65535))])
             (tunsigned 4294967295)
          (safe-cast (tunsigned 4294967295)
                     (tunsigned 65790)
            (+ 17
               (safe-cast (tunsigned 65790)
                          (tunsigned 65535)
                 (tuple-ref (call %foo.1 %b.5) 1))
               (safe-cast (tunsigned 65790)
                          (tunsigned 255)
                 (if (tuple-ref (call %foo.1 %b.5) 0)
                     %a.4
                     (safe-cast (tunsigned 255) (tunsigned 0) 0))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit foo<T>(x: T): T {"
      "  return x;"
      "}"
      "export circuit bar(y: [Uint<8>, Uint<8>]): Uint<32> {"
      "  return foo<[Uint<16>, Uint<16>]>(y)[1] + foo<Vector<2, Uint<16>>>(y)[0];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %foo.1 ([%x.2 (tvector 2 (tunsigned 65535))])
             (tvector 2 (tunsigned 65535))
          %x.2)
        (circuit %bar.3 ([%y.4 (ttuple
                                 (tunsigned 255)
                                 (tunsigned 255))])
             (tunsigned 4294967295)
          (safe-cast (tunsigned 4294967295)
                     (tunsigned 131070)
            (+ 17
               (safe-cast (tunsigned 131070)
                          (tunsigned 65535)
                 (tuple-ref
                   (call %foo.1
                     (safe-cast (tvector 2 (tunsigned 65535))
                                (ttuple (tunsigned 255) (tunsigned 255))
                       %y.4))
                   1))
               (safe-cast (tunsigned 131070)
                          (tunsigned 65535)
                 (tuple-ref
                   (call %foo.1
                     (safe-cast (tvector 2 (tunsigned 65535))
                                (ttuple (tunsigned 255) (tunsigned 255))
                       %y.4))
                   0)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M1 {"
      "  struct S { x: Vector<2, Field> }"
      "  export circuit foo(s: S): Vector<2, Field> { return s.x; }"
      "}"
      "module M2 {"
      "  import M1;"
      "  struct S { x: [ Field, Field ] };"
      "  export circuit bar(a: Field): [Field, Field] { return foo(S {x: [a, a * 2]}); }"
      "}"
      "import M2;"
      "export { bar };"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %foo.1 ([%s.2 (tstruct S
                                 (x (tvector 2 (tfield))))])
             (tvector 2 (tfield))
          (elt-ref %s.2 x 0))
        (circuit %bar.3 ([%a.4 (tfield)])
             (ttuple (tfield) (tfield))
          (call %foo.1
            (new (tstruct S (x (ttuple (tfield) (tfield))))
              (tuple
                %a.4
                (* #f %a.4 (safe-cast (tfield) (tunsigned 2) 2))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Boolean, y: Field): Field {"
      "  return (x ? x : x).lookup(y);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 21" "expected left-hand side of ~a to have an ADT or contract type, received ~a" ("." "Boolean")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): [Field, Boolean] {"
      "  return [y, x];"
      "}"
      "export circuit foo(): Field {"
      "  const [a, b] = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x.2 (tboolean)] [%y.3 (tfield)])
             (ttuple (tfield) (tboolean))
          (tuple %y.3 %x.2))
        (circuit %foo.4 ()
             (tfield)
          (let* ([[%__compact_tuple1.5 (ttuple (tfield) (tboolean))]
                  (call %bar.1 #t (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%a.6 (tfield)] (tuple-ref %__compact_tuple1.5 0)])
              (let* ([[%b.7 (tboolean)]
                      (tuple-ref %__compact_tuple1.5 1)])
                (if %b.7
                    %a.6
                    (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.6))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): [Field, Boolean] {"
      "  return [y, x];"
      "}"
      "export circuit foo(): Field {"
      "  const [a, b] : [Field, Boolean] = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x.2 (tboolean)] [%y.3 (tfield)])
             (ttuple (tfield) (tboolean))
          (tuple %y.3 %x.2))
        (circuit %foo.4 ()
             (tfield)
          (let* ([[%__compact_tuple1.5 (ttuple (tfield) (tboolean))]
                  (call %bar.1 #t (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%a.6 (tfield)] (tuple-ref %__compact_tuple1.5 0)])
              (let* ([[%b.7 (tboolean)]
                      (tuple-ref %__compact_tuple1.5 1)])
                (if %b.7
                    %a.6
                    (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.6))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(y: Field): Vector<3, Field> {"
      "  return [y, y, y];"
      "}"
      "export circuit foo(): Field {"
      "  const [, , a] : [Field, Field, Field] = bar(17);"
      "  return true ? a : 2 * a;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%y.2 (tfield)])
             (tvector 3 (tfield))
          (tuple %y.2 %y.2 %y.2))
        (circuit %foo.3 ()
             (tfield)
          (let* ([[%__compact_pattern_tmp1.4 (ttuple
                                               (tfield)
                                               (tfield)
                                               (tfield))]
                  (call %bar.1 (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%a.5 (tfield)]
                    (tuple-ref %__compact_pattern_tmp1.4 2)])
              (if #t
                  %a.5
                  (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.5)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): [Field, Boolean, Boolean] {"
      "  return [y, x, x];"
      "}"
      "export circuit foo(): Field {"
      "  const [a, b] = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x.2 (tboolean)] [%y.3 (tfield)])
             (ttuple (tfield) (tboolean) (tboolean))
          (tuple %y.3 %x.2 %x.2))
        (circuit %foo.4 ()
             (tfield)
          (let* ([[%__compact_tuple1.5 (ttuple
                                         (tfield)
                                         (tboolean)
                                         (tboolean))]
                  (call %bar.1 #t (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%a.6 (tfield)] (tuple-ref %__compact_tuple1.5 0)])
              (let* ([[%b.7 (tboolean)]
                      (tuple-ref %__compact_tuple1.5 1)])
                (if %b.7
                    %a.6
                    (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.6))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): [Field, Boolean, Boolean] {"
      "  return [y, x, x];"
      "}"
      "export circuit foo(): Field {"
      "  const [a, b] : [Field, Boolean] = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("[Field, Boolean, Boolean]" "[Field, Boolean]")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): Field {"
      "  return y;"
      "}"
      "export circuit foo(): Field {"
      "  const [a, b] = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 9" "expected a tuple, Vector, or Bytes type, received ~a" ("Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): Field {"
      "  return y;"
      "}"
      "export circuit foo(): Field {"
      "  const [a, b] : [Field, Boolean] = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("Field" "[Field, Boolean]")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const {a, b} = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x.2 (tboolean)] [%y.3 (tfield)])
             (tstruct S (a (tfield)) (b (tboolean)))
          (new (tstruct S (a (tfield)) (b (tboolean))) %y.3 %x.2))
        (circuit %foo.4 ()
             (tfield)
          (let* ([[%__compact_const1.5 (tstruct S
                                         (a (tfield))
                                         (b (tboolean)))]
                  (call %bar.1 #t (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%a.6 (tfield)] (elt-ref %__compact_const1.5 a 0)])
              (let* ([[%b.7 (tboolean)]
                      (elt-ref %__compact_const1.5 b 1)])
                (if %b.7
                    %a.6
                    (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.6))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const {a, b} : S = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x.2 (tboolean)] [%y.3 (tfield)])
             (tstruct S (a (tfield)) (b (tboolean)))
          (new (tstruct S (a (tfield)) (b (tboolean))) %y.3 %x.2))
        (circuit %foo.4 ()
             (tfield)
          (let* ([[%__compact_const1.5 (tstruct S
                                         (a (tfield))
                                         (b (tboolean)))]
                  (call %bar.1 #t (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%a.6 (tfield)] (elt-ref %__compact_const1.5 a 0)])
              (let* ([[%b.7 (tboolean)]
                      (elt-ref %__compact_const1.5 b 1)])
                (if %b.7
                    %a.6
                    (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.6))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(): Field {"
      "  const {a} : S = bar(true, 17);"
      "  return 2 * a;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x.2 (tboolean)] [%y.3 (tfield)])
             (tstruct S (a (tfield)) (b (tboolean)))
          (new (tstruct S (a (tfield)) (b (tboolean))) %y.3 %x.2))
        (circuit %foo.4 ()
             (tfield)
          (let* ([[%__compact_const1.5 (tstruct S
                                         (a (tfield))
                                         (b (tboolean)))]
                  (call %bar.1 #t (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%a.6 (tfield)] (elt-ref %__compact_const1.5 a 0)])
              (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.6))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "struct T { x: Boolean, y: Field }"
      "circuit bar(x: Boolean, y: Field): T {"
      "  return T { x, y };"
      "}"
      "export circuit foo(): Field {"
      "  const {a, b} = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 9" "structure ~s has no field named ~s" (T a)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "struct T { x: Boolean, y: Field }"
      "circuit bar(x: Boolean, y: Field): T {"
      "  return T { x, y };"
      "}"
      "export circuit foo(): Field {"
      "  const {a, b} : S = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("struct T<x: Boolean, y: Field>" "struct S<a: Field, b: Boolean>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "struct T { x: Boolean, y: Field }"
      "circuit bar(x: Boolean, y: Field): T {"
      "  return T { x, y };"
      "}"
      "export circuit foo(): Field {"
      "  const {x: b, y: a} : T = bar(true, 17);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x.2 (tboolean)] [%y.3 (tfield)])
             (tstruct T (x (tboolean)) (y (tfield)))
          (new (tstruct T (x (tboolean)) (y (tfield))) %x.2 %y.3))
        (circuit %foo.4 ()
             (tfield)
          (let* ([[%__compact_const1.5 (tstruct T
                                         (x (tboolean))
                                         (y (tfield)))]
                  (call %bar.1 #t (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%b.6 (tboolean)]
                    (elt-ref %__compact_const1.5 x 0)])
              (let* ([[%a.7 (tfield)] (elt-ref %__compact_const1.5 y 1)])
                (if %b.6
                    %a.7
                    (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.7))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const [{a: [a, b], b: b1}, b2] = bar(x1, x2, y, z);"
      "  return [b1 ? a : 2 * a, b2 ? b : 'hello!'];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x1.2 (tboolean)]
                         [%x2.3 (tboolean)]
                         [%y.4 (tfield)]
                         [%z.5 (tbytes 6)])
             (ttuple
               (tstruct S (a (ttuple (tfield) (tbytes 6))) (b (tboolean)))
               (tboolean))
          (tuple
            (new (tstruct S
                   (a (ttuple (tfield) (tbytes 6)))
                   (b (tboolean)))
              (tuple %y.4 %z.5)
              %x1.2)
            %x2.3))
        (circuit %foo.6 ([%x1.7 (tboolean)]
                         [%x2.8 (tboolean)]
                         [%y.9 (tfield)]
                         [%z.10 (tbytes 6)])
             (ttuple (tfield) (tbytes 6))
          (let* ([[%__compact_const1.11 (ttuple
                                          (tstruct S
                                            (a (ttuple (tfield) (tbytes 6)))
                                            (b (tboolean)))
                                          (tboolean))]
                  (call %bar.1 %x1.7 %x2.8 %y.9 %z.10)])
            (let* ([[%__compact_const2.12 (tstruct S
                                            (a (ttuple (tfield) (tbytes 6)))
                                            (b (tboolean)))]
                    (tuple-ref %__compact_const1.11 0)])
              (let* ([[%__compact_const3.13 (ttuple (tfield) (tbytes 6))]
                      (elt-ref %__compact_const2.12 a 0)])
                (let* ([[%a.14 (tfield)]
                        (tuple-ref %__compact_const3.13 0)])
                  (let* ([[%b.15 (tbytes 6)]
                          (tuple-ref %__compact_const3.13 1)])
                    (let* ([[%b1.16 (tboolean)]
                            (elt-ref %__compact_const2.12 b 1)])
                      (let* ([[%b2.17 (tboolean)]
                              (tuple-ref %__compact_const1.11 1)])
                        (tuple
                          (if %b1.16
                              %a.14
                              (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.14))
                          (if %b2.17
                              %b.15
                              #vu8(104 101 108 108 111 33)))))))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const [{a: [a, b], c: b1}, b2] = bar(x1, x2, y, z);"
      "  return [b1 ? a : 2 * a, b2 ? b : 'hello!'];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 10" "structure ~s has no field named ~s" (S c)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const [{a: [a, b], b: b1}, b2, q] = bar(x1, x2, y, z);"
      "  return [b1 ? a : 2 * a, b2 ? b : 'hello!'];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 9" "index ~d is out-of-bounds for a ~a of length ~d" (2 "tuple" 2)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const [{a: [a, b], b: b1}] = bar(x1, x2, y, z);"
      "  return [b1 ? a : 2 * a, b1 ? b : 'hello!'];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x1.2 (tboolean)]
                         [%x2.3 (tboolean)]
                         [%y.4 (tfield)]
                         [%z.5 (tbytes 6)])
             (ttuple
               (tstruct S (a (ttuple (tfield) (tbytes 6))) (b (tboolean)))
               (tboolean))
          (tuple
            (new (tstruct S
                   (a (ttuple (tfield) (tbytes 6)))
                   (b (tboolean)))
              (tuple %y.4 %z.5)
              %x1.2)
            %x2.3))
        (circuit %foo.6 ([%x1.7 (tboolean)]
                         [%x2.8 (tboolean)]
                         [%y.9 (tfield)]
                         [%z.10 (tbytes 6)])
             (ttuple (tfield) (tbytes 6))
          (let* ([[%__compact_pattern_tmp1.11 (ttuple
                                                (tstruct S
                                                  (a (ttuple
                                                       (tfield)
                                                       (tbytes 6)))
                                                  (b (tboolean)))
                                                (tboolean))]
                  (call %bar.1 %x1.7 %x2.8 %y.9 %z.10)])
            (let* ([[%__compact_pattern_tmp2.12 (tstruct S
                                                  (a (ttuple
                                                       (tfield)
                                                       (tbytes 6)))
                                                  (b (tboolean)))]
                    (tuple-ref %__compact_pattern_tmp1.11 0)])
              (let* ([[%__compact_pattern_tmp3.13 (ttuple
                                                    (tfield)
                                                    (tbytes 6))]
                      (elt-ref %__compact_pattern_tmp2.12 a 0)])
                (let* ([[%a.14 (tfield)]
                        (tuple-ref %__compact_pattern_tmp3.13 0)])
                  (let* ([[%b.15 (tbytes 6)]
                          (tuple-ref %__compact_pattern_tmp3.13 1)])
                    (let* ([[%b1.16 (tboolean)]
                            (elt-ref %__compact_pattern_tmp2.12 b 1)])
                      (tuple
                        (if %b1.16
                            %a.14
                            (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.14))
                        (if %b1.16
                            %b.15
                            #vu8(104 101 108 108 111 33))))))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const [{a: [a, b], b: b1}, ] = bar(x1, x2, y, z);"
      "  return [b1 ? a : 2 * a, b1 ? b : 'hello!'];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ([%x1.2 (tboolean)]
                         [%x2.3 (tboolean)]
                         [%y.4 (tfield)]
                         [%z.5 (tbytes 6)])
             (ttuple
               (tstruct S (a (ttuple (tfield) (tbytes 6))) (b (tboolean)))
               (tboolean))
          (tuple
            (new (tstruct S
                   (a (ttuple (tfield) (tbytes 6)))
                   (b (tboolean)))
              (tuple %y.4 %z.5)
              %x1.2)
            %x2.3))
        (circuit %foo.6 ([%x1.7 (tboolean)]
                         [%x2.8 (tboolean)]
                         [%y.9 (tfield)]
                         [%z.10 (tbytes 6)])
             (ttuple (tfield) (tbytes 6))
          (let* ([[%__compact_pattern_tmp1.11 (ttuple
                                                (tstruct S
                                                  (a (ttuple
                                                       (tfield)
                                                       (tbytes 6)))
                                                  (b (tboolean)))
                                                (tboolean))]
                  (call %bar.1 %x1.7 %x2.8 %y.9 %z.10)])
            (let* ([[%__compact_pattern_tmp2.12 (tstruct S
                                                  (a (ttuple
                                                       (tfield)
                                                       (tbytes 6)))
                                                  (b (tboolean)))]
                    (tuple-ref %__compact_pattern_tmp1.11 0)])
              (let* ([[%__compact_pattern_tmp3.13 (ttuple
                                                    (tfield)
                                                    (tbytes 6))]
                      (elt-ref %__compact_pattern_tmp2.12 a 0)])
                (let* ([[%a.14 (tfield)]
                        (tuple-ref %__compact_pattern_tmp3.13 0)])
                  (let* ([[%b.15 (tbytes 6)]
                          (tuple-ref %__compact_pattern_tmp3.13 1)])
                    (let* ([[%b1.16 (tboolean)]
                            (elt-ref %__compact_pattern_tmp2.12 b 1)])
                      (tuple
                        (if %b1.16
                            %a.14
                            (* #f (safe-cast (tfield) (tunsigned 2) 2) %a.14))
                        (if %b1.16
                            %b.15
                            #vu8(104 101 108 108 111 33))))))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const [, {a: [a, b], b: b1}] = bar(x1, x2, y, z);"
      "  return [b1 ? a : 2 * a, b1 ? b : 'hello!'];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 12" "expected structure type, received ~a" ("Boolean")))
    )

  (test
    '(
      "circuit bar(x: Vector<15, Uint<8>>): Uint<8> {"
      "  return x[5];"
      "}"
      "export circuit foo(x: [Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>]): Uint<16> {"
      "  const q1 = bar([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);"
      "  const q2 = bar(x);"
      "  return q1 + q2;"
      "}"
      )
    (returns
      (program
        (circuit %bar.0 ([%x.1 (tvector 15 (tunsigned 255))])
             (tunsigned 255)
          (tuple-ref %x.1 5))
        (circuit %foo.2 ([%x.3 (ttuple (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255))])
             (tunsigned 65535)
          (safe-cast (tunsigned 65535)
                     (tunsigned 510)
            (let* ([[%q1.4 (tunsigned 255)]
                    (call %bar.0
                      (safe-cast (tvector 15 (tunsigned 255))
                              (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3)
                                (tunsigned 4) (tunsigned 5) (tunsigned 6)
                                (tunsigned 7) (tunsigned 8) (tunsigned 9)
                                (tunsigned 10) (tunsigned 11) (tunsigned 12)
                                (tunsigned 13) (tunsigned 14) (tunsigned 15))
                        (tuple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)))])
              (let* ([[%q2.5 (tunsigned 255)] (call %bar.0 %x.3)])
                (+ 9
                   (safe-cast (tunsigned 510) (tunsigned 255) %q1.4)
                   (safe-cast (tunsigned 510) (tunsigned 255) %q2.5))))))))
    )

  (test
    '(
      "module M<T> {"
      "  export circuit bar(x: Vector<15, Uint<8>>): Uint<8> {"
      "    return x[5];"
      "  }"
      "}"
      "import M<[Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>]>;"
      "import M<Vector<15, Uint<8>>>;"
      "export circuit foo(x: [Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>],
                          y: Vector<15, Uint<8>>): Uint<16> {"
      "  const q1 = bar(x);"
      "  const q2 = bar(y);"
      "  const q3 = bar([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);"
      "  return q1 + q2 + q3;"
      "}"
      "export { bar }"
      )
    (returns
      (program
        (circuit %bar.1 ([%x.2 (tvector 15 (tunsigned 255))])
             (tunsigned 255)
          (tuple-ref %x.2 5))
        (circuit %foo.3 ([%x.4 (ttuple (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255) (tunsigned 255)
                                 (tunsigned 255))]
                         [%y.0 (tvector 15 (tunsigned 255))])
             (tunsigned 65535)
          (safe-cast (tunsigned 65535)
                     (tunsigned 765)
            (let* ([[%q1.5 (tunsigned 255)] (call %bar.1 %x.4)])
              (let* ([[%q2.6 (tunsigned 255)] (call %bar.1 %y.0)])
                (let* ([[%q3.7 (tunsigned 255)]
                        (call %bar.1
                          (safe-cast (tvector 15 (tunsigned 255))
                                     (ttuple
                                       (tunsigned 1) (tunsigned 2) (tunsigned 3)
                                       (tunsigned 4) (tunsigned 5) (tunsigned 6)
                                       (tunsigned 7) (tunsigned 8) (tunsigned 9)
                                       (tunsigned 10) (tunsigned 11)
                                       (tunsigned 12) (tunsigned 13)
                                       (tunsigned 14) (tunsigned 15))
                            (tuple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)))])
                  (+ 10
                     (safe-cast (tunsigned 765)
                                (tunsigned 510)
                       (+ 9
                          (safe-cast (tunsigned 510) (tunsigned 255) %q1.5)
                          (safe-cast (tunsigned 510) (tunsigned 255) %q2.6)))
                     (safe-cast (tunsigned 765) (tunsigned 255) %q3.7)))))))))
    )

  (test
    '(
      "export circuit foo(x: [Uint<8>, Boolean]): [Uint<8>, Boolean] {"
      "  return map((x) => x, x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "~a should be a vector but has a tuple type ~a that cannot be converted to a vector because its element types are unrelated" ("map second argument" "[Uint<8>, Boolean]")))
    )

  (test
    '(
      "export circuit foo(x: [Uint<8>, Boolean]): Uint<8> {"
      "  return fold((x, y) => y, 0, x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "~a should be a vector but has a tuple type ~a that cannot be converted to a vector because its element types are unrelated" ("fold third argument" "[Uint<8>, Boolean]")))
    )

  (test
    '(
      "module M1 {"
      "  struct pr { a: Field; d: Field}"
      "  export circuit bar({a, d}: pr): pr {"
      "    return pr{a+1, d-1};"
      "  }"
      "}"
      "module M2 {"
      "  struct pr { a: Field; d: Field}"
      "  export circuit foo(): pr {"
      "    return bar(pr { 7, 13 });"
      "  }"
      "}"
      "import M1;"
      "import M2;"
      "export { foo };"
      )
    (returns
      (program
        (circuit %bar.0 ([%__compact_pattern_tmp1.1 (tstruct pr
                                                      (a (tfield))
                                                      (d (tfield)))])
             (tstruct pr (a (tfield)) (d (tfield)))
          (let* ([[%a.2 (tfield)]
                  (elt-ref %__compact_pattern_tmp1.1 a 0)])
            (let* ([[%d.3 (tfield)]
                    (elt-ref %__compact_pattern_tmp1.1 d 1)])
              (new (tstruct pr (a (tfield)) (d (tfield)))
                (+ #f %a.2 (safe-cast (tfield) (tunsigned 1) 1))
                (- #f %d.3 (safe-cast (tfield) (tunsigned 1) 1))))))
        (circuit %foo.4 ()
             (tstruct pr (a (tfield)) (d (tfield)))
          (call %bar.0
            (new (tstruct pr (a (tfield)) (d (tfield)))
              (safe-cast (tfield) (tunsigned 7) 7)
              (safe-cast (tfield) (tunsigned 13) 13))))))
    )

  (test
    '(
      "module M1 {"
      "  struct pr<T> { a: T; d: T}"
      "  export circuit bar({a, d}: pr<Field>): pr<Field> {"
      "    return pr<Field>{a+1, d-1};"
      "  }"
      "}"
      "module M2 {"
      "  struct pr { a: Field; d: Field}"
      "  export circuit foo(): pr {"
      "    return bar(pr { 7, 13 });"
      "  }"
      "}"
      "import M1;"
      "import M2;"
      "export { foo };"
      )
    (returns
      (program
        (circuit %bar.0 ([%__compact_pattern_tmp1.1 (tstruct pr
                                                      (a (tfield))
                                                      (d (tfield)))])
             (tstruct pr (a (tfield)) (d (tfield)))
          (let* ([[%a.2 (tfield)]
                  (elt-ref %__compact_pattern_tmp1.1 a 0)])
            (let* ([[%d.3 (tfield)]
                    (elt-ref %__compact_pattern_tmp1.1 d 1)])
              (new (tstruct pr (a (tfield)) (d (tfield)))
                (+ #f %a.2 (safe-cast (tfield) (tunsigned 1) 1))
                (- #f %d.3 (safe-cast (tfield) (tunsigned 1) 1))))))
        (circuit %foo.4 ()
             (tstruct pr (a (tfield)) (d (tfield)))
          (call %bar.0
            (new (tstruct pr (a (tfield)) (d (tfield)))
              (safe-cast (tfield) (tunsigned 7) 7)
              (safe-cast (tfield) (tunsigned 13) 13))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export struct Complex {"
      "  a: List<Vector<3, Field>>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("struct field 'a'" "List<Vector<3, Field>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(a: List<Vector<3, Field>>): [];"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 11" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("argument 'a'" "List<Vector<3, Field>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): List<Vector<3, Field>>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("witness return" "List<Vector<3, Field>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit f(): List<Vector<3, Field>> {"
      "  return;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("circuit return" "List<Vector<3, Field>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit f(a: List<Vector<3, Field>>): [] {"
      "  return;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 11" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("argument 'a'" "List<Vector<3, Field>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger q: List<Vector<3, Field>>;"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration
          %q.1
          (List (tvector 3 (tfield))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger q: Vector<17, Counter>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 11" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("vector element" "Counter")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger q: Vector<17, List<Field>>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 11" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("vector element" "List<Field>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger q: [Uint<32>, List<Field>, Boolean];"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 11" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("tuple element 2" "List<Field>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit f(): [] {"
      "  const v: Vector<0, List<Field>> = [];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 12" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("vector element" "List<Field>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit f(): [] {"
      "  const v: List<Field> = default<List<Field>>;"
      "}"
      )
    (returns
      (program (public-ledger-declaration %kernel.0 (Kernel))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit f(): [] {"
      "  const res = map ((a: List<Field>) => a.isEmpty(), []) ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 21" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("argument 'a'" "List<Field>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit f(): [] {"
      "  const res = map ((a: Field) : List<Field> => default<List<Field>>, []) ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 20" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("anonymous circuit return" "List<Field>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness get_balance(): Uint<64>;"
      ""
      "export circuit balance_exceeds(n: Uint<64>): Boolean {"
      "  return disclose(get_balance() as Map<Field, Field> as Field as Uint<32> as Boolean) != n;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 36" "invalid context for a ledger ADT type" ()))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(): Field {"
      "  const c = Counter { };"
      "  return c;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 13" "invalid context for a ledger ADT type" ()))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Bytes<16>, y: Field): Field {"
      "  return b ? x : y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "mismatch between type ~a and type ~a of condition branches" ("Bytes<16>" "Field")))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Bytes<16>, y: Field): Bytes<16> {"
      "  return b ? x : y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "mismatch between type ~a and type ~a of condition branches" ("Bytes<16>" "Field")))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Bytes<16>, y: Field): Field {"
      "  if (b)"
      "   return x;"
      "  else"
      "   return y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 4" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Bytes<16>" "Field" "circuit foo")))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Bytes<16>, y: Field): Bytes<16> {"
      "  if (b)"
      "   return x;"
      "  else"
      "   return y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 4" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Field" "Bytes<16>" "circuit foo")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit bar(): Maybe<Field> {"
      "  return Maybe<Field> { is_some: true, value: 17 };"
      "}"
      "export circuit foo(): Boolean {"
      "  const { is_some } = bar();"
      "  return is_some;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (circuit %bar.1 ()
             (tstruct Maybe (is_some (tboolean)) (value (tfield)))
          (new (tstruct Maybe (is_some (tboolean)) (value (tfield)))
            #t
            (safe-cast (tfield) (tunsigned 17) 17)))
        (circuit %foo.2 ()
             (tboolean)
          (let* ([[%__compact_pattern_tmp1.3 (tstruct Maybe
                                               (is_some (tboolean))
                                               (value (tfield)))]
                  (call %bar.1)])
            (let* ([[%is_some.4 (tboolean)]
                    (elt-ref %__compact_pattern_tmp1.3 is_some 0)])
              %is_some.4)))))
    )

  (test
    "examples/bugs/pm-16611.compact"
    (oops
      message: "~a:\n  ~?"
      irritants: '("pm-16611.compact line 21 char 9" "expected ~:r argument of ~s to have type ~a but received ~a" (2 mint "Uint<64>" "Uint<128>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "ledger field: Field;"
      "export circuit foo(x: Uint<16>): [] {"
      "  if (x < 100) {"
      "    return counter += disclose(x);"
      "  } else if (x < 200) {"
      "    return counter -= disclose(x);"
      "  } else {"
      "    return field = disclose(x);"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %counter.1 (Counter))
        (public-ledger-declaration
          %field.2
          (__compact_Cell (tfield)))
        (circuit %foo.3 ([%x.4 (tunsigned 65535)])
             (ttuple)
          (if (< %x.4 (safe-cast (tunsigned 65535) (tunsigned 100) 100))
              (ledger-call increment %counter.1 (disclose %x.4))
              (if (< %x.4 (safe-cast (tunsigned 65535) (tunsigned 200) 200))
                  (ledger-call decrement %counter.1 (disclose %x.4))
                  (ledger-call write
                    %field.2
                    (safe-cast (tfield) (tunsigned 65535) (disclose %x.4))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "ledger field: Field;"
      "export circuit foo(x: Uint<16>): [] {"
      "  return x < 100 ? counter += disclose(x) :"
      "         x < 200 ? counter -= disclose(x) :"
      "         field = disclose(x);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %counter.1 (Counter))
        (public-ledger-declaration
          %field.2
          (__compact_Cell (tfield)))
        (circuit %foo.3 ([%x.4 (tunsigned 65535)])
             (ttuple)
          (if (< %x.4 (safe-cast (tunsigned 65535) (tunsigned 100) 100))
              (ledger-call increment %counter.1 (disclose %x.4))
              (if (< %x.4 (safe-cast (tunsigned 65535) (tunsigned 200) 200))
                  (ledger-call decrement %counter.1 (disclose %x.4))
                  (ledger-call write
                    %field.2
                    (safe-cast (tfield) (tunsigned 65535) (disclose %x.4))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "ledger field: Field;"
      "export circuit foo(x: Uint<16>): Field {"
      "  if (x < 100) {"
      "    return counter += disclose(x), x * x;"
      "  } else if (x < 200) {"
      "    return counter -= disclose(x), x * x;"
      "  } else {"
      "    return field = disclose(x), x * x;"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %counter.1 (Counter))
        (public-ledger-declaration
          %field.2
          (__compact_Cell (tfield)))
        (circuit %foo.3 ([%x.4 (tunsigned 65535)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned 4294836225)
            (if (< %x.4 (safe-cast (tunsigned 65535) (tunsigned 100) 100))
                (seq
                  (ledger-call increment %counter.1 (disclose %x.4))
                  (* 32
                     (safe-cast (tunsigned 4294836225) (tunsigned 65535) %x.4)
                     (safe-cast (tunsigned 4294836225) (tunsigned 65535) %x.4)))
                (if (< %x.4 (safe-cast (tunsigned 65535) (tunsigned 200) 200))
                    (seq
                      (ledger-call decrement %counter.1 (disclose %x.4))
                      (* 32
                         (safe-cast (tunsigned 4294836225) (tunsigned 65535) %x.4)
                         (safe-cast (tunsigned 4294836225)
                                 (tunsigned 65535)
                           %x.4)))
                    (seq
                      (ledger-call write
                        %field.2
                        (safe-cast (tfield) (tunsigned 65535) (disclose %x.4)))
                      (* 32
                         (safe-cast (tunsigned 4294836225) (tunsigned 65535) %x.4)
                         (safe-cast (tunsigned 4294836225)
                                 (tunsigned 65535)
                           %x.4)))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "ledger field: Field;"
      "export circuit foo(x: Uint<16>): [] {"
      "  (() => counter += disclose(x))();"
      "  (() => counter -= disclose(x))();"
      "  (() => field = disclose(x))();"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %counter.1 (Counter))
        (public-ledger-declaration
          %field.2
          (__compact_Cell (tfield)))
        (circuit %foo.3 ([%x.4 (tunsigned 65535)])
             (ttuple)
          (seq
            (call (circuit ()
                       (ttuple)
                    (ledger-call increment %counter.1 (disclose %x.4))))
            (call (circuit ()
                       (ttuple)
                    (ledger-call decrement %counter.1 (disclose %x.4))))
            (call (circuit ()
                       (ttuple)
                    (ledger-call write
                      %field.2
                      (safe-cast (tfield) (tunsigned 65535) (disclose %x.4)))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "ledger field: Field;"
      "export circuit foo(b: Boolean, x: Uint<16>): [] {"
      "  (() => counter += b ? 7 : disclose(x))();"
      "  (() => counter -= b ? 7 : disclose(x))();"
      "  (() => field = b ? 7 : disclose(x))();"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration %kernel.0 (Kernel))
        (public-ledger-declaration %counter.1 (Counter))
        (public-ledger-declaration
          %field.2
          (__compact_Cell (tfield)))
        (circuit %foo.3 ([%b.4 (tboolean)] [%x.5 (tunsigned 65535)])
             (ttuple)
          (seq
            (call (circuit ()
                       (ttuple)
                    (ledger-call increment
                      %counter.1
                      (if %b.4
                          (safe-cast (tunsigned 65535) (tunsigned 7) 7)
                          (disclose %x.5)))))
            (call (circuit ()
                       (ttuple)
                    (ledger-call decrement
                      %counter.1
                      (if %b.4
                          (safe-cast (tunsigned 65535) (tunsigned 7) 7)
                          (disclose %x.5)))))
            (call (circuit ()
                       (ttuple)
                    (ledger-call write
                      %field.2
                      (safe-cast (tfield)
                                 (tunsigned 65535)
                        (if %b.4
                            (safe-cast (tunsigned 65535) (tunsigned 7) 7)
                            (disclose %x.5))))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "ledger field: Field;"
      "export circuit foo(x: Uint<16>): [] {"
      "  if (x < 100) {"
      "    return counter -= counter += disclose(x);"
      "  } else {"
      "    return field = disclose(x);"
      "  }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 20" "expected right-hand side of ~a to have type ~a but received ~a" ("-=" "Uint<16>" "[]")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "ledger field: Field;"
      "export circuit foo(x: Uint<16>): [] {"
      "  if (x < 100) {"
      "    return counter += disclose(x);"
      "  } else {"
      "    return field = counter -= disclose(x);"
      "  }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 18" "expected right-hand side of ~a to have type ~a but received ~a" ("=" "Field" "[]")))
    )

  ; pm-16181
  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "constructor(){"
      "    for (const bob of [default<Map<[], Boolean>>]) {"
      "    }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 24" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("tuple element" "Map<[], Boolean>")))
    )

  ; pm-16181
  (test
    '(
      "import CompactStandardLibrary;"
      "constructor(){"
      "  const tom = default<Counter>;"
      "  assert(tom != tom, 'oops');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 10" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("equality-operator left operand" "Counter")))
    )

  ; pm-16181
  (test
    '(
      "import CompactStandardLibrary;"
      "constructor(){"
      "  const tom = default<Counter>;"
      "  assert(0 == tom, 'oops');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 10" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("equality-operator right operand" "Counter")))
    )

  ; pm-17201
  (test
    '(
      "module M<#K> {"
        "circuit bar<#I>(v: Vector<K, Field>): Field {"
        "  return I;"
        "}"
        "export circuit foo(v: Vector<K, Field>): Field {"
        "  return bar<0>(v) + bar<1>(v);"
        "}"
      "}"
      "import M<5>;"
      "export { foo }"
      )
    (returns
      (program
        (circuit %bar.0 ([%v.1 (tvector 5 (tfield))])
             (tfield)
          (safe-cast (tfield) (tunsigned 1) 1))
        (circuit %bar.2 ([%v.3 (tvector 5 (tfield))])
             (tfield)
          (safe-cast (tfield) (tunsigned 0) 0))
        (circuit %foo.4 ([%v.5 (tvector 5 (tfield))])
             (tfield)
          (+ #f (call %bar.2 %v.5) (call %bar.0 %v.5)))))
    )

  (test
    '(
      "module M<#K> {"
        "circuit bar<#I>(v: Vector<K, Field>): Field {"
        "  return v[I];"
        "}"
        "export circuit foo(v: Vector<K, Field>): Field {"
        "  return bar<0>(v) + bar<1>(v);"
        "}"
      "}"
      "import M<5>;"
      "export { foo }"
      )
    (returns
      (program
        (circuit %bar.0 ([%v.1 (tvector 5 (tfield))])
             (tfield)
          (tuple-ref %v.1 1))
        (circuit %bar.2 ([%v.3 (tvector 5 (tfield))])
             (tfield)
          (tuple-ref %v.3 0))
        (circuit %foo.4 ([%v.5 (tvector 5 (tfield))])
             (tfield)
          (+ #f (call %bar.2 %v.5) (call %bar.0 %v.5)))))
    )

  (test
    '(
      "module M<#K> {"
        "circuit bar<#I>(v: Vector<K, Field>): Field {"
        "  return v[I];"
        "}"
        "export circuit foo(v: Vector<K, Field>): Field {"
        "  return bar<0>(v) + bar<1>(v);"
        "}"
      "}"
      "import M<1>;"
      "export { foo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "index ~d is out-of-bounds for a ~a of length ~d" (1 "vector" 1)))
    )

  (test
    '(
      "module M<#K> {"
        "circuit bar<#I>(v: Vector<K, Field>): Vector<I, Field> {"
        "  return slice<I>(v, 2);"
        "}"
        "export circuit foo(v: Vector<K, Field>): Vector<1, Field> {"
        "  return bar<1>(v);"
        "}"
      "}"
      "import M<1>;"
      "export { foo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "slice index ~d plus length ~d is out-of-bounds for a ~a of length ~d" (2 1 "vector" 1)))
    )

  (test
    '(
      "export circuit foo(v: Vector<5, Field>): Field {"
      "  return v[true];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

  (test
    '(
      "export circuit foo(v: Vector<5, Field>): Field {"
      "  return slice<2>(v, true);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

  (test
    '(
      "export circuit foo(v: Vector<5, Field>): Field {"
      "  return slice<2>(true, 2);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "expected a tuple, Vector, or Bytes type, received ~a" ("Boolean")))
    )

  (test
    '(
      "export circuit foo(v: [Field, Field, Field]): Field {"
      "  return slice<4>(v, 3+1);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "slice length ~d exceeds the length ~d of the input vector" (4 3)))
    )

  (test
    '(
      "export circuit foo(v: Vector<3, Field>): Field {"
      "  return slice<4>(v, 3+1);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "slice length ~d exceeds the length ~d of the input vector" (4 3)))
    )

  (test
    '(
      "circuit bar(v: Vector<5, Field>, i: Uint<0..5>): Field {"
      "  return v[i];"
      "}"
      "export circuit foo(v: Vector<5, Field>): Field {"
      "  return bar(v, 3);"
      "}"
      )
    (returns
      (program
        (circuit %bar.0 ([%v.1 (tvector 5 (tfield))]
                         [%i.2 (tunsigned 4)])
             (tfield)
          (vector-ref %v.1 %i.2))
        (circuit %foo.3 ([%v.4 (tvector 5 (tfield))])
             (tfield)
          (call %bar.0 %v.4 (safe-cast (tunsigned 4) (tunsigned 3) 3)))))
    )

  (test
    '(
      "export circuit bar(v: Vector<2, Field>, i: Vector<2, Uint<32>>): Vector<4, Field> {"
      "  return [...v, ...i];"
      "}"
      )
    (returns
      (program
        (circuit %bar.1 ([%v.2 (tvector 2 (tfield))]
                         [%i.0 (tvector 2 (tunsigned 4294967295))])
             (tvector 4 (tfield))
          (vector
            (spread 2 %v.2)
            (spread
              2
              (safe-cast (tvector 2 (tfield))
                         (tvector 2 (tunsigned 4294967295))
                %i.0))))))
    )

  (test
    '(
      "export circuit bar(v: Vector<2, Field>, i: Vector<2, Uint<32>>): Vector<5, Field> {"
      "  return [...v, ...i];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Vector<4, Field>" "Vector<5, Field>" "circuit bar")))
    )

  (test
    '(
      "export circuit bar(v: Vector<2, Field>, i: Vector<2, Uint<32>>): Vector<4, Field> {"
      "  const t: [Field,  Field, Uint<32>, Uint<32>] = [...v, ...i];"
      "  return t;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("Vector<4, Field>" "[Field, Field, Uint<32>, Uint<32>]")))
    )

  (test
    '(
      "export ledger F: Vector<6, Uint<32>>;"
      "export circuit foo(iv: Vector<32, Uint<16>>): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  F = [v[0], ...slice<2>(v, 4), v[15], true, v[31]];"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "tuple/vector construction expression with vector-typed spreads has unrelated element types ~a and ~a" ("Uint<16>" "Boolean")))
    )

  (test
    '(
      "export circuit bar(v: Vector<2, Field>, i: Uint<16>): Vector<4, Field> {"
      "  return [...v, ...i];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 17" "expected tuple/vector spread expression to have a tuple, Vector, or Bytes type but received ~a" ("Uint<16>")))
    )

  ; 19426
  (test
    '(
      "ledger F: Vector<4, Boolean>;"
      "export circuit foo(): Vector<4, Boolean> {"
      "  F = [true, false, true, false, true, false] as Vector<4, Boolean>;"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "cannot cast from type ~a to type ~a" ("[Boolean, Boolean, Boolean, Boolean, Boolean, Boolean]" "Vector<4, Boolean>")))
    )

  (test
    '(
      "ledger F: Bytes<4>;"
      "export circuit foo(): Vector<4, Boolean> {"
      "  F = [true, false, true, false] as Bytes<4>;"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "cannot cast from type ~a to type ~a" ("[Boolean, Boolean, Boolean, Boolean]" "Bytes<4>")))
    )

  ; tests for writing lang ref for patterns
  (test
    '(
      "circuit unroll<T>([a, [b, c], d]: [T, [T, T], T]) : [T, T, T, T] {"
      "  return [a, b, c, d];"
      "}"
      "export circuit unroll_fields(fs: [Field, [Field, Field], Field]): Vector<4, Field> {"
      "  return unroll<Field>(fs);"
      "}"
      )
    (returns
      (program
        (circuit %unroll.0 ([%__compact_pattern_tmp1.1 (ttuple
                                                         (tfield)
                                                         (ttuple
                                                           (tfield)
                                                           (tfield))
                                                         (tfield))])
             (ttuple (tfield) (tfield) (tfield) (tfield))
          (let* ([[%a.2 (tfield)]
                  (tuple-ref %__compact_pattern_tmp1.1 0)])
            (let* ([[%__compact_pattern_tmp2.3 (ttuple
                                                 (tfield)
                                                 (tfield))]
                    (tuple-ref %__compact_pattern_tmp1.1 1)])
              (let* ([[%b.4 (tfield)]
                      (tuple-ref %__compact_pattern_tmp2.3 0)])
                (let* ([[%c.5 (tfield)]
                        (tuple-ref %__compact_pattern_tmp2.3 1)])
                  (let* ([[%d.6 (tfield)]
                          (tuple-ref %__compact_pattern_tmp1.1 2)])
                    (tuple %a.2 %b.4 %c.5 %d.6)))))))
        (circuit %unroll_fields.7 ([%fs.8 (ttuple
                                            (tfield)
                                            (ttuple (tfield) (tfield))
                                            (tfield))])
             (tvector 4 (tfield))
          (call %unroll.0 %fs.8))))
    )

  (test ; TODO PM 19090
        ; this is a good ex of the convienience of having a don't care type so
        ; one won't have to instantiate wild parameters.
    '(
      "circuit foo<T, B>([a, [b, , c]] : [Field, [B, T, B]]) : B {"
      "  return (a as B) && b && c;"
      "}"
      "export circuit instantiate_foo(bs : [Field, [Boolean, Boolean, Boolean]]) : Boolean {"
      "  return foo<Boolean, Boolean>(bs);"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%__compact_pattern_tmp1.1 (ttuple
                                                      (tfield)
                                                      (ttuple
                                                        (tboolean)
                                                        (tboolean)
                                                        (tboolean)))])
             (tboolean)
          (let* ([[%a.2 (tfield)]
                  (tuple-ref %__compact_pattern_tmp1.1 0)])
            (let* ([[%__compact_pattern_tmp2.3 (ttuple
                                                 (tboolean)
                                                 (tboolean)
                                                 (tboolean))]
                    (tuple-ref %__compact_pattern_tmp1.1 1)])
              (let* ([[%b.4 (tboolean)]
                      (tuple-ref %__compact_pattern_tmp2.3 0)])
                (let* ([[%c.5 (tboolean)]
                        (tuple-ref %__compact_pattern_tmp2.3 2)])
                  (if (if (if (== %a.2 (safe-cast (tfield) (tunsigned 0) 0))
                              #f
                              #t)
                          %b.4
                          #f)
                      %c.5
                      #f))))))
        (circuit %instantiate_foo.6 ([%bs.7 (ttuple
                                              (tfield)
                                              (ttuple
                                                (tboolean)
                                                (tboolean)
                                                (tboolean)))])
             (tboolean)
          (call %foo.0 %bs.7))))
    )

  (test
    '(
      "circuit foo<T>([a, [b, , c]] : [Field, [Boolean, T, Boolean]]) : Boolean {"
      "  return (a as Boolean) && b && c;"
      "}"
      "export circuit foo_instantiated(ls: [Field, Vector<3, Boolean>]): Boolean {"
      "  return foo<Boolean>(ls);"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%__compact_pattern_tmp1.1 (ttuple
                                                      (tfield)
                                                      (ttuple
                                                        (tboolean)
                                                        (tboolean)
                                                        (tboolean)))])
             (tboolean)
          (let* ([[%a.2 (tfield)]
                  (tuple-ref %__compact_pattern_tmp1.1 0)])
            (let* ([[%__compact_pattern_tmp2.3 (ttuple
                                                 (tboolean)
                                                 (tboolean)
                                                 (tboolean))]
                    (tuple-ref %__compact_pattern_tmp1.1 1)])
              (let* ([[%b.4 (tboolean)]
                      (tuple-ref %__compact_pattern_tmp2.3 0)])
                (let* ([[%c.5 (tboolean)]
                        (tuple-ref %__compact_pattern_tmp2.3 2)])
                  (if (if (if (== %a.2 (safe-cast (tfield) (tunsigned 0) 0))
                              #f
                              #t)
                          %b.4
                          #f)
                      %c.5
                      #f))))))
        (circuit %foo_instantiated.6 ([%ls.7 (ttuple
                                               (tfield)
                                               (tvector 3 (tboolean)))])
             (tboolean)
          (call %foo.0 %ls.7))))
    )

  (test
   '(
     "circuit foo<T>(): T {"
     "  const [x, , y] = [1, 2, 3];"
     "  return x + y;"
     "}"
     "export circuit bar(): Field {"
     "  return foo<Field>();"
     "}"
     )
   (returns
      (program
        (circuit %foo.0 ()
             (tfield)
          (safe-cast (tfield)
                  (tunsigned 4)
            (let* ([[%__compact_pattern_tmp1.1 (ttuple
                                                 (tunsigned 1)
                                                 (tunsigned 2)
                                                 (tunsigned 3))]
                    (tuple 1 2 3)])
              (let* ([[%x.2 (tunsigned 1)]
                      (tuple-ref %__compact_pattern_tmp1.1 0)])
                (let* ([[%y.3 (tunsigned 3)]
                        (tuple-ref %__compact_pattern_tmp1.1 2)])
                  (+ 3
                     (safe-cast (tunsigned 4) (tunsigned 1) %x.2)
                     (safe-cast (tunsigned 4) (tunsigned 3) %y.3)))))))
        (circuit %bar.4 () (tfield) (call %foo.0))))
   )

  (test
    '(
      "export circuit foo([a, [b, c]] : [Field, [Boolean, Boolean]]) : Boolean {"
      "  return (a as Boolean) && b && c;"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%__compact_pattern_tmp1.1 (ttuple
                                                      (tfield)
                                                      (ttuple
                                                        (tboolean)
                                                        (tboolean)))])
             (tboolean)
          (let* ([[%a.2 (tfield)]
                  (tuple-ref %__compact_pattern_tmp1.1 0)])
            (let* ([[%__compact_pattern_tmp2.3 (ttuple
                                                 (tboolean)
                                                 (tboolean))]
                    (tuple-ref %__compact_pattern_tmp1.1 1)])
              (let* ([[%b.4 (tboolean)]
                      (tuple-ref %__compact_pattern_tmp2.3 0)])
                (let* ([[%c.5 (tboolean)]
                        (tuple-ref %__compact_pattern_tmp2.3 1)])
                  (if (if (if (== %a.2 (safe-cast (tfield) (tunsigned 0) 0))
                              #f
                              #t)
                          %b.4
                          #f)
                      %c.5
                      #f))))))))
    )

  (test
    '(
      "export circuit foo([a, [b, c]] : [Field, Boolean]) : Boolean {"
      "  return (a as Boolean) && b && c;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 24" "expected a tuple, Vector, or Bytes type, received ~a" ("Boolean")))
    )

  (test
    '(
      "struct SS {a: Field, b: Boolean, c : Boolean}"
      "struct S {b: Field, a: Boolean}"
      "circuit foo<T, TT>({a, }: T) : TT { return a; }"
      "export circuit foo_S(x: S): Boolean { return foo<S, Boolean>(x); }"
      "export circuit foo_SS(x: SS): Field { return foo<SS, Field>(x); }"
      )
    (returns
      (program
        (circuit %foo.0 ([%__compact_pattern_tmp1.1 (tstruct S
                                                      (b (tfield))
                                                      (a (tboolean)))])
             (tboolean)
          (let* ([[%a.2 (tboolean)]
                  (elt-ref %__compact_pattern_tmp1.1 a 1)])
            %a.2))
        (circuit %foo.3 ([%__compact_pattern_tmp1.4 (tstruct SS
                                                      (a (tfield))
                                                      (b (tboolean))
                                                      (c (tboolean)))])
             (tfield)
          (let* ([[%a.5 (tfield)]
                  (elt-ref %__compact_pattern_tmp1.4 a 0)])
            %a.5))
        (circuit %foo_S.6 ([%x.7 (tstruct S
                                   (b (tfield))
                                   (a (tboolean)))])
             (tboolean)
          (call %foo.0 %x.7))
        (circuit %foo_SS.8 ([%x.9 (tstruct SS
                                    (a (tfield))
                                    (b (tboolean))
                                    (c (tboolean)))])
             (tfield)
          (call %foo.3 %x.9))))
    )

  (test ; TODO bad error message. PM-19115
    '(
      "struct SS {a: Field, b: Boolean, c : Boolean}"
      "struct S {b: Field, a: Boolean}"
      "circuit foo<T>({a, }: T) : Field { return a; }"
      "export circuit foo_S(x: S): Field { return foo<S>(x); }"
      "export circuit foo_SS(x: SS): Field { return foo<SS>(x); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 36" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo")))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c : Boolean}"
      "export circuit foo1({a, }: S) : Field { return a; }"
      "export circuit foo2({a: x, }: S) : Field { return x; }"
      )
    (returns
      (program
        (circuit %foo1.0 ([%__compact_pattern_tmp2.1 (tstruct S
                                                       (a (tfield))
                                                       (b (tboolean))
                                                       (c (tboolean)))])
             (tfield)
          (let* ([[%a.2 (tfield)]
                  (elt-ref %__compact_pattern_tmp2.1 a 0)])
            %a.2))
        (circuit %foo2.3 ([%__compact_pattern_tmp1.4 (tstruct S
                                                       (a (tfield))
                                                       (b (tboolean))
                                                       (c (tboolean)))])
             (tfield)
          (let* ([[%x.5 (tfield)]
                  (elt-ref %__compact_pattern_tmp1.4 a 0)])
            %x.5))))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c : Boolean}"
      "export circuit foo2({a: x, }: S) : Field { return a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 51" "unbound identifier ~s" (a)))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c : Boolean}"
      "export circuit foo3({a: b, b}: S) : Field { return b; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 21" "found multiple bindings for ~s in the same block" (b)))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c : Boolean}"
      "export circuit foo3({a: b, b: a}: S) : Field { return b; }"
      )
    (returns
      (program
        (circuit %foo3.0 ([%__compact_pattern_tmp1.1 (tstruct S
                                                       (a (tfield))
                                                       (b (tboolean))
                                                       (c (tboolean)))])
             (tfield)
          (let* ([[%b.2 (tfield)]
                  (elt-ref %__compact_pattern_tmp1.1 a 0)])
            (let* ([[%a.3 (tboolean)]
                    (elt-ref %__compact_pattern_tmp1.1 b 1)])
              %b.2)))))
    )

  (test
    '(
      "struct P {a: Field, bs: [Boolean, Boolean]}"
      "struct X {b: Field, a: P}"
      "export circuit foo4({a, bs:[b, bb] }: P) : Boolean{ return (a as Boolean) && bb;}"
      )
    (returns
      (program
        (circuit %foo4.0 ([%__compact_pattern_tmp1.1 (tstruct P
                                                       (a (tfield))
                                                       (bs (ttuple
                                                             (tboolean)
                                                             (tboolean))))])
             (tboolean)
          (let* ([[%a.2 (tfield)]
                  (elt-ref %__compact_pattern_tmp1.1 a 0)])
            (let* ([[%__compact_pattern_tmp2.3 (ttuple
                                                 (tboolean)
                                                 (tboolean))]
                    (elt-ref %__compact_pattern_tmp1.1 bs 1)])
              (let* ([[%b.4 (tboolean)]
                      (tuple-ref %__compact_pattern_tmp2.3 0)])
                (let* ([[%bb.5 (tboolean)]
                        (tuple-ref %__compact_pattern_tmp2.3 1)])
                  (if (if (== %a.2 (safe-cast (tfield) (tunsigned 0) 0)) #f #t)
                      %bb.5
                      #f))))))))
    )

  (test
    '(
      "struct P {a: Field, bs: [Boolean, Boolean]}"
      "struct X {b: Field, a: P}"
      "export circuit foo4({a, bs:[b, bb] }: P) : Boolean{ return (a as Boolean) && bs;}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 78" "unbound identifier ~s" (bs)))
    )

  (test
    '(
      "struct T {b: Field, a: Boolean}"
      "export circuit foo({a,  }: T) : Field { return a; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 41" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "Field" "circuit foo")))
    )

  (test
    '(
      "struct T {b: Field, a: Boolean}"
      "export circuit foo({x }: T) : Field { return x; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 20" "structure ~s has no field named ~s" (T x)))
    )

  (test
    '(
      "struct P {a: Field, bs: [Boolean, Boolean]}"
      "export circuit foo4({a, bs:[b, bb, bbb, ] }: P) : Boolean{ return (a as Boolean) && bb;}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 28" "index ~d is out-of-bounds for a ~a of length ~d" (2 "tuple" 2)))
    )

  (test
   '(
     "constructor([x, y]: [Field, Field]) { const z = x + y; }"
     )
   (returns
      (program
        (constructor ([%__compact_pattern_tmp1.0 (ttuple
                                                   (tfield)
                                                   (tfield))])
          (seq
            (let* ([[%x.1 (tfield)]
                    (tuple-ref %__compact_pattern_tmp1.0 0)])
              (let* ([[%y.2 (tfield)]
                      (tuple-ref %__compact_pattern_tmp1.0 1)])
                (let* ([[%z.3 (tfield)] (+ #f %x.1 %y.2)]) (tuple))))
            (tuple)))))
   )

  (test
   '(
     "circuit foo(x: Boolean): [] { return ; }"
     "circuit foo(x: Boolean) : [] { return; }"
     "export circuit bar(x: Boolean): [] { foo(x); }"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 38" "call site ambiguity (multiple compatible functions) in call to ~a\n    supplied argument types:\n      (~{~a~^, ~})\n    compatible functions:~{\n      ~a~}" (foo ("Boolean") ("line 1 char 1" "line 2 char 1"))))
   )

  (test
   '(
     "circuit foo(x: Field): [] { return ; }"
     "circuit foo(x: Boolean) : [] { return; }"
     "export circuit bar(x: Boolean): [] { foo(x); }"
     )
   (returns
      (program
        (circuit %foo.0 ([%x.1 (tfield)]) (ttuple) (tuple))
        (circuit %foo.2 ([%x.3 (tboolean)]) (ttuple) (tuple))
        (circuit %bar.4 ([%x.5 (tboolean)])
             (ttuple)
          (seq (call %foo.2 %x.5) (tuple)))))
   )

  (test
   '(
     "export circuit foo(x: Boolean): [] { return ; }"
     "export circuit foo(x: Boolean) : [] { return; }"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "multiple top-level exports for ~s" (foo)))
   )

  (test
   '(
     "circuit foo<T>(x: T): T {return x;}"
     "export circuit bar<>(x: Field): Field { foo<Field>(x); }"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "mismatch between actual return type ~a and declared return type ~a of ~a" ("[]" "Field" "circuit bar")))
   )

  (test
   '(
     "circuit foo<T>(x: T): T {return x;}"
     "export circuit bar<>(x: Field): Field { return foo<Field>(x); }"
     )
   (returns
      (program
        (circuit %foo.0 ([%x.1 (tfield)]) (tfield) %x.1)
        (circuit %bar.2 ([%x.3 (tfield)])
             (tfield)
          (call %foo.0 %x.3))))
   )

  (test
    '(
      "struct P {a: Field, bs: [Boolean, Boolean]}"
      "export circuit foo4({a, bs:[b, , bb, ] }: P) : Boolean{ return (a as Boolean) && bb;}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 28" "index ~d is out-of-bounds for a ~a of length ~d" (2 "tuple" 2)))
    )

  (test ; TODO PM-19090 inconsistant pattern behavior
    '(
      "struct P {a: Field, bs: [Boolean, Boolean]}"
      "export circuit foo4({a, bs:[b, bb, , ] }: P) : Boolean{ return (a as Boolean) && bb;}"
      )
    (returns
      (program
        (circuit %foo4.0 ([%__compact_pattern_tmp1.1 (tstruct P
                                                       (a (tfield))
                                                       (bs (ttuple
                                                             (tboolean)
                                                             (tboolean))))])
             (tboolean)
          (let* ([[%a.2 (tfield)]
                  (elt-ref %__compact_pattern_tmp1.1 a 0)])
            (let* ([[%__compact_pattern_tmp2.3 (ttuple
                                                 (tboolean)
                                                 (tboolean))]
                    (elt-ref %__compact_pattern_tmp1.1 bs 1)])
              (let* ([[%b.4 (tboolean)]
                      (tuple-ref %__compact_pattern_tmp2.3 0)])
                (let* ([[%bb.5 (tboolean)]
                        (tuple-ref %__compact_pattern_tmp2.3 1)])
                  (if (if (== %a.2 (safe-cast (tfield) (tunsigned 0) 0)) #f #t)
                      %bb.5
                      #f))))))))
    )

  (test ; TODO PM-19090 inconsistant pattern behavior
   '(
     "export circuit foo([b, bb, , ] : [Boolean, Boolean]) : [] { return; }"
     "export circuit call_foo() : [] { return foo([true, true, true]); }"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 41" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        ([Boolean, Boolean, Boolean])\n      declared argument types for function at line 1 char 1:\n        ([Boolean, Boolean])" #f)))
   )

  (test
   '(
     "export circuit foo([b, , bb ] : [Boolean, Boolean]) : [] { return; }"
     "export circuit call_foo() : [] { return foo([true, true, true]); }"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 20" "index ~d is out-of-bounds for a ~a of length ~d" (2 "tuple" 2)))
   )

  (test
   '(
     "export circuit foo([, b, , ] : [Boolean, Boolean]) : [] { return; }"
     "export circuit call_foo() : [] { return foo([true, true, true]); }"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 41" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        ([Boolean, Boolean, Boolean])\n      declared argument types for function at line 1 char 1:\n        ([Boolean, Boolean])" #f)))
   )

  (test
   '(
     "export circuit foo([, b, , ] : [Boolean, Boolean]) : [] { return; }"
     "export circuit call_foo() : [] { return foo([true, true]); }"
     )
   (returns
      (program
        (circuit %foo.0 ([%__compact_pattern_tmp1.1 (ttuple
                                                      (tboolean)
                                                      (tboolean))])
             (ttuple)
          (let* ([[%b.2 (tboolean)]
                  (tuple-ref %__compact_pattern_tmp1.1 1)])
            (tuple)))
        (circuit %call_foo.3 ()
             (ttuple)
          (call %foo.0 (tuple #t #t)))))
   )

  (test
   '(
     "export circuit foo([, b, , ] : [Boolean, Boolean]) : [] { return; }"
     "export circuit call_foo() : [] { return foo([true, true, 1, 1, 1, 1]); }"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 41" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        ([Boolean, Boolean, Uint<1>, Uint<1>, Uint<1>, Uint<1>])\n      declared argument types for function at line 1 char 1:\n        ([Boolean, Boolean])" #f)))
   )

  (test
   '(
     "export circuit foo([, b, , ] : [Boolean, Boolean, Field, Field]) : [] { return; }"
     "export circuit call_foo() : [] { return foo([true, true, 1, 1, 1, 1]); }"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 41" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (foo #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        ([Boolean, Boolean, Uint<1>, Uint<1>, Uint<1>, Uint<1>])\n      declared argument types for function at line 1 char 1:\n        ([Boolean, Boolean, Field, Field])" #f)))
   )

  (test
   '(
     "export circuit foo([b, bb, , bbb ] : [Boolean, Boolean]) : Boolean {return b;}"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 20" "index ~d is out-of-bounds for a ~a of length ~d" (3 "tuple" 2)))
   )

  (test
    '(
      "export circuit sum(v: Vector<3, Vector<2, Field>>): Field {"
      "  return fold((x: Field, [a, b]: Vector<2, Field>): Field => a + b + x, 0, v);"
      "}"
      )
    (returns
      (program
        (circuit %sum.0 ([%v.1 (tvector 3 (tvector 2 (tfield)))])
             (tfield)
          (fold
            (circuit ([%x.2 (tfield)]
                      [%__compact_pattern_tmp1.3 (tvector 2 (tfield))])
                 (tfield)
              (let* ([[%a.4 (tfield)]
                      (tuple-ref %__compact_pattern_tmp1.3 0)])
                (let* ([[%b.5 (tfield)]
                        (tuple-ref %__compact_pattern_tmp1.3 1)])
                  (+ #f (+ #f %a.4 %b.5) %x.2))))
            (safe-cast (tfield) (tunsigned 0) 0)
            %v.1))))
    )

  (test
    '(
      "export circuit sum(v: Vector<3, [Field, Field]>): Field {"
      "  return fold((x: Field, [a, b]: [Field, Field]): Field => a + b + x, 0, v);"
      "}"
      )
    (returns
      (program
        (circuit %sum.0 ([%v.1 (tvector
                                 3
                                 (ttuple (tfield) (tfield)))])
             (tfield)
          (fold
            (circuit ([%x.2 (tfield)]
                      [%__compact_pattern_tmp1.3 (ttuple (tfield) (tfield))])
                 (tfield)
              (let* ([[%a.4 (tfield)]
                      (tuple-ref %__compact_pattern_tmp1.3 0)])
                (let* ([[%b.5 (tfield)]
                        (tuple-ref %__compact_pattern_tmp1.3 1)])
                  (+ #f (+ #f %a.4 %b.5) %x.2))))
            (safe-cast (tfield) (tunsigned 0) 0)
            %v.1))))
    )

  (test
    '(
      "export circuit sum(v: Vector<3, [Field, Field]>): Field {"
      "  return fold((x, [a, b]) => a + b + x, 0, v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "fold requires the return type and first-argument type to be the same\n    ~:[[inferred] ~;~]first-argument type: ~a,\n    ~:[[inferred] ~;~]return type: ~a" (#f "Uint<0..1>" #f "Field")))
    )

  (test
    '(
      "export circuit and(v: Vector<3, [Boolean, Boolean]>): Vector<3, Boolean> {"
      "return map(([a, b]) =>  a && b , v);"
      "}"
      )
    (returns
      (program
        (circuit %and.0 ([%v.1 (tvector
                                 3
                                 (ttuple (tboolean) (tboolean)))])
             (tvector 3 (tboolean))
          (map
            (circuit ([%__compact_pattern_tmp1.2 (ttuple
                                                   (tboolean)
                                                   (tboolean))])
                 (tboolean)
              (let* ([[%a.3 (tboolean)]
                      (tuple-ref %__compact_pattern_tmp1.2 0)])
                (let* ([[%b.4 (tboolean)]
                        (tuple-ref %__compact_pattern_tmp1.2 1)])
                  (if %a.3 %b.4 #f))))
            %v.1))))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, z, , y] : Vector<2, Field> = [1, 2];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "index ~d is out-of-bounds for a ~a of length ~d" (3 "vector" 2)))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, z, , y] : [Field, Field] = [1, 2];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "index ~d is out-of-bounds for a ~a of length ~d" (3 "tuple" 2)))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, z, , y] : Vector<2, Field> = [1, 2, 3, 4];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("[Uint<1>, Uint<0..3>, Uint<2>, Uint<0..5>]" "Vector<2, Field>")))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, z, , y] : [Field, Field] = [1, 2, 3, 4];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("[Uint<1>, Uint<0..3>, Uint<2>, Uint<0..5>]" "[Field, Field]")))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, z, , y] : [Field, Field, Field, Field] = [1, 2, 3, 4];"
      "  const [a, b, , c] : Vector<4, Field> = [1, 2, 3, 4];"
      "  return x + y + a + b;"
      "}"
      )
    (returns
      (program
        (circuit %bad.0 ()
             (tfield)
          (let* ([[%__compact_pattern_tmp1.1 (ttuple
                                               (tfield)
                                               (tfield)
                                               (tfield)
                                               (tfield))]
                  (safe-cast (ttuple (tfield) (tfield) (tfield) (tfield))
                          (ttuple
                            (tunsigned 1)
                            (tunsigned 2)
                            (tunsigned 3)
                            (tunsigned 4))
                    (tuple 1 2 3 4))])
            (let* ([[%x.2 (tfield)]
                    (tuple-ref %__compact_pattern_tmp1.1 0)])
              (let* ([[%z.3 (tfield)]
                      (tuple-ref %__compact_pattern_tmp1.1 1)])
                (let* ([[%y.4 (tfield)]
                        (tuple-ref %__compact_pattern_tmp1.1 3)])
                  (let* ([[%__compact_pattern_tmp2.5 (tvector 4 (tfield))]
                          (safe-cast (tvector 4 (tfield))
                                  (ttuple
                                    (tunsigned 1)
                                    (tunsigned 2)
                                    (tunsigned 3)
                                    (tunsigned 4))
                            (tuple 1 2 3 4))])
                    (let* ([[%a.6 (tfield)]
                            (tuple-ref %__compact_pattern_tmp2.5 0)])
                      (let* ([[%b.7 (tfield)]
                              (tuple-ref %__compact_pattern_tmp2.5 1)])
                        (let* ([[%c.8 (tfield)]
                                (tuple-ref %__compact_pattern_tmp2.5 3)])
                          (+ #f (+ #f (+ #f %x.2 %y.4) %a.6) %b.7))))))))))))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, y] : [Field, Field, Field, Field] = [1, 2, 3, 4];"
      "  const [a, b] : Vector<4, Field> = [1, 2, 3, 4];"
      "  return x + y + a + b;"
      "}"
      )
    (returns
      (program
        (circuit %bad.0 ()
             (tfield)
          (let* ([[%__compact_pattern_tmp1.1 (ttuple
                                               (tfield)
                                               (tfield)
                                               (tfield)
                                               (tfield))]
                  (safe-cast (ttuple (tfield) (tfield) (tfield) (tfield))
                          (ttuple
                            (tunsigned 1)
                            (tunsigned 2)
                            (tunsigned 3)
                            (tunsigned 4))
                    (tuple 1 2 3 4))])
            (let* ([[%x.2 (tfield)]
                    (tuple-ref %__compact_pattern_tmp1.1 0)])
              (let* ([[%y.3 (tfield)]
                      (tuple-ref %__compact_pattern_tmp1.1 1)])
                (let* ([[%__compact_pattern_tmp2.4 (tvector 4 (tfield))]
                        (safe-cast (tvector 4 (tfield))
                                (ttuple
                                  (tunsigned 1)
                                  (tunsigned 2)
                                  (tunsigned 3)
                                  (tunsigned 4))
                          (tuple 1 2 3 4))])
                  (let* ([[%a.5 (tfield)]
                          (tuple-ref %__compact_pattern_tmp2.4 0)])
                    (let* ([[%b.6 (tfield)]
                            (tuple-ref %__compact_pattern_tmp2.4 1)])
                      (+ #f (+ #f (+ #f %x.2 %y.3) %a.5) %b.6))))))))))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, y, , , , , ] : [Field, Field, Field, Field] = [1, 2, 3, 4];"
      "  const [a, b, , , , , ] : Vector<4, Field> = [1, 2, 3, 4];"
      "  return x + y + a + b;"
      "}"
      )
    (returns
      (program
        (circuit %bad.0 ()
             (tfield)
          (let* ([[%__compact_pattern_tmp1.1 (ttuple
                                               (tfield)
                                               (tfield)
                                               (tfield)
                                               (tfield))]
                  (safe-cast (ttuple (tfield) (tfield) (tfield) (tfield))
                          (ttuple
                            (tunsigned 1)
                            (tunsigned 2)
                            (tunsigned 3)
                            (tunsigned 4))
                    (tuple 1 2 3 4))])
            (let* ([[%x.2 (tfield)]
                    (tuple-ref %__compact_pattern_tmp1.1 0)])
              (let* ([[%y.3 (tfield)]
                      (tuple-ref %__compact_pattern_tmp1.1 1)])
                (let* ([[%__compact_pattern_tmp2.4 (tvector 4 (tfield))]
                        (safe-cast (tvector 4 (tfield))
                                (ttuple
                                  (tunsigned 1)
                                  (tunsigned 2)
                                  (tunsigned 3)
                                  (tunsigned 4))
                          (tuple 1 2 3 4))])
                  (let* ([[%a.5 (tfield)]
                          (tuple-ref %__compact_pattern_tmp2.4 0)])
                    (let* ([[%b.6 (tfield)]
                            (tuple-ref %__compact_pattern_tmp2.4 1)])
                      (+ #f (+ #f (+ #f %x.2 %y.3) %a.5) %b.6))))))))))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, y, , , , , ] : [Field, Field, Field, Field] = [1, 2, 3, 4, true, true];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("[Uint<1>, Uint<0..3>, Uint<2>, Uint<0..5>, Boolean, Boolean]" "[Field, Field, Field, Field]")))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, z, y, ,] : [Field, Field] = [1, 2];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "index ~d is out-of-bounds for a ~a of length ~d" (2 "tuple" 2)))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, z, , y] = [1, 2, 3];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "index ~d is out-of-bounds for a ~a of length ~d" (3 "tuple" 3)))
    )

  (test
    '(
      "export circuit good(): Field {"
      "  const [x, z, y, ,] = [1, 2, 3];"
      "  return x + y;"
      "}"
      )
    (returns
      (program
        (circuit %good.0 ()
             (tfield)
          (safe-cast (tfield)
                  (tunsigned 4)
            (let* ([[%__compact_pattern_tmp1.1 (ttuple
                                                 (tunsigned 1)
                                                 (tunsigned 2)
                                                 (tunsigned 3))]
                    (tuple 1 2 3)])
              (let* ([[%x.2 (tunsigned 1)]
                      (tuple-ref %__compact_pattern_tmp1.1 0)])
                (let* ([[%z.3 (tunsigned 2)]
                        (tuple-ref %__compact_pattern_tmp1.1 1)])
                  (let* ([[%y.4 (tunsigned 3)]
                          (tuple-ref %__compact_pattern_tmp1.1 2)])
                    (+ 3
                       (safe-cast (tunsigned 4) (tunsigned 1) %x.2)
                       (safe-cast (tunsigned 4) (tunsigned 3) %y.4))))))))))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, z, y, ,] : [Field, Field] = [1, 2, 3, 4];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("[Uint<1>, Uint<0..3>, Uint<2>, Uint<0..5>]" "[Field, Field]")))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, , y] : [Field, Field, Field] = [1, 2];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("[Uint<1>, Uint<0..3>]" "[Field, Field, Field]")))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, y, ,] : [Field, Field, Field] = [1, 2];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("[Uint<1>, Uint<0..3>]" "[Field, Field, Field]")))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, , y] : [Field, Field, Field] = [1, , 3];"
      "  return x + y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 48" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a tuple argument" "\"]\""))))
    )

  (test
    '(
      "export circuit bad(): Field {"
      "  const [x, , y] : [Field, Field, Field] = [1, 2, 3];"
      "  const [a, , b] : Vector<3, Field> = [1, 2, 3];"
      "  return x + y + a + b;"
      "}"
      )
    (returns
      (program
        (circuit %bad.0 ()
             (tfield)
          (let* ([[%__compact_pattern_tmp1.1 (ttuple
                                               (tfield)
                                               (tfield)
                                               (tfield))]
                  (safe-cast (ttuple (tfield) (tfield) (tfield))
                          (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                    (tuple 1 2 3))])
            (let* ([[%x.2 (tfield)]
                    (tuple-ref %__compact_pattern_tmp1.1 0)])
              (let* ([[%y.3 (tfield)]
                      (tuple-ref %__compact_pattern_tmp1.1 2)])
                (let* ([[%__compact_pattern_tmp2.4 (tvector 3 (tfield))]
                        (safe-cast (tvector 3 (tfield))
                                (ttuple
                                  (tunsigned 1)
                                  (tunsigned 2)
                                  (tunsigned 3))
                          (tuple 1 2 3))])
                  (let* ([[%a.5 (tfield)]
                          (tuple-ref %__compact_pattern_tmp2.4 0)])
                    (let* ([[%b.6 (tfield)]
                            (tuple-ref %__compact_pattern_tmp2.4 2)])
                      (+ #f (+ #f (+ #f %x.2 %y.3) %a.5) %b.6))))))))))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit good(): Field {"
      "  const {a, } : S = S {1, true, false};"
      "  return a;"
      "}"
      )
    (returns
      (program
        (circuit %good.0 ()
             (tfield)
          (let* ([[%__compact_pattern_tmp1.1 (tstruct S
                                               (a (tfield))
                                               (b (tboolean))
                                               (c (tboolean)))]
                  (new (tstruct S (a (tfield)) (b (tboolean)) (c (tboolean)))
                    (safe-cast (tfield) (tunsigned 1) 1)
                    #t
                    #f)])
            (let* ([[%a.2 (tfield)]
                    (elt-ref %__compact_pattern_tmp1.1 a 0)])
              %a.2)))))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a, } : S = S {a: 1, };"
      "  return a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 21" "value for element ~s is missing in creation syntax for ~a" (b "struct S<a: Field, b: Boolean, c: Boolean>")))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a, b, c} : S = S {1, true, };"
      "  return a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 25" "value for element ~s is missing in creation syntax for ~a" (c "struct S<a: Field, b: Boolean, c: Boolean>")))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a: x, } : S = S {1, true, false};"
      "  return x;"
      "}"
      )
    (returns
      (program
        (circuit %bad.0 ()
             (tfield)
          (let* ([[%__compact_pattern_tmp1.1 (tstruct S
                                               (a (tfield))
                                               (b (tboolean))
                                               (c (tboolean)))]
                  (new (tstruct S (a (tfield)) (b (tboolean)) (c (tboolean)))
                    (safe-cast (tfield) (tunsigned 1) 1)
                    #t
                    #f)])
            (let* ([[%x.2 (tfield)]
                    (elt-ref %__compact_pattern_tmp1.1 a 0)])
              %x.2)))))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a: b, b } : S = S {1, true, false};"
      "  return a;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 9" "found multiple bindings for ~s in the same block" (b)))
    )

  (test
    '(
      "struct S {a: Field, b: Boolean, c: Boolean}"
      "export circuit bad(): Field {"
      "  const {a: b, b: x } : S = S {1, true, false};"
      "  return b;"
      "}"
      )
    (returns
      (program
        (circuit %bad.0 ()
             (tfield)
          (let* ([[%__compact_pattern_tmp1.1 (tstruct S
                                               (a (tfield))
                                               (b (tboolean))
                                               (c (tboolean)))]
                  (new (tstruct S (a (tfield)) (b (tboolean)) (c (tboolean)))
                    (safe-cast (tfield) (tunsigned 1) 1)
                    #t
                    #f)])
            (let* ([[%b.2 (tfield)]
                    (elt-ref %__compact_pattern_tmp1.1 a 0)])
              (let* ([[%x.3 (tboolean)]
                      (elt-ref %__compact_pattern_tmp1.1 b 1)])
                %b.2))))))
    )

  ; test for pattern blog post
  (test
    '(
      "enum Material { wood, glass, steel }"
      "struct Box { dimensions: [Field, Field, Field], material: Material }"
      "export circuit demo(): [] {"
      "  const myBox = Box { dimensions: [1, 2, 3], material: Material.wood };"
      "  const { dimensions: [length, width, height], material } = myBox;"
      "}"
      )
    (succeeds))

  (test
    '(
      "enum Material { wood, glass, steel }"
      "struct Box { dimensions: [Field, Field, Field], material: Material }"
      "export circuit demo(): [] {"
      "  const { dimensions: [x, , , z] } = Box { [1, 2, 3], Material.wood};"
      "}"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 23" "index ~d is out-of-bounds for a ~a of length ~d" (3 "tuple" 3)))
    )

  (test
    '(
      "enum Material { wood, glass, steel }"
      "struct Box { dimensions: [Field, Field, Field], material: Material }"
      "export circuit demo(): [] {"
      "  const { dimensions: [x, z, , , ] } = Box { [1, 2, 3], Material.wood};"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "export circuit do_sth(): Field {"
       "  return fold((x: Field, [a, b]: [Field, Field]): Field => a + b + x, 0, [[1, 2], [2, 3], [3, 4]]);"
       "}"
       )
    (succeeds))

  ; tests for writing lang ref of return
  (test
    '(
      "export circuit foo(): [] {}"
      )
    (returns (program (circuit %foo.0 () (ttuple) (tuple)))))

  (test
    '(
      "export circuit foo(): [] { return ;}"
      )
    (returns (program (circuit %foo.0 () (ttuple) (tuple)))))

  (test
    '(
      "export circuit foo(): Boolean {}"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "mismatch between actual return type ~a and declared return type ~a of ~a" ("[]" "Boolean" "circuit foo")))
    )

  (test
    '(
      "export circuit foo(c: Boolean): Boolean { if (c) true;}"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "mismatch between actual return type ~a and declared return type ~a of ~a" ("[]" "Boolean" "circuit foo")))
    )

  (test
    '(
      "export circuit foo(c: Boolean): Boolean { if (true) {return c;} }"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 43" "mismatch between type ~a and type ~a of condition branches" ("Boolean" "[]")))
    )

  (test
    '(
      "export circuit foo(c: Boolean): Boolean { if (c) {return true; return 1;} else return false; }"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 64" "unreachable statement" ()))
    )

  (test
    '(
      "export circuit foo(c: Boolean): Boolean { if (c) {return true; const a = 1;} else return false; }"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 70" "unreachable statement" ()))
    )

  (test
    '(
      "export circuit foo(c: Boolean): Boolean { if (c) {return true; return +1;} else return false; }"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 71" "parse error: found ~a looking for~?" ("\"+\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression sequence" "\";\""))))
    )

  (test
    '(
      "export circuit foo(): Boolean { return true, 1; }"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 33" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<1>" "Boolean" "circuit foo")))
    )

  (test
    '(
      "export circuit foo(): Boolean { return 1, true; }"
      )
    (returns
       (program (circuit %foo.0 () (tboolean) (seq 1 #t))))
    )

  (test
    '(
      "export circuit foo(): [] { ((x) => {return;})(true); }"
      )
    (returns
       (program
         (circuit %foo.0 ()
              (ttuple)
           (seq
             (call (circuit ([%x.1 (tboolean)]) (ttuple) (tuple)) #t)
             (tuple)))))
    )

  (test
    '(
      "export circuit foo(): [] { return ((x) => {return;})(true); }"
      )
    (returns
       (program
         (circuit %foo.0 ()
              (ttuple)
           (call (circuit ([%x.1 (tboolean)]) (ttuple) (tuple)) #t))))
    )

  (test
    '(
      "constructor () { return; }"
      )
    (returns (program (constructor () (tuple))))
    )

  (test
    '(
      "constructor () { return true; }"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 18" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "[]" "ledger constructor")))
    )

  (test
    '(
      "export circuit foo(c: Boolean): Boolean {"
      "  return ((x) : Boolean => {"
      "    if (c)"
      "       return x;"
      "    else"
      "       return !x;"
      "    })(c);"
      "}"
      )
    (returns
       (program
         (circuit %foo.0 ([%c.1 (tboolean)])
              (tboolean)
           (call (circuit ([%x.2 (tboolean)])
                      (tboolean)
                   (if %c.1 %x.2 (if %x.2 #f #t)))
             %c.1))))
    )

  (test
    '(
      "export circuit foo(c: Boolean): Boolean {"
      "  return ((x) : Boolean => {"
      "    if (c)"
      "       return x;"
      "    })(c);"
      "}"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 3 char 5" "mismatch between type ~a and type ~a of condition branches" ("Boolean" "[]")))
    )

  ; test for bounds of merkle trees
  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: MerkleTree<~d, Boolean>;" (min-merkle-tree-depth))
      ,(format "ledger field2: MerkleTree<~d, Boolean>;" (max-merkle-tree-depth))
      )
    (succeeds))

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: MerkleTree<~d, Boolean>;" (- (min-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 16" "~a depth ~d does not fall in ~d <= depth <= ~d" (MerkleTree ,(- (min-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: MerkleTree<~d, Boolean>;" (+ (max-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 16" "~a depth ~d does not fall in ~d <= depth <= ~d" (MerkleTree ,(+ (max-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: MerkleTree<5, MerkleTree<~d, Boolean>>;" (+ (max-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 30" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("non-ADT type" "ledger ADT type" value_type "<standard library>")))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "module M<#n>{"
      "  export ledger field1: MerkleTree<n, Boolean>;"
      "}"
      ,(format "import M<~d>;" (+ (max-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 25" "~a depth ~d does not fall in ~d <= depth <= ~d" (MerkleTree ,(+ (max-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "module M<#n>{"
      "  export ledger field1: MerkleTree<n, Boolean>;"
      "}"
      ,(format "import M<~d>;" (- (min-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 25" "~a depth ~d does not fall in ~d <= depth <= ~d" (MerkleTree ,(- (min-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: HistoricMerkleTree<~d, Boolean>;" (min-merkle-tree-depth))
      ,(format "ledger field2: HistoricMerkleTree<~d, Boolean>;" (max-merkle-tree-depth))
      )
    (succeeds))

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: HistoricMerkleTree<~d, Boolean>;" (- (min-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 16" "~a depth ~d does not fall in ~d <= depth <= ~d" (HistoricMerkleTree ,(- (min-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: HistoricMerkleTree<~d, Boolean>;" (+ (max-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 16" "~a depth ~d does not fall in ~d <= depth <= ~d" (HistoricMerkleTree ,(+ (max-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    '(
      "export circuit foo(): Boolean { return 1, true; }"
      )
    (returns
      (program (circuit %foo.0 () (tboolean) (seq 1 #t))))
    )

  (test
    '(
      "export circuit foo(): [] { ((x) => {return;})(true); }"
      )
    (returns
       (program
         (circuit %foo.0 ()
              (ttuple)
           (seq
             (call (circuit ([%x.1 (tboolean)]) (ttuple) (tuple)) #t)
             (tuple)))))
   )

  (test
    '(
      "export circuit foo(): [] { return ((x) => {return;})(true); }"
      )
    (returns
       (program
         (circuit %foo.0 ()
              (ttuple)
           (call (circuit ([%x.1 (tboolean)]) (ttuple) (tuple)) #t))))
    )

  (test
    '(
      "constructor () { return; }"
      )
    (returns (program (constructor () (tuple))))
    )

  (test
    '(
      "constructor () { return true; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 18" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "[]" "ledger constructor")))
    )

  (test
    '(
      "export circuit foo(c: Boolean): Boolean {"
      "  return ((x) : Boolean => {"
      "    if (c)"
      "       return x;"
      "    else"
      "       return !x;"
      "    })(c);"
      "}"
      )
    (returns
      (program
        (circuit %foo.0 ([%c.1 (tboolean)])
             (tboolean)
          (call (circuit ([%x.2 (tboolean)])
                     (tboolean)
                  (if %c.1 %x.2 (if %x.2 #f #t)))
            %c.1))))
    )

  (test
    '(
      "export circuit foo(c: Boolean): Boolean {"
      "  return ((x) : Boolean => {"
      "    if (c)"
      "       return x;"
      "    })(c);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 5" "mismatch between type ~a and type ~a of condition branches" ("Boolean" "[]")))
    )

    ; test for bounds of merkle trees
  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: MerkleTree<~d, Boolean>;" (min-merkle-tree-depth))
      ,(format "ledger field2: MerkleTree<~d, Boolean>;" (max-merkle-tree-depth))
      )
    (succeeds))

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: MerkleTree<~d, Boolean>;" (- (min-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 16" "~a depth ~d does not fall in ~d <= depth <= ~d" (MerkleTree ,(- (min-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: MerkleTree<~d, Boolean>;" (+ (max-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 16" "~a depth ~d does not fall in ~d <= depth <= ~d" (MerkleTree ,(+ (max-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: MerkleTree<5, MerkleTree<~d, Boolean>>;" (+ (max-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 30" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("non-ADT type" "ledger ADT type" value_type "<standard library>")))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "module M<#n>{"
      "  export ledger field1: MerkleTree<n, Boolean>;"
      "}"
      ,(format "import M<~d>;" (+ (max-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 25" "~a depth ~d does not fall in ~d <= depth <= ~d" (MerkleTree ,(+ (max-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "module M<#n>{"
      "  export ledger field1: MerkleTree<n, Boolean>;"
      "}"
      ,(format "import M<~d>;" (- (min-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 25" "~a depth ~d does not fall in ~d <= depth <= ~d" (MerkleTree ,(- (min-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: HistoricMerkleTree<~d, Boolean>;" (min-merkle-tree-depth))
      ,(format "ledger field2: HistoricMerkleTree<~d, Boolean>;" (max-merkle-tree-depth))
      )
    (succeeds)
    )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: HistoricMerkleTree<~d, Boolean>;" (- (min-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 16" "~a depth ~d does not fall in ~d <= depth <= ~d" (HistoricMerkleTree ,(- (min-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "ledger field1: HistoricMerkleTree<~d, Boolean>;" (+ (max-merkle-tree-depth) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 16" "~a depth ~d does not fall in ~d <= depth <= ~d" (HistoricMerkleTree ,(+ (max-merkle-tree-depth) 1) ,(min-merkle-tree-depth) ,(max-merkle-tree-depth))))
    )
)

; tests limits for vectors, bytes, and tuples.
; it sets max-bytes/vector-length to 150 for testing to avoid waiting a noticable time
; for tests that builds max possible tuples.
; NB: if you set this to lower than what some of the types in standard library use
; (e.g., 32 or 64) you'd get a different error for tests that import std.
(parameterize ([max-bytes/vector-length 150])
(run-tests expand-modules-and-types
  ; tests for bounds of vectors
  (test
    `(
      ,(format "export sealed ledger foo: Vector<~d, Boolean>;" (max-bytes/vector-length))
      )
    (succeeds))

  (test
    `(
      ,(format "export sealed ledger foo: Vector<~d, Boolean>;" (+ (max-bytes/vector-length) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 27" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("vector type" 151 150)))
   )

  (test
    '(
      "export sealed ledger foo: Vector<0, Boolean>;"
      )
    (succeeds))

  (test
    '(
      "export sealed ledger foo: Vector<-1, Boolean>;"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 34" "parse error: found ~a looking for~?" ("\"-\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a type size"))))
    )

  (test
    `(
      "module M<#n>{"
      "  export circuit foo(v: Vector<n, Boolean>): Vector<n, Boolean> {"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d> prefix $;" (max-bytes/vector-length))
      "export { $foo }"
      )
    (succeeds))

  (test
    `(
      "module M<#n>{"
      "  export circuit foo(v: Vector<n, Boolean>): Vector<n, Boolean> {"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d> prefix $;" (+ (max-bytes/vector-length) 1))
      "export { $foo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 25" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("vector type" 151 150)))
    )

  ; test for bounds of bytes
  (test
    `(
      ,(format "export sealed ledger foo: Bytes<~d>;" (max-bytes/vector-length))
      )
    (succeeds))

  (test
    `(
      ,(format "export sealed ledger foo: Bytes<~d>;" (+ (max-bytes/vector-length) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 27" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("bytes type" 151 150)))
    )

  (test
    '(
      "export sealed ledger foo: Bytes<0>;"
      )
    (succeeds))

  (test
    '(
      "export sealed ledger foo: Bytes<-1>;"
      )
    (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 33" "parse error: found ~a looking for~?" ("\"-\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a type size"))))
    )

  ; test for bounds of tuples
  (test
    `(
      ,(format "export sealed ledger foo: ~a;"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (max-bytes/vector-length)))
      )
    (succeeds))

  (test
    `(
      ,(format "export sealed ledger foo: ~a;"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (+ (max-bytes/vector-length) 1)))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 27" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("tuple type" 151 150)))
    )

  (test
    `(
      "export circuit foo() : [] {"
      ,(format "  const x = '~a';" (make-string (+ (max-bytes/vector-length) 1) #\x))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 13" "length ~d of the UTF-8 representation of string constant exceeds the maximum supported length ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )
)

(run-tests infer-types
  ; test for bounds of pads
  (test
    `(
      ,(format "export circuit foo() : Bytes<~d>{" (max-bytes/vector-length))
      ,(format "  return pad(~d,'a');" (max-bytes/vector-length))
      "}"
      )
    (succeeds))

  (test
    `(
      "export circuit foo() : Bytes<0>{"
      "  return pad(0,'a');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "cannot pad ~s to length ~s since its utf8-equivalent already exceeds that length" ("a" 0)))
    )

  (test
    `(
      ,(format "export circuit foo() : Bytes<~d>{" (max-bytes/vector-length))
      ,(format "  return pad(~d,'a');" (+ (max-bytes/vector-length) 1))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 10" "pad length ~d exceeds the maximum supported length ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit foo() : Bytes<~d>{" (max-bytes/vector-length))
      ,(format "  return pad(~d,'a');" -1)
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 14" "parse error: found ~a looking for~?" ("\"-\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a non-negative numeric constant"))))
    )

  (test
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Vector<~d, Field> {"
               (+ (max-bytes/vector-length) 1)
               (+ (max-bytes/vector-length) 1))
      "  return v;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("vector type" 151 150)))
    )

  (test
    `(
      ,(format "export circuit foo(v: Bytes<~d>): Bytes<~d> {"
               (+ (max-bytes/vector-length) 1)
               (+ (max-bytes/vector-length) 1))
      "  return v;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("bytes type" 151 150)))
    )

  (test
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Vector<1, Field> {" (max-bytes/vector-length))
      ,(format "  return slice<1>(v, ~d);" (max-bytes/vector-length))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 22" "index ~d exceeds maximum index allowed ~d for a ~a slicing" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "vector")))
    )

  (test
    `(
      ,(format "export circuit foo(v: ~a): [Field] {"
              ((lambda (n)
                 (let loop ([i 0] [result '()])
                   (if (= i n)
                       (format #f "[~{~a~^, ~}]" (reverse result))
                       (loop (+ i 1) (cons "Field" result))))) (max-bytes/vector-length)))
      ,(format "  return slice<1>(v, ~d);" (max-bytes/vector-length))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 22" "index ~d exceeds maximum index allowed ~d for a ~a slicing" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "tuple")))
    )

  (test
    `(
      ,(format "export circuit foo(v: ~a): [Field] {"
              ((lambda (n)
                 (let loop ([i 0] [result '()])
                   (if (= i n)
                       (format #f "[~{~a~^, ~}]" (reverse result))
                       (loop (+ i 1) (cons "Field" result))))) (max-bytes/vector-length)))
      ,(format "  return v[~d];" (max-bytes/vector-length))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 12" "index ~d exceeds maximum allowed index ~d for a ~a reference" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "tuple")))
    )

  (test
    `(
      ,(format "export circuit foo(v: Bytes<~d>): Bytes<~d> {"
               (max-bytes/vector-length)
               (+ (max-bytes/vector-length) 1))
      ,(format "  return slice<~d>(v, ~d);"
               (max-bytes/vector-length)
               (max-bytes/vector-length))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 36" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("bytes type" 151 150)))
    )

  (test
    `(
      ,(format "export circuit foo(v: Bytes<~d>): [] {" (max-bytes/vector-length))
      "  return slice<10>(Bytes[...v, 1], 10);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 20" "Bytes construction length\n    ~d exceeds the maximum bytes length allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
   )

  (test
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Vector<2, Field> {" (max-bytes/vector-length))
      ,(format "  return slice<2>(v, ~d);" (max-bytes/vector-length))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 22" "index ~d exceeds maximum index allowed ~d for a ~a slicing" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "vector")))
    )

  (test
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Vector<2, Field> {" (- (max-bytes/vector-length) 1))
      ,(format "  return slice<2>(v, ~d);" (max-bytes/vector-length))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 22" "index ~d exceeds maximum index allowed ~d for a ~a slicing" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "vector")))
    )

  (test
    `(
      ,(format "export circuit foo(v: ~a): [Field, Field] {"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (max-bytes/vector-length)))
      ,(format "  return slice<2>(v, ~d);" (max-bytes/vector-length))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 22" "index ~d exceeds maximum index allowed ~d for a ~a slicing" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "tuple")))
    )

  (test
    `(
      ,(format "export circuit foo(b: Bytes<~d>): [] {" (max-bytes/vector-length))
      ,(format "  const x = slice<1>(~a, 0);"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "Bytes[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "0" result))))) (+ (max-bytes/vector-length) 1)))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 22" "Bytes construction length\n    ~d exceeds the maximum bytes length allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      "module M<#K> {"
      "circuit bar<#I>(v: Bytes<K>): Bytes<I> {"
      "  return slice<I>(v, 2);"
      "}"
      "export circuit foo(v: Bytes<K>): Bytes<1> {"
      "  return bar<1>(v);"
      "}"
      "}"
      ,(format "import M<~d>;" (+ (max-bytes/vector-length) 1))
      "export { foo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 23" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("bytes type" 151 150)))
    )

  (test
    `(
      ,(format "export circuit bar(v: Vector<~d, Field>, i: Vector<1, Field>): [] {" (max-bytes/vector-length))
      "  const x = [...v, ...i];"
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 13" "the size of tuple/vector construction expression with vector-typed spread\n    ~d\n  exceeds the maximum vector size allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit bar(v: Vector<~d, Field>, i: Vector<1, Field>): [] {" (- (max-bytes/vector-length) 1))
      "  const x = [...v, ...i];"
      "  return ;"
      "}"
      )
    (succeeds)
    )

  (test
    `(
      ,(format "export circuit bar(v: Vector<~d, Field>, i: Vector<2, Field>): [] {" (- (max-bytes/vector-length) 1))
      "  const x = [...v, ...i];"
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 13" "the size of tuple/vector construction expression with vector-typed spread\n    ~d\n  exceeds the maximum vector size allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit bar(v: Vector<~d, Field>, i: Vector<1, Field>): [] {" (max-bytes/vector-length))
      ,(format "  const y = v as ~a;"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (max-bytes/vector-length)))
      "  const x = [...y, ...i];"
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 13" "the size of tuple/vector construction expression with vector-typed spread\n    ~d\n  exceeds the maximum vector size allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit bar(v: Vector<~d, Field>, i: [Field]): [] {" (max-bytes/vector-length))
      ,(format "  const y = v as ~a;"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (max-bytes/vector-length)))
      "  const x = [...y, ...i];"
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 13" "the size of tuple/vector construction expression with tuple-typed spread\n    ~d\n  exceeds the maximum tuple size allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit bar(v: ~a, i: [Field]): [] {"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (max-bytes/vector-length)))
      "  const x = [...v, ...i];"
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 13" "the size of tuple/vector construction expression with tuple-typed spread\n    ~d\n  exceeds the maximum tuple size allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit foo(v: ~a): ~a {"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (+ (max-bytes/vector-length) 1))
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (+ (max-bytes/vector-length) 1)))
      "  return v;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("tuple type" 151 150)))
    )

  (test
    `(
      "export circuit bar(i: [Field, Field]): [] {"
      ,(format " const v = ~a;"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "1" result))))) (- (max-bytes/vector-length) 1)))
      "  const x = [...v, ...i];"
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 13" "the size of tuple/vector construction expression with tuple-typed spread\n    ~d\n  exceeds the maximum tuple size allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit bar(v: ~a, i: [Field]): ~a {"
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (- (max-bytes/vector-length) 1))
               ((lambda (n)
                  (let loop ([i 0] [result '()])
                    (if (= i n)
                        (format #f "[~{~a~^, ~}]" (reverse result))
                        (loop (+ i 1) (cons "Field" result))))) (max-bytes/vector-length)))
      "  const x = [...v, ...i];"
      "  return x;"
      "}"
      )
    (succeeds)
    )

  (test
    `(
      ,(format "export circuit bar(v: Vector<~d, Field>, i: [Field]): [] {" (max-bytes/vector-length))
      "  const x = [...v, ...i];"
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 13" "the size of tuple/vector construction expression with vector-typed spread\n    ~d\n  exceeds the maximum vector size allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit bar(v: Vector<~d, Field>, i: [Field]): [] {" (- (max-bytes/vector-length) 1))
      "  const x = [...v, ...i];"
      "  return ;"
      "}"
      )
    (succeeds)
    )

  (test
    `(
      ,(format "export circuit bar(v: Vector<~d, Field>, i: [Field, Field]): [] {" (- (max-bytes/vector-length) 1))
      "  const x = [...v, ...i];"
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 13" "the size of tuple/vector construction expression with vector-typed spread\n    ~d\n  exceeds the maximum vector size allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit bar(v: Vector<~d, Field>, i: [Field, Field]): [] {" (- (max-bytes/vector-length) 1))
      "  const x = [...i, ...v];"
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 13" "the size of tuple/vector construction expression with vector-typed spread\n    ~d\n  exceeds the maximum vector size allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "export circuit foo(f: Field): [] {"
      ,(format "  const x = transientHash<Vector<~d, Field>>(f);" (+ (max-bytes/vector-length) 1))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 27" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("vector type" 151 150)))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "export circuit foo(f: Field): [] {"
      ,(format "  const x = transientHash<Bytes<~d>>(f);" (+ (max-bytes/vector-length) 1))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 27" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("bytes type" 151 150)))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "export circuit foo(f: Field): [] {"
      ,(format "  const x = transientHash<~a>(f);"
               ((lambda (n)
                    (let loop ([i 0] [result '()])
                      (if (= i n)
                          (format #f "[~{~a~^, ~}]" (reverse result))
                          (loop (+ i 1) (cons "Field" result))))) (+ (max-bytes/vector-length) 1)))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 27" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("tuple type" 151 150)))
    )

  (test
    `(
      "ledger F: Vector<10, Field>;"
      ,(format "export circuit foo(bv: Vector<~d, Field>): [] {" (max-bytes/vector-length))
      ,(format "  F = [255, ...slice<~d>(disclose(bv), 1), 0];" (max-bytes/vector-length))
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 16" "slice index ~d plus length ~d is out-of-bounds for a ~a of length ~d" (1 ,(max-bytes/vector-length) "vector" ,(max-bytes/vector-length))))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      ,(format "export circuit foo(bv: Bytes<~d>): [] {" (max-bytes/vector-length))
      ,(format "  F = Bytes[255, ...slice<~d>(disclose(bv), 1), 0];" (- (max-bytes/vector-length) 1))
      "  return ;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 7" "Bytes construction length\n    ~d exceeds the maximum bytes length allowed\n    ~d" (,(+ (max-bytes/vector-length) 1) ,(max-bytes/vector-length))))
    )

  ; PM-19767
  (test
    '(
      "import CompactStandardLibrary;"
      "constructor(){"
      "  for (const bob of slice<197908171978938887506682837333954029155>(default<Either<Field,SendResult>>, 0o23103656654)) {"
      "  }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 21" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("slice" 197908171978938887506682837333954029155 150)))
   )

  (test
    `(
      "import CompactStandardLibrary;"
      ,(format "constructor(v: Vector<~d, Field>){" (max-bytes/vector-length))
      "  for (const bob of slice<197908171978938887506682837333954029155>(v, 0)) {"
      "  }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 21" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("slice" 197908171978938887506682837333954029155 150)))
   )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(): []{"
      "  for (const bob of slice<197908171978938887506682837333954029155>(default<Either<Field,SendResult>>, 0o23103656654)) {"
      "  }"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 21" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("slice" 197908171978938887506682837333954029155 150)))
   )

  (test
    '(
      "import CompactStandardLibrary;"
      "constructor(){"
      "  const bob = pad(153991381835065054463771822173069549287, 'oBjlyD');"
      "  const tom = slice<0>(default<Opaque<'string'>>, 57855240729977993385528989091578690226);"
      "  assert (lambda <= bob, 'QYZqgUFVDnuR');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 15" "pad length ~d exceeds the maximum supported length ~d" (153991381835065054463771822173069549287 ,(max-bytes/vector-length))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "constructor(){"
      "  const bob = default<CoinInfo>;"
      "  const tom = pad(0b1000110101110110011101100011111, 'mABfLuWsISiQzXzpZMgaPXwnrnsy');"
      "  assert (tom == bob < bob, 'WFleWyhsudhbmة');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 4 char 15" "pad length ~d exceeds the maximum supported length ~d" (1186675487 ,(max-bytes/vector-length))))
    )

  (test
    `(
      "module M<#n>{"
      "  export circuit foo(v: Vector<n, Boolean>): Vector<n, Boolean> {"
      "    return slice<n>(v, 1);"
      "  }"
      "}"
      ,(format "import M<~d> prefix $;" (+ (max-bytes/vector-length) 0))
      "export { $foo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 3 char 12" "slice index ~d plus length ~d is out-of-bounds for a ~a of length ~d" (1 ,(max-bytes/vector-length) "vector" ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit foo(v: Bytes<~d>): [] {" (max-bytes/vector-length))
      ,(format "  const x = v as Bytes<~d>;" (+ (max-bytes/vector-length) 1))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 18" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("bytes type" 151 150)))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit foo(v: Vector<n, Field>): Field { return v[n]; }"
      "}"
      ,(format "import M<~d>;" (max-bytes/vector-length))
      "export { foo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 61" "index ~d exceeds maximum allowed index ~d for a ~a reference" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "vector")))
    )

  (test ; this is caught in resolve-indices/simplify
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Field { const n = ~d; return v[n+1]; }"
               (max-bytes/vector-length)
               (- (max-bytes/vector-length) 1))
      )
    (returns
      (program
        (circuit %foo.0 ([%v.1 (tvector ,(max-bytes/vector-length) (tfield))])
             (tfield)
          (let* ([[%n.2 (tunsigned ,(- (max-bytes/vector-length) 1))] ,(- (max-bytes/vector-length) 1)])
            (vector-ref
              %v.1
              (+ 8
                 (safe-cast (tunsigned ,(max-bytes/vector-length)) (tunsigned ,(- (max-bytes/vector-length) 1)) %n.2)
                 (safe-cast (tunsigned ,(max-bytes/vector-length)) (tunsigned 1) 1))))))))

  (test
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Field { return v[~d]; }"
               (max-bytes/vector-length)
               (max-bytes/vector-length))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 61" "index ~d exceeds maximum allowed index ~d for a ~a reference" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "vector")))
    )

  (test ; this is caught in resolve-indices/simplify
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Field { return v[~d + 1]; }"
               (max-bytes/vector-length)
               (- (max-bytes/vector-length) 1))
      )
    (returns
      (program
        (circuit %foo.0 ([%v.1 (tvector ,(max-bytes/vector-length) (tfield))])
             (tfield)
          (vector-ref
            %v.1
            (+ 8
               (safe-cast (tunsigned ,(max-bytes/vector-length)) (tunsigned ,(- (max-bytes/vector-length) 1)) ,(- (max-bytes/vector-length) 1))
               (safe-cast (tunsigned ,(max-bytes/vector-length)) (tunsigned 1) 1)))))))
)

(run-tests resolve-indices/simplify
  (test
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Field { return v[~d+1]; }"
               (max-bytes/vector-length)
               (- (max-bytes/vector-length) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 59" "invalid vector index ~d for vector of length ~d" (,(max-bytes/vector-length) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Field { return v[~d]; }"
               (max-bytes/vector-length)
               (max-bytes/vector-length))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 61" "index ~d exceeds maximum allowed index ~d for a ~a reference" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "vector")))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit foo(v: Vector<n, Field>): Field { return v[n]; }"
      "}"
      ,(format "import M<~d>;" (max-bytes/vector-length))
      "export { foo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 61" "index ~d exceeds maximum allowed index ~d for a ~a reference" (,(max-bytes/vector-length) ,(- (max-bytes/vector-length) 1) "vector")))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit foo(v: Vector<n, Field>): Field { return v[n]; }"
      "}"
      ,(format "import M<~d>;" (- (max-bytes/vector-length) 1))
      "export { foo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 59" "index ~d is out-of-bounds for a ~a of length ~d" (,(- (max-bytes/vector-length) 1) "vector" ,(- (max-bytes/vector-length) 1))))
    )

  (test
    `(
      ,(format "export circuit foo(): [] { const x = pad(~d, 'hi')[~d]; }"
               (max-bytes/vector-length)
               (- (max-bytes/vector-length) 1))
      )
    (succeeds)
    )

  (test
    `(
      ,(format "export circuit foo(): [] { const x = pad(~d, 'hi')[~d]; }"
               (- (max-bytes/vector-length) 1)
               (- (max-bytes/vector-length) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 38" "invalid Bytes index ~d for a Bytes value of length ~d" (,(- (max-bytes/vector-length) 1) ,(- (max-bytes/vector-length) 1))))
    )

  (test
    `(
      ,(format "export circuit foo(): [] { const x = pad(~d, 'hi')[~d]; }"
               (max-bytes/vector-length)
               (max-bytes/vector-length))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 38" "invalid Bytes index ~d for a Bytes value of length ~d" (,(max-bytes/vector-length) ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit foo(): [] { const x = slice<1>(pad(~d, 'hi'), ~d); }"
               (max-bytes/vector-length)
               (max-bytes/vector-length))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 38" "invalid slice index ~d and length ~d for a Bytes value of length ~d" (,(max-bytes/vector-length) 1 ,(max-bytes/vector-length))))
    )

  (test
    `(
      ,(format "export circuit foo(): [] { const x = slice<1>(pad(~d, 'hi'), ~d); }"
               (max-bytes/vector-length)
               (- (max-bytes/vector-length) 5))
      )
    (succeeds)
    )

  (test
    `(
      ,(format "export circuit foo(v: Vector<~d, Field>): Field { const n = ~d; return v[n+1]; }"
               (max-bytes/vector-length)
               (- (max-bytes/vector-length) 1))
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 1 char 74" "invalid vector index ~d for vector of length ~d" (,(max-bytes/vector-length) ,(max-bytes/vector-length))))
    )

  (test
    '(
      "export circuit foo(v: Bytes<10>): Bytes<1> {"
      "  return slice<1>(v, 10);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "invalid slice index ~d and length ~d for a Bytes value of length ~d" (10 1 10)))
    )

  (test
    '(
      "export circuit foo(v: Bytes<3>): Bytes<3> {"
      "  return slice<3>(v, 3);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "invalid slice index ~d and length ~d for a Bytes value of length ~d" (3 3 3)))
    )

  (test
    '(
      "export circuit foo(v: Bytes<3>): Bytes<3> {"
      "  return slice<3>(v, 2+1);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "invalid slice index ~d and length ~d for a Bytes value of length ~d" (3 3 3)))
   )

  (test
    '(
      "module M<#K> {"
      "  circuit bar<#I>(v: Bytes<K>): Bytes<I> {"
      "    return slice<I>(v, 2);"
      "  }"
      "  export circuit foo(v: Bytes<K>): Bytes<1> {"
      "    return bar<1>(v);"
      "  }"
      "}"
      "import M<1>;"
      "export { foo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 12" "invalid slice index ~d and length ~d for a Bytes value of length ~d" (2 1 1)))
    )
))

(run-tests combine-ledger-declarations
  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "export ledger field2: Counter;"
      "constructor() {}"
      "ledger field3: Counter;"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Counter))
          (%field2.2 (Counter))
          (%field3.3 (Counter))
          (constructor () (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Counter;"
      "constructor() {}"
      "ledger field3: Counter;"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Counter))
          (%field2.2 (Counter))
          (%field3.3 (Counter))
          (constructor () (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "export ledger field2: Counter;"
      "export ledger field3: Counter;"
      "constructor() {}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Counter))
          (%field2.2 (Counter))
          (%field3.3 (Counter))
          (constructor () (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1.read();"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Counter))
          (constructor () (tuple)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (public-ledger %field1.1 (read))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Counter))
          (constructor () (tuple)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (public-ledger %field1.1 (read))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "witness merkle_path_root(foo: Foo): MerkleTreeDigest;"
      ""
      "ledger field1: Map<Field, Foo>;"
      "ledger field2: HistoricMerkleTree<10, Foo>;"
      "ledger field3: Boolean;"
      ""
      "export circuit foo(n: Field, foo: Foo): Boolean {"
      "  field3.write(field1.lookup(n).baz);"
      "  return field2.checkRoot(merkle_path_root(field1.lookup(n)));"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1
            (Map (tfield)
                 (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
          (%field2.2
            (HistoricMerkleTree
              10
              (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
          (%field3.3 (__compact_Cell (tboolean)))
          (constructor () (tuple)))
        (witness %merklePathRoot.4 ([%foo.5 (tstruct Foo
                                                (bar (tbytes 32))
                                                (baz (tboolean)))])
             (tstruct MerkleTreeDigest (field (tfield))))
        (circuit %foo.6 ([%n.7 (tfield)]
                         [%foo.8 (tstruct Foo
                                   (bar (tbytes 32))
                                   (baz (tboolean)))])
             (tboolean)
          (seq
            (public-ledger %field3.3
              (write
                (elt-ref (public-ledger %field1.1 (lookup %n.7)) baz 1)))
            (public-ledger %field2.2
              (checkRoot
                (call %merklePathRoot.4
                  (public-ledger %field1.1 (lookup %n.7)))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      ""
      "export circuit foo(x: Field): Field {"
      "  field1 += 5;"
      "  field1-=2;"
      "  field2 =x;"
      "  return field1 * field2;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Counter))
          (%field2.2 (__compact_Cell (tfield)))
          (constructor () (tuple)))
        (circuit %foo.3 ([%x.4 (tfield)])
             (tfield)
          (seq
            (public-ledger %field1.1
              (increment (safe-cast (tunsigned 65535) (tunsigned 5) 5)))
            (public-ledger %field1.1
              (decrement (safe-cast (tunsigned 65535) (tunsigned 2) 2)))
            (public-ledger %field2.2 (write %x.4))
            (* #f
               (safe-cast (tfield) (tunsigned 18446744073709551615)
                 (public-ledger %field1.1 (read)))
               (public-ledger %field2.2 (read)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Xounter;"
      "ledger field2: Field;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 16" "unbound identifier ~s" (Xounter)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter<Boolean>;"
      "ledger field2: Field;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 16" "mismatch between actual number ~s and declared number ~s of ADT parameters for ~s" (1 0 Counter)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: List;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 16" "mismatch between actual number ~s and declared number ~s of ADT parameters for ~s" (0 1 List)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: List<Field, Boolean>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 16" "mismatch between actual number ~s and declared number ~s of ADT parameters for ~s" (2 1 List)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export ledger field1: Xounter;"
      "  export ledger field2: Field;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 25" "unbound identifier ~s" (Xounter)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      " ledger field1: Counter;"
      " ledger field2: Field;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (constructor () (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Counter))
          (%field2.2 (__compact_Cell (tfield)))
          (constructor () (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      "export circuit foo(): Field { return field3.read(); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 38" "unbound identifier ~s" (field3)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      "export circuit foo(): Field { return field2.read(); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Counter))
          (%field2.2 (__compact_Cell (tfield)))
          (constructor () (tuple)))
        (circuit %foo.3 ()
             (tfield)
          (public-ledger %field2.2 (read)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      "export circuit foo(): Field { field2.write(); return 3; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 37" "~s ~s requires ~s argument~:*~p but received ~s" (__compact_Cell write 1 0)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      "export circuit foo(): Field { return field2.read(0); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 44" "~s ~s requires ~s argument~:*~p but received ~s" (__compact_Cell read 0 1)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      "export circuit foo(): Field { return field2.malarky(); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 44" "operation ~a undefined for ledger field type ~a" (malarky "Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      "export circuit foo(): Field { field2.write(true, 0); return 3; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 37" "~s ~s requires ~s argument~:*~p but received ~s" (__compact_Cell write 1 2)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "ledger field2: Field;"
      "export circuit foo(): Field { return field2.malarky(); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 44" "operation ~a undefined for ledger field type ~a" (malarky "Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "constructor() {"
      "  counter = 0;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 11" "operation ~a undefined for ledger field type ~a" ("=" "Counter")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger c: Counter;"
      "export circuit test(): []  {"
      "  c = default<Counter>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 5" "operation ~a undefined for ledger field type ~a" ("=" "Counter")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger mapmap: Map<Boolean, Map<Boolean, Field>>;"
      ""
      "export circuit foo(): Field {"
      "  return 0;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%mapmap.1 (Map (tboolean) (Map (tboolean) (tfield))))
          (constructor () (tuple)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 0) 0))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger mmmc: Map<Boolean, Map<Boolean, Map<Boolean, Counter>>>;"
      ""
      "circuit foo(): Field {"
      "  return mmmc;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 10" "incomplete chain of ledger indirects: final result must be a regular type, but received ADT type ~a" ("Map<Boolean, Map<Boolean, Map<Boolean, Counter>>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger mmmc: Map<Boolean, Map<Boolean, Map<Boolean, Counter>>>;"
      ""
      "circuit foo(): Field {"
      "  return mmmc.lookup(true);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 14" "incomplete chain of ledger indirects: final result must be a regular type, but received ADT type ~a" ("Map<Boolean, Map<Boolean, Counter>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger mmmc: Map<Boolean, Map<Boolean, Map<Boolean, Counter>>>;"
      ""
      "circuit foo(): Field {"
      "  return mmmc.lookup(true).lookup(false);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 27" "incomplete chain of ledger indirects: final result must be a regular type, but received ADT type ~a" ("Map<Boolean, Counter>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "export circuit foo(): Field {"
      "  field1.insert(true, default<Counter>);"
      "  field1.lookup(true).increment(1);"
      "  return field1.lookup(true).read();"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Map (tboolean) (Counter)))
          (constructor () (tuple)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (seq
              (public-ledger %field1.1 (insert #t (default (Counter))))
              (public-ledger %field1.1
                (lookup #t)
                (increment (safe-cast (tunsigned 65535) (tunsigned 1) 1)))
              (public-ledger %field1.1 (lookup #t) (read)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "export circuit foo(): Field {"
      "  field1.insert(true, default<Counter>);"
      "  field1.lookup(true) += 1;"
      "  return field1.lookup(true);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Map (tboolean) (Counter)))
          (constructor () (tuple)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (seq
              (public-ledger %field1.1 (insert #t (default (Counter))))
              (public-ledger %field1.1
                (lookup #t)
                (increment (safe-cast (tunsigned 65535) (tunsigned 1) 1)))
              (public-ledger %field1.1 (lookup #t) (read)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "circuit foo(): Field {"
      "  field1.insert(true, default<Counter>);"
      "  field1.lookup(true) += 1;"
      "  return field1;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 10" "incomplete chain of ledger indirects: final result must be a regular type, but received ADT type ~a" ("Map<Boolean, Counter>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "circuit foo(): Field {"
      "  field1.insert(true, default<Counter>);"
      "  field1.lookup(true).increment(1).read();"
      "  return field1.lookup(true);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 35" "expected left-hand side of ~a to have an ADT or contract type, received ~a" ("." "[]")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Counter>;"
      ""
      "export circuit foo(): Field {"
      "  field1.insert(7, default<Counter>);"
      "  return field1.lookup(7);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1 (Map (tfield) (Counter)))
          (constructor () (tuple)))
        (circuit %foo.2 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (seq
              (public-ledger %field1.1
                (insert (safe-cast (tfield) (tunsigned 7) 7) (default (Counter))))
              (public-ledger %field1.1
                (lookup (safe-cast (tfield) (tunsigned 7) 7))
                (read)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Counter>;"
      ""
      "circuit foo(): Field {"
      "  field1.write(default<Counter>);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 9" "operation ~a undefined for ledger field type ~a" (write "Map<Field, Counter>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Set<Counter>;"
      ""
      "circuit foo(): Field {"
      "  field1.write(default<Counter>);"
      "  return field1.read();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 20" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("non-ADT type" "ledger ADT type" value_type "<standard library>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Uint<32>, Counter>;"
      ""
      "circuit foo(): Field {"
      "  field1.insert(7, default<Counter>);"
      "  return field1;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 10" "incomplete chain of ledger indirects: final result must be a regular type, but received ADT type ~a" ("Map<Uint<32>, Counter>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger x: Counter;"
      "ledger x: Field;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 1" "another binding found for ~s in the same scope at ~a" (x "line 2 char 1")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "constructor() {}"
      "export ledger foo: Counter;"
      "constructor() {return;}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "found other ledger constructors in program: ~{\n    ~a~^,~}" (("line 4 char 1"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "constructor() {}"
      "ledger foo: Counter;"
      "constructor() { return; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "found other ledger constructors in program: ~{\n    ~a~^,~}" (("line 4 char 1"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  import CompactStandardLibrary;"
      "  export { kernel };"
      "}"
      "import M prefix $;"
      "ledger kernelA: Kernel;"
      "ledger kernelB: Kernel;"
      "export circuit foo(): Vector<4, ContractAddress> {"
      "  return [kernel.self(), $kernel.self(), kernelA.self(), kernelB.self()];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.1 ()
             (tvector 4 (tstruct ContractAddress (bytes (tbytes 32))))
          (tuple
            (public-ledger %kernel.0 (self))
            (public-ledger %kernel.0 (self))
            (public-ledger %kernel.0 (self))
            (public-ledger %kernel.0 (self))))))
    )
)

(run-tests discard-unused-functions
  (test
    '(
      "module M {"
      "  export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      "  export circuit foo() : Boolean { return true; }"
      "  export circuit foo(b: Boolean) : Boolean { return b; }"
      "}"
      "import M;"
      "circuit foo() : Boolean { return false; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export {bar}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%n.1 (tfield)])
             (tfield)
          (if (call %foo.2)
              (call %foo.3 %n.1)
              (safe-cast (tfield) (tunsigned 17) 17)))
        (circuit %foo.2 () (tboolean) #t)
        (circuit %foo.3 ([%a.4 (tfield)]) (tfield) %a.4)))
    )

  (test
    '(
      "module M {"
      "  export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      "  export circuit foo() : Boolean { return true; }"
      "  export circuit foo(b: Boolean) : Boolean { return b; }"
      "  circuit decoy(b: Boolean) : Boolean { return foo(b); }"
      "}"
      "import M;"
      "circuit foo() : Boolean { return false; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export {bar}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%n.1 (tfield)])
             (tfield)
          (if (call %foo.2)
              (call %foo.3 %n.1)
              (safe-cast (tfield) (tunsigned 17) 17)))
        (circuit %foo.2 () (tboolean) #t)
        (circuit %foo.3 ([%a.4 (tfield)]) (tfield) %a.4)))
    )

  (test
    '(
      "module M {"
      "  export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      "  export circuit foo() : Boolean { return true; }"
      "  export circuit foo(b: Boolean) : Boolean { return b; }"
      "}"
      "import M;"
      "circuit foo() : Boolean { return false; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "circuit decoy(b: Boolean) : Boolean { return foo(b); }"
      "export {bar}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 46" "call site ambiguity (multiple compatible functions) in call to ~a\n    supplied argument types:\n      (~{~a~^, ~})\n    compatible functions:~{\n      ~a~}" (foo ("Boolean") ("line 4 char 3" "line 9 char 1"))))
    )

  (test
    '(
      "circuit A<t1, t2>(x: t1): t2 {"
      "  return x as t2;"
      "}"
      "circuit A<#t>(x: Uint<t..37>): Field {"
      "  return x;"
      "}"
      "circuit A<t>(x: t): Field {"
      "  return x ? 1 : 0;"
      "}"
      "circuit A<t>(x: Uint<16>): Field {"
      "  return x;"
      "}"
      "export circuit B(x: Uint<0..8>): Field {"
      "  return A<Boolean>(x);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %A.0 ([%x.1 (tunsigned 65535)])
             (tfield)
          (safe-cast (tfield) (tunsigned 65535) %x.1))
        (circuit %B.2 ([%x.3 (tunsigned 7)])
             (tfield)
          (call %A.0 (safe-cast (tunsigned 65535) (tunsigned 7) %x.3)))))
    )
)

(run-tests reject-recursive-circuits
  (test
    `(
      "export circuit foo(n: Field, s: Bytes<20>) : Boolean { return foo(n, s); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "recursion involving~?" ("~#[~; ~a~; ~a and ~a~:;~@{~#[~; and~] ~a~^,~}~]" (foo))))
    )

  (test
    `(
      "export circuit foo(n: Field, s: Bytes<20>) : Boolean { return bar(n, s); }"
      "export circuit bar(n: Field, s: Bytes<20>) : Boolean { return foo(n, s); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "recursion involving~?" ("~#[~; ~a~; ~a and ~a~:;~@{~#[~; and~] ~a~^,~}~]" (foo "bar at line 2 char 1"))))
    )

  (test
    `(
      "export circuit isOdd(n: Field) : Boolean { return (n == 0) || isEven(n - 1); } "
      "export circuit isEven(n: Field) : Boolean { return ! isOdd(n - 1); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "recursion involving~?" ("~#[~; ~a~; ~a and ~a~:;~@{~#[~; and~] ~a~^,~}~]" (isOdd "isEven at line 2 char 1"))))
    )

  (test
    `(
      "export circuit three(n: Field, s: Bytes<20>) : Boolean { return blind(n, s); }"
      "export circuit blind(n: Field, s: Bytes<20>) : Boolean { return mice(n, s); }"
      "export circuit butcherwife() : [] { assert(blind(3, pad(20, 'ran after')), 'carving knife'); }"
      "export circuit mice(n: Field, s: Bytes<20>) : Boolean { return three(n, s); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "recursion involving~?" ("~#[~; ~a~; ~a and ~a~:;~@{~#[~; and~] ~a~^,~}~]" (three "blind at line 2 char 1" "mice at line 4 char 1"))))
    )

  ; the next set of tests were inherited from eliminate-redundant-upcasts when that pass was itself eliminated
  (test ;; FIXME uncomment composable contract
    "test-center/compact/test.compact"
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%x0.1 (__compact_Cell (tfield)))
          (%x1.2 (Set (tfield)))
          (%x2.3 (Counter))
          (%x3.4 (List (tfield)))
          (%x4.5 (Map (tfield) (tboolean)))
          (%x5.6 (MerkleTree 32 (tfield)))
          (%x6.7 (HistoricMerkleTree 10 (tfield)))
          (%x7.8
            (__compact_Cell
              (tstruct CoinInfo
                (nonce (tbytes 32))
                (color (tbytes 32))
                (value (tunsigned
                         340282366920938463463374607431768211455)))))
          (%x10.9
            (__compact_Cell
              (tstruct MerkleTreeDigest (field (tfield)))))
          (%x11.10
            (__compact_Cell
              (tstruct QualifiedCoinInfo
                (nonce (tbytes 32))
                (color (tbytes 32))
                (value (tunsigned 340282366920938463463374607431768211455))
                (mt_index (tunsigned 18446744073709551615)))))
          (%x13.11
            (__compact_Cell
              (tstruct ContractAddress (bytes (tbytes 32)))))
          (%authority.12 (__compact_Cell (tbytes 32)))
          (%state.13
            (__compact_Cell
              (tenum PublicState setup commit reveal final)))
          (%topic.14
            (__compact_Cell
              (tstruct Maybe
                (is_some (tboolean))
                (value (topaque "string")))))
          (%tally_yes.15 (Counter))
          (%committed_votes.16 (MerkleTree 10 (tbytes 32)))
          (%committed.17 (Set (tbytes 32)))
          (%ciphertexts.18 (__compact_Cell (topaque "Uint8Array")))
          (constructor ([%state.19 (tfield)])
            (seq
              (fold
                (circuit ([%t.20 (ttuple)] [%i.21 (tunknown)])
                     (ttuple)
                  (seq
                    (seq
                      (+ #f %state.19 (safe-cast (tfield) (tunsigned 1) 1))
                      (tuple))
                    %t.20))
                (tuple)
                (tuple))
              (tuple))))
        (circuit %foo.22 ([%a.23 (tboolean)] [%b.24 (tfield)])
             (tboolean)
          #f)
        (circuit %bar.25 ([%a.26 (tboolean)] [%b.27 (tboolean)])
             (tstruct frob (q (tfield)))
          (let* ([[%x.28 (tboolean)]
                  (call %foo.22 #t (safe-cast (tfield) (tunsigned 17) 17))])
            (let* ([[%y.29 (tunsigned 3)]
                    (if %a.26
                        (if %b.27 3 (safe-cast (tunsigned 3) (tunsigned 2) 2))
                        (safe-cast (tunsigned 3)
                                   (tunsigned 1)
                          (if %b.27
                              1
                              (safe-cast (tunsigned 1) (tunsigned 0) 0))))])
              (let* ([[%w.30 (tboolean)] (if %a.26 #t #f)])
                (let* ([[%v.31 (tboolean)]
                        (if %a.26
                            #f
                            (fold
                              %foo.22
                              #t
                              (tuple-ref (tuple (tuple)) 0)))])
                  (seq
                    (if %a.26
                        (if %b.27
                            (assert %a.26 "a should be true")
                            (if %b.27
                                (assert %a.26 "a should be true")
                                (tuple)))
                        (tuple))
                    (if %a.26
                        (if %b.27 (assert %a.26 "a should be true") (tuple))
                        (let* ([[%v.32 (tboolean)] %a.26])
                          (if %b.27
                              (assert %v.32 "a should be false")
                              (tuple))))
                    (fold
                      (circuit ([%b.33 (tboolean)]
                                [%c.34 (tboolean)]
                                [%d.35 (tfield)])
                           (tboolean)
                        (if (if %a.26 %b.33 #f) %c.34 #f))
                      #t
                      (tuple #f #t #t #f)
                      (tuple 0 1 2 3))
                    (tuple-ref (tuple 1 2 3 4) 2)
                    (map
                      %foo.22
                      (tuple #f #f #t #f)
                      (tuple 1 2 3 4))
                    (assert
                      (== (public-ledger %kernel.0 (self))
                          (public-ledger %kernel.0 (self)))
                      "oops")
                    (new (tstruct frob (q (tfield)))
                      (public-ledger %x0.1 (read)))))))))
        (circuit %baz.36 ([%b.37 (tboolean)])
             (tunsigned 1023)
          (disclose
            (if %b.37
                (safe-cast (tunsigned 1023) (tunsigned 1) 1)
                (safe-cast (tunsigned 1023) (tunsigned 0) 0))))
        (circuit %nullX.38 () (tboolean) (default (tboolean)))))
    )

  (test
    '(
      "export circuit bar() : Vector<0, Field> { return []; }"
     )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 () (tvector 0 (tfield)) (tuple))))
    )

  (test
    '(
      "module A {"
      "  export witness w(a: Field): Boolean;"
      "}"
      "import A;"
      "witness w(a: Field, b: Field): Boolean;"
      "export circuit foo(a : Field) : Boolean { return w(a); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (witness %w.0 ([%a.1 (tfield)]) (tboolean))
        (circuit %foo.2 ([%a.3 (tfield)])
             (tboolean)
          (call %w.0 %a.3)))))

  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return true; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%a.1 (tboolean)]) (tboolean) #t))))

  (test
    '(
      "export circuit foo(a: Boolean) : Boolean { return !(!a && a || a && a); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%a.1 (tboolean)])
             (tboolean)
          (if (if (if (if %a.1 #f #t) %a.1 #f) #t (if %a.1 %a.1 #f))
              #f
              #t))))
    )

  (test
    '(
      "export circuit foo(a: Boolean) : Field { const x = 7; if (a) return x+1; return x-1; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%a.1 (tboolean)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned 8)
            (let* ([[%x.2 (tunsigned 7)] 7])
              (if %a.1
                  (+ 4
                     (safe-cast (tunsigned 8) (tunsigned 7) %x.2)
                     (safe-cast (tunsigned 8) (tunsigned 1) 1))
                  (safe-cast (tunsigned 8)
                             (tunsigned 7)
                    (seq
                      (assert
                        (if (< %x.2 (safe-cast (tunsigned 7) (tunsigned 1) 1))
                            #f
                            #t)
                        "result of subtraction would be negative")
                      (- 3 %x.2 (safe-cast (tunsigned 7) (tunsigned 1) 1))))))))))
    )

  (test
    '(
      "export circuit foo(a: Bytes<20>, i: Field) : Boolean { return a == [pad(20,'a'), pad(20,'b'), pad(20,'c')][1]; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%a.1 (tbytes 20)] [%i.2 (tfield)])
             (tboolean)
          (== %a.1
              (tuple-ref
                (tuple
                  #vu8(97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                  #vu8(98 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                  #vu8(99 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))
                1)))))
    )

  (test
    '(
      "export circuit foo(a: Vector<0, Boolean>, i: Field) : Boolean { return a == [[],[],[]][0]; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%a.1 (tvector 0 (tboolean))]
                         [%i.2 (tfield)])
             (tboolean)
          (== %a.1 (tuple-ref (tuple (tuple) (tuple) (tuple)) 0)))))
    )

  (test
    '(
      "circuit foo(a: Field, b: Field) : Field { return a * b; }"
      "export circuit bar(x: Field) : Field { return foo(x-1, x+1); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%a.1 (tfield)] [%b.2 (tfield)])
             (tfield)
          (* #f %a.1 %b.2))
        (circuit %bar.3 ([%x.4 (tfield)])
             (tfield)
          (call %foo.0
            (- #f %x.4 (safe-cast (tfield) (tunsigned 1) 1))
            (+ #f %x.4 (safe-cast (tfield) (tunsigned 1) 1))))))
  )

  (test
    '(
      "export circuit bar(a: Field, v: Vector<0, Boolean>) : Vector<0, Boolean> { return a == 0 ? v : []; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%a.1 (tfield)]
                         [%v.2 (tvector 0 (tboolean))])
             (tvector 0 (tboolean))
          (if (== %a.1 (safe-cast (tfield) (tunsigned 0) 0))
              %v.2
              (tuple)))))
    )

  (test
    '(
      "circuit foo() : Vector<3, Field> { return [5, 13, 53]; }"
      "export circuit bar(a: Field) : Field { return foo()[1]; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (tvector 3 (tfield))
          (safe-cast (tvector 3 (tfield))
                     (ttuple (tunsigned 5) (tunsigned 13) (tunsigned 53))
            (tuple 5 13 53)))
        (circuit %bar.1 ([%a.2 (tfield)])
             (tfield)
          (tuple-ref (call %foo.0) 1))))
    )

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field>;"
      "export circuit bar(a: foo) : Field { return a.x; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%a.1 (tstruct foo (x (tfield)))])
             (tfield)
          (elt-ref %a.1 x 0)))))

  (test
    '(
      "module Foo<A> {"
      "  export struct foo { x: A; }"
      "}"
      "import Foo<Field> prefix $;"
      "export circuit bar(a: Field) : $foo { return $foo{ x: a }; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%a.1 (tfield)])
             (tstruct foo (x (tfield)))
          (new (tstruct foo (x (tfield))) %a.1)))))

  (test ; just see if it succeeds
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it succeeds
    "examples/election.compact"
    (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
   (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
   (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
   (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/counter/contract/src/counter.compact"
    (succeeds))

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/welcome/contract/src/welcome.compact"
    (succeeds))

  (test
    '(
      "module Foo<A> {"
      "  export module Bar<B> {"
      "    export struct bar { a: A; b: B;}"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit rat(b: Boolean) : bar { return bar{a: 3, b: b}; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %rat.0 ([%b.1 (tboolean)])
             (tstruct bar (a (tfield)) (b (tboolean)))
          (new (tstruct bar (a (tfield)) (b (tboolean)))
            (safe-cast (tfield) (tunsigned 3) 3)
            %b.1))))
    )

  (test
    '(
      "module Foo<A> {"
      "  circuit foo(a: A) : A { return a; }"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%a.1 (tfield)]) (tfield) %a.1)
        (circuit %bar.2 ([%a.3 (tfield)] [%b.4 (tboolean)])
             (tfield)
          (call %foo.0 %a.3))
        (circuit %foo.5 ([%b.6 (tboolean)])
             (tfield)
          (call %bar.2 (safe-cast (tfield) (tunsigned 3) 3) %b.6))))
    )

  (test
    '(
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      "module Foo<A> {"
      "  export module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  circuit foo(a: A) : A { return a; }"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.1 ([%b.2 (tboolean)])
             (tfield)
          (call %bar.3 (safe-cast (tfield) (tunsigned 3) 3) %b.2))
        (circuit %bar.3 ([%a.4 (tfield)] [%b.0 (tboolean)])
             (tfield)
          (call %foo.5 %a.4))
        (circuit %foo.5 ([%a.6 (tfield)]) (tfield) %a.6)))
    )

  (test
    '(
      "module Foo<A> {"
      "  circuit foo(a: A) : A { return a; }"
      "  module Bar<B> {"
      "    circuit bar(a: A, b: B) : A { return foo(a); }"
      "    export {bar}"
      "  }"
      "  export {Bar}"
      "}"
      "import Foo<Field>;"
      "import Bar<Boolean>;"
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%a.1 (tfield)]) (tfield) %a.1)
        (circuit %bar.2 ([%a.3 (tfield)] [%b.4 (tboolean)])
             (tfield)
          (call %foo.0 %a.3))
        (circuit %foo.5 ([%b.6 (tboolean)])
             (tfield)
          (call %bar.2 (safe-cast (tfield) (tunsigned 3) 3) %b.6))))
    )

  (test
    '(
      "module Foo<A> {"
      "  circuit foo(a: A) : A { return a; }"
      "  module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  export {bar}"
      "}"
      "import Foo<Field>;"
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%a.1 (tfield)]) (tfield) %a.1)
        (circuit %bar.2 ([%a.3 (tfield)] [%b.4 (tboolean)])
             (tfield)
          (call %foo.0 %a.3))
        (circuit %foo.5 ([%b.6 (tboolean)])
             (tfield)
          (call %bar.2 (safe-cast (tfield) (tunsigned 3) 3) %b.6))))
    )

  (test
    '(
      "export circuit foo(b: Boolean) : Field { return bar(3, b); }"
      "module Foo<A> {"
      "  export {bar}"
      "  module Bar<B> {"
      "    export circuit bar(a: A, b: B) : A { return foo(a); }"
      "  }"
      "  import Bar<Boolean>;"
      "  circuit foo(a: A) : A { return a; }"
      "}"
      "import Foo<Field>;"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tfield)
          (call %bar.2 (safe-cast (tfield) (tunsigned 3) 3) %b.1))
        (circuit %bar.2 ([%a.3 (tfield)] [%b.4 (tboolean)])
             (tfield)
          (call %foo.5 %a.3))
        (circuit %foo.5 ([%a.6 (tfield)]) (tfield) %a.6)))
    )

  (test
    '(
      "module Foo<A> {"
      "  export circuit bar() : A { return A{ a: 1, d: 2 }; }"
      "}"
      "struct pr { a: Field; d: Field; }"
      "import Foo<pr>;"
      "export {bar}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ()
             (tstruct pr (a (tfield)) (d (tfield)))
          (new (tstruct pr (a (tfield)) (d (tfield)))
            (safe-cast (tfield) (tunsigned 1) 1)
            (safe-cast (tfield) (tunsigned 2) 2)))))
    )

  (test
    '(
      "circuit foo() : Boolean { return true; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 () (tboolean) #t)
        (circuit %foo.1 ([%a.2 (tfield)]) (tfield) %a.2)
        (circuit %bar.3 ([%n.4 (tfield)])
             (tfield)
          (if (call %foo.0)
              (call %foo.1 %n.4)
              (safe-cast (tfield) (tunsigned 17) 17)))))
    )

  (test
    '(
      "module M {"
      "  export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      "  export circuit foo() : Boolean { return true; }"
      "  export circuit foo(b: Boolean) : Boolean { return b; }"
      "}"
      "import M;"
      "circuit foo() : Boolean { return false; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export {bar}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%n.1 (tfield)])
             (tfield)
          (if (call %foo.2)
              (call %foo.3 %n.1)
              (safe-cast (tfield) (tunsigned 17) 17)))
        (circuit %foo.2 () (tboolean) #t)
        (circuit %foo.3 ([%a.4 (tfield)]) (tfield) %a.4)))
    )

  (test
    '(
      "export circuit sum(v: Vector<10,Field>) : Field {"
      "  return fold((a, n): Field => a + n,"
      "              0,"
      "              v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %sum.0 ([%v.1 (tvector 10 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.2 (tfield)] [%n.3 (tfield)])
                 (tfield)
              (+ #f %a.2 %n.3))
            (safe-cast (tfield) (tunsigned 0) 0)
            %v.1))))
  )

  (test
    '(
      "module M<#n> {"
      "  export circuit sum(v: Vector<n, Field>) : Field {"
      "    return fold((a: Field, n) => a + n,"
      "                0,"
      "                v);"
      "  }"
      "}"
      "import M<10>;"
      "import M<20>;"
      "circuit foo(u: Vector<10, Field>): Field { return sum(u); }"
      "circuit foo(w: Vector<20, Field>): Field { return sum(w); }"
      "export circuit bar(u: Vector<10, Field>, v: Vector<20, Field>): Field {"
      "  return foo(u) + foo(v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %sum.0 ([%v.1 (tvector 20 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.2 (tfield)] [%n.3 (tfield)])
                 (tfield)
              (+ #f %a.2 %n.3))
            (safe-cast (tfield) (tunsigned 0) 0)
            %v.1))
        (circuit %sum.4 ([%v.5 (tvector 10 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.6 (tfield)] [%n.7 (tfield)])
                 (tfield)
              (+ #f %a.6 %n.7))
            (safe-cast (tfield) (tunsigned 0) 0)
            %v.5))
        (circuit %foo.8 ([%u.9 (tvector 10 (tfield))])
             (tfield)
          (call %sum.4 %u.9))
        (circuit %foo.10 ([%w.11 (tvector 20 (tfield))])
             (tfield)
          (call %sum.0 %w.11))
        (circuit %bar.12 ([%u.13 (tvector 10 (tfield))]
                          [%v.14 (tvector 20 (tfield))])
             (tfield)
          (+ #f (call %foo.8 %u.13) (call %foo.10 %v.14)))))
  )

  (test
    '(
      "module M<#n> {"
      "  export witness foo(v: Vector<n, Field>) : Field;"
      "}"
      "import M<10>;"
      "import M<20>;"
      "export circuit bar10(u: Vector<10, Field>): Field { return foo(u); }"
      "export circuit bar20(w: Vector<20, Field>): Field { return foo(w); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (witness %foo.0 ([%v.1 (tvector 20 (tfield))]) (tfield))
        (witness %foo.2 ([%v.3 (tvector 10 (tfield))]) (tfield))
        (circuit %bar10.4 ([%u.5 (tvector 10 (tfield))])
             (tfield)
          (call %foo.2 %u.5))
        (circuit %bar20.6 ([%w.7 (tvector 20 (tfield))])
             (tfield)
          (call %foo.0 %w.7))))
  )

  (test
    '(
      "export circuit foo(v: Vector<10, Field>): Boolean {"
      "  return fold((b, x) => {"
      "            const y = x;"
      "            {"
      "              const x = y * 1;"
      "              return b && x == 0;"
      "            }"
      "          },"
      "          true,"
      "          v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%v.1 (tvector 10 (tfield))])
             (tboolean)
          (fold
            (circuit ([%b.2 (tboolean)] [%x.3 (tfield)])
                 (tboolean)
              (let* ([[%y.4 (tfield)] %x.3])
                (let* ([[%x.5 (tfield)] (* #f
                                           %y.4
                                           (safe-cast (tfield) (tunsigned 1)
                                             1))])
                  (if %b.2
                      (== %x.5 (safe-cast (tfield) (tunsigned 0) 0))
                      #f))))
            #t
            %v.1))))
  )

  (test
    '(
      "export circuit C(x: Field, y: Field): Field {"
      "  if (x == 2) return y + 7;"
      "  assert(!(x == 2), 'oops 1');"
      "  if (x == 3) {"
      "    if (y == 0)"
      "       assert(y == 0, 'oops 2');"
      "    else"
      "       return y + 9;"
      "  }"
      "  assert(!(x == 3), 'oops 3');"
      "  return y + 11;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %C.0 ([%x.1 (tfield)] [%y.2 (tfield)])
             (tfield)
          (if (== %x.1 (safe-cast (tfield) (tunsigned 2) 2))
              (+ #f %y.2 (safe-cast (tfield) (tunsigned 7) 7))
              (seq
                (assert
                  (if (== %x.1 (safe-cast (tfield) (tunsigned 2) 2)) #f #t)
                  "oops 1")
                (if (== %x.1 (safe-cast (tfield) (tunsigned 3) 3))
                    (if (== %y.2 (safe-cast (tfield) (tunsigned 0) 0))
                        (seq
                          (assert
                            (== %y.2 (safe-cast (tfield) (tunsigned 0) 0))
                            "oops 2")
                          (assert
                            (if (== %x.1 (safe-cast (tfield) (tunsigned 3) 3))
                                #f
                                #t)
                            "oops 3")
                          (+ #f %y.2 (safe-cast (tfield) (tunsigned 11) 11)))
                        (+ #f %y.2 (safe-cast (tfield) (tunsigned 9) 9)))
                    (seq
                      (assert
                        (if (== %x.1 (safe-cast (tfield) (tunsigned 3) 3))
                            #f
                            #t)
                        "oops 3")
                      (+ #f
                         %y.2
                         (safe-cast (tfield) (tunsigned 11) 11)))))))))
  )

  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean { return b && x == 0; }"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold(foo, true, v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {foo, X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tfield)])
             (tboolean)
          (if %b.1 (== %x.2 (safe-cast (tfield) (tunsigned 0) 0)) #f))
        (circuit %X$C.3 ([%v.4 (tvector 0 (tfield))])
             (tboolean)
          (fold
            %foo.0
            #t
            %v.4))
        (circuit %Y$C.5 ([%v.6 (tvector 1 (tfield))])
             (tboolean)
          (fold
            %foo.0
            #t
            %v.6))
        (circuit %Z$C.7 ([%v.8 (tvector 2 (tfield))])
             (tboolean)
          (fold
            %foo.0
            #t
            %v.8))))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold((b, x) => b && x == 0,"
      "                true,"
      "                v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %X$C.0 ([%v.1 (tvector 0 (tfield))])
             (tboolean)
          (fold
            (circuit ([%b.2 (tboolean)] [%x.3 (tfield)])
                 (tboolean)
              (if %b.2 (== %x.3 (safe-cast (tfield) (tunsigned 0) 0)) #f))
            #t
            %v.1))
        (circuit %Y$C.4 ([%v.5 (tvector 1 (tfield))])
             (tboolean)
          (fold
            (circuit ([%b.6 (tboolean)] [%x.7 (tfield)])
                 (tboolean)
              (if %b.6 (== %x.7 (safe-cast (tfield) (tunsigned 0) 0)) #f))
            #t
            %v.5))
        (circuit %Z$C.8 ([%v.9 (tvector 2 (tfield))])
             (tboolean)
          (fold
            (circuit ([%b.10 (tboolean)] [%x.11 (tfield)])
                 (tboolean)
              (if %b.10 (== %x.11 (safe-cast (tfield) (tunsigned 0) 0)) #f))
            #t
            %v.9))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    return map(foo, v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %X$C.2 ([%v.3 (tvector 0 (tfield))])
             (tvector 0 (tboolean))
          (map %foo.0 %v.3))
        (circuit %Y$C.4 ([%v.5 (tvector 1 (tfield))])
             (tvector 1 (tboolean))
          (map %foo.0 %v.5))
        (circuit %Z$C.6 ([%v.7 (tvector 2 (tfield))])
             (tvector 2 (tboolean))
          (map %foo.0 %v.7))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    return map((x) => foo(x + 1),"
      "               v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %X$C.2 ([%v.3 (tvector 0 (tfield))])
             (tvector 0 (tboolean))
          (map
            (circuit ([%x.4 (tfield)])
                 (tboolean)
              (call %foo.0 (+ #f %x.4 (safe-cast (tfield) (tunsigned 1) 1))))
            %v.3))
        (circuit %Y$C.5 ([%v.6 (tvector 1 (tfield))])
             (tvector 1 (tboolean))
          (map
            (circuit ([%x.7 (tfield)])
                 (tboolean)
              (call %foo.0 (+ #f %x.7 (safe-cast (tfield) (tunsigned 1) 1))))
            %v.6))
        (circuit %Z$C.8 ([%v.9 (tvector 2 (tfield))])
             (tvector 2 (tboolean))
          (map
            (circuit ([%x.10 (tfield)])
                 (tboolean)
              (call %foo.0
                (+ #f %x.10 (safe-cast (tfield) (tunsigned 1) 1))))
            %v.9))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return W<B>(S(q)); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (witness %W.0 ([%x.1 (tboolean)]) (tboolean))
        (witness %W.2 ([%x.3 (tfield)]) (tboolean))
        (witness %W.4 ([%x.5 (tboolean)]) (tfield))
        (witness %W.6 ([%x.7 (tfield)]) (tfield))
        (circuit %S.8 ([%q.9 (tboolean)]) (tboolean) %q.9)
        (circuit %S.10 ([%q.11 (tfield)]) (tfield) %q.11)
        (circuit %T.12 ([%q.13 (tboolean)])
             (tboolean)
          (call %W.0 (call %S.8 %q.13)))
        (circuit %T.14 ([%q.15 (tfield)])
             (tboolean)
          (call %W.2 (call %S.10 %q.15)))
        (circuit %T.16 ([%q.17 (tboolean)])
             (tfield)
          (call %W.4 (call %S.8 %q.17)))
        (circuit %T.18 ([%q.19 (tfield)])
             (tfield)
          (call %W.6 (call %S.10 %q.19)))
        (circuit %foo1.20 ([%x.21 (tfield)])
             (tboolean)
          (call %T.14 %x.21))
        (circuit %foo2.22 ([%x.23 (tfield)])
             (tfield)
          (call %T.18 %x.23))
        (circuit %foo3.24 ([%x.25 (tboolean)])
             (tboolean)
          (call %T.12 %x.25))
        (circuit %foo4.26 ([%x.27 (tboolean)])
             (tfield)
          (call %T.16 %x.27))))
    )

  (test
    '(
      "module A {"
      "  export enum Names { bill, sally, fred, george }"
      "}"
      "import A;"
      "module M<T> {"
      "  export circuit enumid(x: T): T {"
      "    return x;"
      "  }"
      "}"
      "import M<Names>;"
      "export circuit foo(x: Names): Boolean {"
      "  return x == Names.bill;"
      "}"
      "export circuit rats(): Boolean {"
      "  return foo(Names.bill);"
      "}"
      "export circuit mice(): Boolean {"
      "  return foo(enumid(Names.george));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %enumid.0 ([%x.1 (tenum Names
                                    bill
                                    sally
                                    fred
                                    george)])
             (tenum Names bill sally fred george)
          %x.1)
        (circuit %foo.2 ([%x.3 (tenum Names
                                 bill
                                 sally
                                 fred
                                 george)])
             (tboolean)
          (== %x.3
              (enum-ref (tenum Names bill sally fred george) bill)))
        (circuit %rats.4 ()
             (tboolean)
          (call %foo.2
            (enum-ref (tenum Names bill sally fred george) bill)))
        (circuit %mice.5 ()
             (tboolean)
          (call %foo.2
            (call %enumid.0
              (enum-ref (tenum Names bill sally fred george) george))))))
    )

  (test
    '(
      "export circuit foo() : Vector<2, Bytes<80>> {"
      "  const x = [pad(80, 'hello!'), pad(80, 'four score and seven years ago our fathers brought forth')];"
      "  const y = [pad(80, 'four score and seven years ago our fathers brought forth'), pad(80, 'hello!')];"
      "  assert(x == y, 'oops');"
      "  return x;"
      "}"
    )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (tvector 2 (tbytes 80))
          (let* ([[%x.1 (ttuple (tbytes 80) (tbytes 80))]
                  (tuple
                    #vu8(104 101 108 108 111 33 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                         0 0 0 0)
                    #vu8(102 111 117 114 32 115 99 111 114 101 32 97 110 100 32
                         115 101 118 101 110 32 121 101 97 114 115 32 97 103
                         111 32 111 117 114 32 102 97 116 104 101 114 115 32 98
                         114 111 117 103 104 116 32 102 111 114 116 104 0 0 0 0
                         0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))])
            (let* ([[%y.2 (ttuple (tbytes 80) (tbytes 80))]
                    (tuple
                      #vu8(102 111 117 114 32 115 99 111 114 101 32 97 110 100
                           32 115 101 118 101 110 32 121 101 97 114 115 32 97
                           103 111 32 111 117 114 32 102 97 116 104 101 114 115
                           32 98 114 111 117 103 104 116 32 102 111 114 116 104
                           0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                      #vu8(104 101 108 108 111 33 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                           0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                           0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                           0 0 0 0 0 0 0))])
              (seq (assert (== %x.1 %y.2) "oops") %x.1))))))
    )

  (test
    '(
      "export circuit foo(arg: Bytes<20>) : Field { return arg as Field; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%arg.1 (tbytes 20)])
             (tfield)
          (cast-from-bytes (tfield) 20 %arg.1)))))

  (test
    '(
      "export circuit foo(arg: Field) : Bytes<20> { return arg as Bytes<20>; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%arg.1 (tfield)])
             (tbytes 20)
          (field->bytes 20 %arg.1))))
    )

  (test
    '(
      "export circuit baz(b: Boolean) : Field { return !(!b && b || b && b) as Field; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %baz.0 ([%b.1 (tboolean)])
             (tfield)
          (if (if (if (if (if %b.1 #f #t) %b.1 #f)
                      #t
                      (if %b.1 %b.1 #f))
                  #f
                  #t)
              (safe-cast (tfield) (tunsigned 1) 1)
              (safe-cast (tfield) (tunsigned 0) 0)))))
    )

  (test
    '(
      "enum E { a, b, c }"
      "export circuit baz(b: E) : Field { return E.b as Field; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %baz.0 ([%b.1 (tenum E a b c)])
             (tfield)
          (cast-from-enum (tfield) (tenum E a b c)
            (enum-ref (tenum E a b c) b)))))
    )

  (test
    '(
      "export circuit baz(x: Field) : Boolean { return x + 1 as Boolean; }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %baz.0 ([%x.1 (tfield)])
             (tboolean)
          (if (== (+ #f %x.1 (safe-cast (tfield) (tunsigned 1) 1))
                  (safe-cast (tfield) (tunsigned 0) 0))
              #f
              #t))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1.read();"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (field1 (Counter))
          (constructor () (tuple)))
        (circuit %foo.0 ()
             (tfield)
          (safe-cast (tfield) (tunsigned 18446744073709551615)
            (public-ledger field1 (read))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "witness merkle_path_root(foo: Foo): MerkleTreeDigest;"
      ""
      "ledger field1: Map<Field, Foo>;"
      "ledger field2: HistoricMerkleTree<10, Foo>;"
      "ledger field3: Boolean;"
      ""
      "export circuit foo(n: Field, foo: Foo): Boolean {"
      "  field3.write(field1.lookup(n).baz);"
      "  const q = field1.lookup(n);"
      "  assert(!(q == default<Foo>), 'entry not found');"
      "  return field2.checkRoot(merkle_path_root(q));"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field1.1
            (Map (tfield)
                 (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
          (%field2.2
            (HistoricMerkleTree
              10
              (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
          (%field3.3 (__compact_Cell (tboolean)))
          (constructor () (tuple)))
        (witness %merklePathRoot.4 ([%foo.5 (tstruct Foo
                                                (bar (tbytes 32))
                                                (baz (tboolean)))])
             (tstruct MerkleTreeDigest (field (tfield))))
        (circuit %foo.6 ([%n.7 (tfield)]
                         [%foo.8 (tstruct Foo
                                   (bar (tbytes 32))
                                   (baz (tboolean)))])
             (tboolean)
          (seq
            (public-ledger %field3.3
              (write
                (elt-ref (public-ledger %field1.1 (lookup %n.7)) baz 1)))
            (let* ([[%q.9 (tstruct Foo
                            (bar (tbytes 32))
                            (baz (tboolean)))]
                    (public-ledger %field1.1 (lookup %n.7))])
              (seq
                (assert
                  (if (== %q.9
                          (default
                            (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
                      #f
                      #t)
                  "entry not found")
                (public-ledger %field2.2
                  (checkRoot (call %merklePathRoot.4 %q.9)))))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "ledger field0: Counter;"
      "ledger field1: Boolean;"
      "ledger field2: Set<Field>;"
      "ledger field3: Map<Field, Foo>;"
      "ledger field4: List<Foo>;"
      "ledger field5: MerkleTree<10, Foo>;"
      "ledger field6: HistoricMerkleTree<10, Field>;"
      "ledger field7: QualifiedCoinInfo;"
      "ledger field8: Set<QualifiedCoinInfo>;"
      "ledger field9: Map<Field, QualifiedCoinInfo>;"
      "ledger field10: List<QualifiedCoinInfo>;"
      ""
      "export circuit foo(x: Field, ci: CoinInfo): Boolean {"
      "  field0.resetToDefault();"
      "  field0.increment(5);"
      "  field0.decrement(2);"
      "  assert(field0.lessThan(4), 'oops 1');"
      "  field1.write(true);"
      "  const b = field1.read();"
      "  field2.resetToDefault();"
      "  assert(field2.isEmpty(), 'oops 2a');"
      "  assert(field2.size() == 0, 'oops 2b');"
      "  assert(!field2.member(x), 'oops 2c');"
      "  field2.insert(x);"
      "  field2.insert(x + 1);"
      "  field2.insert(x + 2);"
      "  field2.insert(x + 1);"
      "  assert(field2.size() == 3, 'oops 2d');"
      "  field2.remove(x + 1);"
      "  assert(field2.size() == 2, 'oops 2e');"
      "  assert(!field2.isEmpty(), 'oops 2f');"
      "  assert(field2.member(x), 'oops 2g');"
      "  assert(!field2.member(x + 1), 'oops 2h');"
      "  assert(field2.member(x + 2), 'oops 2i');"
      "  field3.resetToDefault();"
      "  field4.resetToDefault();"
      "  field5.resetToDefault();"
      "  field6.resetToDefault();"
      "  field7.writeCoin(ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  const q2 = field7.read();"
      "  field8.resetToDefault();"
      "  field8.insertCoin(ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  assert(field8.member(q2), 'oops 8a');"
      "  field8.remove(q2);"
      "  assert(!field8.member(q2), 'oops 8b');"
      "  field9.resetToDefault();"
      "  field9.insertCoin(x, ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  const q4 = field9.lookup(x);"
      "  field10.resetToDefault();"
      "  field10.pushFrontCoin(ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  const q5 = field10.head();"
      "  return b;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field0.1 (Counter))
          (%field1.2 (__compact_Cell (tboolean)))
          (%field2.3 (Set (tfield)))
          (%field3.4
            (Map (tfield)
                 (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
          (%field4.5
            (List (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
          (%field5.6
            (MerkleTree
              10
              (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
          (%field6.7 (HistoricMerkleTree 10 (tfield)))
          (%field7.8
            (__compact_Cell
              (tstruct QualifiedCoinInfo
                (nonce (tbytes 32))
                (color (tbytes 32))
                (value (tunsigned 340282366920938463463374607431768211455))
                (mt_index (tunsigned 18446744073709551615)))))
          (%field8.9
            (Set (tstruct QualifiedCoinInfo
                   (nonce (tbytes 32))
                   (color (tbytes 32))
                   (value (tunsigned 340282366920938463463374607431768211455))
                   (mt_index (tunsigned 18446744073709551615)))))
          (%field9.10
            (Map (tfield)
                 (tstruct QualifiedCoinInfo
                   (nonce (tbytes 32))
                   (color (tbytes 32))
                   (value (tunsigned 340282366920938463463374607431768211455))
                   (mt_index (tunsigned 18446744073709551615)))))
          (%field10.11
            (List
              (tstruct QualifiedCoinInfo
                (nonce (tbytes 32))
                (color (tbytes 32))
                (value (tunsigned 340282366920938463463374607431768211455))
                (mt_index (tunsigned 18446744073709551615)))))
          (constructor () (tuple)))
        (circuit %right.12 ([%value.13 (tstruct ContractAddress
                                         (bytes (tbytes 32)))])
             (tstruct Either
               (is_left (tboolean))
               (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
               (right (tstruct ContractAddress (bytes (tbytes 32)))))
          (new (tstruct Either
                 (is_left (tboolean))
                 (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
                 (right (tstruct ContractAddress (bytes (tbytes 32)))))
            #f
            (default (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
            %value.13))
        (circuit %foo.14 ([%x.15 (tfield)]
                          [%ci.16 (tstruct CoinInfo
                                    (nonce (tbytes 32))
                                    (color (tbytes 32))
                                    (value (tunsigned
                                             340282366920938463463374607431768211455)))])
             (tboolean)
          (seq
            (public-ledger %field0.1 (resetToDefault))
            (public-ledger %field0.1
              (increment (safe-cast (tunsigned 65535) (tunsigned 5) 5)))
            (public-ledger %field0.1
              (decrement (safe-cast (tunsigned 65535) (tunsigned 2) 2)))
            (assert
              (public-ledger %field0.1
                (lessThan
                  (safe-cast (tunsigned 18446744073709551615) (tunsigned 4) 4)))
              "oops 1")
            (public-ledger %field1.2 (write #t))
            (let* ([[%b.17 (tboolean)]
                    (public-ledger %field1.2 (read))])
              (seq
                (public-ledger %field2.3 (resetToDefault))
                (assert (public-ledger %field2.3 (isEmpty)) "oops 2a")
                (assert
                  (== (public-ledger %field2.3 (size))
                      (safe-cast (tunsigned 18446744073709551615)
                                 (tunsigned 0)
                        0))
                  "oops 2b")
                (assert
                  (if (public-ledger %field2.3 (member %x.15)) #f #t)
                  "oops 2c")
                (public-ledger %field2.3 (insert %x.15))
                (public-ledger %field2.3
                  (insert (+ #f %x.15 (safe-cast (tfield) (tunsigned 1) 1))))
                (public-ledger %field2.3
                  (insert (+ #f %x.15 (safe-cast (tfield) (tunsigned 2) 2))))
                (public-ledger %field2.3
                  (insert (+ #f %x.15 (safe-cast (tfield) (tunsigned 1) 1))))
                (assert
                  (== (public-ledger %field2.3 (size))
                      (safe-cast (tunsigned 18446744073709551615)
                              (tunsigned 3)
                        3))
                  "oops 2d")
                (public-ledger %field2.3
                  (remove (+ #f %x.15 (safe-cast (tfield) (tunsigned 1) 1))))
                (assert
                  (== (public-ledger %field2.3 (size))
                      (safe-cast (tunsigned 18446744073709551615)
                              (tunsigned 2)
                        2))
                  "oops 2e")
                (assert
                  (if (public-ledger %field2.3 (isEmpty)) #f #t)
                  "oops 2f")
                (assert (public-ledger %field2.3 (member %x.15)) "oops 2g")
                (assert
                  (if (public-ledger %field2.3
                        (member
                          (+ #f %x.15 (safe-cast (tfield) (tunsigned 1) 1))))
                      #f
                      #t)
                  "oops 2h")
                (assert
                  (public-ledger %field2.3
                    (member (+ #f %x.15 (safe-cast (tfield) (tunsigned 2) 2))))
                  "oops 2i")
                (public-ledger %field3.4 (resetToDefault))
                (public-ledger %field4.5 (resetToDefault))
                (public-ledger %field5.6 (resetToDefault))
                (public-ledger %field6.7 (resetToDefault))
                (public-ledger %field7.8
                  (writeCoin
                    %ci.16
                    (call %right.12 (public-ledger %kernel.0 (self)))))
                (let* ([[%q2.18 (tstruct QualifiedCoinInfo
                                  (nonce (tbytes 32))
                                  (color (tbytes 32))
                                  (value (tunsigned
                                           340282366920938463463374607431768211455))
                                  (mt_index (tunsigned 18446744073709551615)))]
                        (public-ledger %field7.8 (read))])
                  (seq
                    (public-ledger %field8.9 (resetToDefault))
                    (public-ledger %field8.9
                      (insertCoin
                        %ci.16
                        (call %right.12 (public-ledger %kernel.0 (self)))))
                    (assert
                      (public-ledger %field8.9 (member %q2.18))
                      "oops 8a")
                    (public-ledger %field8.9 (remove %q2.18))
                    (assert
                      (if (public-ledger %field8.9 (member %q2.18)) #f #t)
                      "oops 8b")
                    (public-ledger %field9.10 (resetToDefault))
                    (public-ledger %field9.10
                      (insertCoin
                        %x.15
                        %ci.16
                        (call %right.12 (public-ledger %kernel.0 (self)))))
                    (let* ([[%q4.19 (tstruct QualifiedCoinInfo
                                      (nonce (tbytes 32))
                                      (color (tbytes 32))
                                      (value (tunsigned
                                               340282366920938463463374607431768211455))
                                      (mt_index (tunsigned
                                                  18446744073709551615)))]
                            (public-ledger %field9.10 (lookup %x.15))])
                      (seq
                        (public-ledger %field10.11 (resetToDefault))
                        (public-ledger %field10.11
                          (pushFrontCoin
                            %ci.16
                            (call %right.12 (public-ledger %kernel.0 (self)))))
                        (let* ([[%q5.20 (tstruct Maybe
                                          (is_some (tboolean))
                                          (value (tstruct QualifiedCoinInfo
                                                   (nonce (tbytes 32))
                                                   (color (tbytes 32))
                                                   (value (tunsigned
                                                            340282366920938463463374607431768211455))
                                                   (mt_index (tunsigned
                                                               18446744073709551615)))))]
                                (public-ledger %field10.11 (head))])
                          %b.17)))))))))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  for (const i of [3, 2, 1]) i + 1;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (ttuple)
          (seq
            (fold
              (circuit ([%t.1 (ttuple)] [%i.2 (tunsigned 3)])
                   (ttuple)
                (seq
                  (seq
                    (+ 3
                       (safe-cast (tunsigned 4) (tunsigned 3) %i.2)
                       (safe-cast (tunsigned 4) (tunsigned 1) 1))
                    (tuple))
                  %t.1))
              (tuple)
              (tuple 3 2 1))
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(v: Vector<10, Boolean>): [] {"
      "  for (const i of v) !i;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%v.1 (tvector 10 (tboolean))])
             (ttuple)
          (seq
            (fold
              (circuit ([%t.2 (ttuple)] [%i.3 (tboolean)])
                   (ttuple)
                (seq (seq (if %i.3 #f #t) (tuple)) %t.2))
              (tuple)
              %v.1)
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger x: Counter;"
      "export circuit foo(v: Vector<10, Boolean>): [] {"
      "  for (const i of v) if (i) x += 1;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%x (Counter))
          (constructor () (tuple)))
        (circuit %foo.0 ([%v.1 (tvector 10 (tboolean))])
             (ttuple)
          (seq
            (fold
              (circuit ([%t.2 (ttuple)] [%i.3 (tboolean)])
                   (ttuple)
                (seq
                  (seq
                    (if %i.3
                        (public-ledger %x
                          (increment
                            (safe-cast (tunsigned 65535) (tunsigned 1) 1)))
                        (tuple))
                    (tuple))
                  %t.2))
              (tuple)
              %v.1)
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(): [] {"
      "  for (const i of 3..7) i + 1;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (ttuple)
          (seq
            (fold
              (circuit ([%t.1 (ttuple)] [%i.2 (tunsigned 6)])
                   (ttuple)
                (seq
                  (seq
                    (+ 3
                       (safe-cast (tunsigned 7) (tunsigned 6) %i.2)
                       (safe-cast (tunsigned 7) (tunsigned 1) 1))
                    (tuple))
                  %t.1))
              (tuple)
              (tuple 3 4 5 6))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger x: Counter;"
      "export circuit foo(): [] {"
      "  for (const i of 3..7) x += i;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%x.1 (Counter))
          (constructor () (tuple)))
        (circuit %foo.2 ()
             (ttuple)
          (seq
            (fold
              (circuit ([%t.3 (ttuple)] [%i.4 (tunsigned 6)])
                   (ttuple)
                (seq
                  (seq
                    (public-ledger %x.1
                      (increment
                        (safe-cast (tunsigned 65535) (tunsigned 6) %i.4)))
                    (tuple))
                  %t.3))
              (tuple)
              (tuple 3 4 5 6))
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Uint<10>): Uint<10> {"
      "  return b ? x + 1023 as Uint<10> : 0;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tunsigned 1023)])
             (tunsigned 1023)
          (if %b.1
              (downcast-unsigned
                1023
                (+ 11
                   (safe-cast (tunsigned 2046) (tunsigned 1023) %x.2)
                   (safe-cast (tunsigned 2046) (tunsigned 1023) 1023)))
              (safe-cast (tunsigned 1023) (tunsigned 0) 0)))))
    )

  (test
    '(
      "export circuit foo(n: Uint<3>, v1: Vector<4, Field>, v2: Vector<4, Uint<8>>): Vector<4, Field> {"
      "  return map((x, y, z) => x + y + z,"
      "             v1,"
      "             [n + 1, n * n, n + 10, n - 1],"
      "             v2);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n.1 (tunsigned 7)]
                         [%v1.2 (tvector 4 (tfield))]
                         [%v2.3 (tvector 4 (tunsigned 255))])
             (tvector 4 (tfield))
          (map
            (circuit ([%x.4 (tfield)]
                      [%y.5 (tunsigned 49)]
                      [%z.6 (tunsigned 255)])
                 (tfield)
              (+ #f
                 (+ #f %x.4 (safe-cast (tfield) (tunsigned 49) %y.5))
                 (safe-cast (tfield) (tunsigned 255) %z.6)))
            %v1.2
            (tuple
              (+ 4
                 (safe-cast (tunsigned 8) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 8) (tunsigned 1) 1))
              (* 6
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1))
              (+ 5
                 (safe-cast (tunsigned 17) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 17) (tunsigned 10) 10))
              (seq
                (assert
                  (if (< %n.1 (safe-cast (tunsigned 7) (tunsigned 1) 1)) #f #t)
                  "result of subtraction would be negative")
                (- 3 %n.1 (safe-cast (tunsigned 7) (tunsigned 1) 1))))
            %v2.3))))
    )

  (test
    '(
      "circuit bar(x: Uint<7>): [] {"
      "  assert(!(x == 0), 'oops');"
      "}"
      "export circuit foo(b: Boolean, x: Vector<2, Uint<3>>): Uint<16> {"
      "  return (b ? x : [0, 0])[1];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%b.1 (tboolean)]
                         [%x.2 (tvector 2 (tunsigned 7))])
             (tunsigned 65535)
          (safe-cast (tunsigned 65535)
                     (tunsigned 7)
            (tuple-ref
              (if %b.1
                  %x.2
                  (safe-cast (tvector 2 (tunsigned 7))
                             (ttuple (tunsigned 0) (tunsigned 0))
                    (tuple 0 0)))
              1)))))
    )

  (test
    '(
      "circuit bar(x: Uint<7>): Uint<7> {"
      "  assert(!(x == 0), 'oops');"
      "  return x;"
      "}"
      "export circuit foo(b: Boolean, x: Vector<2, Uint<3>>): [] {"
      "  return b ? x[0] : bar(x[1]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<7>" "[]" "circuit foo")))
    )

  (test
    '(
      "circuit bar(x: Uint<7>): Uint<7> {"
      "  assert(!(x == 0), 'oops');"
      "  return x;"
      "}"
      "export circuit foo(): [] {"
      "  return [];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 () (ttuple) (tuple))))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Uint<10>): Uint<10> {"
      "  return b ? x + 1023 as Uint<10> : 0;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tunsigned 1023)])
             (tunsigned 1023)
          (if %b.1
              (downcast-unsigned
                1023
                (+ 11
                   (safe-cast (tunsigned 2046) (tunsigned 1023) %x.2)
                   (safe-cast (tunsigned 2046) (tunsigned 1023) 1023)))
              (safe-cast (tunsigned 1023) (tunsigned 0) 0)))))
    )

  (test
    '(
      "export circuit foo(n: Uint<3>, v1: Vector<4, Field>, v2: Vector<4, Uint<8>>): Vector<4, Field> {"
      "  return map((x, y, z) => x + y + z,"
      "             v1,"
      "             [n + 1, n * n, n + 10, n - 1],"
      "             v2);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n.1 (tunsigned 7)]
                         [%v1.2 (tvector 4 (tfield))]
                         [%v2.3 (tvector 4 (tunsigned 255))])
             (tvector 4 (tfield))
          (map
            (circuit ([%x.4 (tfield)]
                      [%y.5 (tunsigned 49)]
                      [%z.6 (tunsigned 255)])
                 (tfield)
              (+ #f
                 (+ #f %x.4 (safe-cast (tfield) (tunsigned 49) %y.5))
                 (safe-cast (tfield) (tunsigned 255) %z.6)))
            %v1.2
            (tuple
              (+ 4
                 (safe-cast (tunsigned 8) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 8) (tunsigned 1) 1))
              (* 6
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 49) (tunsigned 7) %n.1))
              (+ 5
                 (safe-cast (tunsigned 17) (tunsigned 7) %n.1)
                 (safe-cast (tunsigned 17) (tunsigned 10) 10))
              (seq
                (assert
                  (if (< %n.1 (safe-cast (tunsigned 7) (tunsigned 1) 1)) #f #t)
                  "result of subtraction would be negative")
                (- 3 %n.1 (safe-cast (tunsigned 7) (tunsigned 1) 1))))
            %v2.3))))
    )

  (test
    '(
      "export circuit foo(n1: Field): Field {"
      "  return n1 as Field;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n1.1 (tfield)]) (tfield) %n1.1)))
    )

  (test
    '(
      "export circuit foo(n1: Uint<3>): Field {"
      "  return n1 as Field;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n1.1 (tunsigned 7)])
             (tfield)
          (safe-cast (tfield) (tunsigned 7) %n1.1))))
    )

  (test
    '(
      "export circuit foo(n1: Field): Uint<3> {"
      "  return n1 as Uint<3>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n1.1 (tfield)])
             (tunsigned 7)
          (downcast-unsigned 7 %n1.1))))
    )

  (test
    '(
      "export circuit foo(n1: Uint<3>): Uint<3> {"
      "  return n1 as Uint<3>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n1.1 (tunsigned 7)])
             (tunsigned 7)
          %n1.1)))
    )

  (test
    '(
      "export circuit foo(n1: Uint<3>): Uint<7> {"
      "  return n1 as Uint<7>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n1.1 (tunsigned 7)])
             (tunsigned 127)
          (safe-cast (tunsigned 127) (tunsigned 7) %n1.1))))
    )

  (test
    '(
      "export circuit foo(n1: Uint<13>): Uint<7> {"
      "  return n1 as Uint<7>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n1.1 (tunsigned 8191)])
             (tunsigned 127)
          (downcast-unsigned 127 %n1.1))))
    )

  (test
    '(
      "export circuit foo(bv: Bytes<10>): Bytes<10> {"
      "  return bv as Bytes<10>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%bv.1 (tbytes 10)]) (tbytes 10) %bv.1)))
    )

  (test
    '(
      "export circuit foo(bv: Bytes<3>): Bytes<10> {"
      "  return bv as Bytes<10>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "cannot cast from type ~a to type ~a" ("Bytes<3>" "Bytes<10>")))
    )

  (test
    '(
      "export circuit foo(bv: Bytes<10>): Bytes<3> {"
      "  return bv as Bytes<3>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "cannot cast from type ~a to type ~a" ("Bytes<10>" "Bytes<3>")))
    )

  (test
    '(
      "export circuit foo(): Boolean {"
      "  return 0 as Boolean;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 () (tboolean) #f)))
    )

  (test
    '(
      "export circuit foo(): Boolean {"
      "  return 1 as Boolean;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (tboolean)
          (if (== 1 (safe-cast (tunsigned 1) (tunsigned 0) 0)) #f #t))))
    )

  (test
    '(
      "export circuit foo(): Boolean {"
      "  return 5 as Boolean;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (tboolean)
          (if (== 5 (safe-cast (tunsigned 5) (tunsigned 0) 0)) #f #t))))
    )

  (test
    '(
      "export circuit foo(): Uint<3> {"
      "  return true as Uint<3>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (tunsigned 7)
          (if #t
              (safe-cast (tunsigned 7) (tunsigned 1) 1)
              (safe-cast (tunsigned 7) (tunsigned 0) 0)))))
    )

  (test
    '(
      "export circuit foo(b: Boolean): Uint<0..1> {"
      "  return b as Uint<0..1>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tunsigned 0)
          (if %b.1 (downcast-unsigned 0 1) 0))))
    )

  (test
    '(
      "export circuit foo(x: Boolean): Uint<3> {"
      "  return x as Uint<3>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%x.1 (tboolean)])
             (tunsigned 7)
          (if %x.1
              (safe-cast (tunsigned 7) (tunsigned 1) 1)
              (safe-cast (tunsigned 7) (tunsigned 0) 0)))))
    )

  (test
    '(
      "circuit bar(x: Uint<7>): [] {"
      "  assert(!(x == 0), 'oops');"
      "}"
      "export circuit foo(x: Uint<3>): Uint<30> {"
      "  return x * (bar(x), x);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%x.1 (tunsigned 127)])
             (ttuple)
          (seq
            (assert
              (if (== %x.1 (safe-cast (tunsigned 127) (tunsigned 0) 0))
                  #f
                  #t)
              "oops")
            (tuple)))
        (circuit %foo.2 ([%x.3 (tunsigned 7)])
             (tunsigned 1073741823)
          (safe-cast (tunsigned 1073741823)
                     (tunsigned 49)
            (* 6
               (safe-cast (tunsigned 49) (tunsigned 7) %x.3)
               (safe-cast (tunsigned 49)
                          (tunsigned 7)
                 (seq
                   (call %bar.0 (safe-cast (tunsigned 127) (tunsigned 7) %x.3))
                   %x.3)))))))
    )

  (test
    '(
      "circuit bar(x: Uint<7>): [] {"
      "  assert(!(x == 0), 'oops');"
      "}"
      "export circuit foo(x: Uint<3>): Uint<30> {"
      "  return x * (bar(x), x);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%x.1 (tunsigned 127)])
             (ttuple)
          (seq
            (assert
              (if (== %x.1 (safe-cast (tunsigned 127) (tunsigned 0) 0))
                  #f
                  #t)
              "oops")
            (tuple)))
        (circuit %foo.2 ([%x.3 (tunsigned 7)])
             (tunsigned 1073741823)
          (safe-cast (tunsigned 1073741823)
                     (tunsigned 49)
            (* 6
               (safe-cast (tunsigned 49) (tunsigned 7) %x.3)
               (safe-cast (tunsigned 49)
                          (tunsigned 7)
                 (seq
                   (call %bar.0 (safe-cast (tunsigned 127) (tunsigned 7) %x.3))
                   %x.3)))))))
    )

  (test
    '(
      "circuit bar(x: Uint<7>): [] {"
      "  assert(!(x == 0), 'oops');"
      "}"
      "export circuit foo(b: Boolean, x: Vector<2, Uint<3>>): Vector<2, Uint<30>> {"
      "  return b ? x : [0, 0];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%b.1 (tboolean)]
                         [%x.2 (tvector 2 (tunsigned 7))])
             (tvector 2 (tunsigned 1073741823))
          (safe-cast (tvector 2 (tunsigned 1073741823))
                     (tvector 2 (tunsigned 7))
            (if %b.1
                %x.2
                (safe-cast (tvector 2 (tunsigned 7))
                           (ttuple (tunsigned 0) (tunsigned 0))
                  (tuple 0 0)))))))
    )

  (test
    '(
      "circuit bar(x: [Field, [Field], Uint<32>]): Field {"
      "  return x[0] + x[1][0] + x[2];"
      "}"
      "export circuit foo1(): Field {"
      "  return bar([3, [5], 7]);"
      "}"
      "export circuit foo2(x: [Uint<8>, [Uint<8>], Uint<8>]): Field {"
      "  return bar(x);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%x.1 (ttuple
                                 (tfield)
                                 (ttuple (tfield))
                                 (tunsigned 4294967295))])
             (tfield)
          (+ #f
             (+ #f (tuple-ref %x.1 0) (tuple-ref (tuple-ref %x.1 1) 0))
             (safe-cast (tfield)
                        (tunsigned 4294967295)
               (tuple-ref %x.1 2))))
        (circuit %foo1.2 ()
             (tfield)
          (call %bar.0
            (safe-cast (ttuple
                         (tfield)
                         (ttuple (tfield))
                         (tunsigned 4294967295))
                       (ttuple (tunsigned 3) (ttuple (tunsigned 5)) (tunsigned 7))
              (tuple 3 (tuple 5) 7))))
        (circuit %foo2.3 ([%x.4 (ttuple
                                  (tunsigned 255)
                                  (ttuple (tunsigned 255))
                                  (tunsigned 255))])
             (tfield)
          (call %bar.0
            (safe-cast (ttuple
                         (tfield)
                         (ttuple (tfield))
                         (tunsigned 4294967295))
                       (ttuple
                         (tunsigned 255)
                         (ttuple (tunsigned 255))
                         (tunsigned 255))
              %x.4)))))
    )

  (test
    '(
      "witness W(): [];"
      "circuit bar(x: Vector<0, Field>): Field {"
      "  return 7;"
      "}"
      "export circuit foo(x: Vector<0, Uint<16>>): Field {"
      "  return bar((W(), x));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (witness %W.0 () (ttuple))
        (circuit %bar.1 ([%x.2 (tvector 0 (tfield))])
             (tfield)
          (safe-cast (tfield) (tunsigned 7) 7))
        (circuit %foo.3 ([%x.4 (tvector 0 (tunsigned 65535))])
             (tfield)
          (call %bar.1
            (safe-cast (tvector 0 (tfield))
                       (tvector 0 (tunsigned 65535))
              (seq (call %W.0) %x.4))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit foo<T>(x: T): T {"
      "  return x;"
      "}"
      "export circuit bar(y: [Uint<8>, Uint<8>]): Uint<32> {"
      "  return foo<[Uint<16>, Uint<16>]>(y)[0]"
      "         + foo<Vector<2, Uint<16>>>(y)[1]"
      "         + foo<Vector<2, Uint<16>>>(y)[0]"
      "         + foo<[Uint<16>, Uint<16>]>(y)[1];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.1 ([%x.2 (ttuple
                                 (tunsigned 65535)
                                 (tunsigned 65535))])
             (ttuple (tunsigned 65535) (tunsigned 65535))
          %x.2)
        (circuit %bar.3 ([%y.4 (ttuple
                                 (tunsigned 255)
                                 (tunsigned 255))])
             (tunsigned 4294967295)
          (safe-cast (tunsigned 4294967295)
                     (tunsigned 262140)
            (+ 18
               (safe-cast (tunsigned 262140)
                          (tunsigned 196605)
                 (+ 18
                    (safe-cast (tunsigned 196605)
                               (tunsigned 131070)
                      (+ 17
                         (safe-cast (tunsigned 131070)
                                    (tunsigned 65535)
                           (tuple-ref
                             (call %foo.1
                               (safe-cast (ttuple
                                            (tunsigned 65535)
                                            (tunsigned 65535))
                                       (ttuple (tunsigned 255) (tunsigned 255))
                                 %y.4))
                             0))
                         (safe-cast (tunsigned 131070)
                                    (tunsigned 65535)
                           (tuple-ref
                             (call %foo.1
                               (safe-cast (ttuple
                                            (tunsigned 65535)
                                            (tunsigned 65535))
                                          (ttuple (tunsigned 255) (tunsigned 255))
                                 %y.4))
                             1))))
                    (safe-cast (tunsigned 196605)
                               (tunsigned 65535)
                      (tuple-ref
                        (call %foo.1
                          (safe-cast (ttuple (tunsigned 65535) (tunsigned 65535))
                                     (ttuple (tunsigned 255) (tunsigned 255))
                            %y.4))
                        0))))
               (safe-cast (tunsigned 262140)
                          (tunsigned 65535)
                 (tuple-ref
                   (call %foo.1
                     (safe-cast (ttuple (tunsigned 65535) (tunsigned 65535))
                                (ttuple (tunsigned 255) (tunsigned 255))
                       %y.4))
                   1)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit foo<T>(x: T): T {"
      "  return x;"
      "}"
      "export circuit bar(y: [Uint<8>, Uint<8>]): Uint<32> {"
      "  return foo<Vector<2, Uint<16>>>(y)[0]"
      "         + foo<[Uint<16>, Uint<16>]>(y)[1]"
      "         + foo<[Uint<16>, Uint<16>]>(y)[0]"
      "         + foo<Vector<2, Uint<16>>>(y)[1];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.1 ([%x.2 (tvector 2 (tunsigned 65535))])
             (tvector 2 (tunsigned 65535))
          %x.2)
        (circuit %bar.3 ([%y.4 (ttuple
                                 (tunsigned 255)
                                 (tunsigned 255))])
             (tunsigned 4294967295)
          (safe-cast (tunsigned 4294967295)
                     (tunsigned 262140)
            (+ 18
               (safe-cast (tunsigned 262140)
                          (tunsigned 196605)
                 (+ 18
                    (safe-cast (tunsigned 196605)
                               (tunsigned 131070)
                      (+ 17
                         (safe-cast (tunsigned 131070)
                                    (tunsigned 65535)
                           (tuple-ref
                             (call %foo.1
                               (safe-cast (tvector 2 (tunsigned 65535))
                                          (ttuple (tunsigned 255) (tunsigned 255))
                                 %y.4))
                             0))
                         (safe-cast (tunsigned 131070)
                                    (tunsigned 65535)
                           (tuple-ref
                             (call %foo.1
                               (safe-cast (tvector 2 (tunsigned 65535))
                                          (ttuple (tunsigned 255) (tunsigned 255))
                                 %y.4))
                             1))))
                    (safe-cast (tunsigned 196605)
                               (tunsigned 65535)
                      (tuple-ref
                        (call %foo.1
                          (safe-cast (tvector 2 (tunsigned 65535))
                                     (ttuple (tunsigned 255) (tunsigned 255))
                            %y.4))
                        0))))
               (safe-cast (tunsigned 262140)
                          (tunsigned 65535)
                 (tuple-ref
                   (call %foo.1
                     (safe-cast (tvector 2 (tunsigned 65535))
                                (ttuple (tunsigned 255) (tunsigned 255))
                       %y.4))
                   1)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit foo<T>(x: T): T {"
      "  return x;"
      "}"
      "export circuit bar(y: Vector<2, Uint<8>>): Uint<32> {"
      "  return foo<[Uint<16>, Uint<16>]>(y)[0]"
      "         + foo<Vector<2, Uint<16>>>(y)[1]"
      "         + foo<Vector<2, Uint<16>>>(y)[0]"
      "         + foo<[Uint<16>, Uint<16>]>(y)[1];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.1 ([%x.2 (ttuple
                                 (tunsigned 65535)
                                 (tunsigned 65535))])
             (ttuple (tunsigned 65535) (tunsigned 65535))
          %x.2)
        (circuit %bar.3 ([%y.4 (tvector 2 (tunsigned 255))])
             (tunsigned 4294967295)
          (safe-cast (tunsigned 4294967295)
                     (tunsigned 262140)
            (+ 18
               (safe-cast (tunsigned 262140)
                          (tunsigned 196605)
                 (+ 18
                    (safe-cast (tunsigned 196605)
                               (tunsigned 131070)
                      (+ 17
                         (safe-cast (tunsigned 131070)
                                    (tunsigned 65535)
                           (tuple-ref
                             (call %foo.1
                               (safe-cast (ttuple
                                            (tunsigned 65535)
                                            (tunsigned 65535))
                                          (tvector 2 (tunsigned 255))
                                 %y.4))
                             0))
                         (safe-cast (tunsigned 131070)
                                    (tunsigned 65535)
                           (tuple-ref
                             (call %foo.1
                               (safe-cast (ttuple
                                            (tunsigned 65535)
                                            (tunsigned 65535))
                                          (tvector 2 (tunsigned 255))
                                 %y.4))
                             1))))
                    (safe-cast (tunsigned 196605)
                            (tunsigned 65535)
                      (tuple-ref
                        (call %foo.1
                          (safe-cast (ttuple (tunsigned 65535) (tunsigned 65535))
                                     (tvector 2 (tunsigned 255))
                            %y.4))
                        0))))
               (safe-cast (tunsigned 262140)
                          (tunsigned 65535)
                 (tuple-ref
                   (call %foo.1
                     (safe-cast (ttuple (tunsigned 65535) (tunsigned 65535))
                                (tvector 2 (tunsigned 255))
                       %y.4))
                   1)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit foo<T>(x: T): T {"
      "  return x;"
      "}"
      "export circuit bar(y: Vector<2, Uint<8>>): Uint<32> {"
      "  return foo<Vector<2, Uint<16>>>(y)[0]"
      "         + foo<[Uint<16>, Uint<16>]>(y)[1]"
      "         + foo<[Uint<16>, Uint<16>]>(y)[0]"
      "         + foo<Vector<2, Uint<16>>>(y)[1];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.1 ([%x.2 (tvector 2 (tunsigned 65535))])
             (tvector 2 (tunsigned 65535))
          %x.2)
        (circuit %bar.3 ([%y.4 (tvector 2 (tunsigned 255))])
             (tunsigned 4294967295)
          (safe-cast (tunsigned 4294967295)
                     (tunsigned 262140)
            (+ 18
               (safe-cast (tunsigned 262140)
                          (tunsigned 196605)
                 (+ 18
                    (safe-cast (tunsigned 196605)
                               (tunsigned 131070)
                      (+ 17
                         (safe-cast (tunsigned 131070)
                                    (tunsigned 65535)
                           (tuple-ref
                             (call %foo.1
                               (safe-cast (tvector 2 (tunsigned 65535))
                                          (tvector 2 (tunsigned 255))
                                 %y.4))
                             0))
                         (safe-cast (tunsigned 131070)
                                    (tunsigned 65535)
                           (tuple-ref
                             (call %foo.1
                               (safe-cast (tvector 2 (tunsigned 65535))
                                          (tvector 2 (tunsigned 255))
                                 %y.4))
                             1))))
                    (safe-cast (tunsigned 196605)
                               (tunsigned 65535)
                      (tuple-ref
                        (call %foo.1
                          (safe-cast (tvector 2 (tunsigned 65535))
                                     (tvector 2 (tunsigned 255))
                            %y.4))
                        0))))
               (safe-cast (tunsigned 262140)
                          (tunsigned 65535)
                 (tuple-ref
                   (call %foo.1
                     (safe-cast (tvector 2 (tunsigned 65535))
                                (tvector 2 (tunsigned 255))
                       %y.4))
                   1)))))))
    )

  (test
    '(
      "struct S { x: Field; }"
      "enum E { right, left };"
      "circuit bar(x: Vector<2, [Opaque<'string'>, E, S, Field]>): Field {"
      "  return x[1][2].x + x[0][3];"
      "}"
      "export circuit foo(x: Vector<2, [Opaque<'string'>, E, S, Uint<16>]>): Field {"
      "  return bar(x) + 7;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%x.1 (tvector
                                 2
                                 (ttuple
                                   (topaque "string")
                                   (tenum E right left)
                                   (tstruct S (x (tfield)))
                                   (tfield)))])
             (tfield)
          (+ #f
             (elt-ref (tuple-ref (tuple-ref %x.1 1) 2) x 0)
             (tuple-ref (tuple-ref %x.1 0) 3)))
        (circuit %foo.2 ([%x.3 (tvector
                                 2
                                 (ttuple
                                   (topaque "string")
                                   (tenum E right left)
                                   (tstruct S (x (tfield)))
                                   (tunsigned 65535)))])
             (tfield)
          (+ #f
             (call %bar.0
               (safe-cast (tvector
                            2
                            (ttuple
                              (topaque "string")
                              (tenum E right left)
                              (tstruct S (x (tfield)))
                              (tfield)))
                          (tvector
                            2
                            (ttuple
                              (topaque "string")
                              (tenum E right left)
                              (tstruct S (x (tfield)))
                              (tunsigned 65535)))
                 %x.3))
             (safe-cast (tfield) (tunsigned 7) 7)))))
    )

  (test
    '(
      "circuit bar(x: Vector<2, [[], Boolean, Bytes<32>, Field]>): Field {"
      "  return x[0][3] + 11;"
      "}"
      "export circuit foo(x: Vector<2, [[], Boolean, Bytes<32>, Uint<16>]>): Field {"
      "  return bar(x) + 7;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %bar.0 ([%x.1 (tvector
                                 2
                                 (ttuple
                                   (ttuple)
                                   (tboolean)
                                   (tbytes 32)
                                   (tfield)))])
             (tfield)
          (+ #f
             (tuple-ref (tuple-ref %x.1 0) 3)
             (safe-cast (tfield) (tunsigned 11) 11)))
        (circuit %foo.2 ([%x.3 (tvector
                                 2
                                 (ttuple
                                   (ttuple)
                                   (tboolean)
                                   (tbytes 32)
                                   (tunsigned 65535)))])
             (tfield)
          (+ #f
             (call %bar.0
               (safe-cast (tvector
                            2
                            (ttuple (ttuple) (tboolean) (tbytes 32) (tfield)))
                          (tvector
                            2
                            (ttuple
                              (ttuple)
                              (tboolean)
                              (tbytes 32)
                              (tunsigned 65535)))
                 %x.3))
             (safe-cast (tfield) (tunsigned 7) 7)))))
    )

  ; pm-16893
  ; Internal compiler error: Exception: failed assertion cannot-happen at line 3057, char 29 of compiler/analysis-passes.ss
  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field: Field;"
      ""
      "constructor(x: Field) {"
      ""
      "  for (const x of []) {"
      "    field.write(x);"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%field.1 (__compact_Cell (tfield)))
          (constructor ([%x.2 (tfield)])
            (seq
              (fold
                (circuit ([%t.3 (ttuple)] [%x.4 (tunknown)])
                     (ttuple)
                  (seq
                    (seq
                      (public-ledger %field.1
                        (write (safe-cast (tfield) (tunknown) %x.4)))
                      (tuple))
                    %t.3))
                (tuple)
                (tuple))
              (tuple))))))
    )

  ; pm-16893
  (test
    '(
      "constructor(x: Field) {"
      "  for (const x of []) {"
      "    const k: Field = x;"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration
          (constructor ([%x.0 (tfield)])
            (seq
              (fold
                (circuit ([%t.1 (ttuple)] [%x.2 (tunknown)])
                     (ttuple)
                  (seq
                    (seq
                      (let* ([[%k.3 (tfield)]
                              (safe-cast (tfield) (tunknown) %x.2)])
                        (tuple))
                      (tuple))
                    %t.1))
                (tuple)
                (tuple))
              (tuple))))))
    )

  ; pm-16893
  (test
    '(
      "constructor(x: Field) {"
      "  fold((a, x) => { const k: Field = x; return a; }, 0, []);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration
          (constructor ([%x.0 (tfield)])
            (seq
              (fold
                (circuit ([%a.1 (tunsigned 0)] [%x.2 (tunknown)])
                     (tunsigned 0)
                  (let* ([[%k.3 (tfield)] (safe-cast (tfield) (tunknown) %x.2)])
                    %a.1))
                0
                (tuple))
              (tuple))))))
    )

  ; pm-16893
  (test
    '(
      "constructor(x: Field) {"
      "  map((x) => { const k: Field = x; return x; }, []);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration
          (constructor ([%x.0 (tfield)])
            (seq
              (map
                (circuit ([%x.1 (tunknown)])
                     (tunknown)
                  (let* ([[%k.2 (tfield)] (safe-cast (tfield) (tunknown) %x.1)])
                    %x.1))
                (tuple))
              (tuple))))))
    )

  ; pm-16893
  (test
    '(
      "constructor(x: Field) {"
      "  const v = [];"
      "  map((x) => { const k: Field = x; return x; }, v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration
          (constructor ([%x.0 (tfield)])
            (seq
              (let* ([[%v.1 (ttuple)] (tuple)])
                (map
                  (circuit ([%x.2 (tunknown)])
                       (tunknown)
                    (let* ([[%k.3 (tfield)] (safe-cast (tfield) (tunknown) %x.2)])
                      %x.2))
                  %v.1))
              (tuple))))))
    )

  ; pm-16893
  (test
    '(
      "circuit bar(): [] {}"
      "constructor(x: Field) {"
      "  map((x) => { const k: Field = x; return x + k; }, bar());"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 43" "~a requires its ~a operand to be a Field or Uint; the actual type is ~a" (+ "left" "Unknown")))
    )

  (test
    '(
      "circuit foo(x: Field): Field { return x; }"
      "constructor(x: Field) {"
      "  map(foo, []);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration
          (constructor ([%x.0 (tfield)])
            (seq
              (map %foo.1 (tuple))
              (tuple))))
        (circuit %foo.1 ([%x.2 (tfield)]) (tfield) %x.2)))
    )

  (test
    '(
      "constructor() {"
      "  const k: Vector<0, Field> = [];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration
          (constructor ()
            (seq
              (let* ([[%k.0 (tvector 0 (tfield))] (tuple)]) (tuple))
              (tuple))))))
    )
  ; end of tests inherited from eliminate-redundant-upcasts
)

(run-tests recognize-let
  (test
    '(
      "circuit foo(n: Field): Boolean {"
      "  const x = !(n == 1);"
      "  return ((x) => x && n == 0)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  return foo(n+1) ? n - 1 : n + 1;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n.1 (tfield)])
             (tboolean)
          (let* ([[%x.2 (tboolean)] (if (== %n.1 (safe-cast (tfield) (tunsigned 1) 1))
                                        #f
                                        #t)])
            (let* ([[%x.3 (tboolean)] (if %x.2 #f #t)])
              (if %x.3 (== %n.1 (safe-cast (tfield) (tunsigned 0) 0)) #f))))
        (circuit %bar.4 ([%n.5 (tfield)])
             (tfield)
          (if (call %foo.0 (+ #f %n.5 (safe-cast (tfield) (tunsigned 1) 1)))
              (- #f %n.5 (safe-cast (tfield) (tunsigned 1) 1))
              (+ #f %n.5 (safe-cast (tfield) (tunsigned 1) 1))))))
    )

  (test
    '(
      "circuit foo(n: Field): Field {"
      "  const x = n == 0;"
      "  return 1 + ((x) => x == false ? n + 7 : n + 13)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  return foo(n-1) * foo(n-2) * 3;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%n.1 (tfield)])
             (tfield)
          (let* ([[%x.2 (tboolean)] (== %n.1 (safe-cast (tfield) (tunsigned 0) 0))])
            (+ #f
               (safe-cast (tfield) (tunsigned 1) 1)
               (let* ([[%x.3 (tboolean)] (if %x.2 #f #t)])
                 (if (== %x.3 #f)
                     (+ #f %n.1 (safe-cast (tfield) (tunsigned 7) 7))
                     (+ #f %n.1 (safe-cast (tfield) (tunsigned 13) 13)))))))
        (circuit %bar.4 ([%n.5 (tfield)])
             (tfield)
          (* #f
             (* #f
                (call %foo.0 (- #f %n.5 (safe-cast (tfield) (tunsigned 1) 1)))
                (call %foo.0 (- #f %n.5 (safe-cast (tfield) (tunsigned 2) 2))))
             (safe-cast (tfield) (tunsigned 3) 3)))))
    )

  (test
    '(
      "circuit foo(x: Field): Field {"
      "  return 1 + (() => x)();"
      "}"
      "export circuit bar(n: Field): Field {"
      "  return foo(n) * foo(n+1) * 3;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%x.1 (tfield)])
             (tfield)
          (+ #f (safe-cast (tfield) (tunsigned 1) 1) (let* () %x.1)))
        (circuit %bar.2 ([%n.3 (tfield)])
             (tfield)
          (* #f
             (* #f
                (call %foo.0 %n.3)
                (call %foo.0 (+ #f %n.3 (safe-cast (tfield) (tunsigned 1) 1))))
             (safe-cast (tfield) (tunsigned 3) 3)))))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Field): Field {"
      "  return 1 + ((b, x) => x ? b - 1 : b + 1)(x + 1, !b);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tfield)])
             (tfield)
          (+ #f
             (safe-cast (tfield) (tunsigned 1) 1)
             (let* ([[%b.3 (tfield)] (+ #f %x.2 (safe-cast (tfield) (tunsigned 1) 1))]
                    [[%x.4 (tboolean)] (if %b.1 #f #t)])
               (if %x.4
                   (- #f %b.3 (safe-cast (tfield) (tunsigned 1) 1))
                   (+ #f %b.3 (safe-cast (tfield) (tunsigned 1) 1))))))))
    )

  (test
    "examples/tiny.compact"
    (returns
      (program
        (kernel-declaration (%kernel.1 (Kernel)))
        (public-ledger-declaration
          (%authority.2 (__compact_Cell (tbytes 32)))
          (%value.3 (__compact_Cell (tfield)))
          (%state.4 (__compact_Cell (tenum STATE unset set)))
          (constructor ([%v.0 (tfield)])
            (seq
              (let* ([[%sk.5 (tbytes 32)] (call %private$secretKey.6)])
                (seq
                  (public-ledger %authority.2
                    (write (call %publicKey.7 %sk.5)))
                  (public-ledger %value.3 (write (disclose %v.0)))
                  (public-ledger %state.4
                    (write (enum-ref (tenum STATE unset set) set)))))
              (tuple))))
        (type-definition Maybe (T)
          (tstruct Maybe (is_some (tboolean)) (value T)))
        (circuit %some.8 ([%value.9 (tfield)])
             (tstruct Maybe (is_some (tboolean)) (value (tfield)))
          (new (tstruct Maybe (is_some (tboolean)) (value (tfield)))
            #t
            %value.9))
        (circuit %none.10 ()
             (tstruct Maybe (is_some (tboolean)) (value (tfield)))
          (new (tstruct Maybe (is_some (tboolean)) (value (tfield)))
            #f
            (default (tfield))))
        (external %persistentHash<.11 ([%value.12 (tvector
                                                    2
                                                    (tbytes 32))])
             (tbytes 32))
        (witness %private$secretKey.6 () (tbytes 32))
        (circuit %inState.13 ([%s.14 (tenum STATE unset set)])
             (tboolean)
          (== (public-ledger %state.4 (read)) %s.14))
        (circuit %set.15 ([%v.16 (tfield)])
             (ttuple)
          (seq
            (seq
              (assert
                (call %inState.13 (enum-ref (tenum STATE unset set) unset))
                "set: attempted to overwrite recorded value")
              (let* ([[%sk.17 (tbytes 32)] (call %private$secretKey.6)])
                (let* ([[%apk.18 (tbytes 32)] (call %publicKey.7 %sk.17)])
                  (seq
                    (public-ledger %authority.2 (write %apk.18))
                    (public-ledger %value.3 (write (disclose %v.16)))
                    (public-ledger %state.4
                      (write (enum-ref (tenum STATE unset set) set)))))))
            (tuple)))
        (circuit %get.19 ()
             (tstruct Maybe (is_some (tboolean)) (value (tfield)))
          (if (call %inState.13
                (enum-ref (tenum STATE unset set) set))
              (call %some.8 (public-ledger %value.3 (read)))
              (call %none.10)))
        (circuit %clear.20 ()
             (ttuple)
          (seq
            (seq
              (assert
                (call %inState.13 (enum-ref (tenum STATE unset set) set))
                "clear: no value is currently recorded")
              (let* ([[%sk.21 (tbytes 32)] (call %private$secretKey.6)])
                (let* ([[%apk.22 (tbytes 32)] (call %publicKey.7 %sk.21)])
                  (seq
                    (assert
                      (== %apk.22 (public-ledger %authority.2 (read)))
                      "clear: attempted clear without proper authorization")
                    (public-ledger %authority.2 (write (default (tbytes 32))))
                    (public-ledger %value.3 (write (default (tfield))))
                    (public-ledger %state.4
                      (write (enum-ref (tenum STATE unset set) unset)))))))
            (tuple)))
        (circuit %publicKey.7 ([%sk.23 (tbytes 32)])
             (tbytes 32)
          (disclose
            (call %persistentHash<.11
              (tuple
                #vu8(108 97 114 101 115 58 116 105 110 121 58 112 107 58 0 0
                     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                %sk.23))))))
    )

  (test
    '(
      "export circuit foo(): [Field, Field, Field] { return map((n) => n + 1, [1, 2, 3]); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (ttuple (tfield) (tfield) (tfield))
          (safe-cast (ttuple (tfield) (tfield) (tfield))
                     (tvector 3 (tunsigned 4))
            (map
              (circuit ([%n.1 (tunsigned 3)])
                   (tunsigned 4)
                (+ 3
                   (safe-cast (tunsigned 4) (tunsigned 3) %n.1)
                   (safe-cast (tunsigned 4) (tunsigned 1) 1)))
              (tuple 1 2 3))))))
    )

  (test
    '(
      "export circuit foo(): [] { return map((n: Field) => n + 1, []); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (ttuple)
          (map
            (circuit ([%n.1 (tfield)])
                 (tfield)
              (+ #f %n.1 (safe-cast (tfield) (tunsigned 1) 1)))
            (tuple)))))
    )

  (test
    '(
      "export circuit foo(): Field { return fold((a, n): Field => a + n, 0, [1, 2, 3, 4, 5]); }"
      )
    (returns
      (program
        (public-ledger-declaration (constructor () (tuple)))
        (circuit %foo.0 ()
             (tfield)
          (fold
            (circuit ([%a.1 (tfield)] [%n.2 (tunsigned 5)])
                 (tfield)
              (+ #f %a.1 (safe-cast (tfield) (tunsigned 5) %n.2)))
            (safe-cast (tfield) (tunsigned 0) 0)
            (tuple 1 2 3 4 5)))))
    )
)

(run-tests check-sealed-fields
  (test
    '(
      "import CompactStandardLibrary;"
      "sealed ledger q: Field;"
      "constructor() { q = 1000; }"
      "export circuit foo(): Field { return q; }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%q.1 (__compact_Cell (tfield)))
          (constructor ()
            (seq
              (public-ledger %q.1 (write (safe-cast (tfield) (tunsigned 1000) 1000)))
              (tuple))))
        (circuit %foo.0 () (tfield) (public-ledger %q.1 (read)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "sealed ledger q: Field;"
      "constructor() { q = 1000; }"
      "export circuit foo(): Field { q = q + 1; return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 1" "exported circuits cannot modify sealed ledger fields but ~a calls (directly or indirectly) ~a, which ~a at ~a" (foo foo "modifies sealed field q" "line 4 char 31")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "sealed ledger ctr: Counter;"
      "ledger q: Map<Field, Field>;"
      "constructor() { q.insert(1, 1000); }"
      "export circuit foo(): Field { return q.lookup((ctr.increment(1), ctr)); }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 1" "exported circuits cannot modify sealed ledger fields but ~a calls (directly or indirectly) ~a, which ~a at ~a" (foo foo "modifies sealed field ctr" "line 5 char 48")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { q = n; }"
      "}"
      "import M;"
      "constructor() { init(37); }"
      "export circuit foo(): Field { return q; }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%q.1 (__compact_Cell (tfield)))
          (constructor ()
            (seq (call %init.2 (safe-cast (tfield) (tunsigned 37) 37)) (tuple))))
        (circuit %init.2 ([%n.3 (tfield)])
             (ttuple)
          (seq (public-ledger %q.1 (write %n.3)) (tuple)))
        (circuit %foo.4 () (tfield) (public-ledger %q.1 (read)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { q = n; }"
      "}"
      "import M;"
      "constructor() { init(37); }"
      "export circuit foo(): Field { init(73); return q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 1" "exported circuits cannot modify sealed ledger fields but ~a calls (directly or indirectly) ~a, which ~a at ~a" (foo init "modifies sealed field q" "line 4 char 39")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { q = n; }"
      "}"
      "import M prefix M$;"
      "constructor() { M$init(37); }"
      "export circuit foo(): Field { return M$q; }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%q.1 (__compact_Cell (tfield)))
          (constructor ()
            (seq (call %M$init.2 (safe-cast (tfield) (tunsigned 37) 37)) (tuple))))
        (circuit %M$init.2 ([%n.3 (tfield)])
             (ttuple)
          (seq (public-ledger %q.1 (write %n.3)) (tuple)))
        (circuit %foo.4 () (tfield) (public-ledger %q.1 (read)))))
    )

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export sealed ledger q: Field;"
         "  export circuit init(n: Field): [] { q = n; }"
         "}"))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "import 'M' prefix M$;"
         "constructor() { M$init(37); }"
         "export circuit foo(): Field { M$init(73); return M$q; }"
      ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 1" "exported circuits cannot modify sealed ledger fields but ~a calls (directly or indirectly) ~a, which ~a at ~a" (foo init "modifies sealed field q" "M.compact line 3 char 39"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { q = n; }"
      "}"
      "import M prefix M$;"
      "constructor() { M$init(37); }"
      "export circuit foo(): Field { M$init(73); return M$q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 1" "exported circuits cannot modify sealed ledger fields but ~a calls (directly or indirectly) ~a, which ~a at ~a" (foo init "modifies sealed field q" "line 4 char 39")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { q = n; }"
      "}"
      "import M prefix M$;"
      "constructor() { M$init(37); }"
      "export circuit foo(): Field { return M$q; }"
      "export { M$q }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%M$q.1 (__compact_Cell (tfield)))
          (constructor ()
            (seq (call %M$init.2 (safe-cast (tfield) (tunsigned 37) 37)) (tuple))))
        (circuit %M$init.2 ([%n.3 (tfield)])
             (ttuple)
          (seq (public-ledger %M$q.1 (write %n.3)) (tuple)))
        (circuit %foo.4 () (tfield) (public-ledger %M$q.1 (read)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { q = n; }"
      "}"
      "import M prefix M$;"
      "constructor() { M$init(37); }"
      "export circuit foo(): Field { M$init(37); return M$q; }"
      "export { M$q }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 1" "exported circuits cannot modify sealed ledger fields but ~a calls (directly or indirectly) ~a, which ~a at ~a" (foo init "modifies sealed field q" "line 4 char 39")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { q = n; }"
      "}"
      "import M prefix M$;"
      "export sealed ledger q: Set<Boolean>;"
      "constructor() { M$init(37); }"
      "export circuit foo(): Field { q.insert(true); M$init(73); return M$q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 1" "exported circuits cannot modify sealed ledger fields but ~a calls (directly or indirectly) ~a, which ~a at ~a" (foo foo "modifies sealed field q" "line 9 char 31")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "sealed ledger q: Map<Uint<8>, Map<Uint<8>, Uint<16>>>;"
      "constructor() { }"
      "export circuit foo(): Uint<16> { return q.lookup(7).lookup(11); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 (Kernel)))
        (public-ledger-declaration
          (%q.1
            (Map (tunsigned 255)
                 (Map (tunsigned 255) (tunsigned 65535))))
          (constructor () (tuple)))
        (circuit %foo.2 ()
             (tunsigned 65535)
          (public-ledger %q.1
            (lookup (safe-cast (tunsigned 255) (tunsigned 7) 7))
            (lookup (safe-cast (tunsigned 255) (tunsigned 11) 11))))))
    )
)

(run-tests identify-pure-circuits
  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    const x = disclose(ix);"
      "    F = disclose(x * 3);"
      "    return F;"
      "  }"
      "  export circuit foo(ix: Field, iy: Field): Field {"
      "    const x = disclose(ix), y = disclose(iy);"
      "    F = disclose(x + y);"
      "    return F;"
      "  }"
      "}"
      "import M;"
      "export pure circuit bar(ix: Uint<32>): [Field, Field] {"
      "  return [foo(ix), foo(ix, ix)];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 15 char 1" "circuit ~a is marked pure but is actually impure because it calls (directly or indirectly) impure circuit ~a;\n    ~:*~a is impure because it ~a at ~a" (bar foo "accesses ledger field F" "line 6 char 12")))
    )
)

(run-tests propagate-ledger-paths
  (test
    '(
      "import CompactStandardLibrary;"
      "ledger f1: Field;"
      "ledger f2: Field;"
      "ledger f3: Field;"
      "ledger f4: Field;"
      "ledger f5: Field;"
      "ledger f6: Field;"
      "ledger f7: Field;"
      "ledger f8: Field;"
      "ledger f9: Field;"
      "ledger f10: Field;"
      "ledger f11: Field;"
      "ledger f12: Field;"
      "ledger f13: Field;"
      "ledger f14: Field;"
      "ledger f15: Field;"
      "ledger f16: Field;"
      "ledger f17: Field;"
      "ledger f18: Field;"
      "ledger f19: Field;"
      "ledger f20: Field;"
      "ledger f21: Field;"
      "ledger f22: Field;"
      "ledger f23: Field;"
      "ledger f24: Field;"
      "ledger f25: Field;"
      "ledger f26: Field;"
      "ledger f27: Field;"
      "ledger f28: Field;"
      "ledger f29: Field;"
      "ledger f30: Field;"
      "export circuit foo(): Field {"
      "  return f16;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          (((%f1.1 (0 0) (__compact_Cell (tfield))) (%f2.2 (0 1) (__compact_Cell (tfield))) (%f3.3 (0 2) (__compact_Cell (tfield)))
             (%f4.4 (0 3) (__compact_Cell (tfield))) (%f5.5 (0 4) (__compact_Cell (tfield)))
             (%f6.6 (0 5) (__compact_Cell (tfield))) (%f7.7 (0 6) (__compact_Cell (tfield)))
             (%f8.8 (0 7) (__compact_Cell (tfield))) (%f9.9 (0 8) (__compact_Cell (tfield)))
             (%f10.10 (0 9) (__compact_Cell (tfield)))
             (%f11.11 (0 10) (__compact_Cell (tfield)))
             (%f12.12 (0 11) (__compact_Cell (tfield)))
             (%f13.13 (0 12) (__compact_Cell (tfield)))
             (%f14.14 (0 13) (__compact_Cell (tfield)))
             (%f15.15 (0 14) (__compact_Cell (tfield))))
           ((%f16.16 (1 0) (__compact_Cell (tfield))) (%f17.17 (1 1) (__compact_Cell (tfield)))
             (%f18.18 (1 2) (__compact_Cell (tfield)))
             (%f19.19 (1 3) (__compact_Cell (tfield)))
             (%f20.20 (1 4) (__compact_Cell (tfield)))
             (%f21.21 (1 5) (__compact_Cell (tfield)))
             (%f22.22 (1 6) (__compact_Cell (tfield)))
             (%f23.23 (1 7) (__compact_Cell (tfield)))
             (%f24.24 (1 8) (__compact_Cell (tfield)))
             (%f25.25 (1 9) (__compact_Cell (tfield)))
             (%f26.26 (1 10) (__compact_Cell (tfield)))
             (%f27.27 (1 11) (__compact_Cell (tfield)))
             (%f28.28 (1 12) (__compact_Cell (tfield)))
             (%f29.29 (1 13) (__compact_Cell (tfield)))
             (%f30.30 (1 14) (__compact_Cell (tfield)))))
          (constructor () (tuple)))
        (circuit %foo.31 ()
             (tfield)
          (public-ledger %f16.16 (1 0) read))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger x: Field;"
      ""
      "export circuit foo(): [] {"
      "  x = x;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%x.1 (0) (__compact_Cell (tfield))))
          (constructor () (tuple)))
        (circuit %foo.2 ()
             (ttuple)
          (seq
            (let* ([[%tmp.3 (tfield)] (public-ledger %x.1 (0) read)])
              (public-ledger %x.1 (0) write %tmp.3))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export enum E { a, b, c }"
      ""
      "witness flip(): Boolean;"
      "witness flop(): Field;"
      "witness clip(): E;"
      "witness clop(): Uint<16>;"
      ""
      "ledger x: Map<Field, Boolean>;"
      "ledger y: Map<Uint<16>, E>;"
      ""
      "export circuit foo(): [] {"
      "  x.insert(default<Field>, default<Boolean>);"
      "  x.insert(7, flip());"
      "  x.insert(flop(), true);"
      "  x.insert(flop(), flip());"
      "}"
      ""
      "export circuit bar(): [] {"
      "  y.insert(default<Uint<16>>, default<E>);"
      "  y.insert(7, clip());"
      "  y.insert(clop(), E.c);"
      "  y.insert(clop(), clip());"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%x.1 (0) (Map (tfield) (tboolean)))
           (%y.2 (1) (Map (tunsigned 65535) (tenum E a b c))))
          (constructor () (tuple)))
        (type-definition E () (tenum E a b c))
        (witness %flip.3 () (tboolean))
        (witness %flop.4 () (tfield))
        (witness %clip.5 () (tenum E a b c))
        (witness %clop.6 () (tunsigned 65535))
        (circuit %foo.7 ()
             (ttuple)
          (seq
            (public-ledger %x.1 (0) insert
              (default (tfield))
              (default (tboolean)))
            (let* ([[%tmp.8 (tfield)] (safe-cast (tfield) (tunsigned 7) 7)])
              (let* ([[%tmp.9 (tboolean)] (call %flip.3)])
                (public-ledger %x.1 (0) insert %tmp.8 %tmp.9)))
            (let* ([[%tmp.10 (tfield)] (call %flop.4)])
              (public-ledger %x.1 (0) insert %tmp.10 #t))
            (let* ([[%tmp.11 (tfield)] (call %flop.4)])
              (let* ([[%tmp.12 (tboolean)] (call %flip.3)])
                (public-ledger %x.1 (0) insert %tmp.11 %tmp.12)))
            (tuple)))
        (circuit %bar.13 ()
             (ttuple)
          (seq
            (public-ledger %y.2 (1) insert
              (default (tunsigned 65535))
              (default (tenum E a b c)))
            (let* ([[%tmp.14 (tunsigned 65535)]
                    (safe-cast (tunsigned 65535) (tunsigned 7) 7)])
              (let* ([[%tmp.15 (tenum E a b c)] (call %clip.5)])
                (public-ledger %y.2 (1) insert %tmp.14 %tmp.15)))
            (let* ([[%tmp.16 (tunsigned 65535)] (call %clop.6)])
              (public-ledger %y.2 (1) insert
                %tmp.16
                (enum-ref (tenum E a b c) c)))
            (let* ([[%tmp.17 (tunsigned 65535)] (call %clop.6)])
              (let* ([[%tmp.18 (tenum E a b c)] (call %clip.5)])
                (public-ledger %y.2 (1) insert %tmp.17 %tmp.18)))
            (tuple)))))
    )
)

(run-tests track-witness-data
  (test
    '(
      "ledger X: Field;"
      "witness w(): Field;"
      "export circuit foo(): Field {"
      "  return X;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%X.1 (0) (__compact_Cell (tfield))))
          (constructor () (tuple)))
        (circuit %foo.2 () (tfield) (public-ledger %X.1 (0) read))))
    )

  (test
    '(
      "ledger X: Field;"
      "witness w(): Field;"
      "export circuit foo(): [] {"
      "  X = w();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 2 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of = at line 4 char 5"))))
    )

  (test
    '(
      "ledger X: Field;"
      "witness w(): Field;"
      "export circuit foo(): [] {"
      "  const x = w();"
      "  X = x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 2 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the binding of x at line 4 char 9\n      the right-hand side of = at line 5 char 5"))))
    )

  (test
    '(
      "ledger X: Boolean;"
      "witness w(): Field;"
      "export circuit foo(): [] {"
      "  const x = w() == 37;"
      "  X = x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 2 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of a comparison involving the witness value\n    via this path through the program:\n      the comparison at line 4 char 13\n      the binding of x at line 4 char 9\n      the right-hand side of = at line 5 char 5"))))
    )

  (test
    '(
      "ledger X: Boolean;"
      "witness w(): Field;"
      "export circuit foo(): [] {"
      "  const x = w() == 37;"
      "  X = x != true;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 2 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of a comparison involving the result of a comparison involving the witness value\n    via this path through the program:\n      the comparison at line 4 char 13\n      the binding of x at line 4 char 9\n      the comparison at line 5 char 7\n      the right-hand side of = at line 5 char 5"))))
    )

  (test
    '(
      "ledger X: [Field, Boolean];"
      "witness w(): Field;"
      "export circuit foo(): [] {"
      "  const x = w() == 37;"
      "  X = [w(), x != true];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 2 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of = at line 5 char 5" "\n    nature of the disclosure:\n      ledger operation might disclose the result of a comparison involving the result of a comparison involving the witness value\n    via this path through the program:\n      the comparison at line 4 char 13\n      the binding of x at line 4 char 9\n      the comparison at line 5 char 13\n      the right-hand side of = at line 5 char 5"))))
    )

  (test
    '(
      "ledger X: Boolean;"
      "witness w(): Field;"
      "export circuit foo(): [] {"
      "  const x = w() == 37;"
      "  X = !x;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 2 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the comparison at line 4 char 13\n      the binding of x at line 4 char 9\n      the conditional expression at line 5 char 7\n      the right-hand side of = at line 5 char 5"))))
    )

  (test
    '(
      "struct S { a: Boolean, b: Bytes<16> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(): S {"
      "  return S{true, w()};"
      "}"
      "export circuit foo(): [] {"
      "  const x = bar();"
      "  X = x.b;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the binding of x at line 8 char 9\n      the right-hand side of = at line 9 char 5"))))
    )

  (test
    '(
      "struct S { a: Boolean, b: Bytes<16> };"
      "ledger X: Bytes<16>;"
      "witness w(): Boolean;"
      "circuit bar(): S {"
      "  return S{w(), 'c7c7c7c7c7c7c7c7'};"
      "}"
      "export circuit foo(): [] {"
      "  const x = bar();"
      "  X = x.b;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%X.1 (0) (__compact_Cell (tbytes 16))))
          (constructor () (tuple)))
        (witness %w.2 () (tboolean))
        (circuit %bar.3 ()
             (tstruct S (a (tboolean)) (b (tbytes 16)))
          (new (tstruct S (a (tboolean)) (b (tbytes 16)))
            (call %w.2)
            #vu8(99 55 99 55 99 55 99 55 99 55 99 55 99 55 99 55)))
        (circuit %foo.4 ()
             (ttuple)
          (seq
            (let* ([[%x.5 (tstruct S (a (tboolean)) (b (tbytes 16)))]
                    (call %bar.3)])
              (let* ([[%tmp.6 (tbytes 16)] (elt-ref %x.5 b 1)])
                (public-ledger %X.1 (0) write %tmp.6)))
            (tuple)))))
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "ledger X: Bytes<16>;"
      "witness w1(): Bytes<16>;"
      "witness w2(): Bytes<16>;"
      "export circuit bar(b: Boolean, s: S): [] {"
      "  X = disclose(b ? s.a : s.b);"
      "}"
      "export circuit foo(): [] {"
      "  bar(true, S{'c7c7c7c7c7c7c7c7', w1()});"
      "  bar(false, S{w2(), 'c7c7c7c7c7c7c7c7'});"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%X.1 (0) (__compact_Cell (tbytes 16))))
          (constructor () (tuple)))
        (witness %w1.2 () (tbytes 16))
        (witness %w2.3 () (tbytes 16))
        (circuit %bar.4 ([%b.5 (tboolean)]
                         [%s.6 (tstruct S (a (tbytes 16)) (b (tbytes 16)))])
             (ttuple)
          (seq
            (let* ([[%tmp.7 (tbytes 16)]
                    (disclose
                      (if %b.5 (elt-ref %s.6 a 0) (elt-ref %s.6 b 1)))])
              (public-ledger %X.1 (0) write %tmp.7))
            (tuple)))
        (circuit %foo.8 ()
             (ttuple)
          (seq
            (call %bar.4
              #t
              (new (tstruct S (a (tbytes 16)) (b (tbytes 16)))
                #vu8(99 55 99 55 99 55 99 55 99 55 99 55 99 55 99 55)
                (call %w1.2)))
            (call %bar.4
              #f
              (new (tstruct S (a (tbytes 16)) (b (tbytes 16)))
                (call %w2.3)
                #vu8(99 55 99 55 99 55 99 55 99 55 99 55 99 55 99 55)))
            (tuple)))))
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "ledger X: Bytes<16>;"
      "witness w1(): Bytes<16>;"
      "witness w2(): Bytes<16>;"
      "circuit bar(b: Boolean, s: S): [] {"
      "  if (b)"
      "    X = s.a;"
      "  else"
      "    X = s.b;"
      "}"
      "export circuit foo(): [] {"
      "  bar(true, S{'c7c7c7c7c7c7c7c7', w1()});"
      "  bar(false, S{w2(), 'c7c7c7c7c7c7c7c7'});"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.4 () (Kernel)))
        (public-ledger-declaration
          ((%X.5 (0) (__compact_Cell (tbytes 16))))
          (constructor () (tuple)))
        (witness %w1.1 () (tbytes 16))
        (witness %w2.3 () (tbytes 16))
        (circuit %bar.2 ([%b.6 (tboolean)]
                         [%s.7 (tstruct S (a (tbytes 16)) (b (tbytes 16)))])
             (ttuple)
          (seq
            (if %b.6
                (let* ([[%tmp.8 (tbytes 16)] (elt-ref %s.7 a 0)])
                  (public-ledger %X.5 (0) write %tmp.8))
                (let* ([[%tmp.9 (tbytes 16)] (elt-ref %s.7 b 1)])
                  (public-ledger %X.5 (0) write %tmp.9)))
            (tuple)))
        (circuit %foo.0 ()
             (ttuple)
          (seq
            (call %bar.2
              #t
              (new (tstruct S (a (tbytes 16)) (b (tbytes 16)))
                #vu8(99 55 99 55 99 55 99 55 99 55 99 55 99 55 99 55)
                (call %w1.1)))
            (call %bar.2
              #f
              (new (tstruct S (a (tbytes 16)) (b (tbytes 16)))
                (call %w2.3)
                #vu8(99 55 99 55 99 55 99 55 99 55 99 55 99 55 99 55)))
            (tuple)))))
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(b: Boolean, s1: S, s2: S): [] {"
      "  const s = b ? s1 : s2;"
      "  X = s.b;"
      "}"
      "export circuit foo(b: Boolean, s: S): [] {"
      "  bar(disclose(b), disclose(s), S{w(), 'c7c7c7c7c7c7c7c7'});"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%X.2 (0) (__compact_Cell (tbytes 16))))
          (constructor () (tuple)))
        (witness %w.3 () (tbytes 16))
        (circuit %bar.4 ([%b.5 (tboolean)]
                         [%s1.6 (tstruct S (a (tbytes 16)) (b (tbytes 16)))]
                         [%s2.7 (tstruct S (a (tbytes 16)) (b (tbytes 16)))])
             (ttuple)
          (seq
            (let* ([[%s.8 (tstruct S (a (tbytes 16)) (b (tbytes 16)))]
                    (if %b.5 %s1.6 %s2.7)])
              (let* ([[%tmp.9 (tbytes 16)] (elt-ref %s.8 b 1)])
                (public-ledger %X.2 (0) write %tmp.9)))
            (tuple)))
        (circuit %foo.10 ([%b.0 (tboolean)]
                          [%s.11 (tstruct S (a (tbytes 16)) (b (tbytes 16)))])
             (ttuple)
          (seq
            (call %bar.4
              (disclose %b.0)
              (disclose %s.11)
              (new (tstruct S (a (tbytes 16)) (b (tbytes 16)))
                (call %w.3)
                #vu8(99 55 99 55 99 55 99 55 99 55 99 55 99 55 99 55)))
            (tuple)))))
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "ledger X: S;"
      "witness w(): S;"
      "export circuit foo(): [] {"
      "  X = w();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of = at line 5 char 5"))))
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "ledger X: S;"
      "witness w1(): S;"
      "witness w2(): S;"
      "export circuit foo(b: Boolean): [] {"
      "  X = b ? w1() : w2();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w1 at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of = at line 6 char 5")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w2 at line 4 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of = at line 6 char 5")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 5 char 20" ("\n    nature of the disclosure:\n      ledger operation might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional expression at line 6 char 7\n      the right-hand side of = at line 6 char 5"))))
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "ledger X: S;"
      "witness w(): S;"
      "constructor() {"
      "  X = w();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of = at line 5 char 5"))))
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(b: Boolean, s1: S, s2: S): [] {"
      "  const s = b ? s1 : s2;"
      "  X = s.b;"
      "}"
      "constructor(b: Boolean, s: S) {"
      "  bar(disclose(b), disclose(s), S{w(), 'c7c7c7c7c7c7c7c7'});"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%X.2 (0) (__compact_Cell (tbytes 16))))
          (constructor ([%b.0 (tboolean)]
                        [%s.3 (tstruct S (a (tbytes 16)) (b (tbytes 16)))])
            (seq
              (call %bar.4
                (disclose %b.0)
                (disclose %s.3)
                (new (tstruct S (a (tbytes 16)) (b (tbytes 16)))
                  (call %w.5)
                  #vu8(99 55 99 55 99 55 99 55 99 55 99 55 99 55 99 55)))
              (tuple))))
        (witness %w.5 () (tbytes 16))
        (circuit %bar.4 ([%b.6 (tboolean)]
                         [%s1.7 (tstruct S (a (tbytes 16)) (b (tbytes 16)))]
                         [%s2.8 (tstruct S (a (tbytes 16)) (b (tbytes 16)))])
             (ttuple)
          (seq
            (let* ([[%s.9 (tstruct S (a (tbytes 16)) (b (tbytes 16)))]
                    (if %b.6 %s1.7 %s2.8)])
              (let* ([[%tmp.10 (tbytes 16)] (elt-ref %s.9 b 1)])
                (public-ledger %X.2 (0) write %tmp.10)))
            (tuple)))))
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "struct T { v: Vector<1, S> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(b1: Boolean, b2: Boolean, v: Vector<2, T>): [] {"
      "  const t = b1 ? v[0] : v[1];"
      "  const s = t.v[0];"
      "  X = b2 ? s.a : s.b;"
      "}"
      "constructor() {"
      "  bar(false, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(false, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(true, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(true, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "struct T { v: Vector<1, S> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(b1: Boolean, b2: Boolean, v: Vector<2, T>): [] {"
      "  const t = b1 ? v[0] : v[1];"
      "  const s = t.v[0];"
      "  X = b2 ? s.a : s.b;"
      "}"
      "constructor() {"
      "//  bar(false, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "  bar(false, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(true, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(true, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "struct T { v: Vector<1, S> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(b1: Boolean, b2: Boolean, v: Vector<2, T>): [] {"
      "  const t = b1 ? v[0] : v[1];"
      "  const s = t.v[0];"
      "  X = b2 ? s.a : s.b;"
      "}"
      "circuit id(v: T): T { return v; }"
      "constructor() {"
      "//  bar(false, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "  bar(false, true, map(id, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]));"
      "//  bar(true, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(true, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "struct T { v: Vector<1, S> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(b1: Boolean, b2: Boolean, v: Vector<2, T>): [] {"
      "  const t = b1 ? v[0] : v[1];"
      "  const s = t.v[0];"
      "  X = b2 ? s.a : s.b;"
      "}"
      "circuit id(v: Vector<2, T>): Vector<2, T> { return v; }"
      "constructor() {"
      "//  bar(false, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "  bar(false, true, id([T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]));"
      "//  bar(true, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(true, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "struct T { v: Vector<1, S> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(b1: Boolean, b2: Boolean, v: Vector<2, T>): [] {"
      "  const t = b1 ? v[0] : v[1];"
      "  const s = t.v[0];"
      "  X = b2 ? s.a : s.b;"
      "}"
      "constructor() {"
      "//  bar(false, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(false, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "  bar(true, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(true, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "struct T { v: Vector<1, S> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(b1: Boolean, b2: Boolean, v: Vector<2, T>): [] {"
      "  const t = b1 ? v[0] : v[1];"
      "  const s = t.v[0];"
      "  X = b2 ? s.a : s.b;"
      "}"
      "constructor() {"
      "//  bar(false, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(false, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "//  bar(true, false, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "  bar(true, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 4 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the third argument to bar at line 14 char 3\n      the binding of t at line 6 char 9\n      the binding of s at line 7 char 9\n      the right-hand side of = at line 8 char 5"))))
    )

  ; pm-17201
  (test
    '(
      "struct S { a: Bytes<16>, b: Bytes<16> };"
      "struct T { v: Vector<1, S> };"
      "ledger X: Bytes<16>;"
      "witness w(): Bytes<16>;"
      "circuit bar(b1: Boolean, b2: Boolean, v: Vector<2, T>, i: Uint<1>, j: Uint<1>): [] {"
      "  const t = b1 ? v[i] : v[j];"
      "  const z = 0;"
      "  const s = t.v[z];"
      "  X = b2 ? s.a : s.b;"
      "}"
      "constructor() {"
      "  bar(false, true, [T{v: [S{a: w(), b: 'c7c7c7c7c7c7c7c7'}]}, T{v: [S{a: '7c7c7c7c7c7c7c7c', b: 'c7c7c7c7c7c7c7c7'}]}], 0, 1);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 4 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the third argument to bar at line 12 char 3\n      the binding of t at line 6 char 9\n      the binding of s at line 8 char 9\n      the right-hand side of = at line 9 char 5"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Vector<N, Uint<16>> {"
      "  return map((s) => { const x = X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, v);"
      "}"
      "export circuit foo(): Vector<0, Uint<16>> {"
      "  return bar<0>(false, []);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Vector<N, Uint<16>> {"
      "  return map((s) => { const x = X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, v);"
      "}"
      "export circuit foo(): Vector<1, Uint<16>> {"
      "  return bar<1>(false, [S{w(), 107}]);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Vector<N, Uint<16>> {"
      "  return map((s) => { const x = X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, v);"
      "}"
      "export circuit foo(): Vector<1, Uint<16>> {"
      "  return bar<1>(true, [S{w(), 107}]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 68" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 33\n      the binding of x at line 5 char 29\n      the right-hand side of = at line 5 char 68")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 33\n      the binding of x at line 5 char 29"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Vector<N, Uint<16>> {"
      "  return map((s) => { const x = X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, v);"
      "}"
      "export circuit foo(): Vector<2, Uint<16>> {"
      "  return bar<2>(false, [S{w(), 107}, S{w(), 119}]);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Vector<N, Uint<16>> {"
      "  return map((s) => { const x = X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, v);"
      "}"
      "export circuit foo(): Vector<2, Uint<16>> {"
      "  return bar<2>(true, [S{w(), 107}, S{w(), 119}]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 68" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 33\n      the binding of x at line 5 char 29\n      the right-hand side of = at line 5 char 68")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 33\n      the binding of x at line 5 char 29"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Vector<N, Uint<16>> {"
      "  return map((s) => { const x = X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, v);"
      "}"
      "export circuit foo(): Vector<2, Uint<16>> {"
      "  return bar<2>(false, [S{w(), 107}, S{119, w()}]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 68" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 33\n      the binding of x at line 5 char 29\n      the right-hand side of = at line 5 char 68")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 33\n      the binding of x at line 5 char 29"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Vector<N, Uint<16>> {"
      "  return map((s) => { const x = X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, v);"
      "}"
      "export circuit foo(): Vector<2, Uint<16>> {"
      "  return bar<2>(true, [S{w(), 107}, S{119, w()}]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 68" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 33\n      the binding of x at line 5 char 29\n      the right-hand side of = at line 5 char 68")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 33\n      the binding of x at line 5 char 29"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar(b: Boolean, v: Vector<3, S>): Vector<3, Uint<16>> {"
      "  return map((s) => b ? s.a : s.b, v);"
      "}"
      "export circuit foo(): [] {"
      "  const v = bar(false, [S{w(), 3}, S{w(), 5}, S{w(), 7}]);"
      "  X = fold((a, x) => a + x as Uint<16>, 0 as Uint<16>, v);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar(b: Boolean, v: Vector<3, S>): Vector<3, Uint<16>> {"
      "  return map((s) => b ? s.a : s.b, v);"
      "}"
      "export circuit foo(): [] {"
      "  const v = bar(true, [S{w(), 3}, S{w(), 5}, S{w(), 7}]);"
      "  X = fold((a, x) => a + x as Uint<16>, 0 as Uint<16>, v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 13\n      the binding of v at line 8 char 9\n      the computation at line 9 char 22\n      the right-hand side of = at line 9 char 5" "\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 13\n      the binding of v at line 8 char 9\n      the right-hand side of = at line 9 char 5"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar(b: Boolean, v: Vector<3, S>): Vector<3, Uint<16>> {"
      "  return map((s) => b ? s.a : s.b, v);"
      "}"
      "export circuit foo(): [] {"
      "  const v = bar(false, [S{w(), 3}, S{5, w()}, S{7, 11}]);"
      "  X = v[0] + v[1] + v[2] as Uint<16>;"
      "//  X = fold((a, x) => a + x as Uint<16>, 0 as Uint<16>, v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 13\n      the binding of v at line 8 char 9\n      the computation at line 9 char 7\n      the computation at line 9 char 7\n      the right-hand side of = at line 9 char 5"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar(b: Boolean, v: Vector<3, S>): Vector<3, Uint<16>> {"
      "  return map((s) => b ? s.a : s.b, v);"
      "}"
      "export circuit foo(): [] {"
      "  const v = bar(false, [S{w(), 3}, S{5, w()}, S{7, 11}]);"
      "  X = fold((a, x) => a + x as Uint<16>, 0 as Uint<16>, v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 13\n      the binding of v at line 8 char 9\n      the computation at line 9 char 22\n      the right-hand side of = at line 9 char 5"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar(b: Boolean, v: Vector<3, S>): Vector<3, Uint<16>> {"
      "  return map((s) => b ? s.a : s.b, v);"
      "}"
      "export circuit foo(): [] {"
      "  const v = bar(true, [S{w(), 3}, S{5, w()}, S{7, 11}]);"
      "  X = fold((a, x) => a + x as Uint<16>, 0 as Uint<16>, v);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 13\n      the binding of v at line 8 char 9\n      the computation at line 9 char 22\n      the right-hand side of = at line 9 char 5"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Uint<16> {"
      "  return fold((a, s) => { const x = a + X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, 0 as Uint<16>, v);"
      "}"
      "export circuit foo(): Uint<16> {"
      "  return bar<0>(false, []);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Uint<16> {"
      "  return fold((a, s) => { const x = a + X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, 0 as Uint<16>, v);"
      "}"
      "export circuit foo(): Uint<16> {"
      "  return bar<1>(false, [S{w(), 3}]);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Uint<16> {"
      "  return fold((a, s) => { const x = a + X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, 0 as Uint<16>, v);"
      "}"
      "export circuit foo(): Uint<16> {"
      "  return bar<1>(true, [S{w(), 3}]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 76" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the right-hand side of = at line 5 char 76")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Uint<16> {"
      "  return fold((a, s) => { const x = a + X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, 0 as Uint<16>, v);"
      "}"
      "export circuit foo(): Uint<16> {"
      "  return bar<3>(false, [S{w(), 3}, S{w(), 5}, S{w(), 7}]);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%X.1 (0) (__compact_Cell (tunsigned 65535))))
          (constructor () (tuple)))
        (witness %w.2 () (tunsigned 65535))
        (circuit %bar.3 ([%b.4 (tboolean)]
                         [%v.5 (tvector
                                 3
                                 (tstruct S
                                   (a (tunsigned 65535))
                                   (b (tunsigned 65535))))])
             (tunsigned 65535)
          (fold
            (circuit ([%a.6 (tunsigned 65535)]
                      [%s.7 (tstruct S
                              (a (tunsigned 65535))
                              (b (tunsigned 65535)))])
                 (tunsigned 65535)
              (let* ([[%x.8 (tunsigned 65535)]
                      (downcast-unsigned
                        65535
                        (+ 18
                           (safe-cast (tunsigned 196605)
                                      (tunsigned 131070)
                             (+ 17
                                (safe-cast (tunsigned 131070)
                                        (tunsigned 65535)
                                  %a.6)
                                (safe-cast (tunsigned 131070)
                                           (tunsigned 65535)
                                  (public-ledger %X.1 (0) read))))
                           (safe-cast (tunsigned 196605)
                                      (tunsigned 65535)
                             (if %b.4 (elt-ref %s.7 a 0) (elt-ref %s.7 b 1)))))])
                (seq (public-ledger %X.1 (0) write %x.8) %x.8)))
            (safe-cast (tunsigned 65535) (tunsigned 0) 0)
            %v.5))
        (circuit %foo.9 ()
             (tunsigned 65535)
          (call %bar.3
            #f
            (tuple
              (new (tstruct S (a (tunsigned 65535)) (b (tunsigned 65535)))
                (call %w.2)
                (safe-cast (tunsigned 65535) (tunsigned 3) 3))
              (new (tstruct S (a (tunsigned 65535)) (b (tunsigned 65535)))
                (call %w.2)
                (safe-cast (tunsigned 65535) (tunsigned 5) 5))
              (new (tstruct S (a (tunsigned 65535)) (b (tunsigned 65535)))
                (call %w.2)
                (safe-cast (tunsigned 65535) (tunsigned 7) 7)))))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Uint<16> {"
      "  return fold((a, s) => { const x = a + X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, 0 as Uint<16>, v);"
      "}"
      "export circuit foo(): Uint<16> {"
      "  return bar<3>(true, [S{w(), 3}, S{w(), 5}, S{w(), 7}]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 76" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the computation at line 5 char 37\n      the right-hand side of = at line 5 char 76" "\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the right-hand side of = at line 5 char 76" "\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the right-hand side of = at line 5 char 76")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the result of an addition involving the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the computation at line 5 char 37" "\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Uint<16> {"
      "  return fold((a, s) => { const x = a + X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, 0 as Uint<16>, v);"
      "}"
      "export circuit foo(): Uint<16> {"
      "  return bar<3>(false, [S{w(), 3}, S{5, w()}, S{w(), 7}]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 76" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the computation at line 5 char 37\n      the right-hand side of = at line 5 char 76" "\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the right-hand side of = at line 5 char 76")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the result of an addition involving the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the computation at line 5 char 37"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Uint<16> {"
      "  return fold((a, s) => { const x = a + X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, 0 as Uint<16>, v);"
      "}"
      "export circuit foo(): Uint<16> {"
      "  return bar<6>(false, [S{w(), 3}, S{5, w()}, S{w(), 7}, S{w(), 9}, S{w(), 11}, S{w(), 13}]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 76" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the computation at line 5 char 37\n      the right-hand side of = at line 5 char 76" "\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the right-hand side of = at line 5 char 76")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the result of an addition involving the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the computation at line 5 char 37"))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar<#N>(b: Boolean, v: Vector<N, S>): Uint<16> {"
      "  return fold((a, s) => { const x = a + X + (b ? s.a : s.b) as Uint<16>; X = x; return x; }, 0 as Uint<16>, v);"
      "}"
      "export circuit foo(x: Vector<100, S>): Uint<16> {"
      "  return bar<100>(false, x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 76" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter x of exported circuit foo at line 7 char 20" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the computation at line 5 char 37\n      the right-hand side of = at line 5 char 76" "\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the right-hand side of = at line 5 char 76" "\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 8 char 10\n      the computation at line 5 char 37\n      the binding of x at line 5 char 33\n      the right-hand side of = at line 5 char 76"))))
    )

  (test
    '(
      "ledger X: Uint<16>;"
      "witness w(): Uint<16>;"
      "circuit bar(v: Vector<10, Uint<16>>): Uint<32> {"
      "  return fold((a, n) => a + n as Uint<32>, 0 as Uint<32>, v);"
      "}"
      "export circuit foo(b: Boolean, v1: Vector<10, Uint<16>>, v2: Vector<10, Uint<16>>): Uint<32> {"
      "  return bar(b ? v1 : v2) - bar(b ? v2 : v1);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%X.1 (0) (__compact_Cell (tunsigned 65535))))
          (constructor () (tuple)))
        (circuit %bar.2 ([%v.3 (tvector 10 (tunsigned 65535))])
             (tunsigned 4294967295)
          (fold
            (circuit ([%a.4 (tunsigned 4294967295)]
                      [%n.5 (tunsigned 65535)])
                 (tunsigned 4294967295)
              (downcast-unsigned
                4294967295
                (+ 33
                   (safe-cast (tunsigned 4295032830) (tunsigned 4294967295) %a.4)
                   (safe-cast (tunsigned 4295032830) (tunsigned 65535) %n.5))))
            (safe-cast (tunsigned 4294967295) (tunsigned 0) 0)
            %v.3))
        (circuit %foo.6 ([%b.7 (tboolean)]
                         [%v1.8 (tvector 10 (tunsigned 65535))]
                         [%v2.9 (tvector 10 (tunsigned 65535))])
             (tunsigned 4294967295)
          (let* ([[%t.10 (tunsigned 4294967295)]
                  (call %bar.2 (if %b.7 %v1.8 %v2.9))])
            (let* ([[%t.11 (tunsigned 4294967295)]
                    (call %bar.2 (if %b.7 %v2.9 %v1.8))])
              (seq
                (assert
                  (if (< %t.10 %t.11) #f #t)
                  "result of subtraction would be negative")
                (- 32 %t.10 %t.11)))))))
    )
  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "witness w(): Uint<16>;"
      "circuit bar(b: Boolean, x: Uint<16>): Uint<16> {"
      "  if (b) S { w(), w() };"
      "  return x;"
      "}"
      "export circuit foo(b: Boolean): Uint<16> {"
      "  return bar(b, 17);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration () (constructor () (tuple)))
        (witness %w.0 () (tunsigned 65535))
        (circuit %bar.1 ([%b.2 (tboolean)] [%x.3 (tunsigned 65535)])
             (tunsigned 65535)
          (seq
            (if %b.2
                (new (tstruct S (a (tunsigned 65535)) (b (tunsigned 65535)))
                  (call %w.0)
                  (call %w.0))
                (tuple))
            %x.3))
        (circuit %foo.4 ([%b.5 (tboolean)])
             (tunsigned 65535)
          (call %bar.1 %b.5 (safe-cast (tunsigned 65535) (tunsigned 17) 17)))))
    )

  (test
    '(
      "witness w(): Boolean;"
      "circuit bar(v: Vector<5, Boolean>): Boolean {"
      "  return fold((a, b) => a && b, true, v);"
      "}"
      "export circuit foo(x: Boolean): Boolean {"
      "  return bar(disclose([true, x, false, x, w()]));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration () (constructor () (tuple)))
        (witness %w.0 () (tboolean))
        (circuit %bar.1 ([%v.2 (tvector 5 (tboolean))])
             (tboolean)
          (fold
            (circuit ([%a.3 (tboolean)] [%b.4 (tboolean)])
                 (tboolean)
              (if %a.3 %b.4 #f))
            #t
            %v.2))
        (circuit %foo.5 ([%x.6 (tboolean)])
             (tboolean)
          (call %bar.1
            (disclose (tuple #t %x.6 #f %x.6 (call %w.0)))))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "witness w(): Uint<16>;"
      "witness b(): Boolean;"
      "circuit bar(x: Uint<16>): Uint<16> {"
      "  if (b()) S { w(), w() };"
      "  return x;"
      "}"
      "export circuit foo(): Uint<16> {"
      "  return bar(17);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration () (constructor () (tuple)))
        (witness %w.0 () (tunsigned 65535))
        (witness %b.1 () (tboolean))
        (circuit %bar.2 ([%x.3 (tunsigned 65535)])
             (tunsigned 65535)
          (seq
            (if (call %b.1)
                (new (tstruct S (a (tunsigned 65535)) (b (tunsigned 65535)))
                  (call %w.0)
                  (call %w.0))
                (tuple))
            %x.3))
        (circuit %foo.4 ()
             (tunsigned 65535)
          (call %bar.2 (safe-cast (tunsigned 65535) (tunsigned 17) 17)))))
    )

  (test
    '(
      "circuit bar(vb: Vector<5, Boolean>, vn: Vector<5, Field>): Vector<5, Field> {"
      "  return map((b, n) => b ? n : 0, vb, vn);"
      "}"
      "export circuit foo(x: Vector<5, Boolean>): Vector<5, Field> {"
      "  return bar(x, [1, 3, 5, 7, 9]);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %bar.0 ([%vb.1 (tvector 5 (tboolean))]
                         [%vn.2 (tvector 5 (tfield))])
             (tvector 5 (tfield))
          (map
            (circuit ([%b.3 (tboolean)] [%n.4 (tfield)])
                 (tfield)
              (if %b.3 %n.4 (safe-cast (tfield) (tunsigned 0) 0)))
            %vb.1
            %vn.2))
        (circuit %foo.5 ([%x.6 (tvector 5 (tboolean))])
             (tvector 5 (tfield))
          (call %bar.0
            %x.6
            (safe-cast (tvector 5 (tfield))
                       (ttuple (tunsigned 1) (tunsigned 3) (tunsigned 5)
                               (tunsigned 7) (tunsigned 9))
              (tuple 1 3 5 7 9))))))
    )

  (test
    '(
      "struct S { a: Uint<16>, b: Uint<16> };"
      "witness w(): Uint<16>;"
      "witness b(): Boolean;"
      "circuit bar(x: Uint<16>): S {"
      " return b() ? S { w(), w() } : S { w(), w() };"
      "}"
      "export circuit foo(): S {"
      "  return bar(17);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness w at line 2 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the witness value")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness b at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional expression at line 5 char 9"))))
    )

  (test
    '(
      "circuit bar(vb: Vector<5, Boolean>, vn: Vector<5, Field>): Field {"
      "  return fold((a, b, n) => b ? a + n : a, 0 as Field, vb, vn);"
      "}"
      "export circuit foo(x: Vector<5, Boolean>): Field {"
      "  return bar(x, [1, 3, 5, 7, 9]);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %bar.0 ([%vb.1 (tvector 5 (tboolean))]
                         [%vn.2 (tvector 5 (tfield))])
             (tfield)
          (fold
            (circuit ([%a.3 (tfield)] [%b.4 (tboolean)] [%n.5 (tfield)])
                 (tfield)
              (if %b.4 (+ #f %a.3 %n.5) %a.3))
            (safe-cast (tfield) (tunsigned 0) 0)
            %vb.1
            %vn.2))
        (circuit %foo.6 ([%x.7 (tvector 5 (tboolean))])
             (tfield)
          (call %bar.0
            %x.7
            (safe-cast (tvector 5 (tfield))
                       (ttuple (tunsigned 1) (tunsigned 3) (tunsigned 5)
                               (tunsigned 7) (tunsigned 9))
              (tuple 1 3 5 7 9))))))
    )

  (test
    '(
      "witness b(): Boolean;"
      "circuit bar(): Field {"
      " return b() ? 1 : 2;"
      "}"
      "export circuit foo(): Field {"
      "  return bar();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness b at line 1 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional expression at line 3 char 9"))))
    )

  (test
    '("import CompactStandardLibrary;"
      "export { nativeToken }"
      )
    (succeeds))

  (test
    '("import CompactStandardLibrary;"
      "export { tokenType }"
      )
    (succeeds))

  (test
    '("import CompactStandardLibrary;"
      "export { evolveNonce }"
      )
    (succeeds))

  (test
    '("import CompactStandardLibrary;"
      "export { burnAddress }"
      )
    (succeeds))

  (test
    '("import CompactStandardLibrary;"
      "export { mintToken }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter domain_sep of exported circuit mintToken at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose the domain separator of the token being minted given by the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit mintToken at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose the value of a token mint given by the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit mintToken at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter nonce of exported circuit mintToken at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter recipient of exported circuit mintToken at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the boolean value of the witness value"))))
    )

  (test
    '("import CompactStandardLibrary;"
      "export { receive }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter coin of exported circuit receive at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the witness value")))))

  (test
    '("import CompactStandardLibrary;"
      "export { sendImmediate }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a claim of nullifier and the coin with the nullifier given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter target of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the boolean value of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit sendImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the result of a subtraction involving the witness value")))
    ))

  (test
    '("import CompactStandardLibrary;"
      "export { send }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a claim of nullifier and the coin with the nullifier given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter recipient of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the boolean value of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter input of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the result of a subtraction involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter value of exported circuit send at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the result of a subtraction involving the witness value")))
    ))

  (test
    '("import CompactStandardLibrary;"
      "export { mergeCoin }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter a of exported circuit mergeCoin at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a claim of nullifier and the coin with the nullifier given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit mergeCoin at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a claim of nullifier and the coin with the nullifier given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter a of exported circuit mergeCoin at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the result of an addition involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit mergeCoin at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the result of an addition involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter a of exported circuit mergeCoin at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the result of an addition involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit mergeCoin at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the result of an addition involving the witness value")))
    ))

  (test
    '("import CompactStandardLibrary;"
      "export { mergeCoinImmediate }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter a of exported circuit mergeCoinImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a claim of nullifier and the coin with the nullifier given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit mergeCoinImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a claim of nullifier and the coin with the nullifier given by a hash of the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter a of exported circuit mergeCoinImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the result of an addition involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit mergeCoinImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin spend and the coin with the commitment given by a hash of the result of an addition involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter a of exported circuit mergeCoinImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of a converted form of a hash of a modulus of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the witness value" "\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the result of an addition involving the witness value")))
      message: "~a:\n  ~?"
      irritants: '("<standard library>" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit mergeCoinImmediate at <standard library>" ("\n    nature of the disclosure:\n      ledger operation might disclose a link between a coin receive and the coin with the commitment given by a hash of the result of an addition involving the witness value")))
    ))

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger m: Map<Field, Map<Field, Counter>>;"
      "export circuit foo(x: Field, y: Field, z: Uint<16>): [] {"
      "  m.lookup(x).lookup(y).increment(z);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 24" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter z of exported circuit foo at line 3 char 40" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the argument to increment at line 4 char 24"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger m: Map<Field, Map<Field, Counter>>;"
      "export circuit foo(x: Field, y: Field, z: Uint<16>): [] {"
      "  m.lookup(x).lookup(y) += z;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 25" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter z of exported circuit foo at line 3 char 40" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of += at line 4 char 25"))))
    )

  ; NB: tests with contract calls are in the save-contract-info group

  (test
    '(
      "ledger index: Field;"
      "export circuit foo(b: Boolean): [] {"
      "  return b ? index.write(1) : [];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 19" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 2 char 20" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 3 char 10"))))
    )

  (test
    '(
      "ledger index: Field;"
      "export circuit foo(b: Boolean): [] {"
      "  return disclose(b) ? index.write(1) : [];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%index.1 (0) (__compact_Cell (tfield))))
          (constructor () (tuple)))
        (circuit %foo.2 ([%b.3 (tboolean)])
             (ttuple)
          (if (disclose %b.3)
              (let* ([[%tmp.4 (tfield)] (safe-cast (tfield) (tunsigned 1) 1)])
                (public-ledger %index.1 (0) write %tmp.4))
              (tuple)))))
    )

  (test
    '(
      "ledger index: Field;"
      "export circuit foo(b: Boolean, v: Vector<0, Field>): [] {"
      "  return disclose(b) ? disclose(v) : [];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%index.1 (0) (__compact_Cell (tfield))))
          (constructor () (tuple)))
        (circuit %foo.2 ([%b.3 (tboolean)]
                         [%v.4 (tvector 0 (tfield))])
             (ttuple)
          (if (disclose %b.3) (disclose %v.4) (tuple)))))
    )

  (test
    '(
      "ledger index: Field;"
      "export circuit foo(b: Boolean, v: Vector<3, Field>): Vector<3, Field> {"
      "  return disclose(b) ? disclose(v) : [1, 2, 3];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%index.1 (0) (__compact_Cell (tfield))))
          (constructor () (tuple)))
        (circuit %foo.2 ([%b.3 (tboolean)]
                         [%v.4 (tvector 3 (tfield))])
             (tvector 3 (tfield))
          (if (disclose %b.3)
              (disclose %v.4)
              (safe-cast (tvector 3 (tfield))
                         (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                (tuple 1 2 3))))))
    )

  (test
    '(
      "ledger index: Field;"
      "export circuit foo(b: Boolean, v: Vector<3, Field>): [Field, Field, Field] {"
      "  return disclose(b) ? disclose(v) : [1, 2, 3];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%index.1 (0) (__compact_Cell (tfield))))
          (constructor () (tuple)))
        (circuit %foo.2 ([%b.3 (tboolean)]
                         [%v.4 (tvector 3 (tfield))])
             (ttuple (tfield) (tfield) (tfield))
          (if (disclose %b.3)
              (disclose %v.4)
              (safe-cast (tvector 3 (tfield))
                         (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                (tuple 1 2 3))))))
    )

  (test
    '(
      "ledger index: Field;"
      "export circuit foo(b: Boolean, v: Vector<3, Field>): Vector<3, Field> {"
      "  return disclose(b) ? [1, 2, 3] : disclose(v);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%index.1 (0) (__compact_Cell (tfield))))
          (constructor () (tuple)))
        (circuit %foo.2 ([%b.3 (tboolean)]
                         [%v.4 (tvector 3 (tfield))])
             (tvector 3 (tfield))
          (if (disclose %b.3)
              (safe-cast (tvector 3 (tfield))
                         (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                (tuple 1 2 3))
              (disclose %v.4)))))
    )

  (test
    '(
      "ledger index: Field;"
      "export circuit foo(b: Boolean, v: Vector<3, Field>): [Field, Field, Field] {"
      "  return disclose(b) ? [1, 2, 3] : disclose(v);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%index.1 (0) (__compact_Cell (tfield))))
          (constructor () (tuple)))
        (circuit %foo.2 ([%b.3 (tboolean)]
                         [%v.4 (tvector 3 (tfield))])
             (ttuple (tfield) (tfield) (tfield))
          (if (disclose %b.3)
              (safe-cast (tvector 3 (tfield))
                         (ttuple (tunsigned 1) (tunsigned 2) (tunsigned 3))
                (tuple 1 2 3))
              (disclose %v.4)))))
    )

  (test
    '(
      "ledger index: Field;"
      "export circuit foo(b: Boolean): Field {"
      "  return b ? index : 0;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 14" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 2 char 20" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 3 char 10"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger fld: Map<Field, Field>;"
      "export circuit foo(b: Boolean): [] {"
      "  if (b) fld.remove(7);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 13" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 3 char 20" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 4 char 3"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Boolean;"
      "export circuit foo(): Field {"
      "  if (W()) return 5; else return 6;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 12" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W at line 2 char 1" ("\n    nature of the disclosure:\n      returning this value from exported circuit foo might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 4 char 3")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 27" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W at line 2 char 1" ("\n    nature of the disclosure:\n      returning this value from exported circuit foo might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 4 char 3"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Boolean;"
      "export circuit foo(): Field {"
      "  if (W()) return 5;"
      "  return 6;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 12" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W at line 2 char 1" ("\n    nature of the disclosure:\n      returning this value from exported circuit foo might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 4 char 3")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W at line 2 char 1" ("\n    nature of the disclosure:\n      returning this value from exported circuit foo might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 4 char 3"))))
    )

  (test
    '(
      "export circuit foo(x: []): Uint<16> {"
      "  return x as Uint<16>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "cannot cast from type ~a to type ~a" ("[]" "Uint<16>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "export circuit foo(): Uint<16> {"
      "  return counter += 3 as Uint<16>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("[]" "Uint<16>" "circuit foo")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "export circuit foo(): Uint<16> {"
      "  return (counter += 3) as Uint<16>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 10" "cannot cast from type ~a to type ~a" ("[]" "Uint<16>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger counter: Counter;"
      ""
      "export circuit adonis(p: Field): [] {"
      "  for (const y of counter -= 7 as Uint<16>, counter += 3 as Uint<16>) {"
      "    counter += p as Uint<16>;"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%counter.2 (0) (Counter)))
          (constructor () (tuple)))
        (circuit %adonis.3 ([%p.4 (tfield)])
             (ttuple)
          (seq
            (fold
              (circuit ([%t.5 (ttuple)] [%y.6 (tunknown)])
                   (ttuple)
                (seq
                  (seq
                    (let* ([[%tmp.7 (tunsigned 65535)]
                            (downcast-unsigned 65535 %p.4)])
                      (public-ledger %counter.2 (0) increment %tmp.7))
                    (tuple))
                  %t.5))
              (tuple)
              (seq
                (let* ([[%tmp.8 (tunsigned 65535)]
                        (safe-cast (tunsigned 65535) (tunsigned 7) 7)])
                  (public-ledger %counter.2 (0) decrement %tmp.8))
                (let* ([[%tmp.9 (tunsigned 65535)]
                        (safe-cast (tunsigned 65535) (tunsigned 3) 3)])
                  (public-ledger %counter.2 (0) increment %tmp.9))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger counter: Counter;"
      ""
      "export circuit adonis(p: Field): [] {"
      "  for (const y of counter -= (7 as Uint<16>), counter += (3 as Uint<16>)) {"
      "    counter += p as Uint<16>;"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%counter.2 (0) (Counter)))
          (constructor () (tuple)))
        (circuit %adonis.3 ([%p.4 (tfield)])
             (ttuple)
          (seq
            (fold
              (circuit ([%t.5 (ttuple)] [%y.6 (tunknown)])
                   (ttuple)
                (seq
                  (seq
                    (let* ([[%tmp.7 (tunsigned 65535)]
                            (downcast-unsigned 65535 %p.4)])
                      (public-ledger %counter.2 (0) increment %tmp.7))
                    (tuple))
                  %t.5))
              (tuple)
              (seq
                (let* ([[%tmp.8 (tunsigned 65535)]
                        (safe-cast (tunsigned 65535) (tunsigned 7) 7)])
                  (public-ledger %counter.2 (0) decrement %tmp.8))
                (let* ([[%tmp.9 (tunsigned 65535)]
                        (safe-cast (tunsigned 65535) (tunsigned 3) 3)])
                  (public-ledger %counter.2 (0) increment %tmp.9))))
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger counter: Counter;"
      ""
      "export circuit adonis(p: Field): [] {"
      "  for (const y of counter -= (7 as Uint<16>), counter += (3 as Uint<16>)) {"
      "    counter += p + y as Uint<16>;"
      "  }"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 16" "~a requires its ~a operand to be a Field or Uint; the actual type is ~a" (+ "right" "Unknown")))
    )

  ; pm-17201
  (test
    '(
      "circuit bar(v: Vector<1, Vector<0, Field>>): [] {"
      "  v[0];"
      "}"
      "constructor() {"
      "  bar([[]]);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration
          ()
          (constructor ()
            (seq (call %bar.0 (tuple (tuple))) (tuple))))
        (circuit %bar.0 ([%v.1 (tvector 1 (tvector 0 (tfield)))])
             (ttuple)
          (seq (tuple-ref %v.1 0) (tuple)))))
    )

  ; pm-17201
  (test
    '(
      "circuit bar(v: Vector<1, Vector<0, Field>>): [] {"
      "  const k = 0;"
      "  v[k];"
      "}"
      "constructor() {"
      "  bar([[]]);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration
          ()
          (constructor ()
            (seq (call %bar.0 (tuple (tuple))) (tuple))))
        (circuit %bar.0 ([%v.1 (tvector 1 (tvector 0 (tfield)))])
             (ttuple)
          (seq
            (let* ([[%k.2 (tunsigned 0)] 0]) (vector-ref %v.1 %k.2))
            (tuple)))))
    )

  ; issue 1406
  (test
    '(
      "ledger F: Field;"
      "witness W(): Field;"
      ""
      "export circuit foo(x: Field): [] {"
      "  const w = W();"
      "  if (disclose(w) == 1) bar(x);"
      "  if (w == 2) bar(x);"
      "}"
      ""
      "circuit bar(x: Field): [] {"
      "  F = disclose(x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 11 char 5" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W at line 2 char 1" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the binding of w at line 5 char 9\n      the comparison at line 7 char 7\n      the conditional branch at line 7 char 3"))))
    )

  (test
    '(
      "ledger F: Field;"
      "witness W(): Field;"
      ""
      "export circuit foo(x: Field): [] {"
      "  const w = W();"
      "  if (disclose(w) == 1) bar(x);"
      "  if (disclose(w) == 2) bar(x);"
      "}"
      ""
      "circuit bar(x: Field): [] {"
      "  F = disclose(x);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%F.1 (0) (__compact_Cell (tfield))))
          (constructor () (tuple)))
        (witness %W.2 () (tfield))
        (circuit %foo.3 ([%x.4 (tfield)])
             (ttuple)
          (seq
            (let* ([[%w.5 (tfield)] (call %W.2)])
              (seq
                (if (== (disclose %w.5)
                        (safe-cast (tfield) (tunsigned 1) 1))
                    (call %bar.6 %x.4)
                    (tuple))
                (if (== (disclose %w.5)
                        (safe-cast (tfield) (tunsigned 2) 2))
                    (call %bar.6 %x.4)
                    (tuple))))
            (tuple)))
        (circuit %bar.6 ([%x.7 (tfield)])
             (ttuple)
          (seq
            (public-ledger %F.1 (0) write (disclose %x.7))
            (tuple)))))
    )
)

; examples of where disclose can be placed
(run-tests remove-disclose
  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Field;"
      "export circuit foo(): Field {"
      "  return disclose(W());"
      "}"
      "module M {"
      "  witness W(b: Boolean): Boolean;"
      "  witness X(): Field;"
      "  export circuit bar(b: Boolean): Field {"
      "    return disclose(X()) + (disclose(W(b)) ? 3 : 4);"
      "  }"
      "}"
      "import M;"
      "export { bar };"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Field;"
      "export circuit foo(): Field {"
      "  return disclose(W());"
      "}"
      "module M {"
      "  witness W(b: Boolean): Boolean;"
      "  witness X(): Field;"
      "  export circuit bar(b: Boolean): Field {"
      "    return disclose(X()) + disclose(W(b) ? 3 : 4);"
      "  }"
      "}"
      "import M;"
      "export { bar };"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness transientHash(x: Boolean): Field;"
      "export circuit transientHash(x: Field) : Boolean { return x + disclose(transientHash(true)) + transientHash<Field>(x) != 107; }"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness transientHash(x: Boolean): Field;"
      "export circuit transientHash(x: Field) : Boolean { return disclose(x + transientHash(true) + transientHash<Field>(x) != 107); }"
      )
    (succeeds)
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "export circuit C(v: Vector<2, Field>): Vector<2, Boolean> {"
      "  return map(disclose((x) => foo(x)), v);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 14" "parse error: found ~a looking for~?" ("\"disclose\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a function"))))
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "export circuit C(v: Vector<2, Field>): Vector<2, Boolean> {"
      "  return disclose(map((x) => foo(x), v));"
      "}"
     )
    (succeeds)
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "export circuit C(v: Vector<3, Field>, b: Boolean): Vector<3, Boolean> {"
      "  return map((x) => disclose(b && foo(x + 1)),"
      "             v);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "export circuit C(v: Vector<3, Field>, b: Boolean): Vector<3, Boolean> {"
      "  return map((x) => b && disclose(foo(x + 1)),"
      "             v);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "witness foo() : pr;"
      "export circuit C(): Field {"
      "  return disclose(foo()).d;"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "witness foo() : pr;"
      "export circuit C(): Field {"
      "  return disclose(foo().d);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    const w = v;"
      "    return map((x) => {"
      "                const y = x + 1;"
      "                disclose(return foo(y));"
      "                 },"
      "                 w);"
      "  }"
      "}"
      "import M<2>;"
      "export circuit bar() : Vector<2, Boolean> {"
      "  return C([3, 7]);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 26" "parse error: found ~a looking for~?" ("\"return\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an expression"))))
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    const w = v;"
      "    return map((x) => {"
      "                const y = x + 1;"
      "                return disclose(foo(y));"
      "                 },"
      "                 w);"
      "  }"
      "}"
      "import M<2>;"
      "export circuit bar() : Vector<2, Boolean> {"
      "  return C([3, 7]);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "witness W1(a: Vector<3, pr>) : pr;"
      "witness W2(a: Vector<3, pr>) : pr;"
      "witness S() : Vector<3, pr>;"
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  const p = b ? W1(S()) : W2(S());"
      "  return disclose(p.d == 19 ? p.a : b);"
      "}"
       )
    (succeeds))

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "witness W1(a: Vector<3, pr>) : pr;"
      "witness W2(a: Vector<3, pr>) : pr;"
      "witness S() : Vector<3, pr>;"
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  const p = b ? W1(S()) : W2(S());"
      "  return disclose(p.d == 19) ? disclose(p.a) : b;"
      "}"
       )
    (succeeds))

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "witness W1(a: Vector<3, pr>) : pr;"
      "witness W2(a: Vector<3, pr>) : pr;"
      "witness S() : Vector<3, pr>;"
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  const p = b ? W1(S()) : W2(S());"
      "  return disclose(p).d == 19 ? disclose(p.a) : b;"
      "}"
       )
    (succeeds))

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "witness W1(a: Vector<3, pr>) : pr;"
      "witness W2(a: Vector<3, pr>) : pr;"
      "witness S() : Vector<3, pr>;"
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  const p = b ? W1(S()) : W2(S());"
      "  return disclose(p.d) == 19 ? disclose(p.a) : b;"
      "}"
       )
    (succeeds))

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "witness W1(a: Vector<3, pr>) : pr;"
      "witness W2(a: Vector<3, pr>) : pr;"
      "witness S() : Vector<3, pr>;"
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  const p = b ? W1(S()) : W2(S());"
      "  return p.d == 19 ? disclose(p.a) : b;"
      "}"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W1 at line 2 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the binding of p at line 6 char 9\n      the comparison at line 7 char 10\n      the conditional expression at line 7 char 10")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W2 at line 3 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the binding of p at line 6 char 9\n      the comparison at line 7 char 10\n      the conditional expression at line 7 char 10"))))
    )

  (test
    '(
      "witness Y(x: Boolean) : Boolean;"
      "export circuit foo(b: Boolean): Field {"
      "  return Y(b) ? 3 : 4;"
      "}"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness Y at line 1 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional expression at line 3 char 10"))))
    )

  (test
    '(
      "witness Y(x: Boolean) : Boolean;"
      "export circuit foo(b: Boolean): Field {"
      "  return disclose(Y(b)) ? 3 : 4;"
      "}"
       )
    (succeeds)
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "module M {"
      "  export circuit C(v: Field): Boolean {"
      "  return foo(v);"
      "  }"
      "}"
      "import M prefix $;"
      "export {$C};"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness foo at line 1 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit C might disclose the witness value"))))
     )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "module M {"
      "  witness S() : Field;"
      "  export circuit C(v: Field): Boolean {"
      "  return foo(S());"
      "  }"
      "}"
      "import M prefix $;"
      "export {$C};"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness foo at line 1 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit C might disclose the witness value"))))
     )

  (test
    '(
      "module M {"
      "  export witness foo(n: Field) : Boolean;"
      "  export circuit C(v: Field): Boolean {"
      "  return foo(v);"
      "  }"
      "}"
      "import M prefix $;"
      "export {$C};"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness foo at line 2 char 3" ("\n    nature of the disclosure:\n      the value returned from exported circuit C might disclose the witness value"))))
     )

  (test
    '(
      "module M {"
      "  export witness foo(n: Field) : Boolean;"
      "  export circuit C(v: Field): Boolean {"
      "  return disclose(foo(v));"
      "  }"
      "}"
      "import M prefix $;"
      "export {$C};"
       )
    (succeeds)
    )

  (test
    '(
      "module M {"
      "  export witness foo(n: Field) : Boolean;"
      "  export circuit C(v: Field): Boolean {"
      "  return foo(v);"
      "  }"
      "}"
      "import M prefix $;"
      "export {disclose($C)};"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 9" "parse error: found ~a looking for~?" ("\"disclose\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("an identifier" "\"}\""))))
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "export circuit C(v: Field): Boolean {"
      "  return disclose(foo(v) == true);"
      "}"
       )
    (succeeds)
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "circuit C(v: Field): Boolean {"
      "  return foo(v) == true;"
      "}"
      "circuit C2(): [] { C(3); }"
      "export circuit C3(): [] { C2(); }"
       )
    (succeeds)
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "circuit C(v: Field): Boolean {"
      "  return foo(v) == true;"
      "}"
      "circuit C2(): Boolean { return C(3); }"
      "export circuit C3(): Boolean { return C2(); }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 32" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness foo at line 1 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit C3 might disclose the result of a comparison involving the witness value\n    via this path through the program:\n      the comparison at line 3 char 10"))))
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "circuit C(v: Field): Boolean {"
      "  return foo(v) == true;"
      "}"
      "circuit C2(): Boolean { return C(3); }"
      "export circuit C3(): Boolean { return disclose(C2()); }"
       )
    (succeeds)
    )

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export witness foo(n: Field) : Boolean;"
         "  export circuit C(v: Field): Boolean {"
         "  return foo(v);"
         "  }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "export { C }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("M.compact line 4 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness foo at line 2 char 3" ("\n    nature of the disclosure:\n      the value returned from exported circuit C might disclose the witness value"))))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export witness foo(n: Field) : Boolean;"
         "  export circuit C(v: Field): Boolean {"
         "    return foo(v);"
         "  }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "witness W(): Field;"
         "export circuit bar(): Boolean {"
         "  return C(W());"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness foo at M.compact line 2 char 3" ("\n    nature of the disclosure:\n      the value returned from exported circuit bar might disclose the witness value"))))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export witness foo(n: Field) : Boolean;"
         "  export circuit C(v: Field): Boolean {"
         "    return foo(v);"
         "  }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "witness W(): Field;"
         "export circuit bar(): Boolean {"
         "  return C(disclose(W()));"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness foo at M.compact line 2 char 3" ("\n    nature of the disclosure:\n      the value returned from exported circuit bar might disclose the witness value"))))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export witness foo(n: Field) : Boolean;"
         "  export circuit C(v: Field, b: Boolean): Boolean {"
         "  return b == foo(v);"
         "  }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "witness W(): Field;"
         "export circuit bar(): Boolean {"
         "  return C(W(), true);"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness foo at M.compact line 2 char 3" ("\n    nature of the disclosure:\n      the value returned from exported circuit bar might disclose the result of a comparison involving the witness value\n    via this path through the program:\n      the comparison at M.compact line 4 char 10"))))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export witness foo(n: Field) : Boolean;"
         "  export circuit C(v: Field, b: Boolean): Boolean {"
         "  return b == disclose(foo(v));"
         "  }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "witness W(): Boolean;"
         "export circuit bar(): Boolean {"
         "  return C(3, W());"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W at line 2 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit bar might disclose the result of a comparison involving the witness value\n    via this path through the program:\n      the second argument to C at line 4 char 10\n      the comparison at M.compact line 4 char 10"))))
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export witness foo(n: Field) : Boolean;"
         "  export circuit C(v: Field, b: Boolean): Boolean {"
         "  return b == disclose(foo(v));"
         "  }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "witness W(): Boolean;"
         "export circuit bar(): Boolean {"
         "  return C(3, disclose(W()));"
         "}"
         ))
     (succeeds)
     ))

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export witness foo(n: Field) : Boolean;"
         "  export circuit C(v: Field, b: Boolean): Boolean {"
         "    return disclose(b == foo(v));"
         "  }"
         "}"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import M;"
         "witness W(): Boolean;"
         "export circuit bar(): Boolean {"
         "  return C(3, W());"
         "}"
         ))
     (succeeds)
     ))

  (test
    '(
      "import CompactStandardLibrary;"
      "witness qcoin(): QualifiedCoinInfo;"
      "export circuit foo(coin: CoinInfo): [] {"
      "  return createZswapInput(qcoin());"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Boolean;"
      "export circuit foo(): CurvePoint {"
      "  return hashToCurve<Boolean>(W());"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 3" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W at line 2 char 1" ("\n    nature of the disclosure:\n      the value returned from exported circuit foo might disclose a hash of the witness value\n    via this path through the program:\n      the argument to hashToCurve at line 4 char 10"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Boolean;"
      "export circuit foo(): CurvePoint {"
      "  return disclose(hashToCurve<Boolean>(W()));"
      "}"
      )
    (succeeds)
    )

  )

(run-tests save-contract-info
  (test-group
    ((create-file "AuthCell.compact"
       '(
         "import CompactStandardLibrary;"
         "circuit public_key (sk: Bytes<32>): Bytes<32> {"
         "  return persistentHash<Vector<2, Bytes<32>>>([pad(32, 'auth-cell:pk'), sk]);"
         "}"
         "export struct StructExample {"
         "  value: Field;"
         "}"
         "ledger value: StructExample;"
         "sealed ledger authorized_pk: Bytes<32>;"
         "witness sk(): Bytes<32>;"
         "constructor(value_param: StructExample) {"
         "  value = disclose(value_param);"
         "  authorized_pk = disclose(public_key(sk()));"
         "}"
         "export circuit get(): StructExample {"
         "  assert(public_key(sk()) == authorized_pk, 'msg');"
         "  return value;"
         "}"
         "export circuit set(new_value: StructExample): [] {"
         "  assert(public_key(sk()) == authorized_pk, 'msg');"
         "  value = disclose(new_value);"
         "}"
         "export circuit my_pure_circuit(x: Field): Field {"
         "  return disclose(x);"
         "}"))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "export struct StructExample {"
         "  value: Field;"
         "}"
         "contract AuthCell {"
         "  circuit get(): StructExample;"
         "  circuit set(new_value: StructExample): [];"
         "}"
         "sealed ledger auth_cell: AuthCell;"
         "witness foo(): Bytes<32>;"
         "constructor (auth_cell_param: AuthCell) {"
         "  auth_cell = disclose(auth_cell_param);"
         "}"
         "export circuit use_auth_cell(x: StructExample): StructExample {"
         "  const v = auth_cell.get();"
         "  auth_cell.set(StructExample {value: v.value + disclose(x.value)});"
         "  return v;"
         "}"))
      (returns
        (program
          (kernel-declaration (%kernel.0 () (Kernel)))
          (public-ledger-declaration
            ((%auth_cell.1
               (0)
               (__compact_Cell
                 (tcontract AuthCell
                   (get #f () (tstruct StructExample (value (tfield))))
                   (set #f ((tstruct StructExample (value (tfield))))
                     (ttuple))))))
            (constructor ([%auth_cell_param.2 (tcontract AuthCell
                                                (get #f ()
                                                  (tstruct StructExample
                                                    (value (tfield))))
                                                (set #f ((tstruct StructExample
                                                           (value (tfield))))
                                                  (ttuple)))])
              (seq
                (public-ledger %auth_cell.1 (0) write %auth_cell_param.2)
                (tuple))))
          (type-definition StructExample ()
            (tstruct StructExample (value (tfield))))
          (circuit %use_auth_cell.3 ([%x.4 (tstruct StructExample
                                             (value (tfield)))])
               (tstruct StructExample (value (tfield)))
            (let* ([[%v.5 (tstruct StructExample (value (tfield)))]
                    (contract-call get
                         ((public-ledger %auth_cell.1 (0) read)
                          (tcontract AuthCell
                            (get #f () (tstruct StructExample (value (tfield))))
                            (set #f ((tstruct StructExample (value (tfield))))
                              (ttuple)))))])
              (seq
                (contract-call set
                      ((public-ledger %auth_cell.1 (0) read)
                       (tcontract AuthCell
                         (get #f () (tstruct StructExample (value (tfield))))
                         (set #f ((tstruct StructExample (value (tfield))))
                           (ttuple))))
                   (new (tstruct StructExample (value (tfield)))
                     (+ #f (elt-ref %v.5 value 0) (elt-ref %x.4 value 0))))
                 %v.5)))))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "contract C1 {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "export circuit foo(c: C1): C1 { return c; }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 5 char 1" "invalid type ~a for circuit ~a return value:\n  exported circuit return values cannot include contract values" ("contract C1<foo(Bytes<32>): [], pure barr(): Bytes<32>>" foo)))
     )
    )

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "contract C1 {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "export circuit foo(c: C1): Vector<1, C1> { return [c]; }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 5 char 1" "invalid type ~a for circuit ~a return value:\n  exported circuit return values cannot include contract values" ("Vector<1, contract C1<foo(Bytes<32>): [], pure barr(): Bytes<32>>>" foo)))
     )
    )

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.foo(contract_c.read().barr()); }"
         ))
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 4 char 3" "contract declaration has a circuit named ~s, but it is not present in the actual contract definition" (barr)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.read().foo(contract_c.read().barr()); }"
         ))
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 2 char 1" "contract ~s has no circuit declaration named ~s" (C barr)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (barr #t () (tbytes 32))))))
           (constructor () (tuple)))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.read().foo(contract_c.read().barr()); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (barr #t () (tbytes 32))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (barr #t () (tbytes 32)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %hello.3 ()
              (ttuple)
           (contract-call foo
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (barr #t () (tbytes 32))))
             (contract-call barr
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (barr #t () (tbytes 32)))))))))
     ))

  ;; checks if a cycle in contract declaration exists but it only tells user that they need to
  ;; recompile.
  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         "contract B { circuit hello():[]; }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("C.compact line 3 char 1" "error opening ~a; try (re)compiling ~a" ("compiler/testdir/B/compiler/contract-info.json" "compiler/testdir/B.compact"))))
    ((create-file "B.compact"
       '(
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.read().foo(contract_c.read().barr()); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("B.compact line 1 char 1" "error opening ~a; try (re)compiling ~a" ("compiler/testdir/C/compiler/contract-info.json" "compiler/testdir/C.compact")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.foo(contract_c.barr()); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (barr #t () (tbytes 32))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (barr #t () (tbytes 32)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %hello.3 ()
              (ttuple)
           (contract-call foo
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (barr #t () (tbytes 32))))
             (contract-call barr
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (barr #t () (tbytes 32)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.read().barr(contract_c.read().barr()); }"
         ))
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 8 char 54" "~s.~s requires ~s argument~:*~p but received ~s" (C barr 0 1)))))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         "export circuit blah(x: Field, y: Boolean): Boolean { return x == 0 ? y : !y; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit bar(): Bytes<32>;"
         "  circuit blah(x: Field, y: Boolean): Boolean;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(x: Field, y: Boolean): Boolean { return contract_c.read().blah(disclose(x), disclose(y)); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (bar #t () (tbytes 32))
                  (blah #f ((tfield) (tboolean)) (tboolean))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (bar #t () (tbytes 32))
                                 (blah #f ((tfield) (tboolean)) (tboolean)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %hello.3 ([%x.4 (tfield)] [%y.5 (tboolean)])
              (tboolean)
           (contract-call blah
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (bar #t () (tbytes 32))
                   (blah #f ((tfield) (tboolean)) (tboolean))))
             %x.4
             %y.5))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         "export circuit blah(x: Field, y: Boolean): Boolean { return x == 0 ? y : !y; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit bar(): Bytes<32>;"
         "  circuit blah(x: Field, y: Boolean): Boolean;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(x: Field, y: Boolean): [] { return contract_c.read().blah(y, x); }"
         ))
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 9 char 74" "expected ~:r argument of ~s.~s to have type ~a but received ~a" (1 C blah "Field" "Boolean")))))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         "export circuit blah(x: Field, y: Boolean): Boolean { return x == 0 ? y : !y; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "module m<A> {"
         "  export contract C {"
         "    circuit foo(x: A): [];"
         "    pure circuit bar(): A;"
         "  }"
         "}"
         "import m<Bytes<32>>;"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.read().foo(contract_c.read().bar()); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (bar #t () (tbytes 32))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (bar #t () (tbytes 32)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %hello.3 ()
              (ttuple)
           (contract-call foo
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (bar #t () (tbytes 32))))
             (contract-call bar
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (bar #t () (tbytes 32)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         "export circuit blah(x: Field, y: Boolean): Boolean { return x == 0 ? y : !y; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "module m<A> {"
         "  export contract C {"
         "    circuit foo(x: Bytes<32>): [];"
         "    pure circuit bar(): Bytes<32>;"
         "    circuit blah(x: Field, y: A): A;"
         "  }"
         "}"
         "import m<Boolean>;"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(x: Field, y: Boolean): [] { return contract_c.read().blah(y, x); }"
         ))
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 12 char 74" "expected ~:r argument of ~s.~s to have type ~a but received ~a" (1 C blah "Field" "Boolean")))))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         "export circuit blah(x: Field, y: Boolean): Boolean { return x == 0 ? y : !y; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "module m<A> {"
         "  export contract C {"
         "    circuit foo(x: Bytes<32>): [];"
         "    pure circuit bar(): Bytes<32>;"
         "    circuit blah(x: Field, y: A): A;"
         "  }"
         "}"
         "import m<Boolean>;"
         "sealed ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(x: Field, y: Boolean): [] { return contract_c.read().blah(x, y); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 12 char 50" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Boolean" "[]" "circuit hello")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         "export circuit blah(x: Field, y: Boolean): Boolean { return x == 0 ? y : !y; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "module m<A> {"
         "  export contract C {"
         "    circuit foo(x: Bytes<32>): [];"
         "    pure circuit bar(): Bytes<32>;"
         "    circuit blah(x: Field, y: A): A;"
         "  }"
         "}"
         "import m<Boolean>;"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(x: Field, y: Boolean): Boolean { return contract_c.read().blah(disclose(x), disclose(y)); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (bar #t () (tbytes 32))
                  (blah #f ((tfield) (tboolean)) (tboolean))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (bar #t () (tbytes 32))
                                 (blah #f ((tfield) (tboolean)) (tboolean)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %hello.3 ([%x.4 (tfield)] [%y.5 (tboolean)])
              (tboolean)
           (contract-call blah
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (bar #t () (tbytes 32))
                   (blah #f ((tfield) (tboolean)) (tboolean))))
             %x.4
             %y.5))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger Q: Bytes<32>;"
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export circuit bar(): Bytes<32> { return Q; }"
         "constructor(q: Bytes<32>) { Q = disclose(q); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "module m<A> {"
         "  export contract C {"
         "    circuit foo(x: A): [];"
         "    circuit bar(): A;"
         "  }"
         "}"
         "import m<Bytes<32>> prefix $;"
         "export ledger contract_c: $C;"
         "constructor (c: $C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.read().foo(contract_c.read().bar()); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (bar #f () (tbytes 32))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (bar #f () (tbytes 32)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %hello.3 ()
              (ttuple)
           (contract-call foo
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (bar #f () (tbytes 32))))
             (contract-call bar
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (bar #f () (tbytes 32)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger Q: Bytes<32>;"
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export circuit bar(): Bytes<32> { return Q; }"
         "constructor(q: Bytes<32>) { Q = disclose(q); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module m<A> {"
         "  import CompactStandardLibrary;"
         "  export contract C {"
         "    circuit foo(x: A): [];"
         "    circuit bar(): A;"
         "  }"
         "  export ledger contract_c: C;"
         "}"
         "import m<Bytes<32>> prefix $;"
         "constructor (c: $C) { $contract_c = disclose(c); }"
         "export circuit hello(): [] { return $contract_c.read().foo($contract_c.read().bar()); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (bar #f () (tbytes 32))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (bar #f () (tbytes 32)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %hello.3 ()
              (ttuple)
           (contract-call foo
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (bar #f () (tbytes 32))))
             (contract-call bar
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (bar #f () (tbytes 32)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger Q: Bytes<32>;"
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export circuit bar(): Bytes<32> { return Q; }"
         "constructor(q: Bytes<32>) { Q = disclose(q); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module m<A> {"
         "  import CompactStandardLibrary;"
         "  export contract C {"
         "    circuit foo(x: A): [];"
         "    circuit bar(): A;"
         "  }"
         "  export ledger contract_c: C;"
         "}"
         "import m<Bytes<32>> prefix $;"
         "import m<Bytes<64>>;"
         "constructor (c: $C) { $contract_c = disclose(c); }"
         "export circuit hello(x: Bytes<64>): [] { return $contract_c.read().foo(x); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 5" "contract declaration claims the type of circuit ~s argument ~s is ~a, but in the actual contract definition it is ~a" (foo 1 "Bytes<64>" "Bytes<32>")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger Q: Bytes<32>;"
         "export circuit bar(): Bytes<32> { return Q; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit bar(): Bytes<64>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): Bytes<64> { return contract_c.read().bar(); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 3 char 3" "contract declaration claims the return type of circuit ~s is ~a, but in the actual contract definition it is ~a" (bar "Bytes<64>" "Bytes<32>")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger Q: Bytes<32>;"
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export circuit bar(): Bytes<32> { return Q; }"
         "constructor(q: Bytes<32>) { Q = disclose(q); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module m<A> {"
         "  import CompactStandardLibrary;"
         "  export contract C {"
         "    circuit foo(x: A): [];"
         "    circuit bar(): A;"
         "  }"
         "  ledger contract_c: C;"
         "  export circuit m_init(c: C): [] { contract_c = disclose(c); }"
         "  export circuit hello(): [] { return contract_c.read().foo(contract_c.read().bar()); }"
         "}"
         "import m<Bytes<32>>;"
         "constructor (c: C) { m_init(c); }"
         "export { hello };"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (bar #f () (tbytes 32))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (bar #f () (tbytes 32)))])
             (seq (call %m_init.3 %c.2) (tuple))))
         (circuit %m_init.3 ([%c.4 (tcontract C
                                     (foo #f ((tbytes 32)) (ttuple))
                                     (bar #f () (tbytes 32)))])
              (ttuple)
           (seq (public-ledger %contract_c.1 (0) write %c.4) (tuple)))
         (circuit %hello.5 ()
              (ttuple)
           (contract-call foo
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (bar #f () (tbytes 32))))
             (contract-call bar
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (bar #f () (tbytes 32)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): Boolean { return true; }"
         "export pure circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "export contract C {"
         "  circuit foo(x: Field): Boolean;"
         "  pure circuit bar(): Field;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "cannot export ~a (~s) from the top level" ("contract type" C)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): Boolean {"
         "  return x == 3;"
         "}"))
      (succeeds))
    ((create-file "testfile.compact"
       `(
         "module M {"
         "  export contract C {"
         "    circuit foo(x: Field): Boolean;"
         "  }"
         "}"
         "import M;"
         ))
      (returns
        (program
          (public-ledger-declaration () (constructor () (tuple)))))
    ))

  (test-group
    ((create-file "C.compact"
       '(
         "circuit foo(x: Field): Boolean {"
         "  return x == 3;"
         "}"))
      (succeeds))
    ((create-file "testfile.compact"
       `(
         "module M {"
         "  export contract C {"
         "    circuit foo(x: Field): Boolean;"
         "  }"
         "}"
         "import M;"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 3 char 5" "contract declaration has a circuit named ~s, but it is not present in the actual contract definition" (foo)))
    ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): Boolean { return true; }"
         "export pure circuit bar(): Field { return 3; }"
         "export circuit blot(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "module M {"
         "  contract C {"
         "    circuit foo(x: Field): Boolean;"
         "    pure circuit bar(): Field;"
         "  }"
         "  ledger ledger_c : C;"
         "  export circuit putc(c: C): [] {"
         "    ledger_c = disclose(c);"
         "  }"
         "  export circuit callc(): Boolean {"
         "    return ledger_c.foo(ledger_c.bar());"
         "  }"
         "}"
         "contract C {"
         "  circuit foo(x: Field): Boolean;"
         "  pure circuit bar(): Field;"
         "}"
         "constructor(c: C) {"
         "  putc(c);"
         "}"
         "import M;"
         "export { callc };"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%ledger_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tfield)) (tboolean))
                  (bar #t () (tfield))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tfield)) (tboolean))
                                 (bar #t () (tfield)))])
             (seq (call %putc.3 %c.2) (tuple))))
         (circuit %putc.3 ([%c.4 (tcontract C
                                   (foo #f ((tfield)) (tboolean))
                                   (bar #t () (tfield)))])
              (ttuple)
           (seq (public-ledger %ledger_c.1 (0) write %c.4) (tuple)))
         (circuit %callc.5 ()
              (tboolean)
           (contract-call foo
                ((public-ledger %ledger_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tfield)) (tboolean))
                   (bar #t () (tfield))))
             (contract-call bar
                  ((public-ledger %ledger_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tfield)) (tboolean))
                     (bar #t () (tfield)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): Boolean { return true; }"
         "export pure circuit bar(): Field { return 3; }"
         "export circuit blot(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "module M {"
         "  contract C {"
         "    circuit foo(x: Field): Boolean;"
         "    pure circuit bar(): Field;"
         "  }"
         "  ledger ledger_c : C;"
         "  export circuit putc(c: C): [] {"
         "    ledger_c = disclose(c);"
         "  }"
         "  export circuit callc(): Boolean {"
         "    return ledger_c.foo(ledger_c.bar());"
         "  }"
         "}"
         "contract C {"
         "  circuit foo(x: Field): Boolean;"
         "  pure circuit bar(): Field;"
         "  circuit blot(): Bytes<32>;"
         "}"
         "constructor(c: C) {"
         "  putc(c);"
         "}"
         "import M;"
         "export { callc };"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%ledger_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tfield)) (tboolean))
                  (bar #t () (tfield))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tfield)) (tboolean))
                                 (bar #t () (tfield))
                                 (blot #f () (tbytes 32)))])
             (seq
               (call %putc.3
                 (safe-cast (tcontract C
                              (foo #f ((tfield)) (tboolean))
                              (bar #t () (tfield)))
                            (tcontract C
                              (foo #f ((tfield)) (tboolean))
                              (bar #t () (tfield))
                              (blot #f () (tbytes 32)))
                   %c.2))
               (tuple))))
         (circuit %putc.3 ([%c.4 (tcontract C
                                   (foo #f ((tfield)) (tboolean))
                                   (bar #t () (tfield)))])
              (ttuple)
           (seq (public-ledger %ledger_c.1 (0) write %c.4) (tuple)))
         (circuit %callc.5 ()
              (tboolean)
           (contract-call foo
                ((public-ledger %ledger_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tfield)) (tboolean))
                   (bar #t () (tfield))))
             (contract-call bar
                  ((public-ledger %ledger_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tfield)) (tboolean))
                     (bar #t () (tfield)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): Boolean { return true; }"
         "export pure circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "module M {"
         "  contract C {"
         "    circuit foo(x: Field): Boolean;"
         "    pure circuit bar(): Field;"
         "  }"
         "  ledger ledger_c : C;"
         "  export circuit putc(c: C): [] {"
         "    ledger_c = disclose(c);"
         "  }"
         "  export circuit callc(): Boolean {"
         "    return ledger_c.foo(ledger_c.bar());"
         "  }"
         "}"
         "contract C {"
         "  circuit foo(x: Field): Boolean;"
         "}"
         "constructor(c: C) {"
         "  putc(c);"
         "}"
         "import M;"
         "export { callc };"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 19 char 3" "no compatible function named ~a is in scope at this call~@[~a~]~@[~a~]~@[~a~]" (putc #f "\n    one function is incompatible with the supplied argument types\n      supplied argument types:\n        (contract C<foo(Field): Boolean>)\n      declared argument types for function at line 8 char 3:\n        (contract C<foo(Field): Boolean, pure bar(): Field>)" #f)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): [] { return; }"
         "export pure circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit foo(x: Field): [] { return; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module M {"
         "  export contract C {"
         "    circuit foo(x: Field): [];"
         "    pure circuit bar(): Field;"
         "  }"
         "}"
         "import M prefix $;"
         "contract C2 {"
         "  circuit foo(x: Field): [];"
         "}"
         "constructor($c: $C) {"
         "  const c : C2 = $c;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 12 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("contract C<foo(Field): [], pure bar(): Field>" "contract C2<foo(Field): []>")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): [] { return; }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit foo(x: Field): [] { return; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module M {"
         "  export contract C {"
         "    circuit foo(x: Field): [];"
         "  }"
         "}"
         "import M prefix $;"
         "contract C2 {"
         "  circuit foo(x: Field): [];"
         "}"
         "constructor($c: $C) {"
         "  const c : C2 = $c;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("contract C<foo(Field): []>" "contract C2<foo(Field): []>")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): [] { return; }"
         "export pure circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module M {"
         "  export contract C {"
         "    circuit foo(x: Field): [];"
         "    pure circuit bar(): Field;"
         "  }"
         "}"
         "import M prefix $;"
         "contract C {"
         "  circuit foo(x: Field): [];"
         "}"
         "constructor($c: $C) {"
         "  const c : C = $c;"
         "}"
         ))
     (returns
       (program
         (public-ledger-declaration
           ()
           (constructor ([%$c.0 (tcontract C
                                  (foo #f ((tfield)) (ttuple))
                                  (bar #t () (tfield)))])
             (seq
               (let* ([[%c.1 (tcontract C (foo #f ((tfield)) (ttuple)))]
                       (safe-cast (tcontract C (foo #f ((tfield)) (ttuple)))
                                  (tcontract C
                                    (foo #f ((tfield)) (ttuple))
                                    (bar #t () (tfield)))
                         %$c.0)])
                 (tuple))
               (tuple))))))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Field): Field { return x; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit foo(x: Field): Field { return x; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C1 {"
         "  circuit foo(x: Field): Field;"
         "}"
         "contract C2 {"
         "  circuit foo(x: Field): Field;"
         "}"
         "constructor(c1: C1) {"
         "  const c2 : C2 = c1;"
         "}"
         ))
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 8 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("contract C1<foo(Field): Field>" "contract C2<foo(Field): Field>")))))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Field): Field { return x; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit foo(x: Field): [] { return; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C1 {"
         "  circuit foo(x: Field): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit foo(x: Field): [];"
         "}"
         "constructor(c1: C1) {"
         "  const c2 : C2 = c1;"
         "}"
         ))
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 9 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("contract C1<foo(Field): Field, pure bar(): Field>" "contract C2<foo(Field): []>")))
      ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field, y: Field): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module m{"
         "  export contract C {"
         "    circuit foo(x: Field): [];"
         "    pure circuit bar(): Field;"
         "}}"
         "contract C {"
         "  circuit foo(x: Field, y: Field): [];"
         "  pure circuit bar(): Field;"
         "}"
         "import m prefix $;"
         "constructor($c: $C) {"
         "  const c : C = $c;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 3 char 5" "contract declaration claims circuit ~s has ~s argument~:*~p, but in the actual contract definition it has ~s" (foo 1 2)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field, y: Field): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module m{"
         "  export contract C {"
         "    circuit foo(x: Field, y: Field): [];"
         "    pure circuit bar(): Field;"
         "}}"
         "contract C {"
         "  circuit foo(x: Field): [];"
         "  pure circuit bar(): Field;"
         "}"
         "import m prefix $;"
         "constructor($c: $C) {"
         "  const c : C = $c;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 7 char 3" "contract declaration claims circuit ~s has ~s argument~:*~p, but in the actual contract definition it has ~s" (foo 1 2)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Uint<16>): Uint<8> { return x as Uint<8>; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module m{"
         "  export contract C {"
         "    circuit foo(x: Uint<16>): Uint<8>;"
         "    pure circuit bar(): Field;"
         "}}"
         "contract C {"
         "  circuit foo(x: Uint<8>): Uint<16>;"
         "}"
         "import m prefix $;"
         "constructor($c: $C) {"
         "  const c : C = $c;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 7 char 3" "contract declaration claims the type of circuit ~s argument ~s is ~a, but in the actual contract definition it is ~a" (foo 1 "Uint<8>" "Uint<16>")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Field): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit foo(x: Field): [] { return; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C1 {"
         "  circuit foo(x: Field): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit foo(x: Field): [];"
         "}"
         "constructor(c2: C2) {"
         "  const c1 : C1 = c2;"
         "}"
         ))
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 9 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("contract C2<foo(Field): []>" "contract C1<foo(Field): [], pure bar(): Field>")))))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Field): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "witness check(): C;"
         "export circuit hello() : C {return check();}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 7 char 1" "invalid type ~a for witness ~a return value:\n  witness return values cannot include contract values" ("contract C<foo(Field): [], pure bar(): Field>" check)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Field): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "witness check(): Vector<3, C>;"
         "export circuit hello() : C {return check()[1];}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 7 char 1" "invalid type ~a for witness ~a return value:\n  witness return values cannot include contract values" ("Vector<3, contract C<foo(Field): [], pure bar(): Field>>" check)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "struct S { c: C }"
         "contract C {"
         "  circuit foo(x: Field): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "witness check(): S;"
         "export circuit hello() : S {return check();}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 8 char 1" "invalid type ~a for witness ~a return value:\n  witness return values cannot include contract values" ("struct S<c: contract C<foo(Field): [], pure bar(): Field>>" check)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "struct S { c: C }"
         "contract C {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "witness check(x: C): [];"
         "export circuit hello() : [] {return check(contract_c);}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C (foo #f () (ttuple)) (bar #t () (tfield))))))
           (constructor () (tuple)))
         (witness %check.2 ([%x.3 (tcontract C
                                    (foo #f () (ttuple))
                                    (bar #t () (tfield)))])
              (ttuple))
         (circuit %hello.4 ()
              (ttuple)
           (call %check.2 (public-ledger %contract_c.1 (0) read)))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Field): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor(){contract_c = default<C>;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 3 char 3" "contract declaration claims circuit ~s has ~s argument~:*~p, but in the actual contract definition it has ~s" (foo 1 0)))
     ))

  (test
   `(
     "import CompactStandardLibrary;"
     "ledger kerrnel: Kernel;"
     "constructor() { kerrnel = default<Kernel>; }"
     )
   (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 27" "default is not defined for ADT type Kernel" ())))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Field): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor(){contract_c = default<C>;}"
         ))
      (oops
        message: "~a:\n  ~?"
        irritants: '("testfile.compact line 7 char 28" "default is not defined for contract types" ()))))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "circuit foo(c: C): C {return c;}"
         "ledger contract_c: C;"
         "constructor(c: C) {contract_c = disclose(c);}"
         "export circuit foofoo(): [] {const x = foo(contract_c); return;}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.0
              (0)
              (__compact_Cell
                (tcontract C (foo #f () (ttuple)) (bar #t () (tfield))))))
           (constructor ([%c.1 (tcontract C
                                 (foo #f () (ttuple))
                                 (bar #t () (tfield)))])
             (seq (public-ledger %contract_c.0 (0) write %c.1) (tuple))))
         (circuit %foo.2 ([%c.3 (tcontract C
                                  (foo #f () (ttuple))
                                  (bar #t () (tfield)))])
              (tcontract C (foo #f () (ttuple)) (bar #t () (tfield)))
           %c.3)
         (circuit %foofoo.4 ()
              (ttuple)
           (let* ([[%x.5 (tcontract C
                           (foo #f () (ttuple))
                           (bar #t () (tfield)))]
                   (call %foo.2 (public-ledger %contract_c.0 (0) read))])
             (tuple)))))
      ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "export circuit foo(c: C): [] {return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 5 char 1" "invalid type ~a for circuit ~a argument ~d:\n  exported circuit arguments cannot include contract values" ("contract C<foo(): [], pure bar(): Field>" foo 1)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "struct S { c: C, b: Boolean }"
         "contract C {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "export circuit foo(s: S): [] {return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 6 char 1" "invalid type ~a for circuit ~a argument ~d:\n  exported circuit arguments cannot include contract values" ("struct S<c: contract C<foo(): [], pure bar(): Field>, b: Boolean>" foo 1)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "export circuit foo(x: Boolean, c: C): [] {return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 5 char 1" "invalid type ~a for circuit ~a argument ~d:\n  exported circuit arguments cannot include contract values" ("contract C<foo(): [], pure bar(): Field>" foo 2)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor(c: C) {contract_c = disclose(c);}"
         "export circuit foo(): C {return contract_c;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 8 char 1" "invalid type ~a for circuit ~a return value:\n  exported circuit return values cannot include contract values" ("contract C<foo(): [], pure bar(): Field>" foo)))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export circuit barr(): Bytes<32> { return pad(32, ''); }"
         )
       )
     (succeeds))
    ((create-file "UseC.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.foo(contract_c.read().barr()); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (barr #t () (tbytes 32))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (barr #t () (tbytes 32)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %hello.3 ()
              (ttuple)
           (contract-call foo
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (barr #t () (tbytes 32))))
             (contract-call barr
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (barr #t () (tbytes 32)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         )
       )
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor(c: C) {c.foo();}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 7 char 1" "constructor cannot call external contracts but ~a at ~a" ("calls circuit foo from external contract C" "line 7 char 21")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): Field { return 1; }"
         )
       )
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(): Field;"
         "}"
         "ledger q: Map<Field, Field>;"
         "constructor(c: C) { q.insert(1, c.foo()); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 6 char 1" "constructor cannot call external contracts but ~a at ~a" ("calls circuit foo from external contract C" "line 6 char 34")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export circuit bar(): Field { return 3; }"
         )
       )
     (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit fooo(): [] { return; }"
         "export circuit baar(): Field { return 3; }"
         )
       )
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit fooo(): [];"
         "  pure circuit baar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1, c2: C2) {c2.fooo();}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 1" "constructor cannot call external contracts but ~a at ~a" ("calls circuit fooo from external contract C2" "line 11 char 32")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger N: Counter;"
         "export circuit foo(n: Uint<8>): Field { N += disclose(n); return N; }"
         "export pure circuit bar(): Field { return 17; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(n: Uint<8>): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "pure circuit docall(c: C): Field { return c.bar(); }"
         "export circuit hello(): Field { return docall(contract_c); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tunsigned 255)) (tfield))
                  (bar #t () (tfield))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tunsigned 255)) (tfield))
                                 (bar #t () (tfield)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %docall.3 ([%c.4 (tcontract C
                                     (foo #f ((tunsigned 255)) (tfield))
                                     (bar #t () (tfield)))])
              (tfield)
           (contract-call bar
                (%c.4
                 (tcontract C
                   (foo #f ((tunsigned 255)) (tfield))
                   (bar #t () (tfield))))))
         (circuit %hello.5 ()
              (tfield)
           (call %docall.3 (public-ledger %contract_c.1 (0) read)))))
     ))

  (test-group
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger N: Counter;"
         "circuit foo(n: Uint<8>): Field { N += disclose(n); return N; }"
         "pure circuit docall(): Field { return foofoo(); }"
         "circuit foofoo() : Field {return foo(17);}"
         "export circuit hello(): Field { return docall(); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 1" "circuit ~a is marked pure but is actually impure because it calls (directly or indirectly) impure circuit ~a;\n    ~:*~a is impure because it ~a at ~a" (docall foo "accesses ledger field N" "line 3 char 59")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger N: Counter;"
         "export circuit foo(n: Uint<8>): Field { N += disclose(n); return N; }"
         "export pure circuit bar(): Field { return 17; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(n: Uint<8>): Field;"
         "  circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "// bar is declared impure (even though it isn't), so docall isn't pure"
         "pure circuit docall(c: C): Field { return c.bar(); }"
         "export circuit hello(): Field { return docall(contract_c); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 9 char 1" "circuit ~a is marked pure but is actually impure because it ~a at ~a" (docall "calls impure circuit bar of external contract C" "line 9 char 44")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger N: Counter;"
         "export circuit foo(n: Uint<8>): Field { N += disclose(n); return N; }"
         "export pure circuit bar(): Field { return 17; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(n: Uint<8>): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "pure circuit docall(c: C): Field { return c.foo(17); }"
         "export circuit hello(): Field { return docall(contract_c); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 8 char 1" "circuit ~a is marked pure but is actually impure because it ~a at ~a" (docall "calls impure circuit foo of external contract C" "line 8 char 44")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger N: Counter;"
         "export circuit foo(n: Uint<8>): Field { N += disclose(n); return N; }"
         "export pure circuit bar(): Field { return 17; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(n: Uint<8>): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "pure circuit dodocall(c: C): Field { return docall(c); }"
         "circuit docall(c: C): Field { return c.foo(17); }"
         "export circuit hello(): Field { return dodocall(contract_c); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 8 char 1" "circuit ~a is marked pure but is actually impure because it calls (directly or indirectly) impure circuit ~a;\n    ~:*~a is impure because it ~a at ~a" (dodocall docall "calls impure circuit foo of external contract C" "line 9 char 39")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger N: Counter;"
         "export circuit foo(n: Uint<8>): Field { N += disclose(n); return N; }"
         "export pure circuit bar(): Field { return 17; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(n: Uint<8>): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "circuit docall(c: C): Field { return c.foo(17); }"
         "pure circuit dodocall(c: C): Field { return docall(c); }"
         "export circuit hello(): Field { return dodocall(contract_c); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 9 char 1" "circuit ~a is marked pure but is actually impure because it calls (directly or indirectly) impure circuit ~a;\n    ~:*~a is impure because it ~a at ~a" (dodocall docall "calls impure circuit foo of external contract C" "line 8 char 39")))
     ))

  (test-group
    ((create-file "testfile.compact"
       '(
         "export circuit bar(): Field { return 17; }"
         "export pure circuit foo1() : Field { return bar(); }"
         "export pure circuit foo2() : Field { return hello(); }"
         "export circuit hello(): Field { return bar(); }"
         ))
     (returns
       (program
         (public-ledger-declaration () (constructor () (tuple)))
         (circuit %bar.0 () (tfield) (safe-cast (tfield) (tunsigned 17) 17))
         (circuit %foo1.1 () (tfield) (call %bar.0))
         (circuit %foo2.2 () (tfield) (call %hello.3))
         (circuit %hello.3 () (tfield) (call %bar.0))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger N: Counter;"
         "export circuit foo(n: Uint<8>): Field { N += disclose(n); return N; }"
         "export pure circuit bar(): Field { return 17; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(n: Uint<8>): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "pure circuit docall(c: C): Field { return foofoo(c); }"
         "circuit foofoo(c: C) : Field {return c.foo(17);}"
         "export circuit hello(): Field { return docall(contract_c); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 8 char 1" "circuit ~a is marked pure but is actually impure because it calls (directly or indirectly) impure circuit ~a;\n    ~:*~a is impure because it ~a at ~a" (docall foofoo "calls impure circuit foo of external contract C" "line 9 char 39")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger N: Counter;"
         "export circuit foo(n: Uint<8>): Field { N += disclose(n); return N; }"
         "export pure circuit bar(): Field { return 17; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(n: Uint<8>): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit V(): Field { return W(contract_c); }"
         "circuit W(c: C): Field { return X(c); }"
         "circuit X(c: C): Field { return Y(c); }"
         "circuit Y(c: C): Field { return Z(c); }"
         "circuit Z(c: C): Field { return c.foo(17); }"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tunsigned 255)) (tfield))
                  (bar #t () (tfield))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tunsigned 255)) (tfield))
                                 (bar #t () (tfield)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %V.3 ()
              (tfield)
           (call %W.4 (public-ledger %contract_c.1 (0) read)))
         (circuit %W.4 ([%c.5 (tcontract C
                                (foo #f ((tunsigned 255)) (tfield))
                                (bar #t () (tfield)))])
              (tfield)
           (call %X.6 %c.5))
         (circuit %X.6 ([%c.7 (tcontract C
                                (foo #f ((tunsigned 255)) (tfield))
                                (bar #t () (tfield)))])
              (tfield)
           (call %Y.8 %c.7))
         (circuit %Y.8 ([%c.9 (tcontract C
                                (foo #f ((tunsigned 255)) (tfield))
                                (bar #t () (tfield)))])
              (tfield)
           (call %Z.10 %c.9))
         (circuit %Z.10 ([%c.11 (tcontract C
                                  (foo #f ((tunsigned 255)) (tfield))
                                  (bar #t () (tfield)))])
              (tfield)
           (contract-call foo
                (%c.11
                 (tcontract C
                   (foo #f ((tunsigned 255)) (tfield))
                   (bar #t () (tfield))))
             (safe-cast (tunsigned 255) (tunsigned 17) 17)))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger N: Counter;"
         "export circuit foo(n: Uint<8>): Field { N += disclose(n); return N; }"
         "export pure circuit bar(): Field { return 17; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(n: Uint<8>): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit V(): Field { return W(contract_c); }"
         "pure circuit W(c: C): Field { return X(c); }"
         "circuit X(c: C): Field { return Y(c); }"
         "circuit Y(c: C): Field { return Z(c); }"
         "circuit Z(c: C): Field { return c.foo(17); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 9 char 1" "circuit ~a is marked pure but is actually impure because it calls (directly or indirectly) impure circuit ~a;\n    ~:*~a is impure because it ~a at ~a" (W Z "calls impure circuit foo of external contract C" "line 12 char 34")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger X: Bytes<32>;"
         "export circuit foo(x: Bytes<32>): [] { X = disclose(x); }"
         "export circuit bar(): Bytes<32> { return X; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit bar(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export pure circuit hello(): [] { return contract_c.foo(contract_c.read().bar()); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 4 char 3" "contract declaration claims circuit ~s is pure, but it is not in the actual contract definition" (bar)))
     ))

  (test-group
    ((create-file "testfile.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         "witness sk(): Boolean;"
         "export circuit dummy(): Boolean{"
         "  return disclose(sk() == true);"
         "}"
         ))
     (output-file "compiler/testdir/testfile/compiler/contract-info.json"
       '(
         "{"
         "  \"circuits\": ["
         "    {"
         "      \"name\": \"foo\","
         "      \"pure\": true,"
         "      \"arguments\": ["
         "      ],"
         "      \"result-type\": {"
         "        \"type-name\": \"Tuple\","
         "        \"types\": ["
         "        ]"
         "      }"
         "    },"
         "    {"
         "      \"name\": \"bar\","
         "      \"pure\": true,"
         "      \"arguments\": ["
         "      ],"
         "      \"result-type\": {"
         "        \"type-name\": \"Field\""
         "      }"
         "    },"
         "    {"
         "      \"name\": \"dummy\","
         "      \"pure\": false,"
         "      \"arguments\": ["
         "      ],"
         "      \"result-type\": {"
         "        \"type-name\": \"Boolean\""
         "      }"
         "    }"
         "  ],"
         "  \"witnesses\": ["
         "    {"
         "      \"name\": \"sk\","
         "      \"arguments\": ["
         "      ],"
         "      \"result type\": {"
         "        \"type-name\": \"Boolean\""
         "      }"
         "    }"
         "  ],"
         "  \"contracts\": ["
         "  ]"
         "}"))
     ))

  (test-group
    ((create-file "testfile.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         "witness sk(): Boolean;"
         ))
     ; the witnesses field is empty if the witness is unused.
     (output-file "compiler/testdir/testfile/compiler/contract-info.json"
       '(
         "{"
         "  \"circuits\": ["
         "    {"
         "      \"name\": \"foo\","
         "      \"pure\": true,"
         "      \"arguments\": ["
         "      ],"
         "      \"result-type\": {"
         "        \"type-name\": \"Tuple\","
         "        \"types\": ["
         "        ]"
         "      }"
         "    },"
         "    {"
         "      \"name\": \"bar\","
         "      \"pure\": true,"
         "      \"arguments\": ["
         "      ],"
         "      \"result-type\": {"
         "        \"type-name\": \"Field\""
         "      }"
         "    }"
         "  ],"
         "  \"witnesses\": ["
         "  ],"
         "  \"contracts\": ["
         "  ]"
         "}"))
     ))

  (test-group
    ((source-file "examples/tiny.compact")
     (output-file "compiler/testdir/tiny/compiler/contract-info.json"
       '(
         "{"
         "  \"circuits\": ["
         "    {"
         "      \"name\": \"set\","
         "      \"pure\": false,"
         "      \"arguments\": ["
         "        {"
         "          \"name\": \"v\","
         "          \"type\": {"
         "            \"type-name\": \"Field\""
         "          }"
         "        }"
         "      ],"
         "      \"result-type\": {"
         "        \"type-name\": \"Tuple\","
         "        \"types\": ["
         "        ]"
         "      }"
         "    },"
         "    {"
         "      \"name\": \"get\","
         "      \"pure\": false,"
         "      \"arguments\": ["
         "      ],"
         "      \"result-type\": {"
         "        \"type-name\": \"Struct\","
         "        \"name\": \"Maybe\","
         "        \"elements\": ["
         "          {"
         "            \"name\": \"is_some\","
         "            \"type\": {"
         "              \"type-name\": \"Boolean\""
         "            }"
         "          },"
         "          {"
         "            \"name\": \"value\","
         "            \"type\": {"
         "              \"type-name\": \"Field\""
         "            }"
         "          }"
         "        ]"
         "      }"
         "    },"
         "    {"
         "      \"name\": \"clear\","
         "      \"pure\": false,"
         "      \"arguments\": ["
         "      ],"
         "      \"result-type\": {"
         "        \"type-name\": \"Tuple\","
         "        \"types\": ["
         "        ]"
         "      }"
         "    },"
         "    {"
         "      \"name\": \"public_key\","
         "      \"pure\": true,"
         "      \"arguments\": ["
         "        {"
         "          \"name\": \"sk\","
         "          \"type\": {"
         "            \"type-name\": \"Bytes\","
         "            \"length\": 32"
         "          }"
         "        }"
         "      ],"
         "      \"result-type\": {"
         "        \"type-name\": \"Bytes\","
         "        \"length\": 32"
         "      }"
         "    }"
         "  ],"
         "  \"witnesses\": ["
         "    {"
         "      \"name\": \"private$secret_key\","
         "      \"arguments\": ["
         "      ],"
         "      \"result type\": {"
         "        \"type-name\": \"Bytes\","
         "        \"length\": 32"
         "      }"
         "    }"
         "  ],"
         "  \"contracts\": ["
         "  ]"
         "}"))
     )
    )

  (test-group
    ((create-file "AuthCell.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger value: Field;"
         "sealed ledger authorized_pk: Bytes<32>;"
         ""
         "constructor (v: Field, pk: Bytes<32>) {"
         "  value = disclose(v);"
         "  authorized_pk = disclose(pk);"
         "}"
         ""
         "witness sk(): Bytes<32>;"
         ""
         "export circuit get(): Field {"
         "  assert(public_key(sk()) == authorized_pk, 'not authorized');"
         "  return value;"
         "}"
         ""
         "export circuit set(new_value: Field): [] {"
         "  assert(public_key(sk()) == authorized_pk, 'not authorized');"
         "  value = disclose(new_value);"
         "}"
         ""
         "export circuit public_key (sk: Bytes<32>): Bytes<32> {"
         "  return persistentHash<Vector<2, Bytes<32>>>([pad(32, 'auth-cell:pk:'), sk]);"
         "}"
         ))
     (succeeds))
    ((create-file "UseAuthCell.compact"
       '(
         "import CompactStandardLibrary;"
         "contract AuthCell {"
         "  circuit get(): Field;"
         "  circuit set(new_value: Field): [];"
         "}"
         "sealed ledger auth_cell: AuthCell;"
         ""
         "constructor (c: AuthCell) {"
         "  auth_cell = disclose(c);"
         "}"
         ""
         "export circuit use_auth_cell(): Field {"
         "  const v = auth_cell.get();"
         "  auth_cell.set(v + 1);"
         "  return v;"
         "}"
         ))
     (succeeds)
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor(c: C) {contract_c = disclose(c); c.foo();}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 7 char 1" "constructor cannot call external contracts but ~a at ~a" ("calls circuit foo from external contract C" "line 7 char 47")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C;"
         "constructor(c: C) {contract_c = disclose(c);}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C (foo #f () (ttuple)) (bar #t () (tfield))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f () (ttuple))
                                 (bar #t () (tfield)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (circuit %foofoo.3 ()
              (ttuple)
           (let* ([[%x.4 (ttuple)]
                   (contract-call foo
                        ((public-ledger %contract_c.1 (0) read)
                         (tcontract C
                           (foo #f () (ttuple))
                           (bar #t () (tfield)))))])
             (tuple)))))
      ))

  ;; cyclic external contract calls.
  (test-group ;; if the test-group doesn't care about the order this will not throw an error
    ((create-file "C1.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C2{"
         "  circuit foo2(): [];"
         "  pure circuit bar2(): Field;"
         "}"
         "sealed ledger contract_c: C2;"
         "constructor(c2:C2) {contract_c = disclose(c2);}"
         "export circuit foo(): [] { return contract_c.foo2(); }"
         "export circuit bar(): Field { return contract_c.bar2(); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("C1.compact line 2 char 1" "error opening ~a; try (re)compiling ~a" ("compiler/testdir/C2/compiler/contract-info.json" "compiler/testdir/C2.compact"))))
    ((create-file "C2.compact"
       '(
         "export circuit foo2(): [] { return; }"
         "export pure circuit bar2(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  circuit bar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1) {contract_c = disclose(c1);}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 2 char 1" "error opening ~a; try (re)compiling ~a" ("compiler/testdir/C1/compiler/contract-info.json" "compiler/testdir/C1.compact")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (chmod "compiler/testdir/C1/compiler/contract-info.json" 000)
         #t))
      )
    ((create-file "testfile.compact"
       '(
         "contract C1 { circuit foo(): []; }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "error opening ~a; try (re)compiling ~a" ("compiler/testdir/C1/compiler/contract-info.json" "compiler/testdir/C1.compact")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (delete-file fn)
           (call-with-output-file fn
             (lambda (out-port)
               (display "jibber jabber" out-port))))))
      )
    ((create-file "testfile.compact"
       '(
         "contract C1 { circuit foo(): []; }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "error reading ~a: ~a" ("compiler/testdir/C1/compiler/contract-info.json" "Exception: contract-info.json line 1 char 1:\n  expected object or array (received jibber)")))
     ))

  (test-group
    ((create-file "C2.compact"
       '(
         "export circuit foo2(): [] { return; }"
         "export pure circuit bar2(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "C1.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C2{"
         "  circuit foo2(): [];"
         "  pure circuit bar2(): Field;"
         "}"
         "sealed ledger contract_c: C2;"
         "constructor(c2:C2) {contract_c = disclose(c2);}"
         "export circuit foo(): [] { return contract_c.foo2(); }"
         "export circuit bar(): Field { return contract_c.bar2(); }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  circuit bar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1) {contract_c = disclose(c1);}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C1 (foo #f () (ttuple)) (bar #f () (tfield))))))
           (constructor ([%c1.2 (tcontract C1
                                  (foo #f () (ttuple))
                                  (bar #f () (tfield)))])
             (seq
               (public-ledger %contract_c.1 (0) write %c1.2)
               (tuple))))
         (circuit %foofoo.3 ()
              (ttuple)
           (let* ([[%x.4 (ttuple)]
                   (contract-call foo
                        ((public-ledger %contract_c.1 (0) read)
                         (tcontract C1
                           (foo #f () (ttuple))
                           (bar #f () (tfield)))))])
             (tuple)))))
     ))

  (test-group
    ((create-file "C2.compact"
       '(
         "export circuit foo2(): [] { return; }"
         "export pure circuit bar2(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "C1.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C2{"
         "  circuit foo2(): [];"
         "  pure circuit bar2(): Field;"
         "}"
         "sealed ledger contract_c: C2;"
         "constructor(c2:C2) {contract_c = disclose(c2);}"
         "export circuit foo(): [] { return contract_c.foo2(); }"
         "export circuit bar(): Field { return contract_c.bar2(); }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  circuit bar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1) {contract_c = disclose(c1);}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C1 (foo #f () (ttuple)) (bar #f () (tfield))))))
           (constructor ([%c1.2 (tcontract C1
                                  (foo #f () (ttuple))
                                  (bar #f () (tfield)))])
             (seq
               (public-ledger %contract_c.1 (0) write %c1.2)
               (tuple))))
         (circuit %foofoo.3 ()
              (ttuple)
           (let* ([[%x.4 (ttuple)]
                   (contract-call foo
                        ((public-ledger %contract_c.1 (0) read)
                         (tcontract C1
                           (foo #f () (ttuple))
                           (bar #f () (tfield)))))])
             (tuple)))))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit fooo(): [] { return; }"
         "export pure circuit baar(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit fooo(): [];"
         "  pure circuit baar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1, c2: C2) {contract_c = disclose(c1); c2.fooo();}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 1" "constructor cannot call external contracts but ~a at ~a" ("calls circuit fooo from external contract C2" "line 11 char 59")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit fooo(): [] { return; }"
         "export pure circuit baar(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit fooo(): [];"
         "  pure circuit baar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1, c2: C2) {contract_c = disclose(c1); contract_c.foo();}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 1" "constructor cannot call external contracts but ~a at ~a" ("calls circuit foo from external contract C1" "line 11 char 67")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit fooo(): [] { return; }"
         "export pure circuit baar(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit fooo(): [];"
         "  pure circuit baar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1, c2: C2) {contract_c = disclose(c1); const x = c2.baar() + contract_c.bar();}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 1" "constructor cannot call external contracts but ~a at ~a" ("calls circuit bar from external contract C1" "line 11 char 89")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit fooo(): [] { return; }"
         "export pure circuit baar(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit fooo(): [];"
         "  pure circuit baar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1, c2: C2) {contract_c = disclose(c1); return foofoo();}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 1" "constructor cannot call external contracts but calls (directly or indirectly) ~a, which ~a at ~a" (foofoo "calls circuit foo from external contract C1" "line 12 char 50")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit fooo(): [] { return; }"
         "export pure circuit baar(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit fooo(): [];"
         "  pure circuit baar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1, c2: C2) {contract_c = disclose(c1); foofoo();}"
         "circuit fab(): [] {const x = contract_c.foo(); return;}"
         "export circuit foofoo(): [] {return blah();}"
         "circuit blah(): [] {return fab();}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 1" "constructor cannot call external contracts but calls (directly or indirectly) ~a, which ~a at ~a" (fab "calls circuit foo from external contract C1" "line 12 char 40")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit fooo(): [] { return; }"
         "export pure circuit baar(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit fooo(): [];"
         "  pure circuit baar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1, c2: C2) {contract_c = disclose(c1); foofoo();}"
         "circuit fab(): [] {const x = contract_c.foo(); return;}"
         "export circuit foofoo(): [] {return fab();}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 1" "constructor cannot call external contracts but calls (directly or indirectly) ~a, which ~a at ~a" (fab "calls circuit foo from external contract C1" "line 12 char 40")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit fooo(): [] { return; }"
         "export pure circuit baar(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit fooo(): [];"
         "  pure circuit baar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1, c2: C2) {contract_c = disclose(c1); foofoo();}"
         "circuit fab(): [] {const x = contract_c.foo(); return;}"
         "export circuit foofoo(): [] { fab(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 1" "constructor cannot call external contracts but calls (directly or indirectly) ~a, which ~a at ~a" (fab "calls circuit foo from external contract C1" "line 12 char 40")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): Field { return 3; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1) {contract_c = disclose(c1); foofoo(baz());}"
         "export circuit foofoo(a: Field): [] {const x = contract_c.foo() == a; return;}"
         "export circuit baz(): Field {return contract_c.bar();}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 7 char 1" "constructor cannot call external contracts but calls (directly or indirectly) ~a, which ~a at ~a" (baz "calls circuit bar from external contract C1" "line 9 char 47")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): Field { return 3; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1) {contract_c = disclose(c1); foofoo(blah());}"
         "export circuit foofoo(a: Field): [] {const x = contract_c.foo() == a; return;}"
         "export circuit baz(): Field {return contract_c.bar();}"
         "circuit blah() : Field {return id();}"
         "export circuit id(): Field {return baz();}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 7 char 1" "constructor cannot call external contracts but calls (directly or indirectly) ~a, which ~a at ~a" (baz "calls circuit bar from external contract C1" "line 9 char 47")))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): Field { return 3; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): Field;"
         "  pure circuit bar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1) {contract_c = disclose(c1); foofoo(id());}"
         "export circuit foofoo(a: Field): [] {const x = contract_c.foo() == a; return;}"
         "export circuit baz(): Field {return contract_c.bar();}"
         "export circuit id(): Field {return baz();}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 7 char 1" "constructor cannot call external contracts but calls (directly or indirectly) ~a, which ~a at ~a" (baz "calls circuit bar from external contract C1" "line 9 char 47")))
      ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         "export pure circuit bar(): Field { return 1; }"
         ))
      (succeeds))
    ((create-file "C2.compact"
       '(
         "export circuit fooo(): [] { return; }"
         "export pure circuit baar(): Field { return 2;}"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C1 {"
         "  circuit foo(): [];"
         "  pure circuit bar(): Field;"
         "}"
         "contract C2 {"
         "  circuit fooo(): [];"
         "  pure circuit baar(): Field;"
         "}"
         "ledger contract_c: C1;"
         "constructor(c1: C1, c2: C2) {contract_c = disclose(c1); foofoo();}"
         "export circuit foofoo(): [] {const x = contract_c.foo(); return;}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 1" "constructor cannot call external contracts but calls (directly or indirectly) ~a, which ~a at ~a" (foofoo "calls circuit foo from external contract C1" "line 12 char 50")))
     ))

  (test
    '(
      "import CompactStandardLibrary;"
      "contract C { circuit foo(): []; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "error opening ~a; try (re)compiling ~a" ("compiler/C/compiler/contract-info.json" "compiler/testdir/C.compact")))
    )

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([t (file-modification-time (format "~a/C1/compiler/contract-info.json" testdir))])
           (let ([sourcefn (format "~a/C1.compact" testdir)])
             (let loop ()
               (unless (time>? (file-modification-time sourcefn) t)
                 (sleep (make-time 'time-duration (expt 10 8) 1))
                 (let ([s (call-with-port (open-input-file sourcefn) get-string-all)])
                   (call-with-port
                     (open-output-file sourcefn 'replace)
                     (lambda (op) (put-string op s))))
                 (loop)))))
         #t)))
    ((create-file "testfile.compact"
       '(
         "contract C1 { circuit foo(): []; }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 1" "~a has been modified more recently than ~a; try recompiling ~a" ("compiler/testdir/C1.compact" "compiler/testdir/C1/compiler/contract-info.json" "compiler/testdir/C1.compact")))
     ))

  (test-group
    ; this test is reliant on what the first line of contract-info is and how it is read by compactc
    ((create-file "C1.compact"
       '(
         "export circuit foo(): [] { return; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (with-output-to-file
           (format "~a/C1/compiler/contract-info.json" testdir)
           newline
           'replace)
         #t)))
    ((create-file "testfile.compact"
       '(
         "contract C1 { circuit foo(): []; }"
         ))
     (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "missing association for \"contracts\"" C1))
     ))

  (test-group
    ((create-file "C.compact"
      '(
        "export circuit bar(x: Field): [] { return; }"))
      (succeeds))
    ((create-file "C1.compact"
       '(
         "contract C { circuit bar(x: Field) : []; }"
         "export enum E { F }"
         "export struct S { a: E }"
         "export circuit foo(x: Opaque<'string'>, y: Vector<2, S>, z: E): [] { return; }"))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "enum E { F }"
         "struct S { a: E }"
         "contract C1 {"
         "  circuit foo(x: Opaque<'string'>, y: Vector<2, S>, z: E): [];"
         "}"))
      (returns
       (program
         (public-ledger-declaration () (constructor () (tuple)))))
      ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Opaque<'string'>): [] { return; }"))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C1 {"
         "  circuit foo(x: Opaque<'string'>): [];"
         "}"))
      (returns
       (program
         (public-ledger-declaration () (constructor () (tuple)))))
      ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export enum E { F }"
         "export circuit foo(x: E): E { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits" "arguments" "type" "elements") (list->vector '()))))))
    ((create-file "testfile.compact"
       '(
         "enum E { F }"
         "contract C1 { circuit foo(x: E): E; }"
         ))
      (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "enum E does not have any members" C1))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export enum E { F }"
         "export circuit foo(x: E): E { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits" "arguments" "type" "elements") (list->vector '(16)))))))
    ((create-file "testfile.compact"
       '(
         "enum E { F }"
         "contract C1 { circuit foo(x: E): E; }"
         ))
      (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "expected a string, got 16" C1))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export enum E { F }"
         "export circuit foo(x: E): E { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits" "arguments" "type" "elements") 16)))))
    ((create-file "testfile.compact"
       '(
         "enum E { F }"
         "contract C1 { circuit foo(x: E): E; }"
         ))
      (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "expected a vector, got 16" C1))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export enum E { F }"
         "export circuit foo(x: E): E { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
             (replace-value-in-json fn '("circuits" "pure") 16)))))
    ((create-file "testfile.compact"
       '(
         "enum E { F }"
         "contract C1 { circuit foo(x: E): E; }"
         ))
      (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "expected a boolean, got 16" C1))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export enum E { F }"
         "export circuit foo(x: E): E { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits") '())))))
    ((create-file "testfile.compact"
       '(
         "enum E { F }"
         "contract C1 { circuit foo(x: E): E; }"
         ))
     (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "\"circuits\" is not associated with a vector" C1))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export enum E { F }"
         "export circuit foo(x: E): E { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits" "result-type" "type-name") "Enu")))))
    ((create-file "testfile.compact"
       '(
         "enum E { F }"
         "contract C1 { circuit foo(x: E): E; }"
         ))
      (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "unrecognized type-name Enu" C1))
     ))

   (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Vector<2, Uint<16>>): Vector<2, Uint<16>> { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits" "arguments" "type" "length") #t)))))
    ((create-file "testfile.compact"
       '(
         "contract C1 { circuit foo(x: Uint<16>): Uint<16>; }"
         ))
      (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "expected nat, got #t" C1))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Uint<16>): Uint<16> { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits" "arguments" "type" "maxval") #t)))))
    ((create-file "testfile.compact"
       '(
         "contract C1 { circuit foo(x: Uint<16>): Uint<16>; }"
         ))
      (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "expected nat, got #t" C1))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Uint<16>): Uint<16> { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits" "name") "f")))))
    ((create-file "testfile.compact"
       '(
         "contract C1 { circuit foo(x: Uint<16>): Uint<16>; }"
         ))
      (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 15" "contract declaration has a circuit named ~s, but it is not present in the actual contract definition" (foo)))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export pure circuit foo(x: Uint<16>): Uint<16> { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits" "pure") #f)))))
    ((create-file "testfile.compact"
       '(
         "contract C1 { pure circuit foo(x: Uint<16>): Uint<16>; }"
         ))
      (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 1 char 15" "contract declaration claims circuit ~s is pure, but it is not in the actual contract definition" (foo)))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export pure circuit foo(x: Uint<16>): Uint<16> { return x; }"
         ))
      (succeeds)
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C1/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("circuits" "pure") 16)))))
    ((create-file "testfile.compact"
       '(
         "contract C1 { pure circuit foo(x: Uint<16>): Uint<16>; }"
         ))
      (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C1/compiler/contract-info.json" C1 "expected a boolean, got 16" C1))
     ))

  (test-group
    ((create-file "C1.compact"
       '(
         "export circuit foo(x: Vector<2, Uint<16>>): Vector<2, Uint<16>> { return x; }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C1 { circuit foo(x: Vector<2, Uint<16>>): Vector<2, Uint<16>>; }"
         ))
     (returns
       (program
         (public-ledger-declaration () (constructor () (tuple)))))
     ))

  (test-group
    ((create-file "testfile" '())
     (oops
       message: "error ~a: ~a"
       irritants: '("creating output directory" "cannot create \"compiler/testdir/testfile\": file exists"))
     ))

  (test-group
    ((create-file "C1.compact" '())
     (custom-check
       (lambda (pass-name x)
         (mkdir "compiler/testdir/C2")
         (chmod "compiler/testdir/C2" 000)
         #t)))
    ((create-file "C2.compact" '())
     (oops
       message: "error ~a: ~a"
       irritants: '("creating output directory" "cannot create \"compiler/testdir/C2/compiler\": permission denied"))
     ))

  (test-group
    ((create-file "C1.compact" '())
     (custom-check
       (lambda (pass-name x)
         (mkdir "compiler/testdir/C2")
         (mkdir "compiler/testdir/C2/compiler")
         (chmod "compiler/testdir/C2/compiler" 000)
         #t))
     )
    ((create-file "C2.compact" '())
     (oops
       message: "error ~a: ~a"
       irritants: '("creating output file" "failed for compiler/testdir/C2/compiler/contract-info.json: permission denied"))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "D.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module M<A> {"
         "  ledger contract_c: A;"
         "  export circuit init(x: A): [] {"
         "    contract_c = x;"
         "  }"
         "  export circuit hello(): [] { return contract_c.read().foo(contract_c.read().barr()); }"
         "}"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "module M1 {"
         "  import M<C>;"
         "  export { C, init, hello };"
         "}"
         "module M2 {"
         "  import M<C>;"
         "  export { init, hello };"
         "}"
         "module M3 {"
         "  contract D {"
         "    circuit foo(x: Bytes<32>): [];"
         "    pure circuit barr(): Bytes<32>;"
         "  }"
         "  import M<D>;"
         "  export { init, hello };"
         "}"
         "import M1;"
         "import M2;"
         "import M3 prefix M3$;"
         "constructor (c: C) { init(disclose(c)); }"
         "export { hello };"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (barr #t () (tbytes 32)))))
            (%contract_c.2
              (1)
              (__compact_Cell
                (tcontract D
                  (foo #f ((tbytes 32)) (ttuple))
                  (barr #t () (tbytes 32))))))
           (constructor ([%c.3 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (barr #t () (tbytes 32)))])
             (seq (call %init.4 %c.3) (tuple))))
         (circuit %init.4 ([%x.5 (tcontract C
                                   (foo #f ((tbytes 32)) (ttuple))
                                   (barr #t () (tbytes 32)))])
              (ttuple)
           (seq (public-ledger %contract_c.1 (0) write %x.5) (tuple)))
         (circuit %hello.6 ()
              (ttuple)
           (contract-call foo
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (barr #t () (tbytes 32))))
             (contract-call barr
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (barr #t () (tbytes 32)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "module M<A> {"
         "  ledger contract_c: A;"
         "  export circuit init(x: A): [] {"
         "    contract_c = disclose(x);"
         "  }"
         "  export circuit hello(): [] { return contract_c.read().foo(contract_c.read().barr()); }"
         "}"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "module M1 {"
         "  import M<C>;"
         "  export { C, init, hello };"
         "}"
         "module M2 {"
         "  contract C {"
         "    pure circuit barr(): Bytes<32>;"
         "    circuit foo(x: Bytes<32>): [];"
         "  }"
         "  import M<C>;"
         "  export { init, hello };"
         "}"
         "import M1;"
         "import M2;"
         "constructor (c: C) { init(c); }"
         "export { hello };"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (barr #t () (tbytes 32))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (barr #t () (tbytes 32)))])
             (seq (call %init.3 %c.2) (tuple))))
         (circuit %init.3 ([%x.4 (tcontract C
                                   (foo #f ((tbytes 32)) (ttuple))
                                   (barr #t () (tbytes 32)))])
              (ttuple)
           (seq (public-ledger %contract_c.1 (0) write %x.4) (tuple)))
         (circuit %hello.5 ()
              (ttuple)
           (contract-call foo
                ((public-ledger %contract_c.1 (0) read)
                 (tcontract C
                   (foo #f ((tbytes 32)) (ttuple))
                   (barr #t () (tbytes 32))))
             (contract-call barr
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (barr #t () (tbytes 32)))))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "witness W(): Bytes<32>;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit bar(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor(c: C) {"
         "  contract_c = c;"
         "}"
         "export circuit foo(): Bytes<32> {"
         "  contract_c.foo(W());"
         "  return contract_c.bar();"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 8 char 14" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter c of the constructor at line 7 char 13" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of = at line 8 char 14")))
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 13" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W at line 1 char 1" ("\n    nature of the disclosure:\n      contract call argument 1 might disclose the witness value"))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "witness W(): Bytes<32>;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit bar(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor(c: C) {"
         "  contract_c = disclose(c);"
         "}"
         "export circuit foo(): Bytes<32> {"
         "  contract_c.foo(disclose(W()));"
         "  return contract_c.bar();"
         "}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (bar #t () (tbytes 32))))))
           (constructor ([%c.2 (tcontract C
                                 (foo #f ((tbytes 32)) (ttuple))
                                 (bar #t () (tbytes 32)))])
             (seq (public-ledger %contract_c.1 (0) write %c.2) (tuple))))
         (witness %W.3 () (tbytes 32))
         (circuit %foo.4 ()
              (tbytes 32)
           (seq
             (contract-call foo
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (bar #t () (tbytes 32))))
               (call %W.3))
             (contract-call bar
                  ((public-ledger %contract_c.1 (0) read)
                   (tcontract C
                     (foo #f ((tbytes 32)) (ttuple))
                     (bar #t () (tbytes 32)))))))))
     ))

  (test-group ; placement of disclose matters for CC calls
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "witness W(): Bytes<32>;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit bar(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor(c: C) {"
         "  contract_c = c;"
         "}"
         "export circuit foo(): Bytes<32> {"
         "  disclose(contract_c.foo(W()));"
         "  return contract_c.bar();"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 8 char 14" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter c of the constructor at line 7 char 13" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of = at line 8 char 14")))
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 11 char 22" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness W at line 1 char 1" ("\n    nature of the disclosure:\n      contract call argument 1 might disclose the witness value"))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: [Boolean, Bytes<32>]): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C {"
         "  circuit foo(x: [Boolean, Bytes<32>]): [];"
         "  pure circuit bar(): Bytes<32>;"
         "}"
         "sealed ledger contract_c: C;"
         "constructor(c: C) {contract_c = disclose(c);}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((ttuple (tboolean) (tbytes 32))) (ttuple))
                  (bar #t () (tbytes 32))))))
           (constructor ([%c.0 (tcontract C
                                 (foo #f ((ttuple (tboolean) (tbytes 32)))
                                   (ttuple))
                                 (bar #t () (tbytes 32)))])
             (seq
               (public-ledger %contract_c.2 (0) write %c.0)
               (tuple))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: [Boolean, Bytes<32>]): [] { return; }"
         "export pure circuit bar(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit bar(): Bytes<32>;"
         "}"
         "sealed ledger contract_c: C;"
         "constructor(c: C) {contract_c = disclose(c);}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 2 char 3" "contract declaration claims the type of circuit ~s argument ~s is ~a, but in the actual contract definition it is ~a" (foo 1 "Bytes<32>" "[Boolean, Bytes<32>]")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit id(x: Boolean): Boolean { return x; }"
         "export circuit idnot(x: Boolean): Boolean { return !x; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit id (x: Boolean): Boolean;"
         "}"
         "module M {"
         "  export contract C {"
         "    circuit id (x: Boolean): Boolean;"
         "    circuit idnot (x: Boolean): Boolean;"
         "  }"
         "}"
         "import M prefix Sub;"
         "sealed ledger c: C;"
         "sealed ledger subc: SubC;"
         "constructor(c1: C, c2: SubC) { c = disclose(c1); subc = disclose(c2);}"
         "circuit foo<A>(c: A): Boolean{"
         "  return c.id(true);"
         "}"
         "export circuit bar(): Boolean {"
         "  return foo<C>(c) && foo<SubC>(subc);"
         "}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%c.1
              (0)
              (__compact_Cell
                (tcontract C (id #f ((tboolean)) (tboolean)))))
            (%subc.2
              (1)
              (__compact_Cell
                (tcontract C
                  (id #f ((tboolean)) (tboolean))
                  (idnot #f ((tboolean)) (tboolean))))))
           (constructor ([%c1.3 (tcontract C
                                  (id #f ((tboolean)) (tboolean)))]
                         [%c2.4 (tcontract C
                                  (id #f ((tboolean)) (tboolean))
                                  (idnot #f ((tboolean)) (tboolean)))])
             (seq
               (public-ledger %c.1 (0) write %c1.3)
               (public-ledger %subc.2 (1) write %c2.4)
               (tuple))))
         (circuit %foo.5 ([%c.6 (tcontract C
                                  (id #f ((tboolean)) (tboolean))
                                  (idnot #f ((tboolean)) (tboolean)))])
              (tboolean)
           (contract-call id
                (%c.6
                 (tcontract C
                   (id #f ((tboolean)) (tboolean))
                   (idnot #f ((tboolean)) (tboolean))))
             #t))
         (circuit %foo.7 ([%c.8 (tcontract C
                                  (id #f ((tboolean)) (tboolean)))])
              (tboolean)
           (contract-call id
                (%c.8 (tcontract C (id #f ((tboolean)) (tboolean))))
             #t))
         (circuit %bar.9 ()
              (tboolean)
           (if (call %foo.7 (public-ledger %c.1 (0) read))
               (call %foo.5 (public-ledger %subc.2 (1) read))
               #f))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit id(x: Boolean): Boolean { return x; }"
         "export circuit idnot(x: Boolean): Boolean { return !x; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit id (x: Boolean): Boolean;"
         "}"
         "sealed ledger c: [C, Uint<16>];"
         "circuit foo(t: [C, Field]): Boolean{"
         "  return t[0].id(true);"
         "}"
         "export circuit bar(): Boolean {"
         "  return foo(c);"
         "}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%c.1
              (0)
              (__compact_Cell
                (ttuple
                  (tcontract C (id #f ((tboolean)) (tboolean)))
                  (tunsigned 65535)))))
           (constructor () (tuple)))
         (circuit %foo.2 ([%t.3 (ttuple
                                  (tcontract C (id #f ((tboolean)) (tboolean)))
                                  (tfield))])
              (tboolean)
           (contract-call id
                ((tuple-ref %t.3 0)
                 (tcontract C (id #f ((tboolean)) (tboolean))))
             #t))
         (circuit %bar.4 ()
              (tboolean)
           (call %foo.2
             (safe-cast (ttuple
                          (tcontract C (id #f ((tboolean)) (tboolean)))
                          (tfield))
                        (ttuple
                          (tcontract C (id #f ((tboolean)) (tboolean)))
                          (tunsigned 65535))
               (public-ledger %c.1 (0) read))))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit id(x: Boolean): Boolean { return x; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit id (x: List<Field>): Boolean;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 3 char 15" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("argument 'x'" "List<Field>")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit id(x: Boolean): Boolean { return x; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit id (x: Boolean): List<Field>;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 3 char 3" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("circuit id return" "List<Field>")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit id(x: Boolean): Boolean { return x; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit id (x: Boolean): List<Field>;"
         "}"
         "circuit foo(c: C): [] {"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 2 char 1" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("circuit 'id' return" "List<Field>")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit id(x: Boolean): Boolean { return x; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit id (x: Boolean): List<Field>;"
         "}"
         "ledger c: C;"
         "export circuit foo(): C {"
         "  return c;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 2 char 1" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("circuit 'id' return" "List<Field>")))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit id(x: Boolean): Boolean { return x; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit id (x: List<Field>): Boolean;"
         "}"
         "ledger c: C;"
         "export circuit foo(): C {"
         "  return c;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 2 char 1" "expected ~a type to be an ordinary Compact type but received ADT type ~a" ("circuit 'id' argument 1" "List<Field>")))
     ))

  (test
    '(
      "module m { export circuit foo(): [] { } }"
      "import m prefix one_;"
      "import m prefix two_;"
      "export { one_foo, two_foo }"
      )
    (output-file "compiler/testdir/compiler/contract-info.json"
      '(
        "{"
        "  \"circuits\": ["
        "    {"
        "      \"name\": \"one_foo\","
        "      \"pure\": true,"
        "      \"arguments\": ["
        "      ],"
        "      \"result-type\": {"
        "        \"type-name\": \"Tuple\","
        "        \"types\": ["
        "        ]"
        "      }"
        "    },"
        "    {"
        "      \"name\": \"two_foo\","
        "      \"pure\": true,"
        "      \"arguments\": ["
        "      ],"
        "      \"result-type\": {"
        "        \"type-name\": \"Tuple\","
        "        \"types\": ["
        "        ]"
        "      }"
        "    }"
        "  ],"
        "  \"witnesses\": ["
        "  ],"
        "  \"contracts\": ["
        "  ]"
        "}"))
    )

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit id(x: Field): Field { return x; }"
         ))
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit id (x: Field): Field;"
         "}"
         "ledger c: C;"
         "export circuit foo(b: Boolean): [] {"
         "  const t = c;"
         "  if (b) t.id(7);"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 8 char 11" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 6 char 20" ("\n    nature of the disclosure:\n      making this contract call might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 8 char 3"))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger C1: C;"
         "ledger C2: C;"
         "export circuit foo(b: Boolean, x: Bytes<32>): [] {"
         "  const k = b ? C1 : C2;"
         "  k.foo(pad(32, ''));"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 8 char 17" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 7 char 20" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 8 char 13")))
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 8 char 22" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 7 char 20" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 8 char 13")))
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 9 char 4" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 7 char 20" ("\n    nature of the disclosure:\n      contract call contract reference might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional expression at line 8 char 13\n      the binding of k at line 8 char 9"))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger C1: C;"
         "ledger C2: C;"
         "export circuit foo(b: Boolean, x: Bytes<32>): [] {"
         "  if (b) C1.foo(pad(32, '')); else C2.foo(pad(32, ''));"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 8 char 12" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 7 char 20" ("\n    nature of the disclosure:\n      making this contract call might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 8 char 3")))
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 8 char 12" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 7 char 20" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 8 char 3")))
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 8 char 38" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 7 char 20" ("\n    nature of the disclosure:\n      making this contract call might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 8 char 3")))
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 8 char 38" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 7 char 20" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional branch at line 8 char 3"))))
     ))

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export pure circuit barr(): Bytes<32> { return pad(32, ''); }"
         ))
     (succeeds))
    ((create-file "C2.compact"
       '(
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger C1: C;"
         "ledger C2: C;"
         "export circuit foo(b: Boolean, x: Bytes<32>): [] {"
         "  const k1 = C1;"
         "  const k2 = C2;"
         "  const k = b ? k1 : k2;"
         "  k.foo(pad(32, ''));"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("C2.compact line 11 char 4" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit foo at line 7 char 20" ("\n    nature of the disclosure:\n      contract call contract reference might disclose the boolean value of the witness value\n    via this path through the program:\n      the conditional expression at line 10 char 13\n      the binding of k at line 10 char 9"))))
     ))
  )

(run-tests drop-ledger-runtime
  (test
    '(
      "struct S { a: Uint<8>, b: Boolean }"
      "ledger fld: S;"
      "constructor(a: Uint<8>, b: Boolean) {"
      "  fld = disclose(S{a, b});"
      "}"
      "circuit bar({ a, b }: S): Uint<8> {"
      "  return b ? a : 0;"
      "}"
      "export circuit foo(): Uint<8> {"
      "  return bar(fld);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%fld.1
             (0)
             (__compact_Cell
               (tstruct S (a (tunsigned 255)) (b (tboolean)))))))
        (circuit %bar.2 ([%__compact_pattern_tmp1.3 (tstruct S
                                                      (a (tunsigned 255))
                                                      (b (tboolean)))])
             (tunsigned 255)
          (let* ([[%a.4 (tunsigned 255)]
                  (elt-ref %__compact_pattern_tmp1.3 a)])
            (let* ([[%b.5 (tboolean)]
                    (elt-ref %__compact_pattern_tmp1.3 b)])
              (if %b.5 %a.4 (safe-cast (tunsigned 255) (tunsigned 0) 0)))))
        (circuit %foo.6 ()
             (tunsigned 255)
          (call %bar.2 (public-ledger %fld.1 (0) read)))))
    )

  (test
    '(
      "export circuit foo(b: Boolean) : Boolean { return b != true; }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%b.1 (tboolean)])
             (tboolean)
          (if (== %b.1 #t) #f #t))))
    )

  (test
    '(
      "export circuit foo(x: Uint<16>) : Boolean { return x <= 30 || x > 1 || x >= 5; }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%x.1 (tunsigned 65535)])
             (tboolean)
          (if (if (if (< (safe-cast (tunsigned 65535) (tunsigned 30) 30) %x.1) #f #t)
                  #t
                  (< (safe-cast (tunsigned 65535) (tunsigned 1) 1) %x.1))
              #t
              (if (< %x.1 (safe-cast (tunsigned 65535) (tunsigned 5) 5)) #f #t)))))
    )

  (test
    '(
      "export circuit foo(x: Uint<16>) : [] { assert((x <= 30 || x > 1 || x >= 5), 'oops'); }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%x.1 (tunsigned 65535)])
             (ttuple)
          (seq
            (assert
              (if (if (if (< (safe-cast (tunsigned 65535) (tunsigned 30) 30) %x.1) #f #t)
                      #t
                      (< (safe-cast (tunsigned 65535) (tunsigned 1) 1) %x.1))
                  #t
                  (if (< %x.1 (safe-cast (tunsigned 65535) (tunsigned 5) 5)) #f #t))
              "oops")
            (tuple)))))
    )
)

(run-tests replace-enums
  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "export circuit foo(x: Names): Boolean {"
      "  return x == Names.bill;"
      "}"
      "export circuit rats(): Boolean {"
      "  return foo(Names.bill);"
      "}"
      "export circuit mice(): Boolean {"
      "  return foo(Names.george);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%x.1 (tunsigned 3)])
             (tboolean)
          (== %x.1 (safe-cast (tunsigned 3) (tunsigned 0) 0)))
        (circuit %rats.2 ()
             (tboolean)
          (call %foo.0 (safe-cast (tunsigned 3) (tunsigned 0) 0)))
        (circuit %mice.3 () (tboolean) (call %foo.0 3))))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "circuit foo<A>(): Boolean {"
      "  return A.bill;"
      "}"
      "export circuit bar(): Boolean {"
      "  return foo<Names>();"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Enum<Names, bill, sally, fred, george>" "Boolean" "circuit foo")))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "circuit foo<A>(): A {"
      "  return A.bill;"
      "}"
      "export circuit bar(): Names {"
      "  return foo<Names>();"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 () (tunsigned 3) (safe-cast (tunsigned 3) (tunsigned 0) 0))
        (circuit %bar.1 () (tunsigned 3) (call %foo.0))))
    )

  (test
    '(
      "enum E { a, b, c }"
      "export circuit baz(arg: E) : Field { return arg as Field; }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.0 ([%arg.1 (tunsigned 2)])
             (tfield)
          (safe-cast (tfield) (tunsigned 2) %arg.1))))
    )
)

(run-tests unroll-loops
  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean { return true; }"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold(foo, true, v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tfield)])
             (tboolean)
          #t)
        (circuit %X$C.3 ([%v.4 (tvector 0 (tfield))])
             (tboolean)
          (let* ([[%t.5 (tboolean)] #t]
                 [[%t.6 (tvector 0 (tfield))] %v.4])
            %t.5))
        (circuit %Y$C.7 ([%v.8 (tvector 1 (tfield))])
             (tboolean)
          (let* ([[%t.9 (tboolean)] #t]
                 [[%t.10 (tvector 1 (tfield))] %v.8])
            (call %foo.0 %t.9 (tuple-ref %t.10 0))))
        (circuit %Z$C.11 ([%v.12 (tvector 2 (tfield))])
             (tboolean)
          (let* ([[%t.13 (tboolean)] #t]
                 [[%t.14 (tvector 2 (tfield))] %v.12])
            (call %foo.0
              (call %foo.0 %t.13 (tuple-ref %t.14 0))
              (tuple-ref %t.14 1))))))
    )

  (test
    `(
       "export circuit C(v: Vector<2, Field>): Boolean {"
       "  return fold((b, x) => x == 0,"
       "              true,"
       "              v);"
       "}"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %C.0 ([%v.1 (tvector 2 (tfield))])
             (tboolean)
          (flet [%circ.2
                 (circuit ([%b.3 (tboolean)] [%x.4 (tfield)])
                      (tboolean)
                   (== %x.4 (safe-cast (tfield) (tunsigned 0) 0)))]
            (let* ([[%t.5 (tboolean)] #t]
                   [[%t.6 (tvector 2 (tfield))] %v.1])
              (call %circ.2
                (call %circ.2 %t.5 (tuple-ref %t.6 0))
                (tuple-ref %t.6 1))))))))

  (test
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold((b, x) => b && x == 0,"
      "                true,"
      "                v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %X$C.0 ([%v.1 (tvector 0 (tfield))])
             (tboolean)
          (flet [%circ.2
                 (circuit ([%b.3 (tboolean)] [%x.4 (tfield)])
                      (tboolean)
                   (if %b.3 (== %x.4 (safe-cast (tfield) (tunsigned 0) 0)) #f))]
            (let* ([[%t.5 (tboolean)] #t]
                   [[%t.6 (tvector 0 (tfield))] %v.1])
              %t.5)))
        (circuit %Y$C.7 ([%v.8 (tvector 1 (tfield))])
             (tboolean)
          (flet [%circ.9
                 (circuit ([%b.10 (tboolean)] [%x.11 (tfield)])
                      (tboolean)
                   (if %b.10 (== %x.11 (safe-cast (tfield) (tunsigned 0) 0)) #f))]
            (let* ([[%t.12 (tboolean)] #t]
                   [[%t.13 (tvector 1 (tfield))] %v.8])
              (call %circ.9 %t.12 (tuple-ref %t.13 0)))))
        (circuit %Z$C.14 ([%v.15 (tvector 2 (tfield))])
             (tboolean)
          (flet [%circ.16
                 (circuit ([%b.17 (tboolean)] [%x.18 (tfield)])
                      (tboolean)
                   (if %b.17 (== %x.18 (safe-cast (tfield) (tunsigned 0) 0)) #f))]
            (let* ([[%t.19 (tboolean)] #t]
                   [[%t.20 (tvector 2 (tfield))] %v.15])
              (call %circ.16
                (call %circ.16 %t.19 (tuple-ref %t.20 0))
                (tuple-ref %t.20 1)))))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "export circuit C(v: Vector<2, Field>): Vector<2, Boolean> {"
      "  return map((x) => disclose(foo(x)), v);"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %C.2 ([%v.3 (tvector 2 (tfield))])
             (tvector 2 (tboolean))
          (flet [%circ.4
                 (circuit ([%x.5 (tfield)]) (tboolean) (call %foo.0 %x.5))]
            (let* ([[%t.6 (tvector 2 (tfield))] %v.3])
              (tuple
                (call %circ.4 (tuple-ref %t.6 0))
                (call %circ.4 (tuple-ref %t.6 1))))))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    return map((x) => disclose(foo(x)), v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %C.2 ([%v.3 (tvector 0 (tfield))])
             (tvector 0 (tboolean))
          (flet [%circ.4
                 (circuit ([%x.5 (tfield)]) (tboolean) (call %foo.0 %x.5))]
            (let* ([[%t.6 (tvector 0 (tfield))] %v.3])
              (tuple))))
        (circuit %C.7 ([%v.8 (tvector 1 (tfield))])
             (tvector 1 (tboolean))
          (flet [%circ.9
                 (circuit ([%x.10 (tfield)]) (tboolean) (call %foo.0 %x.10))]
            (let* ([[%t.11 (tvector 1 (tfield))] %v.8])
              (tuple (call %circ.9 (tuple-ref %t.11 0))))))
        (circuit %C.12 ([%v.13 (tvector 2 (tfield))])
             (tvector 2 (tboolean))
          (flet [%circ.14
                 (circuit ([%x.15 (tfield)]) (tboolean) (call %foo.0 %x.15))]
            (let* ([[%t.16 (tvector 2 (tfield))] %v.13])
              (tuple
                (call %circ.14 (tuple-ref %t.16 0))
                (call %circ.14 (tuple-ref %t.16 1))))))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    const w = v;"
      "    return map((x) => {"
      "                 const y = x + 1;"
      "                 return disclose(foo(y));"
      "               },"
      "               w);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %X$C.2 ([%v.3 (tvector 0 (tfield))])
             (tvector 0 (tboolean))
          (let* ([[%w.4 (tvector 0 (tfield))] %v.3])
            (flet [%circ.5
                   (circuit ([%x.6 (tfield)])
                        (tboolean)
                     (let* ([[%y.7 (tfield)] (+ #f
                                                %x.6
                                                (safe-cast (tfield) (tunsigned 1) 1))])
                       (call %foo.0 %y.7)))]
              (let* ([[%t.8 (tvector 0 (tfield))] %w.4])
                (tuple)))))
        (circuit %Y$C.9 ([%v.10 (tvector 1 (tfield))])
             (tvector 1 (tboolean))
          (let* ([[%w.11 (tvector 1 (tfield))] %v.10])
            (flet [%circ.12
                   (circuit ([%x.13 (tfield)])
                        (tboolean)
                     (let* ([[%y.14 (tfield)] (+ #f
                                                 %x.13
                                                 (safe-cast (tfield) (tunsigned 1) 1))])
                       (call %foo.0 %y.14)))]
              (let* ([[%t.15 (tvector 1 (tfield))] %w.11])
                (tuple
                  (call %circ.12 (tuple-ref %t.15 0)))))))
        (circuit %Z$C.16 ([%v.17 (tvector 2 (tfield))])
             (tvector 2 (tboolean))
          (let* ([[%w.18 (tvector 2 (tfield))] %v.17])
            (flet [%circ.19
                   (circuit ([%x.20 (tfield)])
                        (tboolean)
                     (let* ([[%y.21 (tfield)] (+ #f
                                                 %x.20
                                                 (safe-cast (tfield) (tunsigned 1) 1))])
                       (call %foo.0 %y.21)))]
              (let* ([[%t.22 (tvector 2 (tfield))] %w.18])
                (tuple
                  (call %circ.19 (tuple-ref %t.22 0))
                  (call %circ.19 (tuple-ref %t.22 1)))))))))
    )

  (test
    `(
      "witness foo(b: Boolean, n: Field, s: Bytes<20>) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>, w: Vector<n, Bytes<20>>): Boolean {"
      "    return fold((b, n, s) => disclose(foo(b, n, s)), true, v, w);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%b.1 (tboolean)]
                         [%n.2 (tfield)]
                         [%s.3 (tbytes 20)])
             (tboolean))
        (circuit %C.4 ([%v.5 (tvector 0 (tfield))]
                       [%w.6 (tvector 0 (tbytes 20))])
             (tboolean)
          (flet [%circ.7
                 (circuit ([%b.8 (tboolean)]
                           [%n.9 (tfield)]
                           [%s.10 (tbytes 20)])
                      (tboolean)
                   (call %foo.0 %b.8 %n.9 %s.10))]
            (let* ([[%t.11 (tboolean)] #t]
                   [[%t.12 (tvector 0 (tfield))] %v.5]
                   [[%t.13 (tvector 0 (tbytes 20))] %w.6])
              %t.11)))
        (circuit %C.14 ([%v.15 (tvector 1 (tfield))]
                        [%w.16 (tvector 1 (tbytes 20))])
             (tboolean)
          (flet [%circ.17
                 (circuit ([%b.18 (tboolean)]
                           [%n.19 (tfield)]
                           [%s.20 (tbytes 20)])
                      (tboolean)
                   (call %foo.0 %b.18 %n.19 %s.20))]
            (let* ([[%t.21 (tboolean)] #t]
                   [[%t.22 (tvector 1 (tfield))] %v.15]
                   [[%t.23 (tvector 1 (tbytes 20))] %w.16])
              (call %circ.17
                %t.21
                (tuple-ref %t.22 0)
                (tuple-ref %t.23 0)))))
        (circuit %C.24 ([%v.25 (tvector 2 (tfield))]
                        [%w.26 (tvector 2 (tbytes 20))])
             (tboolean)
          (flet [%circ.27
                 (circuit ([%b.28 (tboolean)]
                           [%n.29 (tfield)]
                           [%s.30 (tbytes 20)])
                      (tboolean)
                   (call %foo.0 %b.28 %n.29 %s.30))]
            (let* ([[%t.31 (tboolean)] #t]
                   [[%t.32 (tvector 2 (tfield))] %v.25]
                   [[%t.33 (tvector 2 (tbytes 20))] %w.26])
              (call %circ.27
                (call %circ.27
                  %t.31
                  (tuple-ref %t.32 0)
                  (tuple-ref %t.33 0))
                (tuple-ref %t.32 1)
                (tuple-ref %t.33 1)))))))
    )

  (test
    `(
      "witness foo(n: Field, s: Bytes<20>) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>, w: Vector<n, Bytes<20>>): Vector<n, Boolean> {"
      "    return map((n, s) => disclose(foo(n, s)), v, w);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%n.1 (tfield)] [%s.2 (tbytes 20)])
             (tboolean))
        (circuit %C.3 ([%v.4 (tvector 0 (tfield))]
                       [%w.5 (tvector 0 (tbytes 20))])
             (tvector 0 (tboolean))
          (flet [%circ.6
                 (circuit ([%n.7 (tfield)] [%s.8 (tbytes 20)])
                      (tboolean)
                   (call %foo.0 %n.7 %s.8))]
            (let* ([[%t.9 (tvector 0 (tfield))] %v.4]
                   [[%t.10 (tvector 0 (tbytes 20))] %w.5])
              (tuple))))
        (circuit %C.11 ([%v.12 (tvector 1 (tfield))]
                        [%w.13 (tvector 1 (tbytes 20))])
             (tvector 1 (tboolean))
          (flet [%circ.14
                 (circuit ([%n.15 (tfield)] [%s.16 (tbytes 20)])
                      (tboolean)
                   (call %foo.0 %n.15 %s.16))]
            (let* ([[%t.17 (tvector 1 (tfield))] %v.12]
                   [[%t.18 (tvector 1 (tbytes 20))] %w.13])
              (tuple
                (call %circ.14
                  (tuple-ref %t.17 0)
                  (tuple-ref %t.18 0))))))
        (circuit %C.19 ([%v.20 (tvector 2 (tfield))]
                        [%w.21 (tvector 2 (tbytes 20))])
             (tvector 2 (tboolean))
          (flet [%circ.22
                 (circuit ([%n.23 (tfield)] [%s.24 (tbytes 20)])
                      (tboolean)
                   (call %foo.0 %n.23 %s.24))]
            (let* ([[%t.25 (tvector 2 (tfield))] %v.20]
                   [[%t.26 (tvector 2 (tbytes 20))] %w.21])
              (tuple
                (call %circ.22 (tuple-ref %t.25 0) (tuple-ref %t.26 0))
                (call %circ.22
                  (tuple-ref %t.25 1)
                  (tuple-ref %t.26 1))))))))
    )

  (test
    '(
      "struct S { x: Field, y: Boolean, z: Bytes<8>, w: Opaque<'string'> };"
      "module M<A, B> {"
      "  ledger F: Vector<2, [A]>;"
      "  export circuit foo(v: Vector<2, B>): Vector<2, [A]> {"
      "    F = map((x: A) => [x], disclose(v));"
      "    return F;"
      "  }"
      "}"
      "import M<Vector<1, Field>, [Uint<64>]> prefix M1;"
      "import M<Vector<1, Uint<64>>, Vector<1, Uint<32>>> prefix M2;"
      "import M<[Uint<32>], Vector<1, Uint<16>>> prefix M3;"
      "import M<[Uint<16>], [Uint<8>]> prefix M4;"
      "import M<S, S> prefix M5;"
      "export { M1foo, M2foo, M3foo, M4foo, M5foo };"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%F.1
             (0)
             (__compact_Cell (tvector 2 (ttuple (tvector 1 (tfield))))))
           (%F.2
             (1)
             (__compact_Cell
               (tvector
                 2
                 (ttuple (tvector 1 (tunsigned 18446744073709551615))))))
           (%F.3
             (2)
             (__compact_Cell
               (tvector 2 (ttuple (ttuple (tunsigned 4294967295))))))
           (%F.4
             (3)
             (__compact_Cell
               (tvector 2 (ttuple (ttuple (tunsigned 65535))))))
           (%F.5
             (4)
             (__compact_Cell
               (tvector
                 2
                 (ttuple
                   (tstruct S
                     (x (tfield))
                     (y (tboolean))
                     (z (tbytes 8))
                     (w (topaque "string")))))))))
        (circuit %foo.6 ([%v.7 (tvector
                                 2
                                 (ttuple (tunsigned 18446744073709551615)))])
             (tvector 2 (ttuple (tvector 1 (tfield))))
          (seq
            (let* ([[%tmp.8 (tvector 2 (ttuple (tvector 1 (tfield))))]
                    (flet [%circ.9
                           (circuit ([%x.10 (tvector 1 (tfield))])
                                (ttuple (tvector 1 (tfield)))
                             (tuple %x.10))]
                      (let* ([[%t.11 (tvector
                                       2
                                       (ttuple
                                         (tunsigned 18446744073709551615)))]
                              %v.7])
                        (tuple
                          (call %circ.9
                            (safe-cast (tvector 1 (tfield))
                                       (ttuple (tunsigned 18446744073709551615))
                              (tuple-ref %t.11 0)))
                          (call %circ.9
                            (safe-cast (tvector 1 (tfield))
                                       (ttuple (tunsigned 18446744073709551615))
                              (tuple-ref %t.11 1))))))])
              (public-ledger %F.1 (0) write %tmp.8))
            (public-ledger %F.1 (0) read)))
        (circuit %foo.12 ([%v.13 (tvector
                                   2
                                   (tvector 1 (tunsigned 4294967295)))])
             (tvector
               2
               (ttuple (tvector 1 (tunsigned 18446744073709551615))))
          (seq
            (let* ([[%tmp.14 (tvector
                               2
                               (ttuple
                                 (tvector
                                   1
                                   (tunsigned 18446744073709551615))))]
                    (flet [%circ.15
                           (circuit ([%x.16 (tvector
                                              1
                                              (tunsigned
                                                18446744073709551615))])
                                (ttuple
                                  (tvector 1 (tunsigned 18446744073709551615)))
                             (tuple %x.16))]
                      (let* ([[%t.17 (tvector
                                       2
                                       (tvector 1 (tunsigned 4294967295)))]
                              %v.13])
                        (tuple
                          (call %circ.15
                            (safe-cast (tvector
                                         1
                                         (tunsigned 18446744073709551615))
                                       (tvector 1 (tunsigned 4294967295))
                              (tuple-ref %t.17 0)))
                          (call %circ.15
                            (safe-cast (tvector
                                         1
                                         (tunsigned 18446744073709551615))
                                       (tvector 1 (tunsigned 4294967295))
                              (tuple-ref %t.17 1))))))])
              (public-ledger %F.2 (1) write %tmp.14))
            (public-ledger %F.2 (1) read)))
        (circuit %foo.18 ([%v.19 (tvector
                                   2
                                   (tvector 1 (tunsigned 65535)))])
             (tvector 2 (ttuple (ttuple (tunsigned 4294967295))))
          (seq
            (let* ([[%tmp.20 (tvector
                               2
                               (ttuple (ttuple (tunsigned 4294967295))))]
                    (flet [%circ.21
                           (circuit ([%x.22 (ttuple (tunsigned 4294967295))])
                                (ttuple (ttuple (tunsigned 4294967295)))
                             (tuple %x.22))]
                      (let* ([[%t.23 (tvector 2 (tvector 1 (tunsigned 65535)))]
                              %v.19])
                        (tuple
                          (call %circ.21
                            (safe-cast (ttuple (tunsigned 4294967295))
                                       (tvector 1 (tunsigned 65535))
                              (tuple-ref %t.23 0)))
                          (call %circ.21
                            (safe-cast (ttuple (tunsigned 4294967295))
                                       (tvector 1 (tunsigned 65535))
                              (tuple-ref %t.23 1))))))])
              (public-ledger %F.3 (2) write %tmp.20))
            (public-ledger %F.3 (2) read)))
        (circuit %foo.24 ([%v.25 (tvector
                                   2
                                   (ttuple (tunsigned 255)))])
             (tvector 2 (ttuple (ttuple (tunsigned 65535))))
          (seq
            (let* ([[%tmp.26 (tvector
                               2
                               (ttuple (ttuple (tunsigned 65535))))]
                    (flet [%circ.27
                           (circuit ([%x.28 (ttuple (tunsigned 65535))])
                                (ttuple (ttuple (tunsigned 65535)))
                             (tuple %x.28))]
                      (let* ([[%t.29 (tvector 2 (ttuple (tunsigned 255)))]
                              %v.25])
                        (tuple
                          (call %circ.27
                            (safe-cast (ttuple (tunsigned 65535))
                                       (ttuple (tunsigned 255))
                              (tuple-ref %t.29 0)))
                          (call %circ.27
                            (safe-cast (ttuple (tunsigned 65535))
                                       (ttuple (tunsigned 255))
                              (tuple-ref %t.29 1))))))])
              (public-ledger %F.4 (3) write %tmp.26))
            (public-ledger %F.4 (3) read)))
        (circuit %foo.30 ([%v.31 (tvector
                                   2
                                   (tstruct S
                                     (x (tfield))
                                     (y (tboolean))
                                     (z (tbytes 8))
                                     (w (topaque "string"))))])
             (tvector
               2
               (ttuple
                 (tstruct S
                   (x (tfield))
                   (y (tboolean))
                   (z (tbytes 8))
                   (w (topaque "string")))))
          (seq
            (let* ([[%tmp.32 (tvector
                               2
                               (ttuple
                                 (tstruct S
                                   (x (tfield))
                                   (y (tboolean))
                                   (z (tbytes 8))
                                   (w (topaque "string")))))]
                    (flet [%circ.33
                           (circuit ([%x.34 (tstruct S
                                              (x (tfield))
                                              (y (tboolean))
                                              (z (tbytes 8))
                                              (w (topaque "string")))])
                                (ttuple
                                  (tstruct S
                                    (x (tfield))
                                    (y (tboolean))
                                    (z (tbytes 8))
                                    (w (topaque "string"))))
                             (tuple %x.34))]
                      (let* ([[%t.35 (tvector
                                       2
                                       (tstruct S
                                         (x (tfield))
                                         (y (tboolean))
                                         (z (tbytes 8))
                                         (w (topaque "string"))))]
                              %v.31])
                        (tuple
                          (call %circ.33 (tuple-ref %t.35 0))
                          (call %circ.33 (tuple-ref %t.35 1)))))])
              (public-ledger %F.5 (4) write %tmp.32))
            (public-ledger %F.5 (4) read)))))
    )

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export circuit bar(): Bytes<32> { return pad(32, ''); }"
         )
       )
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit bar(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "ledger F: Vector<2, [C]>;"
         "export circuit foo(): [] {"
         "  F = map((x: C) => [x], [contract_c, contract_c]);"
         "}"
         ))
     (returns
       (program
         (kernel-declaration (%kernel.0 () (Kernel)))
         (public-ledger-declaration
           ((%contract_c.1
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tbytes 32)) (ttuple))
                  (bar #t () (tbytes 32)))))
            (%F.2
              (1)
              (__compact_Cell
                (tvector
                  2
                  (ttuple
                    (tcontract C
                      (foo #f ((tbytes 32)) (ttuple))
                      (bar #t () (tbytes 32)))))))))
         (circuit %foo.3 ()
              (ttuple)
           (seq
             (let* ([[%tmp.4 (tvector
                               2
                               (ttuple
                                 (tcontract C
                                   (foo #f ((tbytes 32)) (ttuple))
                                   (bar #t () (tbytes 32)))))]
                     (flet [%circ.5
                            (circuit ([%x.6 (tcontract C
                                              (foo #f ((tbytes 32)) (ttuple))
                                              (bar #t () (tbytes 32)))])
                                 (ttuple
                                   (tcontract C
                                     (foo #f ((tbytes 32)) (ttuple))
                                     (bar #t () (tbytes 32))))
                              (tuple %x.6))]
                       (let* ([[%t.7 (ttuple
                                       (tcontract C
                                         (foo #f ((tbytes 32)) (ttuple))
                                         (bar #t () (tbytes 32)))
                                       (tcontract C
                                         (foo #f ((tbytes 32)) (ttuple))
                                         (bar #t () (tbytes 32))))]
                               (tuple
                                 (public-ledger %contract_c.1 (0) read)
                                 (public-ledger %contract_c.1 (0) read))])
                         (tuple
                           (call %circ.5 (tuple-ref %t.7 0))
                           (call %circ.5 (tuple-ref %t.7 1)))))])
               (public-ledger %F.2 (1) write %tmp.4))
             (tuple)))))
     ))
)

(run-tests inline-circuits
  (test
    `(
       "export circuit C(v: Vector<2, Field>): Boolean {"
       "  return fold((b, x) => x == 0,"
       "              true,"
       "              v);}"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %C.0 ([%v.1 (tvector 2 (tfield))])
             (tboolean)
          (let* ([[%t.2 (tboolean)] #t]
                 [[%t.3 (tvector 2 (tfield))] %v.1])
            (let* ([[%b.4 (tboolean)] (let* ([[%b.5 (tboolean)] %t.2]
                                             [[%x.6 (tfield)] (tuple-ref
                                                                %t.3
                                                                0)])
                                        (== %x.6 (safe-cast (tfield) (tunsigned 0) 0)))]
                   [[%x.7 (tfield)] (tuple-ref %t.3 1)])
              (== %x.7 (safe-cast (tfield) (tunsigned 0) 0))))))))

  (test
    `(
       "export circuit C(v: Vector<2, Uint<16>>): Boolean {"
       "  return fold((b, x) => x <= 0,"
       "              true,"
       "              v);}"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %C.0 ([%v.1 (tvector 2 (tunsigned 65535))])
             (tboolean)
          (let* ([[%t.2 (tboolean)] #t]
                 [[%t.3 (tvector 2 (tunsigned 65535))] %v.1])
            (let* ([[%b.4 (tboolean)] (let* ([[%b.5 (tboolean)] %t.2]
                                             [[%x.6 (tunsigned 65535)] (tuple-ref
                                                                         %t.3
                                                                         0)])
                                        (if (< (safe-cast (tunsigned 65535) (tunsigned 0) 0) %x.6)
                                            #f
                                            #t))]
                   [[%x.7 (tunsigned 65535)] (tuple-ref %t.3 1)])
              (if (< (safe-cast (tunsigned 65535) (tunsigned 0) 0) %x.7) #f #t))))))
    )

  (test
    `(
      "witness foo(b: Boolean, x: Field): Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold((b, x) => disclose(foo(b, x)), true, v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%b.1 (tboolean)] [%x.2 (tfield)])
             (tboolean))
        (circuit %C.3 ([%v.4 (tvector 0 (tfield))])
             (tboolean)
          (let* ([[%t.5 (tboolean)] #t]
                 [[%t.6 (tvector 0 (tfield))] %v.4])
            %t.5))
        (circuit %C.7 ([%v.8 (tvector 1 (tfield))])
             (tboolean)
          (let* ([[%t.9 (tboolean)] #t]
                 [[%t.10 (tvector 1 (tfield))] %v.8])
            (let* ([[%b.11 (tboolean)] %t.9]
                   [[%x.12 (tfield)] (tuple-ref %t.10 0)])
              (call %foo.0 %b.11 %x.12))))
        (circuit %C.13 ([%v.14 (tvector 2 (tfield))])
             (tboolean)
          (let* ([[%t.15 (tboolean)] #t]
                 [[%t.16 (tvector 2 (tfield))] %v.14])
            (let* ([[%b.17 (tboolean)]
                    (let* ([[%b.18 (tboolean)] %t.15]
                           [[%x.19 (tfield)] (tuple-ref %t.16 0)])
                      (call %foo.0 %b.18 %x.19))]
                   [[%x.20 (tfield)] (tuple-ref %t.16 1)])
              (call %foo.0 %b.17 %x.20))))))
    )

  (test
    `(
      "circuit foo(b: Boolean, x: Field): Boolean { return b && x == 0; }"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold(foo, true, v);"
      "  }"
      "}"
      "import M<0>;"
      "import M<1>;"
      "import M<2>;"
      "export circuit bar(v0: Vector<0, Field>, v1: Vector<1, Field>, v2: Vector<2, Field>) : [] {"
      "  assert(C(v0), 'oops 0');"
      "  assert(C(v1), 'oops 1');"
      "  assert(C(v2), 'oops 2');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %bar.0 ([%v0.1 (tvector 0 (tfield))]
                         [%v1.2 (tvector 1 (tfield))]
                         [%v2.3 (tvector 2 (tfield))])
             (ttuple)
          (seq
            (assert
              (let* ([[%v.4 (tvector 0 (tfield))] %v0.1])
                (let* ([[%t.5 (tboolean)] #t]
                       [[%t.6 (tvector 0 (tfield))] %v.4])
                  %t.5))
              "oops 0")
            (assert
              (let* ([[%v.7 (tvector 1 (tfield))] %v1.2])
                (let* ([[%t.8 (tboolean)] #t]
                       [[%t.9 (tvector 1 (tfield))] %v.7])
                  (let* ([[%b.10 (tboolean)] %t.8]
                         [[%x.11 (tfield)] (tuple-ref %t.9 0)])
                    (if %b.10 (== %x.11 (safe-cast (tfield) (tunsigned 0) 0)) #f))))
              "oops 1")
            (assert
              (let* ([[%v.12 (tvector 2 (tfield))] %v2.3])
                (let* ([[%t.13 (tboolean)] #t]
                       [[%t.14 (tvector 2 (tfield))] %v.12])
                  (let* ([[%b.15 (tboolean)] (let* ([[%b.16 (tboolean)] %t.13]
                                                    [[%x.17 (tfield)] (tuple-ref
                                                                        %t.14
                                                                        0)])
                                               (if %b.16
                                                   (== %x.17
                                                       (safe-cast (tfield) (tunsigned 0) 0))
                                                   #f))]
                         [[%x.18 (tfield)] (tuple-ref %t.14 1)])
                    (if %b.15 (== %x.18 (safe-cast (tfield) (tunsigned 0) 0)) #f))))
              "oops 2")
            (tuple)))))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold((b, x) => b && x == 0,"
      "                true,"
      "                v);"
      "  }"
      "}"
      "import M<0>;"
      "import M<1>;"
      "import M<2>;"
      "export circuit bar1() : [] {"
      "  assert(C([]), 'oops 0');"
      "  assert(C([7]), 'oops 1');"
      "  assert(C([23, 57]), 'oops 2');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %bar1.0 ()
             (ttuple)
          (seq
            (assert
              (let* ([[%v.1 (tvector 0 (tfield))] (tuple)])
                (let* ([[%t.2 (tboolean)] #t]
                       [[%t.3 (tvector 0 (tfield))] %v.1])
                  %t.2))
              "oops 0")
            (assert
              (let* ([[%v.4 (tvector 1 (tfield))]
                      (safe-cast (tvector 1 (tfield))
                                 (ttuple (tunsigned 7))
                        (tuple 7))])
                (let* ([[%t.5 (tboolean)] #t]
                       [[%t.6 (tvector 1 (tfield))] %v.4])
                  (let* ([[%b.7 (tboolean)] %t.5]
                         [[%x.8 (tfield)] (tuple-ref %t.6 0)])
                    (if %b.7 (== %x.8 (safe-cast (tfield) (tunsigned 0) 0)) #f))))
              "oops 1")
            (assert
              (let* ([[%v.9 (tvector 2 (tfield))]
                      (safe-cast (tvector 2 (tfield))
                                 (ttuple (tunsigned 23) (tunsigned 57))
                        (tuple 23 57))])
                (let* ([[%t.10 (tboolean)] #t]
                       [[%t.11 (tvector 2 (tfield))] %v.9])
                  (let* ([[%b.12 (tboolean)]
                          (let* ([[%b.13 (tboolean)] %t.10]
                                 [[%x.14 (tfield)] (tuple-ref %t.11 0)])
                            (if %b.13
                                (== %x.14 (safe-cast (tfield) (tunsigned 0) 0))
                                #f))]
                         [[%x.15 (tfield)] (tuple-ref %t.11 1)])
                    (if %b.12
                        (== %x.15 (safe-cast (tfield) (tunsigned 0) 0))
                        #f))))
              "oops 2")
            (tuple)))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    return map(foo, v);"
      "  }"
      "}"
      "import M<2>;"
      "export circuit bar(b: Boolean, n: Field) : Vector<2, Boolean> {"
      "  if (!b) assert(n == 0, 'oops');"
      "  return disclose(C([3, 7]));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %bar.2 ([%b.3 (tboolean)] [%n.4 (tfield)])
             (tvector 2 (tboolean))
          (seq
            (if (if %b.3 #f #t)
                (assert (== %n.4 (safe-cast (tfield) (tunsigned 0) 0)) "oops")
                (tuple))
            (let* ([[%v.5 (tvector 2 (tfield))]
                    (safe-cast (tvector 2 (tfield))
                               (ttuple (tunsigned 3) (tunsigned 7))
                      (tuple 3 7))])
              (let* ([[%t.6 (tvector 2 (tfield))] %v.5])
                (tuple
                  (call %foo.0 (tuple-ref %t.6 0))
                  (call %foo.0 (tuple-ref %t.6 1)))))))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    const w = v;"
      "    return map((x) => {"
      "                 const y = x + 1;"
      "                 return disclose(foo(y));"
      "               },"
      "               w);"
      "  }"
      "}"
      "import M<2>;"
      "export circuit bar() : Vector<2, Boolean> {"
      "  return C([3, 7]);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %bar.2 ()
             (tvector 2 (tboolean))
          (let* ([[%v.3 (tvector 2 (tfield))]
                  (safe-cast (tvector 2 (tfield))
                             (ttuple (tunsigned 3) (tunsigned 7))
                    (tuple 3 7))])
            (let* ([[%w.4 (tvector 2 (tfield))] %v.3])
              (let* ([[%t.5 (tvector 2 (tfield))] %w.4])
                (tuple
                  (let* ([[%x.6 (tfield)] (tuple-ref %t.5 0)])
                    (let* ([[%y.7 (tfield)]
                            (+ #f %x.6 (safe-cast (tfield) (tunsigned 1) 1))])
                      (call %foo.0 %y.7)))
                  (let* ([[%x.8 (tfield)] (tuple-ref %t.5 1)])
                    (let* ([[%y.9 (tfield)]
                            (+ #f %x.8 (safe-cast (tfield) (tunsigned 1) 1))])
                      (call %foo.0 %y.9))))))))))
    )

  (test
    `(
      "witness foo(b: Boolean, n: Field, s: Bytes<20>) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>, w: Vector<n, Bytes<20>>): Boolean {"
      "    return fold((b, n, s) => disclose(foo(b, n, s)), true, v, w);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%b.1 (tboolean)]
                         [%n.2 (tfield)]
                         [%s.3 (tbytes 20)])
             (tboolean))
        (circuit %C.4 ([%v.5 (tvector 0 (tfield))]
                       [%w.6 (tvector 0 (tbytes 20))])
             (tboolean)
          (let* ([[%t.7 (tboolean)] #t]
                 [[%t.8 (tvector 0 (tfield))] %v.5]
                 [[%t.9 (tvector 0 (tbytes 20))] %w.6])
            %t.7))
        (circuit %C.10 ([%v.11 (tvector 1 (tfield))]
                        [%w.12 (tvector 1 (tbytes 20))])
             (tboolean)
          (let* ([[%t.13 (tboolean)] #t]
                 [[%t.14 (tvector 1 (tfield))] %v.11]
                 [[%t.15 (tvector 1 (tbytes 20))] %w.12])
            (let* ([[%b.16 (tboolean)] %t.13]
                   [[%n.17 (tfield)] (tuple-ref %t.14 0)]
                   [[%s.18 (tbytes 20)] (tuple-ref %t.15 0)])
              (call %foo.0 %b.16 %n.17 %s.18))))
        (circuit %C.19 ([%v.20 (tvector 2 (tfield))]
                        [%w.21 (tvector 2 (tbytes 20))])
             (tboolean)
          (let* ([[%t.22 (tboolean)] #t]
                 [[%t.23 (tvector 2 (tfield))] %v.20]
                 [[%t.24 (tvector 2 (tbytes 20))] %w.21])
            (let* ([[%b.25 (tboolean)]
                    (let* ([[%b.26 (tboolean)] %t.22]
                           [[%n.27 (tfield)] (tuple-ref %t.23 0)]
                           [[%s.28 (tbytes 20)] (tuple-ref %t.24 0)])
                      (call %foo.0 %b.26 %n.27 %s.28))]
                   [[%n.29 (tfield)] (tuple-ref %t.23 1)]
                   [[%s.30 (tbytes 20)] (tuple-ref %t.24 1)])
              (call %foo.0 %b.25 %n.29 %s.30))))))
    )

  (test
    `(
      "witness foo(n: Field, s: Bytes<20>) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>, w: Vector<n, Bytes<20>>): Vector<n, Boolean> {"
      "    return map((n, s) => disclose(foo(n, s)), v, w);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%n.1 (tfield)] [%s.2 (tbytes 20)])
             (tboolean))
        (circuit %C.3 ([%v.4 (tvector 0 (tfield))]
                       [%w.5 (tvector 0 (tbytes 20))])
             (tvector 0 (tboolean))
          (let* ([[%t.6 (tvector 0 (tfield))] %v.4]
                 [[%t.7 (tvector 0 (tbytes 20))] %w.5])
            (tuple)))
        (circuit %C.8 ([%v.9 (tvector 1 (tfield))]
                       [%w.10 (tvector 1 (tbytes 20))])
             (tvector 1 (tboolean))
          (let* ([[%t.11 (tvector 1 (tfield))] %v.9]
                 [[%t.12 (tvector 1 (tbytes 20))] %w.10])
            (tuple
              (let* ([[%n.13 (tfield)] (tuple-ref %t.11 0)]
                     [[%s.14 (tbytes 20)] (tuple-ref %t.12 0)])
                (call %foo.0 %n.13 %s.14)))))
        (circuit %C.15 ([%v.16 (tvector 2 (tfield))]
                        [%w.17 (tvector 2 (tbytes 20))])
             (tvector 2 (tboolean))
          (let* ([[%t.18 (tvector 2 (tfield))] %v.16]
                 [[%t.19 (tvector 2 (tbytes 20))] %w.17])
            (tuple
              (let* ([[%n.20 (tfield)] (tuple-ref %t.18 0)]
                     [[%s.21 (tbytes 20)] (tuple-ref %t.19 0)])
                (call %foo.0 %n.20 %s.21))
              (let* ([[%n.22 (tfield)] (tuple-ref %t.18 1)]
                     [[%s.23 (tbytes 20)] (tuple-ref %t.19 1)])
                (call %foo.0 %n.22 %s.23)))))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "export circuit C(v: Vector<3, Field>, b: Boolean): Vector<3, Boolean> {"
      "  return map((x) => b && disclose(foo(x + 1)),"
      "             v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ([%n.1 (tfield)]) (tboolean))
        (circuit %C.2 ([%v.3 (tvector 3 (tfield))]
                       [%b.4 (tboolean)])
             (tvector 3 (tboolean))
          (let* ([[%t.5 (tvector 3 (tfield))] %v.3])
            (tuple
              (let* ([[%x.6 (tfield)] (tuple-ref %t.5 0)])
                (if %b.4 (call %foo.0 (+ #f %x.6 (safe-cast (tfield) (tunsigned 1) 1))) #f))
              (let* ([[%x.7 (tfield)] (tuple-ref %t.5 1)])
                (if %b.4 (call %foo.0 (+ #f %x.7 (safe-cast (tfield) (tunsigned 1) 1))) #f))
              (let* ([[%x.8 (tfield)] (tuple-ref %t.5 2)])
                (if %b.4
                    (call %foo.0 (+ #f %x.8 (safe-cast (tfield) (tunsigned 1) 1)))
                    #f)))))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return disclose(W<B>(S(q))); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "// export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "// export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "// export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 ([%x.1 (tfield)]) (tboolean))
        (circuit %foo1.2 ([%x.3 (tfield)])
             (tboolean)
          (let* ([[%q.4 (tfield)] %x.3])
            (call %W.0 (let* ([[%q.5 (tfield)] %q.4]) %q.5))))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return disclose(W<B>(S(q))); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "// export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "// export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "// export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 ([%x.1 (tfield)]) (tfield))
        (circuit %foo2.2 ([%x.3 (tfield)])
             (tfield)
          (let* ([[%q.4 (tfield)] %x.3])
            (call %W.0 (let* ([[%q.5 (tfield)] %q.4]) %q.5))))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return disclose(W<B>(S(q))); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "// export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "// export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "// export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 ([%x.1 (tboolean)]) (tboolean))
        (circuit %foo3.2 ([%x.3 (tboolean)])
             (tboolean)
          (let* ([[%q.4 (tboolean)] %x.3])
            (call %W.0 (let* ([[%q.5 (tboolean)] %q.4]) %q.5))))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return disclose(W<B>(S(q))); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "// export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "// export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "// export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 ([%x.1 (tboolean)]) (tfield))
        (circuit %foo4.2 ([%x.3 (tboolean)])
             (tfield)
          (let* ([[%q.4 (tboolean)] %x.3])
            (call %W.0 (let* ([[%q.5 (tboolean)] %q.4]) %q.5))))))
    )

  (test
    '(
       "export circuit foo2(arg: Bytes<20>) : Field { return arg as Field; }"
    )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo2.0 ([%arg.1 (tbytes 20)])
             (tfield)
          (bytes->field 20 %arg.1)))))

    (test
    '(
       "export circuit foo(arg: Field) : Bytes<20> { return arg as Bytes<20>; }"
     )
     (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%arg.1 (tfield)])
             (tbytes 20)
          (field->bytes 20 %arg.1))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(1).lookup(2);"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(3); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%field1.1 (0) (Map (tfield) (Map (tfield) (tboolean))))))
        (circuit %foo.2 ([%n.3 (tfield)])
             (tboolean)
          (let* ([[%tmp.4 (tfield)] (safe-cast (tfield) (tunsigned 2) 2)])
            (let* ([[%tmp.0 (tfield)] (safe-cast (tfield) (tunsigned 1) 1)])
              (public-ledger %field1.1 (0 ((tfield) %tmp.0)) lookup
                %tmp.4))))
        (circuit %call_foo.5 ([%i.6 (tfield)])
             (tboolean)
          (let* ([[%n.7 (tfield)] (safe-cast (tfield) (tunsigned 3) 3)])
            (let* ([[%tmp.8 (tfield)] (safe-cast (tfield) (tunsigned 2) 2)])
              (let* ([[%tmp.9 (tfield)] (safe-cast (tfield) (tunsigned 1) 1)])
                (public-ledger %field1.1 (0 ((tfield) %tmp.9)) lookup
                  %tmp.8)))))))
    )
)

(run-tests discard-useless-code
  (test
    '(
      "circuit bar(x: Field, y: Field): [Field, Field] {"
      "  return [x + x, y + y];"
      "}"
      "export circuit foo(x: Field): [Field, Field] {"
      "  return bar(7, x);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%x.1 (tfield)])
             (ttuple (tfield) (tfield))
          (tuple 14 (+ #f %x.1 %x.1)))))
    )

  (test
    '(
      "ledger a: Vector<3, Field>;"
      "export circuit foo(v: Vector<5, Field>): Vector<3, Field> {"
      "  for (const k of 0..1) {"
      "    a = map((x, y) => x + disclose(y), a, slice<3>(v, k));"
      "  }"
      "  return a;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%a.1 (0) (__compact_Cell (tvector 3 (tfield))))))
        (circuit %foo.2 ([%v.3 (tvector 5 (tfield))])
             (tvector 3 (tfield))
          (seq
            (let* ([[%tmp.4 (tvector 3 (tfield))]
                    (let* ([[%t.5 (tvector 3 (tfield))]
                            (public-ledger %a.1 (0) read)]
                           [[%t.6 (tvector 3 (tfield))]
                            (tuple
                              (tuple-ref %v.3 0)
                              (tuple-ref %v.3 1)
                              (tuple-ref %v.3 2))])
                      (tuple
                        (let* ([[%x.7 (tfield)] (tuple-ref %t.5 0)]
                               [[%y.8 (tfield)] (tuple-ref %t.6 0)])
                          (+ #f %x.7 %y.8))
                        (let* ([[%x.9 (tfield)] (tuple-ref %t.5 1)]
                               [[%y.10 (tfield)] (tuple-ref %t.6 1)])
                          (+ #f %x.9 %y.10))
                        (let* ([[%x.11 (tfield)] (tuple-ref %t.5 2)]
                               [[%y.12 (tfield)] (tuple-ref %t.6 2)])
                          (+ #f %x.11 %y.12))))])
              (public-ledger %a.1 (0) write %tmp.4))
            (public-ledger %a.1 (0) read)))))
    )

  (test
    '(
      "ledger a: Vector<3, Field>;"
      "export circuit foo(v: Vector<5, Field>): Vector<3, Field> {"
      "  for (const k of 0..1) {"
      "    a = map((x, y) => x + disclose(y), a, slice<3>(v, k as Uint<0..6>));"
      "  }"
      "  return a;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%a.1 (0) (__compact_Cell (tvector 3 (tfield))))))
        (circuit %foo.2 ([%v.3 (tvector 5 (tfield))])
             (tvector 3 (tfield))
          (seq
            (let* ([[%tmp.4 (tvector 3 (tfield))]
                    (let* ([[%t.5 (tvector 3 (tfield))]
                            (public-ledger %a.1 (0) read)]
                           [[%t.6 (tvector 3 (tfield))]
                            (tuple
                              (tuple-ref %v.3 0)
                              (tuple-ref %v.3 1)
                              (tuple-ref %v.3 2))])
                      (tuple
                        (let* ([[%x.7 (tfield)] (tuple-ref %t.5 0)]
                               [[%y.8 (tfield)] (tuple-ref %t.6 0)])
                          (+ #f %x.7 %y.8))
                        (let* ([[%x.9 (tfield)] (tuple-ref %t.5 1)]
                               [[%y.10 (tfield)] (tuple-ref %t.6 1)])
                          (+ #f %x.9 %y.10))
                        (let* ([[%x.11 (tfield)] (tuple-ref %t.5 2)]
                               [[%y.12 (tfield)] (tuple-ref %t.6 2)])
                          (+ #f %x.11 %y.12))))])
              (public-ledger %a.1 (0) write %tmp.4))
            (public-ledger %a.1 (0) read)))))
    )

  (test
    '(
      "ledger a: Vector<1, Uint<8>>;"
      "export circuit foo(v: Vector<5, Uint<8>>): Vector<1, Uint<8>> {"
      "  for (const k of 0..2) {"
      "    a = disclose(slice<1>(v, k));"
      "  }"
      "  return a;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.13 () (Kernel)))
        (public-ledger-declaration
          ((%a.0 (0) (__compact_Cell (tvector 1 (tunsigned 255))))))
        (circuit %foo.14 ([%v.8 (tvector 5 (tunsigned 255))])
             (tvector 1 (tunsigned 255))
          (seq
            (let* ([[%tmp.6 (tvector 1 (tunsigned 255))]
                    (tuple (tuple-ref %v.8 0))])
              (public-ledger %a.0 (0) write %tmp.6))
            (let* ([[%tmp.10 (tvector 1 (tunsigned 255))]
                    (tuple (tuple-ref %v.8 1))])
              (public-ledger %a.0 (0) write %tmp.10))
            (public-ledger %a.0 (0) read)))))
    )

  (test
    '(
      "ledger a: Vector<3, Uint<8>>;"
      "export circuit foo(v: Vector<5, Uint<8>>): Vector<3, Uint<8>> {"
      "  for (const k of 0..2) {"
      "    a = map((x, y) => x + disclose(y) as Uint<8>, a, slice<3>(v, k));"
      "  }"
      "  return a;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%a.1 (0) (__compact_Cell (tvector 3 (tunsigned 255))))))
        (circuit %foo.2 ([%v.3 (tvector 5 (tunsigned 255))])
             (tvector 3 (tunsigned 255))
          (seq
            (let* ([[%tmp.4 (tvector 3 (tunsigned 255))]
                    (let* ([[%t.5 (tvector 3 (tunsigned 255))]
                            (public-ledger %a.1 (0) read)]
                           [[%t.6 (tvector 3 (tunsigned 255))]
                            (tuple
                              (tuple-ref %v.3 0)
                              (tuple-ref %v.3 1)
                              (tuple-ref %v.3 2))])
                      (tuple
                        (let* ([[%x.7 (tunsigned 255)] (tuple-ref %t.5 0)]
                               [[%y.8 (tunsigned 255)] (tuple-ref %t.6 0)])
                          (downcast-unsigned 255 (+ 9 %x.7 %y.8)))
                        (let* ([[%x.9 (tunsigned 255)] (tuple-ref %t.5 1)]
                               [[%y.10 (tunsigned 255)] (tuple-ref %t.6 1)])
                          (downcast-unsigned 255 (+ 9 %x.9 %y.10)))
                        (let* ([[%x.11 (tunsigned 255)] (tuple-ref %t.5 2)]
                               [[%y.12 (tunsigned 255)] (tuple-ref %t.6 2)])
                          (downcast-unsigned 255 (+ 9 %x.11 %y.12)))))])
              (public-ledger %a.1 (0) write %tmp.4))
            (let* ([[%tmp.13 (tvector 3 (tunsigned 255))]
                    (let* ([[%t.14 (tvector 3 (tunsigned 255))]
                            (public-ledger %a.1 (0) read)]
                           [[%t.15 (tvector 3 (tunsigned 255))]
                            (tuple
                              (tuple-ref %v.3 1)
                              (tuple-ref %v.3 2)
                              (tuple-ref %v.3 3))])
                      (tuple
                        (let* ([[%x.16 (tunsigned 255)] (tuple-ref %t.14 0)]
                               [[%y.17 (tunsigned 255)] (tuple-ref %t.15 0)])
                          (downcast-unsigned 255 (+ 9 %x.16 %y.17)))
                        (let* ([[%x.18 (tunsigned 255)] (tuple-ref %t.14 1)]
                               [[%y.19 (tunsigned 255)] (tuple-ref %t.15 1)])
                          (downcast-unsigned 255 (+ 9 %x.18 %y.19)))
                        (let* ([[%x.20 (tunsigned 255)] (tuple-ref %t.14 2)]
                               [[%y.21 (tunsigned 255)] (tuple-ref %t.15 2)])
                          (downcast-unsigned 255 (+ 9 %x.20 %y.21)))))])
              (public-ledger %a.1 (0) write %tmp.13))
            (public-ledger %a.1 (0) read)))))
    )

  (test
    `(
      "witness w(x: Field): Field;"
      "circuit bar(v: Vector<2, Field>): Field {"
      "  const k1 = w(v[0]);"
      "  const k2 = w(v[1]);"
      "  return k1 + k2;"
      "}"
      "export circuit foo(v: Vector<2, Vector<2, Field>>): Field {"
      "  return disclose(bar(v[0]) * bar(v[1]));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %w.0 ([%x.1 (tfield)]) (tfield))
        (circuit %foo.2 ([%v.3 (tvector 2 (tvector 2 (tfield)))])
             (tfield)
          (* #f
             (let* ([[%v.4 (tvector 2 (tfield))] (tuple-ref %v.3 0)]
                    [[%k1.5 (tfield)] (call %w.0 (tuple-ref %v.4 0))]
                    [[%k2.6 (tfield)] (call %w.0 (tuple-ref %v.4 1))])
               (+ #f %k1.5 %k2.6))
             (let* ([[%v.7 (tvector 2 (tfield))] (tuple-ref %v.3 1)]
                    [[%k1.8 (tfield)] (call %w.0 (tuple-ref %v.7 0))]
                    [[%k2.9 (tfield)] (call %w.0 (tuple-ref %v.7 1))])
               (+ #f %k1.8 %k2.9))))))
    )

  (test
    `(
      "ledger X: Field;"
      "witness w(x: Field): Field;"
      "export circuit foo(v: Vector<2, Field>): Field {"
      "  for (const k1 of v) {"
      "    const k2 = disclose(w(k1));"
      "    X = X + k2;"
      "  }"
      "  return X;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%X.1 (0) (__compact_Cell (tfield)))))
        (witness %w.2 ([%x.3 (tfield)]) (tfield))
        (circuit %foo.4 ([%v.5 (tvector 2 (tfield))])
             (tfield)
          (seq
            (let* ([[%k1.6 (tfield)] (tuple-ref %v.5 0)]
                   [[%k2.7 (tfield)] (call %w.2 %k1.6)]
                   [[%tmp.8 (tfield)]
                    (+ #f (public-ledger %X.1 (0) read) %k2.7)])
              (public-ledger %X.1 (0) write %tmp.8))
            (let* ([[%k1.9 (tfield)] (tuple-ref %v.5 1)]
                   [[%k2.10 (tfield)] (call %w.2 %k1.9)]
                   [[%tmp.11 (tfield)]
                    (+ #f (public-ledger %X.1 (0) read) %k2.10)])
              (public-ledger %X.1 (0) write %tmp.11))
            (public-ledger %X.1 (0) read)))))
    )

  (test
    '(
      "ledger a: Vector<3, Uint<8>>;"
      "export circuit foo(v: Vector<5, Uint<8>>): Vector<3, Uint<8>> {"
      "  for (const k of 0..2) {"
      "    a = map((x, y) => x + disclose(y) as Uint<8>, a, slice<3>(v, k));"
      "  }"
      "  return a;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%a.1 (0) (__compact_Cell (tvector 3 (tunsigned 255))))))
        (circuit %foo.2 ([%v.3 (tvector 5 (tunsigned 255))])
             (tvector 3 (tunsigned 255))
          (seq
            (let* ([[%tmp.4 (tvector 3 (tunsigned 255))]
                    (let* ([[%t.5 (tvector 3 (tunsigned 255))]
                            (public-ledger %a.1 (0) read)]
                           [[%t.6 (tvector 3 (tunsigned 255))]
                            (tuple
                              (tuple-ref %v.3 0)
                              (tuple-ref %v.3 1)
                              (tuple-ref %v.3 2))])
                      (tuple
                        (let* ([[%x.7 (tunsigned 255)] (tuple-ref %t.5 0)]
                               [[%y.8 (tunsigned 255)] (tuple-ref %t.6 0)])
                          (downcast-unsigned 255 (+ 9 %x.7 %y.8)))
                        (let* ([[%x.9 (tunsigned 255)] (tuple-ref %t.5 1)]
                               [[%y.10 (tunsigned 255)] (tuple-ref %t.6 1)])
                          (downcast-unsigned 255 (+ 9 %x.9 %y.10)))
                        (let* ([[%x.11 (tunsigned 255)] (tuple-ref %t.5 2)]
                               [[%y.12 (tunsigned 255)] (tuple-ref %t.6 2)])
                          (downcast-unsigned 255 (+ 9 %x.11 %y.12)))))])
              (public-ledger %a.1 (0) write %tmp.4))
            (let* ([[%tmp.13 (tvector 3 (tunsigned 255))]
                    (let* ([[%t.14 (tvector 3 (tunsigned 255))]
                            (public-ledger %a.1 (0) read)]
                           [[%t.15 (tvector 3 (tunsigned 255))]
                            (tuple
                              (tuple-ref %v.3 1)
                              (tuple-ref %v.3 2)
                              (tuple-ref %v.3 3))])
                      (tuple
                        (let* ([[%x.16 (tunsigned 255)] (tuple-ref %t.14 0)]
                               [[%y.17 (tunsigned 255)] (tuple-ref %t.15 0)])
                          (downcast-unsigned 255 (+ 9 %x.16 %y.17)))
                        (let* ([[%x.18 (tunsigned 255)] (tuple-ref %t.14 1)]
                               [[%y.19 (tunsigned 255)] (tuple-ref %t.15 1)])
                          (downcast-unsigned 255 (+ 9 %x.18 %y.19)))
                        (let* ([[%x.20 (tunsigned 255)] (tuple-ref %t.14 2)]
                               [[%y.21 (tunsigned 255)] (tuple-ref %t.15 2)])
                          (downcast-unsigned 255 (+ 9 %x.20 %y.21)))))])
              (public-ledger %a.1 (0) write %tmp.13))
            (public-ledger %a.1 (0) read)))))
    )

  (test
    '(
      "struct S { a: Field, b: Field };"
      "circuit bar(x: Field, y: Field): [Field, Field, Field] {"
      "  return [x + y, x - y, x * y];"
      "}"
      "export circuit foo(x: Field): Vector<5, [Field, Field, Field]> {"
      "  return [bar(x, x), bar(x, 0), bar(0, x), bar(1, x), bar(x, 1)];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%x.1 (tfield)])
             (tvector 5 (ttuple (tfield) (tfield) (tfield)))
          (tuple
            (tuple (+ #f %x.1 %x.1) 0 (* #f %x.1 %x.1))
            (tuple %x.1 %x.1 0)
            (tuple %x.1 (- #f 0 %x.1) 0)
            (tuple (+ #f 1 %x.1) (- #f 1 %x.1) %x.1)
            (tuple (+ #f %x.1 1) (- #f %x.1 1) %x.1)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Field };"
      "ledger q: Counter;"
      "circuit bar(x: Field, y: Field): S {"
      "  return S { a: y, b: x };"
      "}"
      "export circuit foo(firstp: Boolean, x: Field): [Field, Field] {"
      "  const k = disclose(firstp) ? bar(7, x) : (q += 1, bar(7, x));"
      "  return [ k.a, k.b ];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration ((%q.1 (0) (Counter))))
        (circuit %foo.2 ([%firstp.3 (tboolean)] [%x.4 (tfield)])
             (ttuple (tfield) (tfield))
          (seq
            (if %firstp.3
                (tuple)
                (public-ledger %q.1 (0) increment 1))
            (tuple %x.4 7)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Field };"
      "ledger q: Counter;"
      "circuit bar(x: Field, y: Field): S {"
      "  return S { a: y, b: x };"
      "}"
      "export circuit foo(firstp: Boolean, x: Field, s: S): [Field, Field] {"
      "  const k = disclose(firstp) ? bar(7, x) : (q += 1, s);"
      "  return [ k.a, k.b ];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration ((%q.1 (0) (Counter))))
        (circuit %foo.2 ([%firstp.3 (tboolean)]
                         [%x.4 (tfield)]
                         [%s.5 (tstruct S (a (tfield)) (b (tfield)))])
             (ttuple (tfield) (tfield))
          (let* ([[%k.6 (tstruct S (a (tfield)) (b (tfield)))]
                  (if %firstp.3
                      (new (tstruct S (a (tfield)) (b (tfield))) %x.4 7)
                      (seq (public-ledger %q.1 (0) increment 1) %s.5))])
            (tuple (elt-ref %k.6 a) (elt-ref %k.6 b))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger F: Field;"
      "export circuit foo(v: Vector<10, Field>): Field {"
      "  for (const i of 0..10) {"
      "    F = F + disclose(v)[i];"
      "  }"
      "  return F;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%F.1 (0) (__compact_Cell (tfield)))))
        (circuit %foo.2 ([%v.3 (tvector 10 (tfield))])
             (tfield)
          (seq
            (let* ([[%tmp.4 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 0))])
              (public-ledger %F.1 (0) write %tmp.4))
            (let* ([[%tmp.5 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 1))])
              (public-ledger %F.1 (0) write %tmp.5))
            (let* ([[%tmp.6 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 2))])
              (public-ledger %F.1 (0) write %tmp.6))
            (let* ([[%tmp.7 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 3))])
              (public-ledger %F.1 (0) write %tmp.7))
            (let* ([[%tmp.8 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 4))])
              (public-ledger %F.1 (0) write %tmp.8))
            (let* ([[%tmp.9 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 5))])
              (public-ledger %F.1 (0) write %tmp.9))
            (let* ([[%tmp.10 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 6))])
              (public-ledger %F.1 (0) write %tmp.10))
            (let* ([[%tmp.11 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 7))])
              (public-ledger %F.1 (0) write %tmp.11))
            (let* ([[%tmp.12 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 8))])
              (public-ledger %F.1 (0) write %tmp.12))
            (let* ([[%tmp.13 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) (tuple-ref %v.3 9))])
              (public-ledger %F.1 (0) write %tmp.13))
            (public-ledger %F.1 (0) read)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger F: Field;"
      "export circuit foo(v: Vector<10, Field>, offset: Uint<8>): Field {"
      "  for (const i of 0..10) {"
      "    F = F + disclose(v)[i+disclose(offset)];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 13" "vector index did not reduce to a constant nonnegative value at compile time" ()))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger F: Field;"
      "export circuit foo(v: Vector<10, Field>, offset: Uint<8>): Field {"
      "  for (const x of disclose(slice<5>(v, offset))) {"
      "    F = F + x;"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 28" "slice index did not reduce to a constant nonnegative value at compile time" ()))
    )

 (let ([n* (list 0 1 10 (field-bytes) (+ (field-bytes) 1) (* (field-bytes) 2))])
  (test
      `(
        "import CompactStandardLibrary;"
        "ledger F: Field;"
        ,(format "export circuit foo(): [~{Bytes<~d>~^, ~}] {" n*)
        "  F = F + 73;"
        ,(format "  const v = [~{~d~^, ~}];" (iota (apply max n*)))
        ,(format "  return [~{~a~^, ~}];"
           (map (lambda (n) (format "slice<~d>(v, 0) as Bytes<~:*~d>" n)) n*))
        "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%F.1 (0) (__compact_Cell (tfield)))))
        (circuit %foo.2 ()
             (ttuple ,@(map (lambda (n) `(tbytes ,n)) n*))
          (seq
            (let* ([[%tmp.3 (tfield)]
                    (+ #f (public-ledger %F.1 (0) read) 73)])
              (public-ledger %F.1 (0) write %tmp.3))
            (tuple
              #vu8()
              #vu8(0)
              #vu8(0 1 2 3 4 5 6 7 8 9)
              #vu8(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
                   22 23 24 25 26 27 28 29 30)
              #vu8(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
                   22 23 24 25 26 27 28 29 30 31)
              #vu8(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
                   23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42
                   43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60
                   61))))))
    ))

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit bar(b: Boolean, x: Field): [] {"
      "    const k1 = disclose(x - 1) as Bytes<N>;"
      "    const k2 = disclose(x + 1) as Bytes<N>;"
      "    bv = b ? k1 : k2;"
      "  }"
      "}"
      ,(format "import M<~d>;" (field-bytes))
      "export circuit foo(x: Field): [] {"
      "  bar(true, x);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%bv.1 (0) (__compact_Cell (tbytes 31)))))
        (circuit %foo.2 ([%x.3 (tfield)])
             (ttuple)
          (seq
            (let* ([[%k1.4 (tbytes 31)]
                    (field->bytes 31 (- #f %x.3 1))])
              (seq
                (field->bytes 31 (+ #f %x.3 1))
                (public-ledger %bv.1 (0) write %k1.4)))
            (tuple)))))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit bar(b: Boolean, x: Field): [] {"
      "    const k1 = disclose(x - 1) as Bytes<N>;"
      "    const k2 = disclose(x + 1) as Bytes<N>;"
      "    bv = b ? k1 : k2;"
      "  }"
      "}"
      ,(format "import M<~d>;" (+ (field-bytes) 1))
      "export circuit foo(x: Field): [] {"
      "  bar(true, x);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%bv.2 (0) (__compact_Cell (tbytes 32)))))
        (circuit %foo.3 ([%x.0 (tfield)])
             (ttuple)
          (seq
            (let* ([[%k1.4 (tbytes 32)]
                    (field->bytes 32 (- #f %x.0 1))])
              (public-ledger %bv.2 (0) write %k1.4))
            (tuple)))))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger x: Field;"
      "  export circuit bar(b: Boolean, bv1: Bytes<N>, bv2: Bytes<N>): [] {"
      "    const k1 = (disclose(bv1) as Field) - 1;"
      "    const k2 = (disclose(bv2) as Field) + 1;"
      "    x = b ? k1 : k2;"
      "  }"
      "  export circuit foo(bv1: Bytes<N>, bv2: Bytes<N>): [] {"
      "    bar(true, bv1, bv2);"
      "  }"
      "}"
      ,(format "import M<~d>;" (field-bytes))
      "export { foo };"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%x.2 (0) (__compact_Cell (tfield)))))
        (circuit %foo.3 ([%bv1.4 (tbytes 31)] [%bv2.0 (tbytes 31)])
             (ttuple)
          (seq
            (let* ([[%k1.5 (tfield)] (- #f (bytes->field 31 %bv1.4) 1)])
              (public-ledger %x.2 (0) write %k1.5))
            (tuple)))))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger x: Field;"
      "  export circuit bar(b: Boolean, bv1: Bytes<N>, bv2: Bytes<N>): [] {"
      "    const k1 = (disclose(bv1) as Field) - 1;"
      "    const k2 = (disclose(bv2) as Field) + 1;"
      "    x = b ? k1 : k2;"
      "  }"
      "  export circuit foo(bv1: Bytes<N>, bv2: Bytes<N>): [] {"
      "    bar(true, bv1, bv2);"
      "  }"
      "}"
      ,(format "import M<~d>;" (+ (field-bytes) 1))
      "export { foo };"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%x.1 (0) (__compact_Cell (tfield)))))
        (circuit %foo.2 ([%bv1.3 (tbytes 32)] [%bv2.4 (tbytes 32)])
             (ttuple)
          (seq
            (let* ([[%k1.5 (tfield)] (- #f (bytes->field 32 %bv1.3) 1)])
              (seq
                (bytes->field 32 %bv2.4)
                (public-ledger %x.1 (0) write %k1.5)))
            (tuple)))))
    )

  (test
    '(
      "ledger BV: Bytes<10>;"
      "circuit bar(b: Boolean, bv: Bytes<10>, v: Vector<10, Uint<3>>): [] {"
      "  const k1 = disclose(bv);"
      "  const k2 = disclose(v) as Bytes<10>;"
      "  BV = b ? k1 : k2;"
      "}"
      "export circuit foo(bv: Bytes<10>, v: Vector<10, Uint<3>>): [] {"
      "  bar(true, bv, v);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%BV.1 (0) (__compact_Cell (tbytes 10)))))
        (circuit %foo.2 ([%bv.3 (tbytes 10)]
                         [%v.4 (tvector 10 (tunsigned 7))])
             (ttuple)
          (seq (public-ledger %BV.1 (0) write %bv.3) (tuple)))))
    )

  (test
    '(
      "ledger V: Vector<10, Uint<8>>;"
      "circuit bar(b: Boolean, bv: Bytes<10>, v: Vector<10, Uint<8>>): [] {"
      "  const k1 = disclose(bv) as Vector<10, Uint<8>>;"
      "  const k2 = disclose(v);"
      "  V = b ? k1 : k2;"
      "}"
      "export circuit foo(bv: Bytes<10>, v: Vector<10, Uint<8>>): [] {"
      "  bar(false, bv, v);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%V.1 (0) (__compact_Cell (tvector 10 (tunsigned 255))))))
        (circuit %foo.2 ([%bv.3 (tbytes 10)]
                         [%v.4 (tvector 10 (tunsigned 255))])
             (ttuple)
          (seq (public-ledger %V.1 (0) write %v.4) (tuple)))))
    )
)

(run-tests reduce-to-circuit
  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  return true;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tfield)])
             (tboolean)
          #t)))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  assert(x == 3, 'oops 1');"
      "  return b;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tfield)])
             (tboolean)
          (= %t.3 (== %x.2 3))
          (= %t.4 (select #t %t.3 #t))
          (assert %t.4 "oops 1")
          (= %t.5 (tuple))
          %b.1)))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Uint<16>): Boolean {"
      "  assert(x < 3, 'oops 1');"
      "  return b;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tunsigned 65535)])
             (tboolean)
          (= %t.3 (< 16 %x.2 3))
          (= %t.4 (select #t %t.3 #t))
          (assert %t.4 "oops 1")
          (= %t.5 (tuple))
          %b.1)))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  if (b)"
      "     assert(b, 'oops 1');"
      "  else"
      "     assert(x == 3, 'oops 2');"
      "  return b && x == 3;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%b.1 (tboolean)] [%x.2 (tfield)])
             (tboolean)
          (= %t.3 (select %b.1 #t #f))
          (= %t.4 (select %b.1 #f #t))
          (= %t.5 (tuple))
          (= %t.6 (== %x.2 3))
          (= %t.7 (select %t.4 %t.6 #t))
          (assert %t.7 "oops 2")
          (= %t.8 (tuple))
          (= %t.9 (select %b.1 #t #f))
          (= %t.10 (select %b.1 #f #t))
          (= %t.11 (== %x.2 3))
          (= %t.12 (select %b.1 %t.11 #f))
          %t.12)))
    )

  (test
    `(
      "export circuit foo() : Vector<3, Vector<2, Field>> {"
      "  return [[1, 2], [3, 4], [5, 6]];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (tvector 3 (tvector 2 (tfield)))
          (= %t.1 (tuple 1 2))
          (= %t.2 (tuple 3 4))
          (= %t.3 (tuple 5 6))
          (= %t.4 (tuple %t.1 %t.2 %t.3))
          %t.4)))
    )

  (test
    '(
       "export circuit baz(arg: Bytes<20>) : Field { return arg as Field; }"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.0 ([%arg.1 (tbytes 20)])
             (tfield)
          (= %t.2 (bytes->field #t 20 %arg.1))
          %t.2))))

  (test
    '(
       "export circuit foo(arg: Field) : Bytes<20> { return arg as Bytes<20>; }"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%arg.1 (tfield)])
             (tbytes 20)
          (= %t.2 (field->bytes #t 20 %arg.1))
          %t.2))))

  (test
    '(
      "module A<#n, t> {"
      "  export circuit foo(v : Vector<n, t>, b : Bytes<n>): Field {"
      "    return 17;"
      "  }"
      "}"
      "module B {"
      "  circuit foo(x : Field): Field { return x + 1; }"
      "  circuit bar(x : Field): Field { return x - 1; }"
      "  import A<7, Field> prefix AA;"
      "  import A<30, Boolean> prefix AAA;"
      "  export {foo, AAfoo, AAAfoo, bar}"
      "}"
      "import B;"
      "import B prefix BB;"
      "import B<> prefix BBB;"
      "export {foo, AAfoo, BBfoo, BBAAfoo, BBBfoo, BBBAAAfoo, bar, BBbar, BBBbar}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%v.1 (tvector 7 (tfield))]
                         [%b.2 (tbytes 7)])
             (tfield)
          17)
        (circuit %foo.3 ([%v.4 (tvector 30 (tboolean))]
                         [%b.5 (tbytes 30)])
             (tfield)
          17)
        (circuit %foo.6 ([%x.7 (tfield)])
             (tfield)
          (= %t.8 (+ #f %x.7 1))
          %t.8)
        (circuit %bar.9 ([%x.10 (tfield)])
             (tfield)
          (= %t.11 (- #f %x.10 1))
          %t.11)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1.read();"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration ((%field1.2 (0) (Counter))))
        (circuit %foo.3 ()
             (tfield)
          (= %t.0 (public-ledger #t %field1.2 (0) read))
          %t.0)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "ledger field0: Counter;"
      "ledger field1: Boolean;"
      "ledger field2: Set<Field>;"
      "ledger field3: Map<Field, Foo>;"
      "ledger field4: List<Foo>;"
      "ledger field5: MerkleTree<10, Foo>;"
      "ledger field6: HistoricMerkleTree<10, Field>;"
      "ledger field7: QualifiedCoinInfo;"
      "ledger field8: Set<QualifiedCoinInfo>;"
      "ledger field9: Map<Field, QualifiedCoinInfo>;"
      "ledger field10: List<QualifiedCoinInfo>;"
      ""
      "export circuit foo(x: Field, ci: CoinInfo): Boolean {"
      "  field0.resetToDefault();"
      "  field0.increment(5);"
      "  field0.decrement(2);"
      "  assert(field0.lessThan(4), 'oops 1');"
      "  field1.write(true);"
      "  const q = field1.read();"
      "  field2.resetToDefault();"
      "  assert(field2.isEmpty(), 'oops 2a');"
      "  assert(field2.size() == 0, 'oops 2b');"
      "  assert(!field2.member(disclose(x)), 'oops 2c');"
      "  field2.insert(disclose(x));"
      "  field2.insert(disclose(x) + 1);"
      "  field2.insert(disclose(x) + 2);"
      "  field2.insert(disclose(x) + 1);"
      "  assert(field2.size() == 3, 'oops 2d');"
      "  field2.remove(disclose(x) + 1);"
      "  assert(field2.size() == 2, 'oops 2e');"
      "  assert(!field2.isEmpty(), 'oops 2f');"
      "  assert(field2.member(disclose(x)), 'oops 2g');"
      "  assert(!field2.member(disclose(x) + 1), 'oops 2h');"
      "  assert(field2.member(disclose(x) + 2), 'oops 2i');"
      "  field3.resetToDefault();"
      "  field4.resetToDefault();"
      "  field5.resetToDefault();"
      "  field6.resetToDefault();"
      "  field7.writeCoin(disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field8.resetToDefault();"
      "  field8.insertCoin(disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field9.resetToDefault();"
      "  field9.insertCoin(disclose(x), disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field10.resetToDefault();"
      "  field10.pushFrontCoin(disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  return q;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%field0.1 (0) (Counter))
           (%field1.2 (1) (__compact_Cell (tboolean)))
           (%field2.3 (2) (Set (tfield)))
           (%field3.4
             (3)
             (Map (tfield)
                  (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
           (%field4.5
             (4)
             (List (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
           (%field5.6
             (5)
             (MerkleTree
               10
               (tstruct Foo (bar (tbytes 32)) (baz (tboolean)))))
           (%field6.7 (6) (HistoricMerkleTree 10 (tfield)))
           (%field7.8
             (7)
             (__compact_Cell
               (tstruct QualifiedCoinInfo
                 (nonce (tbytes 32))
                 (color (tbytes 32))
                 (value (tunsigned 340282366920938463463374607431768211455))
                 (mt_index (tunsigned 18446744073709551615)))))
           (%field8.9
             (8)
             (Set (tstruct QualifiedCoinInfo
                    (nonce (tbytes 32))
                    (color (tbytes 32))
                    (value (tunsigned 340282366920938463463374607431768211455))
                    (mt_index (tunsigned 18446744073709551615)))))
           (%field9.10
             (9)
             (Map (tfield)
                  (tstruct QualifiedCoinInfo
                    (nonce (tbytes 32))
                    (color (tbytes 32))
                    (value (tunsigned 340282366920938463463374607431768211455))
                    (mt_index (tunsigned 18446744073709551615)))))
           (%field10.11
             (10)
             (List
               (tstruct QualifiedCoinInfo
                 (nonce (tbytes 32))
                 (color (tbytes 32))
                 (value (tunsigned 340282366920938463463374607431768211455))
                 (mt_index (tunsigned 18446744073709551615)))))))
        (circuit %foo.12 ([%x.13 (tfield)]
                          [%ci.14 (tstruct CoinInfo
                                    (nonce (tbytes 32))
                                    (color (tbytes 32))
                                    (value (tunsigned
                                             340282366920938463463374607431768211455)))])
             (tboolean)
          (= %t.15 (public-ledger #t %field0.1 (0) resetToDefault))
          (= %t.16 (public-ledger #t %field0.1 (0) increment 5))
          (= %t.17 (public-ledger #t %field0.1 (0) decrement 2))
          (= %t.18 (public-ledger #t %field0.1 (0) lessThan 4))
          (= %t.19 (select #t %t.18 #t))
          (assert %t.19 "oops 1")
          (= %t.20 (tuple))
          (= %t.21 (public-ledger #t %field1.2 (1) write #t))
          (= %q.22 (public-ledger #t %field1.2 (1) read))
          (= %t.23 (public-ledger #t %field2.3 (2) resetToDefault))
          (= %t.24 (public-ledger #t %field2.3 (2) isEmpty))
          (= %t.25 (select #t %t.24 #t))
          (assert %t.25 "oops 2a")
          (= %t.26 (tuple))
          (= %t.27 (public-ledger #t %field2.3 (2) size))
          (= %t.28 (== %t.27 0))
          (= %t.29 (select #t %t.28 #t))
          (assert %t.29 "oops 2b")
          (= %t.30 (tuple))
          (= %t.31 (public-ledger #t %field2.3 (2) member %x.13))
          (= %t.32 (select %t.31 #t #f))
          (= %t.33 (select %t.31 #f #t))
          (= %t.34 (select %t.31 #f #t))
          (= %t.35 (select #t %t.34 #t))
          (assert %t.35 "oops 2c")
          (= %t.36 (tuple))
          (= %t.37 (public-ledger #t %field2.3 (2) insert %x.13))
          (= %tmp.38 (+ #f %x.13 1))
          (= %t.39 (public-ledger #t %field2.3 (2) insert %tmp.38))
          (= %tmp.40 (+ #f %x.13 2))
          (= %t.41 (public-ledger #t %field2.3 (2) insert %tmp.40))
          (= %tmp.42 (+ #f %x.13 1))
          (= %t.43 (public-ledger #t %field2.3 (2) insert %tmp.42))
          (= %t.44 (public-ledger #t %field2.3 (2) size))
          (= %t.45 (== %t.44 3))
          (= %t.46 (select #t %t.45 #t))
          (assert %t.46 "oops 2d")
          (= %t.47 (tuple))
          (= %tmp.48 (+ #f %x.13 1))
          (= %t.49 (public-ledger #t %field2.3 (2) remove %tmp.48))
          (= %t.50 (public-ledger #t %field2.3 (2) size))
          (= %t.51 (== %t.50 2))
          (= %t.52 (select #t %t.51 #t))
          (assert %t.52 "oops 2e")
          (= %t.53 (tuple))
          (= %t.54 (public-ledger #t %field2.3 (2) isEmpty))
          (= %t.55 (select %t.54 #t #f))
          (= %t.56 (select %t.54 #f #t))
          (= %t.57 (select %t.54 #f #t))
          (= %t.58 (select #t %t.57 #t))
          (assert %t.58 "oops 2f")
          (= %t.59 (tuple))
          (= %t.60 (public-ledger #t %field2.3 (2) member %x.13))
          (= %t.61 (select #t %t.60 #t))
          (assert %t.61 "oops 2g")
          (= %t.62 (tuple))
          (= %tmp.63 (+ #f %x.13 1))
          (= %t.64 (public-ledger #t %field2.3 (2) member %tmp.63))
          (= %t.65 (select %t.64 #t #f))
          (= %t.66 (select %t.64 #f #t))
          (= %t.67 (select %t.64 #f #t))
          (= %t.68 (select #t %t.67 #t))
          (assert %t.68 "oops 2h")
          (= %t.69 (tuple))
          (= %tmp.70 (+ #f %x.13 2))
          (= %t.71 (public-ledger #t %field2.3 (2) member %tmp.70))
          (= %t.72 (select #t %t.71 #t))
          (assert %t.72 "oops 2i")
          (= %t.73 (tuple))
          (= %t.74 (public-ledger #t %field3.4 (3) resetToDefault))
          (= %t.75 (public-ledger #t %field4.5 (4) resetToDefault))
          (= %t.76 (public-ledger #t %field5.6 (5) resetToDefault))
          (= %t.77 (public-ledger #t %field6.7 (6) resetToDefault))
          (= %value.78 (public-ledger #t %kernel.0 () self))
          (= %tmp.79
             (new (tstruct Either
                    (is_left (tboolean))
                    (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
                    (right (tstruct ContractAddress (bytes (tbytes 32)))))
               #f
               (default (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
               %value.78))
          (= %t.80
             (public-ledger #t %field7.8 (7) writeCoin %ci.14 %tmp.79))
          (= %t.81 (public-ledger #t %field8.9 (8) resetToDefault))
          (= %value.82 (public-ledger #t %kernel.0 () self))
          (= %tmp.83
             (new (tstruct Either
                    (is_left (tboolean))
                    (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
                    (right (tstruct ContractAddress (bytes (tbytes 32)))))
               #f
               (default (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
               %value.82))
          (= %t.84
             (public-ledger #t %field8.9 (8) insertCoin %ci.14 %tmp.83))
          (= %t.85 (public-ledger #t %field9.10 (9) resetToDefault))
          (= %value.86 (public-ledger #t %kernel.0 () self))
          (= %tmp.87
             (new (tstruct Either
                    (is_left (tboolean))
                    (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
                    (right (tstruct ContractAddress (bytes (tbytes 32)))))
               #f
               (default (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
               %value.86))
          (= %t.88
             (public-ledger #t %field9.10 (9) insertCoin
               %x.13
               %ci.14
               %tmp.87))
          (= %t.89 (public-ledger #t %field10.11 (10) resetToDefault))
          (= %value.90 (public-ledger #t %kernel.0 () self))
          (= %tmp.91
             (new (tstruct Either
                    (is_left (tboolean))
                    (left (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
                    (right (tstruct ContractAddress (bytes (tbytes 32)))))
               #f
               (default (tstruct ZswapCoinPublicKey (bytes (tbytes 32))))
               %value.90))
          (= %t.92
             (public-ledger #t %field10.11 (10) pushFrontCoin
               %ci.14
               %tmp.91))
          %q.22)))
    )

  (test ;; FIXME uncomment composable contract
    "test-center/compact/test.compact"
    (succeeds))

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Field): Uint<16> {"
      "  return x as Uint<16>;"
      "}"
      "export circuit bar(x: Uint<32>): Uint<16> {"
      "  return x as Uint<16>;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.0 ([%x.1 (tfield)])
             (tunsigned 65535)
          (= %t.2 (downcast-unsigned #t 65535 %x.1))
          %t.2)
        (circuit %bar.3 ([%x.4 (tunsigned 4294967295)])
             (tunsigned 65535)
          (= %t.5 (downcast-unsigned #t 65535 %x.4))
          %t.5)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Boolean>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(disclose(n));"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(i); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.2 () (Kernel)))
        (public-ledger-declaration
          ((%field1.0 (0) (Map (tfield) (tboolean)))))
        (circuit %foo.3 ([%n.4 (tfield)])
             (tboolean)
          (= %t.5 (public-ledger #t %field1.0 (0) lookup %n.4))
          %t.5)
        (circuit %call_foo.6 ([%i.1 (tfield)])
             (tboolean)
          (= %t.7 (public-ledger #t %field1.0 (0) lookup %i.1))
          %t.7)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Boolean>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(disclose(n));"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(1); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%field1.1 (0) (Map (tfield) (tboolean)))))
        (circuit %foo.2 ([%n.3 (tfield)])
             (tboolean)
          (= %t.4 (public-ledger #t %field1.1 (0) lookup %n.3))
          %t.4)
        (circuit %call_foo.5 ([%i.6 (tfield)])
             (tboolean)
          (= %t.7 (public-ledger #t %field1.1 (0) lookup 1))
          %t.7)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Boolean>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(disclose(n));"
      "}"
      "export circuit call_foo(n: Field) : Boolean { return foo(n); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.2 () (Kernel)))
        (public-ledger-declaration
          ((%field1.0 (0) (Map (tfield) (tboolean)))))
        (circuit %foo.3 ([%n.4 (tfield)])
             (tboolean)
          (= %t.5 (public-ledger #t %field1.0 (0) lookup %n.4))
          %t.5)
        (circuit %call_foo.6 ([%n.1 (tfield)])
             (tboolean)
          (= %t.7 (public-ledger #t %field1.0 (0) lookup %n.1))
          %t.7)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(1).lookup(2);"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(3); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%field1.1 (0) (Map (tfield) (Map (tfield) (tboolean))))))
        (circuit %foo.2 ([%n.3 (tfield)])
             (tboolean)
          (= %t.4
             (public-ledger #t %field1.1 (0 ((tfield) 1)) lookup 2))
          %t.4)
        (circuit %call_foo.5 ([%i.6 (tfield)])
             (tboolean)
          (= %t.7
             (public-ledger #t %field1.1 (0 ((tfield) 1)) lookup 2))
          %t.7)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(1).lookup(disclose(n));"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(2); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%field1.1 (0) (Map (tfield) (Map (tfield) (tboolean))))))
        (circuit %foo.2 ([%n.3 (tfield)])
             (tboolean)
          (= %t.4
             (public-ledger #t %field1.1 (0 ((tfield) 1)) lookup %n.3))
          %t.4)
        (circuit %call_foo.5 ([%i.6 (tfield)])
             (tboolean)
          (= %t.7
             (public-ledger #t %field1.1 (0 ((tfield) 1)) lookup 2))
          %t.7)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(n).lookup(1);"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(2); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%field1.1 (0) (Map (tfield) (Map (tfield) (tboolean))))))
        (circuit %foo.2 ([%n.3 (tfield)])
             (tboolean)
          (= %t.4
             (public-ledger #t %field1.1 (0 ((tfield) %n.3)) lookup 1))
          %t.4)
        (circuit %call_foo.5 ([%i.6 (tfield)])
             (tboolean)
          (= %t.7
             (public-ledger #t %field1.1 (0 ((tfield) 2)) lookup 1))
          %t.7)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(n).lookup(1);"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(i); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%field1.1 (0) (Map (tfield) (Map (tfield) (tboolean))))))
        (circuit %foo.2 ([%n.3 (tfield)])
             (tboolean)
          (= %t.4
             (public-ledger #t %field1.1 (0 ((tfield) %n.3)) lookup 1))
          %t.4)
        (circuit %call_foo.5 ([%i.6 (tfield)])
             (tboolean)
          (= %t.7
             (public-ledger #t %field1.1 (0 ((tfield) %i.6)) lookup 1))
          %t.7)))
    )

  (test
    '(
      "export circuit foo(x: Boolean, y: Boolean): [] {"
      "  if (x) if (!y) 3;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ([%x.1 (tboolean)] [%y.2 (tboolean)])
             (ttuple)
          (= %t.3 (tuple))
          %t.3)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger a: Field;"
      "export circuit foo(x0: Boolean): [] {"
      "  const x = disclose(x0);"
      "  if (x) {"
      "    if (!x) {"
      "      a = 3;"
      "    }"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.4 () (Kernel)))
        (public-ledger-declaration
          ((%a.3 (0) (__compact_Cell (tfield)))))
        (circuit %foo.5 ([%x0.0 (tboolean)])
             (ttuple)
          (= %t.6 (tuple))
          %t.6)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(b: Boolean): [] {"
      "  assert(b, 'oops');"
      "}"
      "export circuit foo(x: Boolean): [] {"
      "  return bar(x);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.1 ([%x.2 (tboolean)])
             (ttuple)
          (= %t.3 (select #t %x.2 #t))
          (assert %t.3 "oops")
          (= %t.4 (tuple))
          (= %t.5 (tuple))
          %t.5)))
    )

  (test
    '(
      "witness W(): Uint<16>;"
      "export circuit foo(): Uint<16> {"
      "  return disclose(W());"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 () (tunsigned 65535))
        (circuit %foo.1 ()
             (tunsigned 65535)
          (= %t.2 (call #t %W.0))
          %t.2)))
    )
)

(run-tests flatten-datatypes
  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(n: Field): [] {"
      "  const a = disclose(n);"
      "  const b = disclose(n);"
      "  if (b == 0) {"
      "    ledger_counter.increment(1);"
      "  }"
      "}")
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%ledger_counter.2 (0) (Counter))))
        (circuit %minimal_error_circuit.3 ((argument
                                             (%n.0)
                                             (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.4 (== %n.0 0))
          (= %t.5 (select 1 %t.4 0))
          (= %t.6 %t.5)
          (= %t.7 (select %t.5 1 0))
          (= %t.8 (select %t.5 0 1))
          (= ()
             (public-ledger %t.7 %ledger_counter.2 (0) increment 1))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(n: Field): []{"
      "  const a = disclose(n);"
      "  const b = disclose(n);"
      "  if (a == 0) {"
      "    if (b == 0) {"
      "      ledger_counter.decrement(1);"
      "    } else {"
      "      ledger_counter.read();"
      "    }"
      "  }"
      "}")
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%ledger_counter.2 (0) (Counter))))
        (circuit %minimal_error_circuit.3 ((argument
                                             (%n.0)
                                             (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.4 (== %n.0 0))
          (= %t.5 (select 1 %t.4 0))
          (= %t.6 %t.5)
          (= %t.7 (select %t.5 1 0))
          (= %t.8 (select %t.5 0 1))
          (= %t.9 (== %n.0 0))
          (= %t.10 (select 1 %t.9 0))
          (= %t.11 %t.10)
          (= %t.12 (select %t.10 %t.7 0))
          (= %t.13 (select %t.10 0 %t.7))
          (= ()
             (public-ledger %t.12 %ledger_counter.2 (0) decrement 1))
          (= (%t.14) (public-ledger %t.13 %ledger_counter.2 (0) read))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(n: Field): [] {"
      "  const a = disclose(n);"
      "  const b = disclose(n);"
      "  if (a == 0) {"
      "    if (b == 0) {"
      "      ledger_counter.decrement(1);"
      "    } else {"
      "      ledger_counter.increment(1);"
      "    }"
      "  }"
      "}")
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%ledger_counter.2 (0) (Counter))))
        (circuit %minimal_error_circuit.3 ((argument
                                             (%n.0)
                                             (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.4 (== %n.0 0))
          (= %t.5 (select 1 %t.4 0))
          (= %t.6 %t.5)
          (= %t.7 (select %t.5 1 0))
          (= %t.8 (select %t.5 0 1))
          (= %t.9 (== %n.0 0))
          (= %t.10 (select 1 %t.9 0))
          (= %t.11 %t.10)
          (= %t.12 (select %t.10 %t.7 0))
          (= %t.13 (select %t.10 0 %t.7))
          (= ()
             (public-ledger %t.12 %ledger_counter.2 (0) decrement 1))
          (= ()
             (public-ledger %t.13 %ledger_counter.2 (0) increment 1))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(n: Field): [] {"
      "  const a = disclose(n);"
      "  const b = disclose(n);"
      "  if (a == 0) {"
      "    if (b == 0) {"
      "      ledger_counter.decrement(1);"
      "    }"
      "  }"
      "}")
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%ledger_counter.2 (0) (Counter))))
        (circuit %minimal_error_circuit.3 ((argument
                                             (%n.0)
                                             (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.4 (== %n.0 0))
          (= %t.5 (select 1 %t.4 0))
          (= %t.6 %t.5)
          (= %t.7 (select %t.5 1 0))
          (= %t.8 (select %t.5 0 1))
          (= %t.9 (== %n.0 0))
          (= %t.10 (select 1 %t.9 0))
          (= %t.11 %t.10)
          (= %t.12 (select %t.10 %t.7 0))
          (= %t.13 (select %t.10 0 %t.7))
          (= ()
             (public-ledger %t.12 %ledger_counter.2 (0) decrement 1))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(): [] {"
      "  const a = 0;"
      "  const b = 0;"
      "  if (a == 0) {"
      "    if (b == 1) {"
      "      ledger_counter.decrement(1);"
      "    } else {"
      "    }"
      "  }"
      "}")
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%ledger_counter.1 (0) (Counter))))
        (circuit %minimal_error_circuit.2 () (ty () ()) ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(n: Field): [] {"
      "  const a = disclose(n);"
      "  const b = disclose(n);"
      "  if (a == 0) {"
      "    if (b == 1) {"
      "      ledger_counter.decrement(1);"
      "    } else {"
      "    }"
      "  }"
      "}")
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%ledger_counter.2 (0) (Counter))))
        (circuit %minimal_error_circuit.3 ((argument
                                             (%n.0)
                                             (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.4 (== %n.0 0))
          (= %t.5 (select 1 %t.4 0))
          (= %t.6 %t.5)
          (= %t.7 (select %t.5 1 0))
          (= %t.8 (select %t.5 0 1))
          (= %t.9 (== %n.0 1))
          (= %t.10 (select 1 %t.9 0))
          (= %t.11 %t.10)
          (= %t.12 (select %t.10 %t.7 0))
          (= %t.13 (select %t.10 0 %t.7))
          (= ()
             (public-ledger %t.12 %ledger_counter.2 (0) decrement 1))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(): [] {"
      "    const a = 0;"
      "    const b = 0;"
      "    if (a == 0 && b == 0) {"
      "        ledger_counter.increment(1);"
      "    } else if (a == 0 && b == 1) {"
      "        ledger_counter.increment(2);"
      "    }"
      "}")
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%ledger_counter.1 (0) (Counter))))
        (circuit %minimal_error_circuit.2 ()
             (ty () ())
          (= () (public-ledger 1 %ledger_counter.1 (0) increment 1))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger ledger_counter: Counter;"
      ""
      "export circuit minimal_error_circuit(n: Field): [] {"
      "    const a = disclose(n);"
      "    const b = disclose(n);"
      "    if (a == 0 && b == 0) {"
      "        ledger_counter.increment(1);"
      "    } else if (a == 0 && b == 1) {"
      "        ledger_counter.increment(2);"
      "    }"
      "}")
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%ledger_counter.2 (0) (Counter))))
        (circuit %minimal_error_circuit.3 ((argument
                                             (%n.0)
                                             (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.4 (== %n.0 0))
          (= %t.5 (select 1 %t.4 0))
          (= %t.6 %t.5)
          (= %t.7 (select %t.5 1 0))
          (= %t.8 (select %t.5 0 1))
          (= %t.9 (== %n.0 0))
          (= %t.10 (select 1 %t.9 0))
          (= %t.11 %t.10)
          (= %t.12 (select %t.5 %t.10 0))
          (= %t.13 (select %t.12 1 0))
          (= %t.14 (select %t.12 0 1))
          (= ()
             (public-ledger %t.13 %ledger_counter.2 (0) increment 1))
          (= %t.15 (== %n.0 0))
          (= %t.16 (select 1 %t.15 0))
          (= %t.17 %t.16)
          (= %t.18 (select %t.16 %t.14 0))
          (= %t.19 (select %t.16 0 %t.14))
          (= %t.20 (== %n.0 1))
          (= %t.21 (select 1 %t.20 0))
          (= %t.22 %t.21)
          (= %t.23 (select %t.16 %t.21 0))
          (= %t.24 (select %t.23 %t.14 0))
          (= %t.25 (select %t.23 0 %t.14))
          (= ()
             (public-ledger %t.24 %ledger_counter.2 (0) increment 2))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Boolean>;"
      ""
      "export circuit foo(n: Field): [] {"
      "  const a = 0;"
      "  const b = 0;"
      "  if (a == 0){"
      "    if (b == 0){"
      "      field1.remove(1);"
      "    }"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%field1.1
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((abytes 1)) ((tfield 1)))))))
        (circuit %foo.2 ((argument
                           (%n.3)
                           (ty ((afield)) ((tfield)))))
             (ty () ())
          (= () (public-ledger 1 %field1.1 (0) remove 1))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Boolean>;"
      ""
      "export circuit foo(n: Field): [] {"
      "  const a = disclose(n);"
      "  const b = disclose(n);"
      "  if (a == 0){"
      "    if (b == 0){"
      "      field1.remove(1);"
      "    }"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%field1.2
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((abytes 1)) ((tfield 1)))))))
        (circuit %foo.3 ((argument
                           (%n.0)
                           (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.4 (== %n.0 0))
          (= %t.5 (select 1 %t.4 0))
          (= %t.6 %t.5)
          (= %t.7 (select %t.5 1 0))
          (= %t.8 (select %t.5 0 1))
          (= %t.9 (== %n.0 0))
          (= %t.10 (select 1 %t.9 0))
          (= %t.11 %t.10)
          (= %t.12 (select %t.10 %t.7 0))
          (= %t.13 (select %t.10 0 %t.7))
          (= () (public-ledger %t.12 %field1.2 (0) remove 1))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Boolean>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(disclose(n));"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(i); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration
          ((%field1.0
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((abytes 1)) ((tfield 1)))))))
        (circuit %foo.1 ((argument
                           (%n.2)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.3) (public-ledger 1 %field1.0 (0) lookup %n.2))
          (%t.3))
        (circuit %call_foo.4 ((argument
                                (%i.5)
                                (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.6) (public-ledger 1 %field1.0 (0) lookup %i.5))
          (%t.6))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(n).lookup(1);"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(i); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration
          ((%field1.0
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((aadt))
                      ((Map (ty ((afield)) ((tfield)))
                            (ty ((abytes 1)) ((tfield 1))))))))))
        (circuit %foo.1 ((argument
                           (%n.2)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.3)
             (public-ledger 1 %field1.0 (0 ((ty ((afield)) ((tfield)))
                                             %n.2)) lookup
               1))
          (%t.3))
        (circuit %call_foo.4 ((argument
                                (%i.5)
                                (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.6)
             (public-ledger 1 %field1.0 (0 ((ty ((afield)) ((tfield)))
                                             %i.5)) lookup
               1))
          (%t.6))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Boolean>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(disclose(n));"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(i); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration
          ((%field1.0
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((abytes 1)) ((tfield 1)))))))
        (circuit %foo.1 ((argument
                           (%n.2)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.3) (public-ledger 1 %field1.0 (0) lookup %n.2))
          (%t.3))
        (circuit %call_foo.4 ((argument
                                (%i.5)
                                (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.6) (public-ledger 1 %field1.0 (0) lookup %ni.5))
          (%t.6))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(n).lookup(1);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration
          ((%field1.0
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((aadt))
                      ((Map (ty ((afield)) ((tfield)))
                            (ty ((abytes 1)) ((tfield 1))))))))))
        (circuit %foo.1 ((argument
                           (%n.2)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.3)
             (public-ledger 1 %field1.0 (0 ((ty ((afield)) ((tfield)))
                                             %n.2)) lookup
               1))
          (%t.3))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(1).lookup(2);"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(3); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration
          ((%field1.0
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((aadt))
                      ((Map (ty ((afield)) ((tfield)))
                            (ty ((abytes 1)) ((tfield 1))))))))))
        (circuit %foo.1 ((argument
                           (%n.2)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.3)
             (public-ledger 1 %field1.0 (0 ((ty ((afield)) ((tfield))) 1)) lookup
               2))
          (%t.3))
        (circuit %call_foo.4 ((argument
                                (%i.5)
                                (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.6)
             (public-ledger 1 %field1.0 (0 ((ty ((afield)) ((tfield))) 1)) lookup
               2))
          (%t.6))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(1).lookup(disclose(n));"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(2); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration
          ((%field1.0
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((aadt))
                      ((Map (ty ((afield)) ((tfield)))
                            (ty ((abytes 1)) ((tfield 1))))))))))
        (circuit %foo.1 ((argument
                           (%n.2)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.3)
             (public-ledger 1 %field1.0 (0 ((ty ((afield)) ((tfield))) 1)) lookup
               %n.2))
          (%t.3))
        (circuit %call_foo.4 ((argument
                                (%i.5)
                                (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.6)
             (public-ledger 1 %field1.0 (0 ((ty ((afield)) ((tfield))) 1)) lookup
               2))
          (%t.6))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(n: Field): Boolean {"
      "  return field1.lookup(n).lookup(1);"
      "}"
      "export circuit call_foo(i: Field) : Boolean { return foo(2); }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration
          ((%field1.0
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((aadt))
                      ((Map (ty ((afield)) ((tfield)))
                            (ty ((abytes 1)) ((tfield 1))))))))))
        (circuit %foo.1 ((argument
                           (%n.2)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.3)
             (public-ledger 1 %field1.0 (0 ((ty ((afield)) ((tfield)))
                                           %n.2)) lookup
               1))
          (%t.3))
        (circuit %call_foo.4 ((argument
                                (%i.5)
                                (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.6)
             (public-ledger 1 %field1.0 (0 ((ty ((afield)) ((tfield))) 2)) lookup
               1))
          (%t.6))))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  assert(x == 3, 'oops 1');"
      "  return b;"
      "}"
      "export circuit call_foo(b: Boolean, x: Field): Boolean { return foo(b, x);}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%b.2)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.3) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.4 (== %x.3 3))
          (= %t.0 (select 1 %t.4 0))
          (= %t.5 %t.0)
          (= %t.6 (select 1 %t.0 1))
          (assert %t.6 "oops 1")
          (%b.2))
        (circuit %call_foo.7 ((argument
                                (%b.8)
                                (ty ((abytes 1)) ((tfield 1))))
                              (argument (%x.9) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.10 (== %x.9 3))
          (= %t.11 (select 1 %t.10 0))
          (= %t.12 %t.11)
          (= %t.13 (select 1 %t.11 1))
          (assert %t.13 "oops 1")
          (%b.8))))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  return true;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%b.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.2) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (1))))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  assert(x == 3, 'oops 1');"
      "  return b;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%b.2)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.3) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.4 (== %x.3 3))
          (= %t.0 (select 1 %t.4 0))
          (= %t.5 %t.0)
          (= %t.6 (select 1 %t.0 1))
          (assert %t.6 "oops 1")
          (%b.2))))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Uint<16>): Boolean {"
      "  assert(x <= 3, 'oops 1');"
      "  return b;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%b.2)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.3) (ty ((abytes 2)) ((tfield 65535)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.4 (< 16 3 %x.3))
          (= %t.5 (select %t.4 1 0))
          (= %t.6 (select %t.4 0 1))
          (= %t.0 (select %t.4 0 1))
          (= %t.7 (select 1 %t.0 1))
          (assert %t.7 "oops 1")
          (%b.2))))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  if (b)"
      "     assert(b, 'oops 1');"
      "  else"
      "     assert(x == 3, 'oops 2');"
      "  return b && x == 3;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%b.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.2) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.3 (select %b.1 1 0))
          (= %t.4 (select %b.1 0 1))
          (= %t.5 (== %x.2 3))
          (= %t.6 (select 1 %t.5 0))
          (= %t.7 %t.6)
          (= %t.8 (select %t.4 %t.6 1))
          (assert %t.8 "oops 2")
          (= %t.9 (select %b.1 1 0))
          (= %t.10 (select %b.1 0 1))
          (= %t.11 (== %x.2 3))
          (= %t.12 (select 1 %t.11 0))
          (= %t.13 %t.12)
          (= %t.14 (select %b.1 %t.12 0))
          (%t.14))))
    )

  (test
    `(
      "export circuit foo() : Vector<3, Vector<2, Field>> {"
      "  return [[1, 2], [3, 4], [5, 6]];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield) (afield) (afield) (afield) (afield) (afield))
                 ((tfield) (tfield) (tfield) (tfield) (tfield) (tfield)))
          (1 2 3 4 5 6))))
    )

  (test
    '(
       "export circuit baz(arg: Bytes<0>) : Field { return arg as Field; }"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.0 ((argument () (ty ((abytes 0)) ())))
             (ty ((afield)) ((tfield)))
          (0))))
    )

  (test
    '(
       "export circuit baz(arg: Bytes<20>) : Field { return arg as Field; }"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.0 ((argument
                           (%arg.1)
                           (ty ((abytes 20))
                               ((tfield
                                  1461501637330902918203684832716283019655932542975)))))
             (ty ((afield)) ((tfield)))
          (%arg.1))))
    )

  (test
    '(
       "export circuit baz(arg: Bytes<31>) : Field { return arg as Field; }"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.0 ((argument
                           (%arg.1)
                           (ty ((abytes 31))
                               ((tfield
                                  452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((afield)) ((tfield)))
          (%arg.1))))
    )

  (test
    '(
       "export circuit baz(arg: Bytes<32>) : Field { return arg as Field; }"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.1 ((argument
                           (%arg.2 %arg.0)
                           (ty ((abytes 32))
                               ((tfield 255)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((afield)) ((tfield)))
          (= %t.3 (bytes->field 1 32 %arg.2 %arg.0))
          (%t.3))))
    )

  (test
    '(
       "export circuit baz(arg: Bytes<40>) : Field { return arg as Field; }"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.1 ((argument
                           (%arg.2 %arg.0)
                           (ty ((abytes 40))
                               ((tfield 4722366482869645213695)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((afield)) ((tfield)))
          (= %t.3 (bytes->field 1 40 %arg.2 %arg.0))
          (%t.3))))
    )

  (test
    '(
       "export circuit baz(arg: Bytes<80>) : Field { return arg as Field; }"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.1 ((argument
                           (%arg.2 %arg.3 %arg.0)
                           (ty ((abytes 80))
                               ((tfield
                                  22300745198530623141535718272648361505980415)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((afield)) ((tfield)))
          (= %t.4 (== %arg.2 0))
          (assert %t.4 "bytes value is too big to fit in a field")
          (= %t.5 (bytes->field 1 80 %arg.3 %arg.0))
          (%t.5))))
    )

  (test
    '(
       "export circuit foo(arg: Field) : Bytes<0> { return arg as Bytes<0>; }"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%arg.1)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 0)) ())
          (= (%t.2 %t.3) (field->bytes 1 0 %arg.1))
          ())))
    )

  (test
    '(
       "export circuit foo(arg: Field) : Bytes<20> { return arg as Bytes<20>; }"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%arg.1)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 20))
                 ((tfield
                    1461501637330902918203684832716283019655932542975)))
          (= (%t.2 %t.3) (field->bytes 1 20 %arg.1))
          (%t.3))))
    )

  (test
    '(
       "export circuit foo(arg: Field) : Bytes<40> { return arg as Bytes<40>; }"
    )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%arg.1)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 40))
                 ((tfield 4722366482869645213695)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= (%t.2 %t.3) (field->bytes 1 40 %arg.1))
          (%t.2 %t.3))))
    )

  (test
    '(
       "export circuit foo(arg: Field) : Bytes<80> { return arg as Bytes<80>; }"
    )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%arg.1)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 80))
                 ((tfield 22300745198530623141535718272648361505980415)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= (%t.2 %t.3) (field->bytes 1 80 %arg.1))
          (0 %t.2 %t.3))))
    )

  (test
    '(
      "export circuit baz(arg: Boolean) : Field { return arg as Field; }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.0 ((argument
                           (%arg.1)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((afield)) ((tfield)))
          (= %t.2 (select %arg.1 1 0))
          (= %t.3 (select %arg.1 0 1))
          (= %t.4 (select %arg.1 1 0))
          (%t.4))))
    )

  (test
    '(
      "enum E { a, b, c }"
      "export circuit baz(arg: E) : Field { return arg as Field; }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.0 ((argument
                           (%arg.1)
                           (ty ((abytes 1)) ((tfield 2)))))
             (ty ((afield)) ((tfield)))
          (%arg.1))))
    )

  (test
    '(
      "export circuit baz(arg: Field) : Boolean { return arg as Boolean; }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.0 ((argument
                           (%arg.1)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.2 (== %arg.1 0))
          (= %t.3 (select 1 %t.2 0))
          (= %t.4 %t.3)
          (= %t.5 (select %t.3 1 0))
          (= %t.6 (select %t.3 0 1))
          (= %t.7 (select %t.3 0 1))
          (%t.7))))
    )

  (test
    '(
      "module A<#n, t> {"
      "  export circuit foo(v : Vector<n, t>, b : Bytes<n>): Field {"
      "    return 17;"
      "  }"
      "}"
      "module B {"
      "  circuit foo(x : Field): Field { return x + 1; }"
      "  circuit bar(x : Field): Field { return x - 1; }"
      "  import A<7, Field> prefix AA;"
      "  import A<30, Boolean> prefix AAA;"
      "  export {foo, AAfoo, AAAfoo, bar}"
      "}"
      "import B;"
      "import B prefix BB;"
      "import B<> prefix BBB;"
      "export {foo, AAfoo, BBfoo, BBAAfoo, BBBfoo, BBBAAAfoo, bar, BBbar, BBBbar}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.23 ((argument
                            (%v.24 %v.25 %v.26 %v.27 %v.28 %v.29 %v.30)
                            (ty ((afield) (afield) (afield) (afield) (afield)
                                  (afield) (afield))
                                ((tfield) (tfield) (tfield) (tfield) (tfield)
                                  (tfield) (tfield))))
                          (argument
                            (%b.31)
                            (ty ((abytes 7)) ((tfield 72057594037927935)))))
             (ty ((afield)) ((tfield)))
          (17))
        (circuit %foo.32 ((argument
                            (%v.33 %v.34 %v.35 %v.36 %v.37 %v.38 %v.39 %v.0
                             %v.1 %v.2 %v.3 %v.4 %v.5 %v.6 %v.7 %v.8 %v.9 %v.10
                             %v.11 %v.12 %v.13 %v.14 %v.15 %v.16 %v.17 %v.18
                             %v.19 %v.20 %v.21 %v.22)
                            (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1))
                                ((tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1))))
                          (argument
                            (%b.40)
                            (ty ((abytes 30))
                                ((tfield
                                   1766847064778384329583297500742918515827483896875618958121606201292619775)))))
             (ty ((afield)) ((tfield)))
          (17))
        (circuit %foo.41 ((argument
                            (%x.42)
                            (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= %t.43 (+ #f %x.42 1))
          (%t.43))
        (circuit %bar.44 ((argument
                            (%x.45)
                            (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= %t.46 (- #f %x.45 1))
          (%t.46))))
    )

  (test
    '(
      "export circuit foo(x: Vector<3, Field>): Boolean {"
      "  return x == [3, 4, 5];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%x.1 %x.2 %x.3)
                           (ty ((afield) (afield) (afield))
                               ((tfield) (tfield) (tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.4 (== %x.1 3))
          (= %t.5 (select 1 %t.4 0))
          (= %t.6 (== %x.2 4))
          (= %t.7 (select %t.5 %t.6 0))
          (= %t.8 (== %x.3 5))
          (= %t.9 (select %t.7 %t.8 0))
          (= %t.10 %t.9)
          (%t.9))))
    )

  (test
    '(
       "export circuit foo(a: Bytes<0>): Bytes<0> {"
       "  return a;"
       "}"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument () (ty ((abytes 0)) ())))
             (ty ((abytes 0)) ())
          ())))
    )

  (test
    '(
      "export circuit foo(): Vector<2, Vector<0, Field>> {"
      "  return [[], []];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 () (ty () ()) ())))
    )

  (test
    '(
       "export circuit foo(b: Bytes<31>) : Bytes<31> {"
       "  return b;"
       "}"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%b.1)
                           (ty ((abytes 31))
                               ((tfield
                                  452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((abytes 31))
                 ((tfield
                    452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (%b.1))))
    )

  (test
    '(
       "export circuit foo() : Bytes<31> {"
       "return 'abcdefghijklmnopqrstuvwxyz01234';"
       "}"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 31))
                 ((tfield
                    452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (92229389609740816795180269993859972877376305008880425034764490106789388897))))
    )

  (test
    '(
       "export circuit foo(a: Bytes<30>, b: Bytes<31>, c : Bytes<32>, d : Bytes<33>) : Bytes<40> {"
       "  return '1234567890123456789012345678901234567890';"
       "}"
       )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%a.2)
                           (ty ((abytes 30))
                               ((tfield
                                  1766847064778384329583297500742918515827483896875618958121606201292619775))))
                         (argument
                           (%b.3)
                           (ty ((abytes 31))
                               ((tfield
                                  452312848583266388373324160190187140051835877600158453279131187530910662655))))
                         (argument
                           (%c.4 %c.0)
                           (ty ((abytes 32))
                               ((tfield 255)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655))))
                         (argument
                           (%d.5 %d.6)
                           (ty ((abytes 33))
                               ((tfield 65535)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((abytes 40))
                 ((tfield 4722366482869645213695)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (889566821702876541746
            86908332635947936520937639616427602624961814622853568299663208045469708849))))
    )

  (test
    '(
      "export circuit foo() : Bytes<40> {"
      "  return pad(40, 'hello!');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 40))
                 ((tfield 4722366482869645213695)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (0 36762444129640))))
    )

  (test
    '(
      "witness bar(x: Bytes<50>) : [];"
      "export circuit foo() : [] {"
      "  bar(pad(50, 'hello!'));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.1 ((argument
                           (%x.2 %x.0)
                           (ty ((abytes 50))
                               ((tfield
                                  5708990770823839524233143877797980545530986495)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty () ()))
        (circuit %foo.3 ()
             (ty () ())
          (= () (call 1 %bar.1 0 36762444129640))
          ())))
    )

  (test
    '(
      "witness bar() : Bytes<50>;"
      "export circuit foo() : Bytes<50> {"
      "  return disclose(bar());"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.0 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (circuit %foo.1 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= (%t.2 %t.3) (call 1 %bar.0))
          (%t.2 %t.3))))
    )

  (test
    '(
      "export circuit foo(b: Boolean) : Bytes<50> {"
      "  return b ? pad(50, 'hello!') : pad(50, 'once upon a time in a galaxy far, far away');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%b.1)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= %t.2 (select %b.1 1 0))
          (= %t.3 (select %b.1 0 1))
          (= %t.4 (select %b.1 0 146740295883472840746347634))
          (= %t.5
             (select
               %b.1
               36762444129640
               172089018921478248217018581585884075052860504307373738624254165310312246895))
          (%t.4 %t.5))))
    )

  (test
    '(
      "circuit bar() : Bytes<50> { return pad(50, 'hello!'); }"
      "export circuit foo() : Bytes<50> {"
      "  const x : Bytes<50> = bar();"
      "  return x;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (0 36762444129640))))
    )

  (test
    '(
      "witness bar() : Bytes<50>;"
      "export circuit foo() : Bytes<50> {"
      "  const x : Bytes<50> = disclose(bar());"
      "  assert(x == pad(50, 'hello!'), 'oops');"
      "  return x;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.1 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (circuit %foo.2 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= (%x.3 %x.4) (call 1 %bar.1))
          (= %t.5 (== %x.3 0))
          (= %t.6 (select 1 %t.5 0))
          (= %t.7 (== %x.4 36762444129640))
          (= %t.0 (select %t.6 %t.7 0))
          (= %t.8 %t.0)
          (= %t.9 (select 1 %t.0 1))
          (assert %t.9 "oops")
          (%x.3 %x.4))))
    )

  (test
    '(
      "witness bar() : Bytes<50>;"
      "export circuit foo() : Bytes<50> {"
      "  const x : Bytes<50> = disclose(bar());"
      "  assert(x == pad(50, 'once upon a time in a galaxy far, far away'), 'oops');"
      "  return x;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.1 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (circuit %foo.2 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= (%x.3 %x.4) (call 1 %bar.1))
          (= %t.5 (== %x.3 146740295883472840746347634))
          (= %t.6 (select 1 %t.5 0))
          (= %t.7
             (== %x.4
                 172089018921478248217018581585884075052860504307373738624254165310312246895))
          (= %t.0 (select %t.6 %t.7 0))
          (= %t.8 %t.0)
          (= %t.9 (select 1 %t.0 1))
          (assert %t.9 "oops")
          (%x.3 %x.4))))
    )

  (test
    '(
      "export circuit foo() : Vector<2, Bytes<80>> {"
      "  const x = [pad(80, 'hello!'), pad(80, 'four score and seven years ago our fathers brought forth')];"
      "  const y = [pad(80, 'four score and seven years ago our fathers brought forth'), pad(80, 'hello!')];"
      "  assert(x == y, 'oops');"
      "  return x;"
      "}"
    )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ()
             (ty ((abytes 80) (abytes 80))
                 ((tfield 22300745198530623141535718272648361505980415)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield 22300745198530623141535718272648361505980415)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= %t.2 (== 0 0))
          (= %t.3 (select 1 %t.2 0))
          (= %t.4
             (== 0
                 655673852914079535706832728104650208561044890911829149250927))
          (= %t.5 (select %t.3 %t.4 0))
          (= %t.6
             (== 36762444129640
                 57307987020550611804426281024220409105956829700898855016698443841058205542))
          (= %t.7 (select %t.5 %t.6 0))
          (= %t.8 (== 0 0))
          (= %t.9 (select %t.7 %t.8 0))
          (= %t.10
             (== 655673852914079535706832728104650208561044890911829149250927
                 0))
          (= %t.11 (select %t.9 %t.10 0))
          (= %t.12
             (== 57307987020550611804426281024220409105956829700898855016698443841058205542
                 36762444129640))
          (= %t.0 (select %t.11 %t.12 0))
          (= %t.13 %t.0)
          (= %t.14 (select 1 %t.0 1))
          (assert %t.14 "oops")
          (0 0 36762444129640 0
             655673852914079535706832728104650208561044890911829149250927
             57307987020550611804426281024220409105956829700898855016698443841058205542))))
    )

  (test
    `(
      "export circuit foo(n: Field): Boolean {"
      ,(format "  return n == ~d;" (max-field))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 15" "constant ~d is larger than the largest representable Uint; use\n    ~:*~d as Field\n  to treat as a value of type Field" (,(max-field))))
    )

  (test
    `(
      "export circuit foo(n: Field): Boolean {"
      ,(format "  return n == ~d;" (+ (max-unsigned) 1))
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 15" "constant ~d is larger than the largest representable Uint; use\n    ~:*~d as Field\n  to treat as a value of type Field" (,(+ (max-unsigned) 1))))
    )

  (test
    `(
      "export circuit foo(n: Field): Boolean {"
      ,(format "  return n == ~d;" (max-unsigned))
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%n.1)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.2
             (== %n.1 ,(max-unsigned)))
          (= %t.3 (select 1 %t.2 0))
          (= %t.4 %t.3)
          (%t.3))))
    )

  (test
    `(
      "export circuit foo(n: Field): Boolean {"
      ,(format "  return n == ~d as Field;" (max-field))
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%n.1)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.2
             (== %n.1 ,(max-field)))
          (= %t.3 (select 1 %t.2 0))
          (= %t.4 %t.3)
          (%t.3))))
    )

  (test
    '(
      "enum Names { bill, sally, fred, george, }"
      "circuit foo<A>(): A {"
      "  return A.sally;"
      "}"
      "export circuit bar(): Names {"
      "  return foo<Names>();"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %bar.0 () (ty ((abytes 1)) ((tfield 3))) (1))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1.read();"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration ((field1 (0) (Counter))))
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= (%t.1) (public-ledger 1 field1 (0) read))
          (%t.1))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger x: Counter;"
      "export circuit foo(v: Vector<3, Boolean>): [] {"
      "  for (const i of disclose(v)) if (i) x += 1;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration ((%x.0 (0) (Counter))))
        (circuit %foo.1 ((argument
                           (%v.2 %v.3 %v.4)
                           (ty ((abytes 1) (abytes 1) (abytes 1))
                               ((tfield 1) (tfield 1) (tfield 1)))))
             (ty () ())
          (= %t.5 (select %v.2 1 0))
          (= %t.6 (select %v.2 0 1))
          (= () (public-ledger %t.5 %x.0 (0) increment 1))
          (= %t.7 (select %v.3 1 0))
          (= %t.8 (select %v.3 0 1))
          (= () (public-ledger %t.7 %x.0 (0) increment 1))
          (= %t.9 (select %v.4 1 0))
          (= %t.10 (select %v.4 0 1))
          (= () (public-ledger %t.9 %x.0 (0) increment 1))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger x: Counter;"
      "export circuit foo(): [] {"
      "  for (const i of 3 .. 7) x += i;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.6 () (Kernel)))
        (public-ledger-declaration ((x (0) (Counter))))
        (circuit %foo.0 ()
             (ty () ())
          (= () (public-ledger 1 x (0) increment 3))
          (= () (public-ledger 1 x (0) increment 4))
          (= () (public-ledger 1 x (0) increment 5))
          (= () (public-ledger 1 x (0) increment 6))
          ())))
    )

  (test
    '(
      "witness foo(x: Uint<5>): [];"
      "export circuit bar(a: Uint<4>, b: Uint<4>): [] {"
      "foo(a + b);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ((argument
                           (%x.1)
                           (ty ((abytes 1)) ((tfield 31)))))
             (ty () ()))
        (circuit %bar.2 ((argument
                           (%a.3)
                           (ty ((abytes 1)) ((tfield 15))))
                         (argument (%b.4) (ty ((abytes 1)) ((tfield 15)))))
             (ty () ())
          (= %t.5 (+ 5 %a.3 %b.4))
          (= () (call 1 %foo.0 %t.5))
          ())))
    )

  (test
    '(
      "export circuit foo(f: Field, x: Field):  [] {"
      "    if (x == 0) {"
      "        if (f as Uint<3> < 7) {"
      "            for (const i of 0 .. 0) {"
      "            }"
      "        }"
      "    }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%f.1)
                           (ty ((afield)) ((tfield))))
                         (argument (%x.2) (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.3 (== %x.2 0))
          (= %t.4 (select 1 %t.3 0))
          (= %t.5 %t.4)
          (= %t.6 (select %t.4 1 0))
          (= %t.7 (select %t.4 0 1))
          (= %t.8 (downcast-unsigned %t.6 7 %f.1))
          ())))
    )

  (test
    '(
      "export circuit foo(f: Field, x: Field):  [] {"
      "    if (x == 0) {"
      "        if (f as Uint<3> < 7) {"
      "            fold((a, x) => a, 7, [0]);"
      "        }"
      "    }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%f.1)
                           (ty ((afield)) ((tfield))))
                         (argument (%x.2) (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.3 (== %x.2 0))
          (= %t.4 (select 1 %t.3 0))
          (= %t.5 %t.4)
          (= %t.6 (select %t.4 1 0))
          (= %t.7 (select %t.4 0 1))
          (= %t.8 (downcast-unsigned %t.6 7 %f.1))
          ())))
    )

  (test
    '(
      "export circuit foo(f: Field, x: Field):  [] {"
      "  if (x == 0) {"
      "    if (f as Uint<3> < 7) {"
      "      3;"
      "    }"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%f.1)
                           (ty ((afield)) ((tfield))))
                         (argument (%x.2) (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.3 (== %x.2 0))
          (= %t.4 (select 1 %t.3 0))
          (= %t.5 %t.4)
          (= %t.6 (select %t.4 1 0))
          (= %t.7 (select %t.4 0 1))
          (= %t.8 (downcast-unsigned %t.6 7 %f.1))
          ())))
    )

  (test
    '(
      "export circuit foo(x: Uint<8>):  [] {"
      "  if (x != 0) {"
      "    if (x < 7) {"
      "      assert(false, 'oops');"
      "    }"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%x.1)
                           (ty ((abytes 1)) ((tfield 255)))))
             (ty () ())
          (= %t.2 (== %x.1 0))
          (= %t.3 (select 1 %t.2 0))
          (= %t.4 %t.3)
          (= %t.5 (select %t.3 1 0))
          (= %t.6 (select %t.3 0 1))
          (= %t.7 (select %t.3 0 1))
          (= %t.8 (select %t.7 1 0))
          (= %t.9 (select %t.7 0 1))
          (= %t.10 (< 8 %x.1 7))
          (= %t.11 (select %t.10 %t.8 0))
          (= %t.12 (select %t.10 0 %t.8))
          (= %t.13 (select %t.11 0 1))
          (assert %t.13 "oops")
          ())))
    )

  (test
    '(
      "export circuit foo(x: Field):  [] {"
      "  if (x != 0) {"
      "    if (x == 7) {"
      "      3;"
      "    }"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%x.1)
                           (ty ((afield)) ((tfield)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "export circuit foo(x: Field):  [] {"
      "  if (x != 0) {"
      "    if (x == 7) {"
      "      assert(false, 'oops');"
      "    }"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%x.1)
                           (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.2 (== %x.1 0))
          (= %t.3 (select 1 %t.2 0))
          (= %t.4 %t.3)
          (= %t.5 (select %t.3 1 0))
          (= %t.6 (select %t.3 0 1))
          (= %t.7 (select %t.3 0 1))
          (= %t.8 (select %t.7 1 0))
          (= %t.9 (select %t.7 0 1))
          (= %t.10 (== %x.1 7))
          (= %t.11 (select 1 %t.10 0))
          (= %t.12 %t.11)
          (= %t.13 (select %t.11 %t.8 0))
          (= %t.14 (select %t.11 0 %t.8))
          (= %t.15 (select %t.13 0 1))
          (assert %t.15 "oops")
          ())))
    )

  (test
    '(
      "export circuit foo(x: Boolean, y: Boolean): [] {"
      "  if (x) if (!y) 3;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%x.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%y.2) (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "export circuit foo(x: Boolean, y: Boolean): [] {"
      "  if (x) if (!y) assert(false, 'oops');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%x.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%y.2) (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          (= %t.3 (select %x.1 1 0))
          (= %t.4 (select %x.1 0 1))
          (= %t.5 (select %y.2 %t.3 0))
          (= %t.6 (select %y.2 0 %t.3))
          (= %t.7 (select %y.2 0 1))
          (= %t.8 (select %t.7 %t.3 0))
          (= %t.9 (select %t.7 0 %t.3))
          (= %t.10 (select %t.8 0 1))
          (assert %t.10 "oops")
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger a: Field;"
      "export circuit foo(x0: Boolean): [] {"
      "  const x = disclose(x0);"
      "  if (x) {"
      "    if (!x) {"
      "      a = 3;"
      "    }"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.4 () (Kernel)))
        (public-ledger-declaration
          ((%a.3 (0) (__compact_Cell (ty ((afield)) ((tfield)))))))
        (circuit %foo.5 ((argument
                           (%x0.6)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: [Field, Boolean]): Boolean {"
      "  return x[0] == 0 && x[1] == false;"
      "}"
      "export circuit foo(): Boolean {"
      "  return bar(default<[Field, Boolean]>);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.1 () (ty ((abytes 1)) ((tfield 1))) (1))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: [Field, Boolean]): Boolean {"
      "  return x[0] == 0 && x[1] == false;"
      "}"
      "export circuit foo(x: Field): Boolean {"
      "  return bar([disclose(x), default<Boolean>]);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.2 ((argument
                           (%x.0)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.3 (== %x.0 0))
          (= %t.4 (select 1 %t.3 0))
          (= %t.5 %t.4)
          (= %t.6 (select %t.4 1 0))
          (= %t.7 (select %t.4 0 1))
          (= %t.8 (select %t.4 1 0))
          (%t.8))))
    )

  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export circuit barr(): Bytes<32> { return pad(32, ''); }"
         )
       )
     (succeeds))
    ((create-file "UseC.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: [C, Field];"
         "constructor (c: C) { contract_c = default<[C, Field]>; }"
         ))
     (succeeds)
     ))

  ; PM-16065
  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger round: Counter;"
      "export ledger bob: Map<Vector<10, Boolean>, Counter>;"
      "export ledger c: List<Vector<20, Vector<20, Vector<20, Field>>>>;"
      "export ledger counter: Counter;"
      "export ledger boberto: Vector<10, Boolean>;"
      "export ledger pop: Map<Uint<32>, Field>;"
      "export ledger bop: Map<Uint<32>, Field>;"
      ""
      "circuit tom(s: Boolean): Uint<16> {"
      ""
      "    counter.increment(65535);"
      "    const r: Uint<64> = counter.read();"
      "    const rob = default<Vector<43590753987470154073008687018949015693739732443847, Uint<16>>>;"
      ""
      "    for (const i of rob) {"
      "      counter.increment(i);"
      "      const p = (r+i) * (i+i) * (r+i) * (i+i) * (r+i) * (i+i) * (r+4) * (i+4) * (r+5) * (i+5);"
      "      pop.insert(i, p);"
      "      const g = pop.lookup(i);"
      "      bop.insert(i+1, g);"
      "    }"
      ""
      "    return 1;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 14 char 25" "~a length\n  ~d\n  exceeds the maximum supported length ~d" ("vector type" 43590753987470154073008687018949015693739732443847 16777216)))
    )
)

(run-tests optimize-circuit
  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  return true;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%b.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.2) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (1))))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  assert(x == 3, 'oops 1');"
      "  return b;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.2 ((argument
                           (%b.3)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.0) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.1 (== %x.0 3))
          (assert %t.1 "oops 1")
          (%b.3))))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Uint<16>): Boolean {"
      "  assert(x <= 3, 'oops 1');"
      "  return b;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.3 ((argument
                           (%b.4)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.0) (ty ((abytes 2)) ((tfield 65535)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.1 (< 16 3 %x.0))
          (= %t.2 (select %t.1 0 1))
          (assert %t.2 "oops 1")
          (%b.4))))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Uint<16>): Boolean {"
      "  assert(x < x, 'oops 1');"
      "  return (3 < 2 || b);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%b.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.2) (ty ((abytes 2)) ((tfield 65535)))))
             (ty ((abytes 1)) ((tfield 1)))
          (assert 0 "oops 1")
          (%b.1))))

    )

  (test
    `(
      "export circuit foo(x: Uint<16>): Boolean {"
      "  assert(x < 100, 'oops 1');"
      "  return (x < 100);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.2 ((argument
                           (%x.0)
                           (ty ((abytes 2)) ((tfield 65535)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.1 (< 16 %x.0 100))
          (assert %t.1 "oops 1")
          (%t.1))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Boolean {"
      "  return b && 2 < 3;"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 1)) ((tfield 1)))
          (%b.0))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Boolean {"
      "  return b && 4 < 3;"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 1)) ((tfield 1)))
          (0))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Boolean {"
      "  const x  : Uint<16> = 4;"
      "  return b && x < 3;"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 1)) ((tfield 1)))
          (0))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Boolean {"
      "  const x  : Uint<16> = 2;"
      "  return b && 4 > 3 && x != 3 && x <= 5 && 5 >= 5;"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 1)) ((tfield 1)))
          (%b.0))))
    )

  (test
    `(
      "export circuit foo(b: Boolean): Boolean {"
      "  const x  : Uint<16> = 2;"
      "  return b || 3 > 4 || x != 2 || 5 <= x || 5 >= 6;"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 1)) ((tfield 1)))
          (%b.0))))
    )

  (test
    `(
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  if (b)"
      "     assert(b, 'oops 1');"
      "  else"
      "     assert(x == 3, 'oops 2');"
      "  return b && x == 3;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.4 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.1) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.2 (== %x.1 3))
          (= %t.3 (select %b.0 1 %t.2))
          (assert %t.3 "oops 2")
          (= %t.6 (select %b.0 %t.2 0))
          (%t.6))))
    )

  (test
    `(
      "export circuit foo() : Vector<3, Vector<2, Field>> {"
      "  return [[1, 2], [3, 4], [5, 6]];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield) (afield) (afield) (afield) (afield) (afield))
                 ((tfield) (tfield) (tfield) (tfield) (tfield) (tfield)))
          (1 2 3 4 5 6))))
    )

  (test
    `(
      "witness W() : Field;"
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  W();"
      "  return true;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 () (ty ((afield)) ((tfield))))
        (circuit %foo.1 ((argument
                           (%b.2)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.3) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.4) (call 1 %W.0))
          (1))))
    )

  (test
    `(
      "export circuit foo(): [] {"
      "  return;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 () (ty () ()) ())))
    )

  (test
    `(
      "struct pr { a: Boolean; d: Field; }"
      "witness W(a: Vector<3, pr>) : pr;"
      "witness S() : Vector<3, pr>;"
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  return disclose(W(S()).a);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 ((argument
                         (%a.1 %a.2 %a.3 %a.4 %a.5 %a.6)
                         (ty ((abytes 1) (afield) (abytes 1) (afield)
                               (abytes 1) (afield))
                             ((tfield 1) (tfield) (tfield 1) (tfield)
                               (tfield 1) (tfield)))))
             (ty ((abytes 1) (afield)) ((tfield 1) (tfield))))
        (witness %S.7 ()
             (ty ((abytes 1) (afield) (abytes 1) (afield) (abytes 1)
                   (afield))
                 ((tfield 1) (tfield) (tfield 1) (tfield) (tfield 1)
                   (tfield))))
        (circuit %foo.8 ((argument
                           (%b.9)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.10) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.11 %t.12 %t.13 %t.14 %t.15 %t.16) (call 1 %S.7))
          (= (%t.17 %t.18)
             (call 1 %W.0 %t.11 %t.12 %t.13 %t.14 %t.15 %t.16))
          (%t.17))))
    )

  (test
    `(
      "struct pr { a: Boolean; d: Field; }"
      "witness W(a: Vector<3, pr>) : pr;"
      "witness S() : Vector<3, pr>;"
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  const p = disclose(W(S()));"
      "  return p.d == 19 ? p.a : b;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.4 ((argument
                         (%a.5 %a.6 %a.7 %a.8 %a.9 %a.10)
                         (ty ((abytes 1) (afield) (abytes 1) (afield)
                               (abytes 1) (afield))
                             ((tfield 1) (tfield) (tfield 1) (tfield)
                               (tfield 1) (tfield)))))
             (ty ((abytes 1) (afield)) ((tfield 1) (tfield))))
        (witness %S.11 ()
             (ty ((abytes 1) (afield) (abytes 1) (afield) (abytes 1)
                   (afield))
                 ((tfield 1) (tfield) (tfield 1) (tfield) (tfield 1)
                   (tfield))))
        (circuit %foo.12 ((argument
                            (%b.2)
                            (ty ((abytes 1)) ((tfield 1))))
                          (argument (%x.13) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.14 %t.15 %t.16 %t.17 %t.18 %t.19) (call 1 %S.11))
          (= (%p.3 %p.0)
             (call 1 %W.4 %t.14 %t.15 %t.16 %t.17 %t.18 %t.19))
          (= %t.1 (== %p.0 19))
          (= %t.20 (select %t.1 %p.3 %b.2))
          (%t.20))))
    )

  (test
    `(
      "struct pr { a: Boolean; d: Field; }"
      "witness W1(a: Vector<3, pr>) : pr;"
      "witness W2(a: Vector<3, pr>) : pr;"
      "witness S() : Vector<3, pr>;"
      "export circuit foo(b: Boolean, x: Field): Boolean {"
      "  const p = b ? W1(S()) : W2(S());"
      "  return disclose(p.d == 19 ? p.a : b);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W1.8 ((argument
                          (%a.9 %a.10 %a.11 %a.12 %a.13 %a.14)
                          (ty ((abytes 1) (afield) (abytes 1) (afield)
                                (abytes 1) (afield))
                              ((tfield 1) (tfield) (tfield 1) (tfield)
                                (tfield 1) (tfield)))))
             (ty ((abytes 1) (afield)) ((tfield 1) (tfield))))
        (witness %W2.15 ((argument
                           (%a.16 %a.17 %a.18 %a.19 %a.20 %a.21)
                           (ty ((abytes 1) (afield) (abytes 1) (afield)
                                 (abytes 1) (afield))
                               ((tfield 1) (tfield) (tfield 1) (tfield)
                                 (tfield 1) (tfield)))))
             (ty ((abytes 1) (afield)) ((tfield 1) (tfield))))
        (witness %S.22 ()
             (ty ((abytes 1) (afield) (abytes 1) (afield) (abytes 1)
                   (afield))
                 ((tfield 1) (tfield) (tfield 1) (tfield) (tfield 1)
                   (tfield))))
        (circuit %foo.23 ((argument
                            (%b.0)
                            (ty ((abytes 1)) ((tfield 1))))
                          (argument (%x.24) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.25 (select %b.0 0 1))
          (= (%t.26 %t.27 %t.28 %t.29 %t.30 %t.31) (call %b.0 %S.22))
          (= (%t.2 %t.4)
             (call %b.0 %W1.8 %t.26 %t.27 %t.28 %t.29 %t.30 %t.31))
          (= (%t.32 %t.33 %t.34 %t.35 %t.36 %t.37) (call %t.25 %S.22))
          (= (%t.1 %t.3)
             (call %t.25 %W2.15 %t.32 %t.33 %t.34 %t.35 %t.36 %t.37))
          (= %p.7 (select %b.0 %t.2 %t.1))
          (= %p.5 (select %b.0 %t.4 %t.3))
          (= %t.6 (== %p.5 19))
          (= %t.38 (select %t.6 %p.7 %b.0))
          (%t.38))))
    )

  (test
    `(
      "witness foo(b: Boolean, x: Field): Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold((x, y) => disclose(foo(x, y)), true, v);"
      "  }"
      "}"
      "import M<0> prefix X$;"
      "import M<1> prefix Y$;"
      "import M<2> prefix Z$;"
      "export {X$C, Y$C, Z$C}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ((argument
                           (%b.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.2) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1))))
        (circuit %X$C.3 ((argument () (ty () ())))
             (ty ((abytes 1)) ((tfield 1)))
          (1))
        (circuit %Y$C.4 ((argument
                           (%v.5)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.6) (call 1 %foo.0 1 %v.5))
          (%t.6))
        (circuit %Z$C.7 ((argument
                           (%v.8 %v.9)
                           (ty ((afield) (afield)) ((tfield) (tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.10) (call 1 %foo.0 1 %v.8))
          (= (%t.11) (call 1 %foo.0 %t.10 %v.9))
          (%t.11))))
    )

  (test
    `(
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold((b, x) => b && x == 0,"
      "                true,"
      "                v);"
      "  }"
      "}"
      "import M<0>;"
      "import M<1>;"
      "import M<2>;"
      "export circuit bar1() : [] {"
      "  assert(C([]), 'oops 0');"
      "  assert(C([7]), 'oops 1');"
      "  assert(C([23, 57]), 'oops 2');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %bar1.0 ()
             (ty () ())
          (assert 0 "oops 1")
          (assert 0 "oops 2")
          ())))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    return map(foo, v);"
      "  }"
      "}"
      "import M<2>;"
      "export circuit bar(b: Boolean, n: Field) : Vector<2, Boolean> {"
      "  if (!b) assert(n == 0, 'oops');"
      "  return disclose(C([3, 7]));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.4 ((argument
                           (%n.5)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1))))
        (circuit %bar.6 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%n.1) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1) (abytes 1)) ((tfield 1) (tfield 1)))
          (= %t.2 (== %n.1 0))
          (= %t.3 (select %b.0 1 %t.2))
          (assert %t.3 "oops")
          (= (%t.8) (call 1 %foo.4 3))
          (= (%t.9) (call 1 %foo.4 7))
          (%t.8 %t.9))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "struct pr { a: Boolean; d: Field; }"
      "export circuit C(v: Vector<1, Field>, b: Boolean): Vector<1, Boolean> {"
      "  return map((x) => {"
      "               const q = pr{ a: b, d: x};"
      "               return q.a || q.a;"
      "             },"
      "             v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %C.1 ((argument (%v.2) (ty ((afield)) ((tfield))))
                       (argument (%b.0) (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 1)) ((tfield 1)))
          (%b.0))))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "export circuit C(v: Vector<3, Field>, b: Boolean): Vector<3, Boolean> {"
      "  return map((x) => b && disclose(foo(x + 1)),"
      "             v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.7 ((argument
                           (%n.8)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1))))
        (circuit %C.9 ((argument
                         (%v.1 %v.3 %v.5)
                         (ty ((afield) (afield) (afield))
                             ((tfield) (tfield) (tfield))))
                       (argument (%b.0) (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 1) (abytes 1) (abytes 1))
                 ((tfield 1) (tfield 1) (tfield 1)))
          (= %t.10 (+ #f %v.1 1))
          (= (%t.2) (call %b.0 %foo.7 %t.10))
          (= %t.11 (select %b.0 %t.2 0))
          (= %t.12 (+ #f %v.3 1))
          (= (%t.4) (call %b.0 %foo.7 %t.12))
          (= %t.13 (select %b.0 %t.4 0))
          (= %t.14 (+ #f %v.5 1))
          (= (%t.6) (call %b.0 %foo.7 %t.14))
          (= %t.15 (select %b.0 %t.6 0))
          (%t.11 %t.13 %t.15))))
    )

  (test
    `(
      "circuit foo(b: Boolean, x: Field): Boolean { return b && x == 0; }"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Boolean {"
      "    return fold(foo, true, v);"
      "  }"
      "}"
      "import M<0>;"
      "import M<1>;"
      "import M<2>;"
      "export circuit bar(v0: Vector<0, Field>, v1: Vector<1, Field>, v2: Vector<2, Field>) : [] {"
      "  assert(C(v0), 'oops 0');"
      "  assert(C(v1), 'oops 1');"
      "  assert(C(v2), 'oops 2');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %bar.7 ((argument () (ty () ()))
                         (argument (%v1.0) (ty ((afield)) ((tfield))))
                         (argument
                           (%v2.2 %v2.4)
                           (ty ((afield) (afield)) ((tfield) (tfield)))))
             (ty () ())
          (= %t.1 (== %v1.0 0))
          (assert %t.1 "oops 1")
          (= %t.3 (== %v2.2 0))
          (= %t.5 (== %v2.4 0))
          (= %t.6 (select %t.3 %t.5 0))
          (assert %t.6 "oops 2")
          ())))
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "export circuit F(b: Boolean, n: Field): Field {"
      "  const x = pr{ a: b, d: n};"
      "  const m = x.d * 2;"
      "  return x.a ? m + 1 : m + 2;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %F.5 ((argument
                         (%b.1)
                         (ty ((abytes 1)) ((tfield 1))))
                       (argument (%n.0) (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= %m.2 (* #f %n.0 2))
          (= %t.4 (+ #f %m.2 1))
          (= %t.3 (+ #f %m.2 2))
          (= %t.7 (select %b.1 %t.4 %t.3))
          (%t.7))))
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "circuit F(b: Boolean, n: Field): Field {"
      "  const x = pr{a: b, d: n};"
      "  const m = x.d * 2;"
      "  return b ? m + 1 : m - 2;"
      "}"
      "export circuit C() : Field {"
      "  return F(false, 17);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %C.0 () (ty ((afield)) ((tfield))) (32))))
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "export circuit C(u: Vector<2, Field>, v: Vector<2, Boolean>): Vector<2, Field> {"
      "  return map((a, b) => b ? 2 * a : 0,"
      "             u, v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %C.6 ((argument
                         (%u.1 %u.4)
                         (ty ((afield) (afield)) ((tfield) (tfield))))
                       (argument
                         (%v.0 %v.3)
                         (ty ((abytes 1) (abytes 1))
                             ((tfield 1) (tfield 1)))))
             (ty ((afield) (afield)) ((tfield) (tfield)))
          (= %t.2 (* #f 2 %u.1))
          (= %t.7 (select %v.0 %t.2 0))
          (= %t.5 (* #f 2 %u.4))
          (= %t.8 (select %v.3 %t.5 0))
          (%t.7 %t.8))))
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "circuit C(u: Vector<2, Field>, v: Vector<2, Boolean>): Vector<2, Field> {"
      "  return map((a, b) => b ? 2 * a : 0,"
      "             u, v);"
      "}"
      "export circuit D() : [] {"
      "  assert(C([7, 11], [false, false])[1] == 1, 'oops 1');"
      "  assert(C([7, 11], [false, true])[0] == 0, 'oops 2');"
      "  assert(C([7, 11], [true, false])[0] == 14, 'oops 3');"
      "  assert(C([7, 11], [true, true])[1] == 22,  'oops 4');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %D.0 () (ty () ()) (assert 0 "oops 1") ())))
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "witness foo() : pr;"
      "export circuit C(): Field {"
      "  return disclose(foo().d);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ()
             (ty ((abytes 1) (afield)) ((tfield 1) (tfield))))
        (circuit %C.1 ()
             (ty ((afield)) ((tfield)))
          (= (%t.2 %t.3) (call 1 %foo.0))
          (%t.3))))
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "export circuit C(p: pr): Field {"
      "  return p.d;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %C.0 ((argument
                         (%p.1 %p.2)
                         (ty ((abytes 1) (afield)) ((tfield 1) (tfield)))))
             (ty ((afield)) ((tfield)))
          (%p.2))))
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "witness foo() : pr;"
      "export circuit C(): Field {"
      "  const p = foo();"
      "  return disclose(p.d);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ()
             (ty ((abytes 1) (afield)) ((tfield 1) (tfield))))
        (circuit %C.1 ()
             (ty ((afield)) ((tfield)))
          (= (%p.2 %p.3) (call 1 %foo.0))
          (%p.3))))
    )

  (test
    '(
      "struct pr { a: Boolean; d: Field; }"
      "export circuit C(n: Field): Boolean {"
      "  const p = pr{a:true,d:n};"
      "  assert(!(p.d == 0), 'oops');"
      "  return p.a;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %C.3 ((argument (%n.0) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.1 (== %n.0 0))
          (= %t.2 (select %t.1 0 1))
          (assert %t.2 "oops")
          (1))))
    )

  (test
    '(
      "export circuit foo(n: Field) : [] { return; }"
      "export circuit C(v: Vector<3, Field>): Vector<3, []> {"
      "  return map(foo, v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%n.1)
                           (ty ((afield)) ((tfield)))))
             (ty () ())
          ())
        (circuit %C.2 ((argument
                         (%v.3 %v.4 %v.5)
                         (ty ((afield) (afield) (afield))
                             ((tfield) (tfield) (tfield)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "export circuit foo(x: [], n: Field) : [] { return; }"
      "export circuit C(v: Vector<3, Field>): [] {"
      "  return fold(foo, [], v);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument () (ty () ()))
                         (argument (%n.1) (ty ((afield)) ((tfield)))))
             (ty () ())
          ())
        (circuit %C.2 ((argument
                         (%v.3 %v.4 %v.5)
                         (ty ((afield) (afield) (afield))
                             ((tfield) (tfield) (tfield)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "circuit foo(n: Field) : [] { return; }"
      "circuit bar(n: Field) : [] { return; }"
      "export circuit C(b: Boolean, n: Field, m: Field): [] {"
      "  return b ? foo(n) : bar(m);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %C.1 ((argument
                         (%b.0)
                         (ty ((abytes 1)) ((tfield 1))))
                       (argument (%n.2) (ty ((afield)) ((tfield))))
                       (argument (%m.3) (ty ((afield)) ((tfield)))))
             (ty () ())
          ())))
    )

  (test
    `(
      "witness foo(n: Field) : Boolean;"
      "module M<#n> {"
      "  export circuit C(v: Vector<n, Field>): Vector<n, Boolean> {"
      "    const w = v;"
      "    return map((x) => {"
      "                const y = x + 1;"
      "                return disclose(foo(y));"
      "                 },"
      "                 w);"
      "  }"
      "}"
      "import M<2>;"
      "export circuit bar() : Vector<2, Boolean> {"
      "  return C([3, 7]);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %foo.0 ((argument
                           (%n.1)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1))))
        (circuit %bar.2 ()
             (ty ((abytes 1) (abytes 1)) ((tfield 1) (tfield 1)))
          (= (%t.3) (call 1 %foo.0 4))
          (= (%t.4) (call 1 %foo.0 8))
          (%t.3 %t.4))))
    )

  (test
    '(
      "module A<#n, t> {"
      "  export circuit foo(v : Vector<n, t>, b : Bytes<n>): Field {"
      "    return 17;"
      "  }"
      "}"
      "module B {"
      "  circuit foo(x : Field): Field { return x + 1; }"
      "  circuit bar(x : Field): Field { return x - 1; }"
      "  import A<7, Field> prefix AA;"
      "  import A<30, Boolean> prefix AAA;"
      "  export {foo, AAfoo, AAAfoo, bar}"
      "}"
      "import B;"
      "import B prefix BB;"
      "import B<> prefix BBB;"
      "export {foo, AAfoo, BBfoo, BBAAfoo, BBAAAfoo, BBBfoo, BBBAAAfoo, bar, BBbar, BBBbar}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.33 ((argument
                            (%v.34 %v.35 %v.36 %v.37 %v.38 %v.39 %v.40)
                            (ty ((afield) (afield) (afield) (afield) (afield)
                                  (afield) (afield))
                                ((tfield) (tfield) (tfield) (tfield) (tfield)
                                  (tfield) (tfield))))
                          (argument
                            (%b.41)
                            (ty ((abytes 7)) ((tfield 72057594037927935)))))
             (ty ((afield)) ((tfield)))
          (17))
        (circuit %foo.42 ((argument
                            (%v.2 %v.3 %v.4 %v.5 %v.6 %v.7 %v.8 %v.9 %v.10
                             %v.11 %v.12 %v.13 %v.14 %v.15 %v.16 %v.17 %v.18
                             %v.19 %v.20 %v.21 %v.22 %v.23 %v.24 %v.25 %v.26
                             %v.27 %v.28 %v.29 %v.30 %v.31)
                            (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1))
                                ((tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1) (tfield 1) (tfield 1)
                                 (tfield 1) (tfield 1))))
                          (argument
                            (%b.32)
                            (ty ((abytes 30))
                                ((tfield
                                   1766847064778384329583297500742918515827483896875618958121606201292619775)))))
             (ty ((afield)) ((tfield)))
          (17))
        (circuit %foo.43 ((argument
                            (%x.1)
                            (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= %t.44 (+ #f %x.1 1))
          (%t.44))
        (circuit %bar.45 ((argument
                            (%x.0)
                            (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= %t.46 (- #f %x.0 1))
          (%t.46))))
    )

  (test
    '(
      "export circuit bar(x : Field): Bytes<20> {"
      "  assert(!(x == 0), 'oops');"
      "  return x == 0 || !(x == 0) ? pad(20, 'goof') : pad(20, 'ball');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %bar.3 ((argument
                           (%x.0)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 20))
                 ((tfield
                    1461501637330902918203684832716283019655932542975)))
          (= %t.1 (== %x.0 0))
          (= %t.2 (select %t.1 0 1))
          (assert %t.2 "oops")
          (1718579047))))
    )

  (test
    '(
      "export circuit bar(x : Field): Field {"
      "  assert(!(x - x == 0), 'oops');"
      "  if (x == 17) assert(!(x == 17), 'oops 1');"
      "  if (!(x == x)) assert(!(x == 17), 'oops 2');"
      "  if (!(0 == x)) assert(!(17 == x), 'oops 3');"
      "  assert(x == 59 ? false : x == 61, 'oops 4');"
      "  assert(x - 17 == x - 17, 'oops 5');"
      "  assert(x == 7 ? x == 17 : x == 19, 'oops 6');"
      "  assert(!(x == 7 ? x == 17 : x == 19), 'oops 7');"
      "  return x - 0 == x || x == 53 ? (x == 17 && !(x == x) ? 37 : x * 0 + x * 1) : 23;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %bar.13 ((argument
                            (%x.0)
                            (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (assert 0 "oops")
          (= %t.1 (== %x.0 17))
          (= %t.2 (select %t.1 0 1))
          (assert %t.2 "oops 1")
          (= %t.3 (== 0 %x.0))
          (= %t.5 (select %t.3 1 %t.2))
          (assert %t.5 "oops 3")
          (= %t.6 (== %x.0 59))
          (= %t.7 (== %x.0 61))
          (= %t.8 (select %t.6 0 %t.7))
          (assert %t.8 "oops 4")
          (= %t.9 (== %x.0 7))
          (= %t.10 (== %x.0 19))
          (= %t.11 (select %t.9 %t.1 %t.10))
          (assert %t.11 "oops 6")
          (= %t.12 (select %t.11 0 1))
          (assert %t.12 "oops 7")
          (%x.0))))
    )

  (test
    '(
      "export circuit foo(x : Field, y: Field): Field {"
      "  assert(x * 5 + 99999999999999999999999999999999999999999999999999 == y, 'oops 2');"
      "  return x * 5 + 99999999999999999999999999999999999999999999999999;"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.5 ((argument
                           (%x.0)
                           (ty ((afield)) ((tfield))))
                         (argument (%y.2) (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= %t.1 (* #f %x.0 5))
          (= %t.3
             (+ #f
                %t.1
                99999999999999999999999999999999999999999999999999))
          (= %t.4 (== %t.3 %y.2))
          (assert %t.4 "oops 2")
          (%t.3))))
    )

  (test
    '(
      "export circuit foo(x : Field, y: Field): Field {"
      "  assert(x == y ? x == 0 : true, 'oops');"
      "  return (x == y ? x == 0 : true) ? x : y;"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.5 ((argument
                           (%x.1)
                           (ty ((afield)) ((tfield))))
                         (argument (%y.0) (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= %t.2 (== %x.1 %y.0))
          (= %t.3 (== %x.1 0))
          (= %t.4 (select %t.2 %t.3 1))
          (assert %t.4 "oops")
          (= %t.6 (select %t.4 %x.1 %y.0))
          (%t.6))))
    )

  (test
    '(
      "export circuit foo(a : Boolean, b: Boolean): [] {"
      "  if (b) assert(b, 'oops 1');"
      "  if (a) if (b) assert(a, 'oops 2');"
      "  if (a) if (b) assert(b, 'oops 3');"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.3 ((argument
                           (%a.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%b.0) (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "export circuit foo(a : Boolean, b: Boolean): [] {"
      "  if (b) assert(b, 'oops 1'); else assert(b, 'oops 2');"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%a.2)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%b.0) (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          (assert %b.0 "oops 2")
          ())))
    )

  (test
    '(
      "export circuit foo(a : Boolean, b: Boolean): [] {"
      "  if (a) {"
      "    return;"
      "  } else {"
      "    if (b) assert(a, 'oops 1');"
      "  }"
      "}"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.5 ((argument
                           (%a.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%b.2) (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          (= %t.1 (select %a.0 0 1))
          (= %t.3 (select %b.2 %t.1 0))
          (= %t.4 (select %t.3 0 1))
          (assert %t.4 "oops 1")
          ())))
    )

  (test
    '(
      "export circuit foo(x: Vector<3, Field>): Boolean {"
      "  return x == [3, 4, 5];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.7 ((argument
                           (%x.0 %x.1 %x.4)
                           (ty ((afield) (afield) (afield))
                               ((tfield) (tfield) (tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.3 (== %x.0 3))
          (= %t.2 (== %x.1 4))
          (= %t.6 (select %t.3 %t.2 0))
          (= %t.5 (== %x.4 5))
          (= %t.8 (select %t.6 %t.5 0))
          (%t.8))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return disclose(W<B>(S(q))); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "// export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "// export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "// export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 ((argument (%x.1) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1))))
        (circuit %foo1.2 ((argument
                            (%x.3)
                            (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.4) (call 1 %W.0 %x.3))
          (%t.4))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return disclose(W<B>(S(q))); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "// export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "// export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "// export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 ((argument (%x.1) (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield))))
        (circuit %foo2.2 ((argument
                            (%x.3)
                            (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= (%t.4) (call 1 %W.0 %x.3))
          (%t.4))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return disclose(W<B>(S(q))); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "// export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "// export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "// export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 ((argument
                         (%x.1)
                         (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 1)) ((tfield 1))))
        (circuit %foo3.2 ((argument
                            (%x.3)
                            (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.4) (call 1 %W.0 %x.3))
          (%t.4))))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "module M<A> {"
      "  witness W<C>(x: A): C;"
      "  circuit S(q: A): A { return q; }"
      "  export circuit T<B>(q: A): B { return disclose(W<B>(S(q))); }"
      "}"
      "import M<Field>;"
      "import M<Boolean>;"
      "// export circuit foo1(x: Field): Boolean { return T<Boolean>(x); }"
      "// export circuit foo2(x: Field): Field { return T<Field>(x); }"
      "// export circuit foo3(x: Boolean): Boolean { return T<Boolean>(x); }"
      "export circuit foo4(x: Boolean): Field { return T<Field>(x); }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.0 ((argument
                         (%x.1)
                         (ty ((abytes 1)) ((tfield 1)))))
             (ty ((afield)) ((tfield))))
        (circuit %foo4.2 ((argument
                            (%x.3)
                            (ty ((abytes 1)) ((tfield 1)))))
             (ty ((afield)) ((tfield)))
          (= (%t.4) (call 1 %W.0 %x.3))
          (%t.4))))
    )

  (test
    '(
      "export circuit foo(b: Boolean, c: Boolean): Bytes<10> {"
      "  const x = 'abcdefghij';"
      "  const y = 'abcdefghij';"
      "  const z = b ? x : y;"
      "  const w = !b ? y : x;"
      "  return c ? z : w;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.2 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%c.1) (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 10)) ((tfield 1208925819614629174706175)))
          (502515278406210103239265))))
    )

  (test
    '(
      "witness bar(s1: Bytes<10>, s2: Bytes<10>): Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  const x = 'abcdefghij';"
      "  const y = 'abcdefghij';"
      "  assert(bar(x, y), 'abcdefghij');"
      "  assert(bar(x, y), 'abcdefghij');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.2 ((argument
                           (%s1.3)
                           (ty ((abytes 10))
                               ((tfield 1208925819614629174706175))))
                         (argument
                           (%s2.4)
                           (ty ((abytes 10))
                               ((tfield 1208925819614629174706175)))))
             (ty ((abytes 1)) ((tfield 1))))
        (circuit %foo.5 ((argument
                           (%b.6)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          (= (%t.0)
             (call 1 %bar.2
               502515278406210103239265
               502515278406210103239265))
          (assert %t.0 "abcdefghij")
          (= (%t.1)
             (call 1 %bar.2
               502515278406210103239265
               502515278406210103239265))
          (assert %t.1 "abcdefghij")
          ())))
    )

  (test
    '(
      "export circuit foo(b: Boolean, c: Boolean, d: Bytes<10>): Bytes<10> {"
      "  const x = 'abcdefghij';"
      "  const y = 'abcdefghij';"
      "  const z = b ? x : d;"
      "  const w = !b ? y : d;"
      "  return c ? z : w;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.5 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%c.2) (ty ((abytes 1)) ((tfield 1))))
                         (argument
                           (%d.1)
                           (ty ((abytes 10))
                               ((tfield 1208925819614629174706175)))))
             (ty ((abytes 10)) ((tfield 1208925819614629174706175)))
          (= %z.4 (select %b.0 502515278406210103239265 %d.1))
          (= %w.3 (select %b.0 %d.1 502515278406210103239265))
          (= %t.6 (select %c.2 %z.4 %w.3))
          (%t.6))))
    )

  (test
    '(
      "witness bar() : [];"
      "export circuit foo(): [] {"
      "  if (false) bar();"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.0 () (ty () ()))
        (circuit %foo.1 () (ty () ()) ())))
    )

  (test
    '(
      "witness bar() : Vector<3, Field>;"
      "export circuit foo(): [] {"
      "  if (false) {"
      "     const x = bar();"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.0 ()
             (ty ((afield) (afield) (afield))
                 ((tfield) (tfield) (tfield))))
        (circuit %foo.1 () (ty () ()) ())))
    )

  (test
    '(
      "export circuit foo() : Bytes<40> {"
      "  return pad(40, 'hello!');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 40))
                 ((tfield 4722366482869645213695)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (0 36762444129640))))
    )

  (test
    '(
      "witness bar(x: Bytes<50>) : [];"
      "export circuit foo() : [] {"
      "  bar(pad(50, 'hello!'));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.1 ((argument
                           (%x.2 %x.0)
                           (ty ((abytes 50))
                               ((tfield
                                  5708990770823839524233143877797980545530986495)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty () ()))
        (circuit %foo.3 ()
             (ty () ())
          (= () (call 1 %bar.1 0 36762444129640))
          ())))
    )

  (test
    '(
      "witness bar() : Bytes<50>;"
      "export circuit foo() : Bytes<50> {"
      "  return disclose(bar());"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.0 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (circuit %foo.1 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= (%t.2 %t.3) (call 1 %bar.0))
          (%t.2 %t.3))))
    )

  (test
    '(
      "export circuit foo(b: Boolean) : Bytes<50> {"
      "  return b ? pad(50, 'hello!') : pad(50, 'once upon a time in a galaxy far, far away');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= %t.2 (select %b.0 0 146740295883472840746347634))
          (= %t.3
             (select
               %b.0
               36762444129640
               172089018921478248217018581585884075052860504307373738624254165310312246895))
          (%t.2 %t.3))))
    )

  (test
    '(
      "export circuit foo() : Vector<2, Bytes<80>> {"
      "  const x = [pad(80, 'hello!'), pad(80, 'four score and seven years ago our fathers brought forth')];"
      "  const y = [pad(80, 'four score and seven years ago our fathers brought forth'), pad(80, 'hello!')];"
      "  assert(x == y, 'oops');"
      "  return x;"
      "}"
    )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 80) (abytes 80))
                 ((tfield 22300745198530623141535718272648361505980415)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield 22300745198530623141535718272648361505980415)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (assert 0 "oops")
          (0 0 36762444129640 0
             655673852914079535706832728104650208561044890911829149250927
             57307987020550611804426281024220409105956829700898855016698443841058205542))))
    )

  (test
    '(
      "circuit bar() : Bytes<50> { return pad(50, 'hello!'); }"
      "export circuit foo() : Bytes<50> {"
      "  const x : Bytes<50> = bar();"
      "  return x;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ()) (circuit %foo.0 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (0 36762444129640))))
    )

  (test
    '(
      "circuit bar() : Bytes<50> { return pad(50, 'hello!'); }"
      "export circuit foo() : Bytes<50> {"
      "  const x : Bytes<50> = bar();"
      "  assert(x == pad(50, 'hello!'), 'oops');"
      "  return x;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (0 36762444129640))))
    )

  (test
    '(
      "circuit bar() : Bytes<50> { return pad(50, 'hello!'); }"
      "export circuit foo() : Bytes<50> {"
      "  const x : Bytes<50> = bar();"
      "  assert(x == pad(50, 'once upon a time in a galaxy far, far away'), 'oops');"
      "  return x;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 50))
                 ((tfield 5708990770823839524233143877797980545530986495)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (assert 0 "oops")
          (0 36762444129640))))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Field): Field {"
      "  return 1 + ((b: Field, x: Boolean): Field => x ? b - 1 : b + 1)(x + 1, !b);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.7 ((argument
                           (%b.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.0) (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= %b.2 (+ #f %x.0 1))
          (= %t.3 (- #f %b.2 1))
          (= %t.4 (+ #f %b.2 1))
          (= %t.5 (select %b.1 %t.4 %t.3))
          (= %t.6 (+ #f 1 %t.5))
          (%t.6))))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Field): Field {"
      "  return 1 + ((b, x) => x ? b - 1 : b + 1)(x + 1, !b);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.7 ((argument
                           (%b.1)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x.0) (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (= %b.2 (+ #f %x.0 1))
          (= %t.3 (- #f %b.2 1))
          (= %t.4 (+ #f %b.2 1))
          (= %t.5 (select %b.1 %t.4 %t.3))
          (= %t.6 (+ #f 1 %t.5))
          (%t.6))))
    )

  (test
    '(
       "witness bar(bv1: Bytes<80>, bv2: Bytes<80>): Bytes<160>;"
       "export circuit foo(arg: Field) : Bytes<160> { return disclose(bar(arg as Bytes<80>, arg as Bytes<80>)); }"
    )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %bar.2 ((argument
                           (%bv1.3 %bv1.4 %bv1.1)
                           (ty ((abytes 80))
                               ((tfield
                                  22300745198530623141535718272648361505980415)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655))))
                         (argument
                           (%bv2.5 %bv2.6 %bv2.7)
                           (ty ((abytes 80))
                               ((tfield
                                  22300745198530623141535718272648361505980415)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((abytes 160))
                 ((tfield 1099511627775)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (circuit %foo.8 ((argument
                           (%arg.0)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 160))
                 ((tfield 1099511627775)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= (%t.9 %t.10) (field->bytes 1 80 %arg.0))
          (= (%t.11 %t.12 %t.13 %t.14 %t.15 %t.16)
             (call 1 %bar.2 0 %t.9 %t.10 0 %t.9 %t.10))
          (%t.11 %t.12 %t.13 %t.14 %t.15 %t.16))))
    )

  (test
    '(
       "export circuit baz(arg: Bytes<80>) : Field { return (arg as Field) + (arg as Field); }"
     )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.5 ((argument
                           (%arg.0 %arg.3 %arg.2)
                           (ty ((abytes 80))
                               ((tfield
                                  22300745198530623141535718272648361505980415)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((afield)) ((tfield)))
          (= %t.1 (== %arg.0 0))
          (assert %t.1 "bytes value is too big to fit in a field")
          (= %t.4 (bytes->field 1 80 %arg.3 %arg.2))
          (= %t.6 (+ #f %t.4 %t.4))
          (%t.6))))
    )

  (test
    '(
      "export circuit baz(arg: Boolean) : Field { return arg as Field; }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.1 ((argument
                           (%arg.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((afield)) ((tfield)))
          (%arg.0))))
    )

  (test
    '(
      "enum E { a, b, c }"
      "export circuit baz(arg: E) : Field { return arg as Field; }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.0 ((argument
                           (%arg.1)
                           (ty ((abytes 1)) ((tfield 2)))))
             (ty ((afield)) ((tfield)))
          (%arg.1))))
    )

  (test
    '(
      "export circuit baz(arg: Field) : Boolean { return arg as Boolean; }"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %baz.2 ((argument
                           (%arg.0)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.1 (== %arg.0 0))
          (= %t.3 (select %t.1 0 1))
          (%t.3))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "witness merkle_path_root(foo: Foo): MerkleTreeDigest;"
      ""
      "ledger field1: Map<Field, Foo>;"
      "ledger field2: HistoricMerkleTree<10, Foo>;"
      "ledger field3: Boolean;"
      ""
      "export circuit foo(n: Field, foo: Foo): Boolean {"
      "  field3.write(field1.lookup(disclose(n)).baz);"
      "  const q = field1.lookup(disclose(n));"
      "  assert(!(q == default<Foo>), 'entry not found');"
      "  return field2.checkRoot(disclose(merkle_path_root(q)));"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.9 () (Kernel)))
        (public-ledger-declaration
          ((%field1.10
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((abytes 32) (abytes 1))
                      ((tfield 255)
                        (tfield
                          452312848583266388373324160190187140051835877600158453279131187530910662655)
                        (tfield 1)))))
           (%field2.11
             (1)
             (HistoricMerkleTree
               10
               (ty ((abytes 32) (abytes 1))
                   ((tfield 255)
                     (tfield
                       452312848583266388373324160190187140051835877600158453279131187530910662655)
                     (tfield 1)))))
           (%field3.12
             (2)
             (__compact_Cell (ty ((abytes 1)) ((tfield 1)))))))
        (witness %merklePathRoot.13 ((argument
                                         (%foo.14 %foo.15 %foo.16)
                                         (ty ((abytes 32) (abytes 1))
                                             ((tfield 255)
                                               (tfield
                                                 452312848583266388373324160190187140051835877600158453279131187530910662655)
                                               (tfield 1)))))
             (ty ((afield)) ((tfield))))
        (circuit %foo.17 ((argument
                            (%n.18)
                            (ty ((afield)) ((tfield))))
                          (argument
                            (%foo.19 %foo.20 %foo.21)
                            (ty ((abytes 32) (abytes 1))
                                ((tfield 255)
                                  (tfield
                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                  (tfield 1)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= (%t.22 %t.23 %t.24)
             (public-ledger 1 %field1.10 (0) lookup %n.18))
          (= () (public-ledger 1 %field3.12 (2) write %t.24))
          (= (%q.0 %q.1 %q.4)
             (public-ledger 1 %field1.10 (0) lookup %n.18))
          (= %t.3 (== %q.0 0))
          (= %t.2 (== %q.1 0))
          (= %t.6 (select %t.3 %t.2 0))
          (= %t.5 (== %q.4 0))
          (= %t.7 (select %t.6 %t.5 0))
          (= %t.8 (select %t.7 0 1))
          (assert %t.8 "entry not found")
          (= (%tmp.25) (call 1 %merklePathRoot.13 %q.0 %q.1 %q.4))
          (= (%t.26)
             (public-ledger 1 %field2.11 (1) checkRoot %tmp.25))
          (%t.26))))
   )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1.read();"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration ((%field1.0 (0) (Counter))))
        (circuit %foo.1 ()
             (ty ((afield)) ((tfield)))
          (= (%t.2) (public-ledger 1 %field1.0 (0) read))
          (%t.2))))
    )

  (test ;; FIXME uncomment the composable contract
    "test-center/compact/test.compact"
    (returns
      (program
        (kernel-declaration (%kernel.13 () (Kernel)))
        (public-ledger-declaration
          (((%x0.14 (0 0) (__compact_Cell (ty ((afield)) ((tfield)))))
             (%x1.15 (0 1) (Set (ty ((afield)) ((tfield)))))
             (%x2.16 (0 2) (Counter)))
           ((%x3.17 (1 0) (List (ty ((afield)) ((tfield)))))
             (%x4.18
               (1 1)
               (Map (ty ((afield)) ((tfield)))
                    (ty ((abytes 1)) ((tfield 1)))))
             (%x5.19 (1 2) (MerkleTree 32 (ty ((afield)) ((tfield)))))
             (%x6.20
               (1 3)
               (HistoricMerkleTree 10 (ty ((afield)) ((tfield)))))
             (%x7.21
               (1 4)
               (__compact_Cell
                 (ty ((abytes 32) (abytes 32) (abytes 16))
                     ((tfield 255)
                       (tfield
                         452312848583266388373324160190187140051835877600158453279131187530910662655)
                       (tfield 255)
                       (tfield
                         452312848583266388373324160190187140051835877600158453279131187530910662655)
                       (tfield 340282366920938463463374607431768211455)))))
             (%x10.22 (1 5) (__compact_Cell (ty ((afield)) ((tfield)))))
             (%x11.23
               (1 6)
               (__compact_Cell
                 (ty ((abytes 32) (abytes 32) (abytes 16) (abytes 8))
                     ((tfield 255)
                       (tfield
                         452312848583266388373324160190187140051835877600158453279131187530910662655)
                       (tfield 255)
                       (tfield
                         452312848583266388373324160190187140051835877600158453279131187530910662655)
                       (tfield 340282366920938463463374607431768211455)
                       (tfield 18446744073709551615)))))
             (%x13.24
               (1 7)
               (__compact_Cell
                 (ty ((abytes 32))
                     ((tfield 255)
                       (tfield
                         452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (%authority.25
               (1 8)
               (__compact_Cell
                 (ty ((abytes 32))
                     ((tfield 255)
                       (tfield
                         452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (%state.26
               (1 9)
               (__compact_Cell (ty ((abytes 1)) ((tfield 3)))))
             (%topic.27
               (1 10)
               (__compact_Cell
                 (ty ((abytes 1) (acompress))
                     ((tfield 1) (topaque "string")))))
             (%tally_yes.28 (1 11) (Counter))
             (%committed_votes.29
               (1 12)
               (MerkleTree
                 10
                 (ty ((abytes 32))
                     ((tfield 255)
                       (tfield
                         452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (%committed.30
               (1 13)
               (Set (ty ((abytes 32))
                        ((tfield 255)
                          (tfield
                            452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (%ciphertexts.31
               (1 14)
               (__compact_Cell
                 (ty ((acompress)) ((topaque "Uint8Array"))))))))
        (circuit %foo.32 ((argument
                            (%a.33)
                            (ty ((abytes 1)) ((tfield 1))))
                          (argument (%b.34) (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (0))
        (circuit %bar.35 ((argument
                            (%a.1)
                            (ty ((abytes 1)) ((tfield 1))))
                          (argument (%b.2) (ty ((abytes 1)) ((tfield 1)))))
             (ty ((afield)) ((tfield)))
          (= %t.3 (select %a.1 0 1))
          (= %t.4 (select %b.2 %t.3 0))
          (= %t.5 (select %t.4 0 1))
          (assert %t.5 "a should be false")
          (= (%t.6 %t.8) (public-ledger 1 %kernel.13 () self))
          (= (%t.7 %t.9) (public-ledger 1 %kernel.13 () self))
          (= %t.11 (== %t.6 %t.7))
          (= %t.10 (== %t.8 %t.9))
          (= %t.12 (select %t.11 %t.10 0))
          (assert %t.12 "oops")
          (= (%t.36) (public-ledger 1 %x0.14 (0 0) read))
          (%t.36))
        (circuit %baz.37 ((argument
                            (%b.0)
                            (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 2)) ((tfield 1023)))
          (%b.0))
        (circuit %nullX.38 () (ty ((abytes 1)) ((tfield 1))) (0))))
    )

  (test
    "examples/tiny.compact"
    (returns
      (program
        (kernel-declaration (%kernel.14 () (Kernel)))
        (public-ledger-declaration
          ((%authority.15
             (0)
             (__compact_Cell
               (ty ((abytes 32))
                   ((tfield 255)
                     (tfield
                       452312848583266388373324160190187140051835877600158453279131187530910662655)))))
           (%value.16 (1) (__compact_Cell (ty ((afield)) ((tfield)))))
           (%state.17
             (2)
             (__compact_Cell (ty ((abytes 1)) ((tfield 1)))))))
        (external %persistentHash.18 ((argument
                                         (%value.19
                                           %value.20
                                           %value.21
                                           %value.22)
                                         (ty ((abytes 32) (abytes 32))
                                             ((tfield 255)
                                               (tfield
                                                 452312848583266388373324160190187140051835877600158453279131187530910662655)
                                               (tfield 255)
                                               (tfield
                                                 452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((abytes 32))
                 ((tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (witness %private$secret_key.23 ()
             (ty ((abytes 32))
                 ((tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (circuit %set.24 ((argument
                            (%v.25)
                            (ty ((afield)) ((tfield)))))
             (ty () ())
          (= (%t.9) (public-ledger 1 %state.17 (2) read))
          (= %t.10 (== %t.9 0))
          (assert %t.10 "set: attempted to overwrite recorded value")
          (= (%sk.26 %sk.27) (call 1 %private$secret_key.23))
          (= (%apk.28 %apk.29)
             (call 1 %persistentHash.18
               0
               1184891903413063782045712785760620
               %sk.26
               %sk.27))
          (= ()
             (public-ledger 1 %authority.15 (0) write %apk.28 %apk.29))
          (= () (public-ledger 1 %value.16 (1) write %v.25))
          (= () (public-ledger 1 %state.17 (2) write 1))
          ())
        (circuit %get.30 ()
             (ty ((abytes 1) (afield)) ((tfield 1) (tfield)))
          (= (%t.11) (public-ledger 1 %state.17 (2) read))
          (= %t.12 (== %t.11 1))
          (= (%value.13) (public-ledger %t.12 %value.16 (1) read))
          (= %t.31 (select %t.12 %value.13 0))
          (%t.12 %t.31))
        (circuit %clear.32 ()
             (ty () ())
          (= (%t.0) (public-ledger 1 %state.17 (2) read))
          (= %t.1 (== %t.0 1))
          (assert %t.1 "clear: no value is currently recorded")
          (= (%sk.33 %sk.34) (call 1 %private$secret_key.23))
          (= (%apk.2 %apk.4)
             (call 1 %persistentHash.18
               0
               1184891903413063782045712785760620
               %sk.33
               %sk.34))
          (= (%t.3 %t.5) (public-ledger 1 %authority.15 (0) read))
          (= %t.7 (== %apk.2 %t.3))
          (= %t.6 (== %apk.4 %t.5))
          (= %t.8 (select %t.7 %t.6 0))
          (assert %t.8
            "clear: attempted clear without proper authorization")
          (= () (public-ledger 1 %authority.15 (0) write 0 0))
          (= () (public-ledger 1 %value.16 (1) write 0))
          (= () (public-ledger 1 %state.17 (2) write 0))
          ())
        (circuit %public_key.35 ((argument
                                   (%sk.36 %sk.37)
                                   (ty ((abytes 32))
                                       ((tfield 255)
                                         (tfield
                                           452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((abytes 32))
                 ((tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= (%t.38 %t.39)
             (call 1 %persistentHash.18
               0
               1184891903413063782045712785760620
               %sk.36
               %sk.37))
          (%t.38 %t.39))))
    )

  (test ; just see if it succeeds
    "examples/zerocash.compact"
    (succeeds))

  (test ; just see if it succeeds
    "examples/election.compact"
    (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
   (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
   (succeeds))

  (test ; just see if it succeeds
   "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
   (succeeds))

  (test
    '(
      "export circuit foo(): Boolean {"
      "  return 5 as Boolean;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 () (ty ((abytes 1)) ((tfield 1))) (1))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Uint<8>): Boolean {"
      "  return (x + x - x) == (x - x + x);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.5 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.6 ((argument
                           (%x.0)
                           (ty ((abytes 1)) ((tfield 255)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.1 (+ 9 %x.0 %x.0))
          (= %t.2 (< 9 %t.1 %x.0))
          (= %t.3 (select %t.2 0 1))
          (assert %t.3 "result of subtraction would be negative")
          (= %t.4 (- 9 %t.1 %x.0))
          (= %t.7 (== %t.4 %x.0))
          (%t.7))))
    )

  (test
    '(
      "export circuit foo(x: Uint<8>, y: Uint<8>): Boolean {"
      "  return x - y == x - y;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.4 ((argument
                           (%x.1)
                           (ty ((abytes 1)) ((tfield 255))))
                         (argument (%y.0) (ty ((abytes 1)) ((tfield 255)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.2 (< 8 %x.1 %y.0))
          (= %t.3 (select %t.2 0 1))
          (assert %t.3 "result of subtraction would be negative")
          (1))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Uint<8>): Boolean {"
      "  return (x + x - x as Uint<7>) == (x + x - x as Uint<7>);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.5 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.6 ((argument
                           (%x.0)
                           (ty ((abytes 1)) ((tfield 255)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.1 (+ 9 %x.0 %x.0))
          (= %t.2 (< 9 %t.1 %x.0))
          (= %t.3 (select %t.2 0 1))
          (assert %t.3 "result of subtraction would be negative")
          (= %t.4 (- 9 %t.1 %x.0))
          (= %t.7 (downcast-unsigned 1 127 %t.4))
          (1))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(): Uint<8> {"
      "  return 12 - (3 * (1 + 3));"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.1 () (ty ((abytes 1)) ((tfield 255))) (0))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(): Uint<8> {"
      "  return 12 - 13;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.2 ()
             (ty ((abytes 1)) ((tfield 255)))
          (assert 0 "result of subtraction would be negative")
          (= %t.0 (- 4 12 13))
          (%t.0))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "ledger X : Field;"
      "export circuit foo(x: Uint<32>, y: Field, z: Bytes<256>): Boolean {"
      "  // should not discard this because it is an implicit assert:"
      "  const t1 : Uint<8> = x as Uint<8>;"
      "  // should not discard this because it is an implicit assert:"
      "  const t2 : Uint<8> = y as Uint<8>;"
      "  // possibly should not discard this because it is a public-state read:"
      "  const t3 : Field = X;"
      "  // *should* discard this:"
      "  const t5 : Field = x + y;"
      "  // should not discard this because it is an implicit assert:"
      "  const t6 : Field = z as Field;"
      "  // should not discard this because it is an implicit assert:"
      "  const t7 : Bytes<8> = y as Bytes<8>;"
      "  return true;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.18 () (Kernel)))
        (public-ledger-declaration
          ((%X.19 (0) (__compact_Cell (ty ((afield)) ((tfield)))))))
        (circuit %foo.20 ((argument
                            (%x.0)
                            (ty ((abytes 4)) ((tfield 4294967295))))
                          (argument (%y.1) (ty ((afield)) ((tfield))))
                          (argument
                            (%z.2 %z.4 %z.6 %z.8 %z.10 %z.12 %z.14 %z.17 %z.16)
                            (ty ((abytes 256))
                                ((tfield 18446744073709551615)
                                  (tfield
                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                  (tfield
                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                  (tfield
                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                  (tfield
                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                  (tfield
                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                  (tfield
                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                  (tfield
                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                  (tfield
                                    452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t1.21 (downcast-unsigned 1 255 %x.0))
          (= %t2.22 (downcast-unsigned 1 255 %y.1))
          (= (%t3.23) (public-ledger 1 %X.19 (0) read))
          (= %t6.3 (== %z.2 0))
          (assert %t6.3 "bytes value is too big to fit in a field")
          (= %t6.5 (== %z.4 0))
          (assert %t6.5 "bytes value is too big to fit in a field")
          (= %t6.7 (== %z.6 0))
          (assert %t6.7 "bytes value is too big to fit in a field")
          (= %t6.9 (== %z.8 0))
          (assert %t6.9 "bytes value is too big to fit in a field")
          (= %t6.11 (== %z.10 0))
          (assert %t6.11 "bytes value is too big to fit in a field")
          (= %t6.13 (== %z.12 0))
          (assert %t6.13 "bytes value is too big to fit in a field")
          (= %t6.15 (== %z.14 0))
          (assert %t6.15 "bytes value is too big to fit in a field")
          (= %t6.24 (bytes->field 1 256 %z.17 %z.16))
          (= (%t7.25 %t7.26) (field->bytes 1 8 %y.1))
          (1))))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "ledger ctr : Counter;"
      "export circuit foo(): Field {"
      "  const t1 = ctr;"
      "  ctr += t1 as Uint<16>;"
      "  // make sure this actually redoes the read:"
      "  return ctr;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration ((%ctr.1 (0) (Counter))))
        (circuit %foo.2 ()
             (ty ((afield)) ((tfield)))
          (= (%t1.0) (public-ledger 1 %ctr.1 (0) read))
          (= %tmp.3 (downcast-unsigned 1 65535 %t1.0))
          (= () (public-ledger 1 %ctr.1 (0) increment %tmp.3))
          (= (%t.4) (public-ledger 1 %ctr.1 (0) read))
          (%t.4))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(format "  const t1 = ~d as Field;" (max-field))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(max-field)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(format "  const t1 = ~d as Field;" (max-field))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(max-field)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(format "  const t1 : Field = ~d as Field;" (max-field))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(max-field)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(let* ([n1 123456789123456789] [n2 (- (max-field) n1)])
         (format "  const t1 : Field = ~d + ~d;" n1 n2))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: `("testfile.compact line 2 char 43" "constant ~d is larger than the largest representable Uint; use\n    ~:*~d as Field\n  to treat as a value of type Field" (,(let* ([n1 123456789123456789] [n2 (- (max-field) n1)]) n2))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(let* ([n1 123456789123456789] [n2 (- (max-field) n1)])
         (format "  const t1 : Field = ~d + (~d as Field);" n1 n2))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(max-field)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(format "  const t1 = ~d as Field;" (+ (max-unsigned) 1))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(+ (max-unsigned) 1)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(format "  const t1 = ~d as Field;" (+ (max-unsigned) 1))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(+ (max-unsigned) 1)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(format "  const t1 : Field = ~d as Field;" (+ (max-unsigned) 1))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(+ (max-unsigned) 1)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(let* ([n1 123456789123456789] [n2 (- (+ (max-unsigned) 1) n1)])
         (format "  const t1 : Field = (~d as Field) + (~d as Field);" n1 n2))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(+ (max-unsigned) 1)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(format "  const t1 = ~d as Field;" (max-unsigned))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(max-unsigned)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(format "  const t1 : Field = ~d;" (max-unsigned))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(max-unsigned)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(let* ([n1 123456789123456789] [n2 (- (max-unsigned) n1)])
         (format "  const t1 : Field = (~d as Field) + (~d as Field);" n1 n2))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456789
               ,(max-unsigned)))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      "  const t1 : Field = 123456789000000000 + 123456789;"
      "  const t2 = t1 as Bytes<4>;"
      "  // the assignment of t3 should turn into t3 = t2 because Bytes<4> fits in one Field value"
      "  // and optimize-circuit should discard it and propagate t2 straight to the reference fo t3"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ()
             (ty ((afield)) ((tfield)))
          (= (%t2.2 %t2.0) (field->bytes 1 4 123456789123456789))
          (= %t4.3 (downcast-unsigned 1 123456789123456789 %t2.0))
          (%t4.3))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      ,(format "  const t1 : Field = (~d as Field) + (~:*~d as Field);" (max-field))
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456789>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1
               123456789123456788
               ,(modulo (* (max-field) 2) (+ (max-field) 1))))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      "  const t1 : Field = 123456789000000000 + 123456789;"
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456789>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (= %t4.1
             (downcast-unsigned 1 123456789123456788 123456789123456789))
          (%t4.1))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      "  const t1 : Field = 123456789000000000 + 123456789;"
      "  const t2 = t1 as Bytes<256>;"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456790>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((afield)) ((tfield)))
          (123456789123456789))))
    )

  (test
    `(
      "export circuit foo(): Field {"
      "  const t2 : Bytes<256> = '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$';"
      "  const t3 = t2 as Field;"
      "  const t4 = t3 as Uint<0..123456789123456789>;"
      "  return t4;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ()
             (ty ((afield)) ((tfield)))
          (assert 0 "bytes value is too big to fit in a field")
          (= %t3.0
             (bytes->field 1 256
               63855931564696431299763410850379360948494476837669428698230285298481505316
               63855931564696431299763410850379360948494476837669428698230285298481505316))
          (= %t4.2 (downcast-unsigned 1 123456789123456788 %t3.0))
          (%t4.2))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit relay(coin: CoinInfo, target: ContractAddress): [] {"
      "  receive(disclose(coin));"
      "  const foo = sendImmediate(disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(disclose(target)), disclose(coin.value));"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.3 () (Kernel)))
        (public-ledger-declaration ())
        (external %transientHash.4 ((argument
                                       (%value.5 %value.6)
                                       (ty ((afield) (afield))
                                           ((tfield) (tfield)))))
             (ty ((afield)) ((tfield))))
        (external %persistentHash<.7 ((argument
                                        (%value.8 %value.9 %value.10 %value.11
                                          %value.12 %value.13 %value.0 %value.1
                                          %value.2)
                                        (ty ((abytes 32) (abytes 32) (abytes 16)
                                              (abytes 1) (abytes 32)
                                              (abytes 6))
                                            ((tfield 255)
                                              (tfield
                                                452312848583266388373324160190187140051835877600158453279131187530910662655)
                                              (tfield 255)
                                              (tfield
                                                452312848583266388373324160190187140051835877600158453279131187530910662655)
                                              (tfield
                                                340282366920938463463374607431768211455)
                                              (tfield 1) (tfield 255)
                                              (tfield
                                                452312848583266388373324160190187140051835877600158453279131187530910662655)
                                              (tfield 281474976710655)))))
             (ty ((abytes 32))
                 ((tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (external %degradeToTransient.14 ((argument
                                              (%x.15 %x.16)
                                              (ty ((abytes 32))
                                                  ((tfield 255)
                                                    (tfield
                                                      452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((afield)) ((tfield))))
        (external %upgradeFromTransient.17 ((argument
                                                (%x.18)
                                                (ty ((afield)) ((tfield)))))
             (ty ((abytes 32))
                 ((tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (external %createZswapInput.19 ((argument
                                            (%coin.20 %coin.21 %coin.22
                                              %coin.23 %coin.24 %coin.25)
                                            (ty ((abytes 32)
                                                  (abytes 32)
                                                  (abytes 16)
                                                  (abytes 8))
                                                ((tfield 255)
                                                  (tfield
                                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                  (tfield 255)
                                                  (tfield
                                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                  (tfield
                                                    340282366920938463463374607431768211455)
                                                  (tfield
                                                    18446744073709551615)))))
             (ty () ()))
        (external %createZswapOutput.26 ((argument
                                             (%coin.27
                                               %coin.28
                                               %coin.29
                                               %coin.30
                                               %coin.31)
                                             (ty ((abytes 32)
                                                   (abytes 32)
                                                   (abytes 16))
                                                 ((tfield 255)
                                                   (tfield
                                                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                   (tfield 255)
                                                   (tfield
                                                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                   (tfield
                                                     340282366920938463463374607431768211455))))
                                           (argument
                                             (%recipient.32
                                               %recipient.33
                                               %recipient.34
                                               %recipient.35
                                               %recipient.36)
                                             (ty ((abytes 1)
                                                   (abytes 32)
                                                   (abytes 32))
                                                 ((tfield 1)
                                                   (tfield 255)
                                                   (tfield
                                                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                   (tfield 255)
                                                   (tfield
                                                     452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty () ()))
        (circuit %relay.37 ((argument
                              (%coin.38 %coin.39 %coin.40 %coin.41 %coin.42)
                              (ty ((abytes 32) (abytes 32) (abytes 16))
                                  ((tfield 255)
                                    (tfield
                                      452312848583266388373324160190187140051835877600158453279131187530910662655)
                                    (tfield 255)
                                    (tfield
                                      452312848583266388373324160190187140051835877600158453279131187530910662655)
                                    (tfield
                                      340282366920938463463374607431768211455))))
                            (argument
                              (%target.43 %target.44)
                              (ty ((abytes 32))
                                  ((tfield 255)
                                    (tfield
                                      452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty () ())
          (= (%value.45 %value.46)
             (public-ledger 1 %kernel.3 () self))
          (= ()
             (call 1 %createZswapOutput.26
               %coin.38
               %coin.39
               %coin.40
               %coin.41
               %coin.42
               0
               0
               0
               %value.45
               %value.46))
          (= (%tmp.47 %tmp.48)
             (call 1 %persistentHash<.7
               %coin.38
               %coin.39
               %coin.40
               %coin.41
               %coin.42
               0
               %value.45
               %value.46
               109277833225325))
          (= ()
             (public-ledger 1 %kernel.3 ()
               claimZswapCoinReceive
               %tmp.47
               %tmp.48))
          (= (%selfAddr.49 %selfAddr.50)
             (public-ledger 1 %kernel.3 () self))
          (= ()
             (call 1 %createZswapInput.19
               %coin.38
               %coin.39
               %coin.40
               %coin.41
               %coin.42
               0))
          (= (%tmp.51 %tmp.52)
             (call 1 %persistentHash<.7
               %coin.38
               %coin.39
               %coin.40
               %coin.41
               %coin.42
               0
               %selfAddr.49
               %selfAddr.50
               121372461130861))
          (= ()
             (public-ledger 1 %kernel.3 ()
               claimZswapNullifier
               %tmp.51
               %tmp.52))
          (= (%t.53)
             (call 1 %degradeToTransient.14 %coin.38 %coin.39))
          (= (%t.54)
             (call 1 %transientHash.4
               10685258091935385184760267925849721347998787314052891846880509847917
               %t.53))
          (= (%t.55 %t.56) (call 1 %upgradeFromTransient.17 %t.54))
          (= ()
             (call 1 %createZswapOutput.26
               %t.55
               %t.56
               %coin.40
               %coin.41
               %coin.42
               0
               0
               0
               %target.43
               %target.44))
          (= (%tmp.57 %tmp.58)
             (call 1 %persistentHash<.7
               %t.55
               %t.56
               %coin.40
               %coin.41
               %coin.42
               0
               %target.43
               %target.44
               109277833225325))
          (= ()
             (public-ledger 1 %kernel.3 ()
               claimZswapCoinSpend
               %tmp.57
               %tmp.58))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit relay(coin: CoinInfo, target: ContractAddress): SendResult {"
      "  receive(disclose(coin));"
      "  return sendImmediate(disclose(coin), disclose(right<ZswapCoinPublicKey, ContractAddress>(target)), disclose(coin.value));"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.3 () (Kernel)))
        (public-ledger-declaration ())
        (external %transientHash.4 ((argument
                                       (%value.5 %value.6)
                                       (ty ((afield) (afield))
                                           ((tfield) (tfield)))))
             (ty ((afield)) ((tfield))))
        (external %persistentHash<.7 ((argument
                                        (%value.8 %value.9 %value.10 %value.11
                                          %value.12 %value.13 %value.0 %value.1
                                          %value.2)
                                        (ty ((abytes 32) (abytes 32) (abytes 16)
                                              (abytes 1) (abytes 32)
                                              (abytes 6))
                                            ((tfield 255)
                                              (tfield
                                                452312848583266388373324160190187140051835877600158453279131187530910662655)
                                              (tfield 255)
                                              (tfield
                                                452312848583266388373324160190187140051835877600158453279131187530910662655)
                                              (tfield
                                                340282366920938463463374607431768211455)
                                              (tfield 1) (tfield 255)
                                              (tfield
                                                452312848583266388373324160190187140051835877600158453279131187530910662655)
                                              (tfield 281474976710655)))))
             (ty ((abytes 32))
                 ((tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (external %degradeToTransient.14 ((argument
                                              (%x.15 %x.16)
                                              (ty ((abytes 32))
                                                  ((tfield 255)
                                                    (tfield
                                                      452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((afield)) ((tfield))))
        (external %upgradeFromTransient.17 ((argument
                                                (%x.18)
                                                (ty ((afield)) ((tfield)))))
             (ty ((abytes 32))
                 ((tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655))))
        (external %createZswapInput.19 ((argument
                                            (%coin.20 %coin.21 %coin.22
                                              %coin.23 %coin.24 %coin.25)
                                            (ty ((abytes 32)
                                                  (abytes 32)
                                                  (abytes 16)
                                                  (abytes 8))
                                                ((tfield 255)
                                                  (tfield
                                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                  (tfield 255)
                                                  (tfield
                                                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                  (tfield
                                                    340282366920938463463374607431768211455)
                                                  (tfield
                                                    18446744073709551615)))))
             (ty () ()))
        (external %createZswapOutput.26 ((argument
                                             (%coin.27
                                               %coin.28
                                               %coin.29
                                               %coin.30
                                               %coin.31)
                                             (ty ((abytes 32)
                                                   (abytes 32)
                                                   (abytes 16))
                                                 ((tfield 255)
                                                   (tfield
                                                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                   (tfield 255)
                                                   (tfield
                                                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                   (tfield
                                                     340282366920938463463374607431768211455))))
                                           (argument
                                             (%recipient.32
                                               %recipient.33
                                               %recipient.34
                                               %recipient.35
                                               %recipient.36)
                                             (ty ((abytes 1)
                                                   (abytes 32)
                                                   (abytes 32))
                                                 ((tfield 1)
                                                   (tfield 255)
                                                   (tfield
                                                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                                                   (tfield 255)
                                                   (tfield
                                                     452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty () ()))
        (circuit %relay.37 ((argument
                              (%coin.38 %coin.39 %coin.40 %coin.41 %coin.42)
                              (ty ((abytes 32) (abytes 32) (abytes 16))
                                  ((tfield 255)
                                    (tfield
                                      452312848583266388373324160190187140051835877600158453279131187530910662655)
                                    (tfield 255)
                                    (tfield
                                      452312848583266388373324160190187140051835877600158453279131187530910662655)
                                    (tfield
                                      340282366920938463463374607431768211455))))
                            (argument
                              (%target.43 %target.44)
                              (ty ((abytes 32))
                                  ((tfield 255)
                                    (tfield
                                      452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((abytes 1) (abytes 32) (abytes 32) (abytes 16)
                   (abytes 32) (abytes 32) (abytes 16))
                 ((tfield 1) (tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield 340282366920938463463374607431768211455)
                   (tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield 340282366920938463463374607431768211455)))
          (= (%value.45 %value.46)
             (public-ledger 1 %kernel.3 () self))
          (= ()
             (call 1 %createZswapOutput.26
               %coin.38
               %coin.39
               %coin.40
               %coin.41
               %coin.42
               0
               0
               0
               %value.45
               %value.46))
          (= (%tmp.47 %tmp.48)
             (call 1 %persistentHash<.7
               %coin.38
               %coin.39
               %coin.40
               %coin.41
               %coin.42
               0
               %value.45
               %value.46
               109277833225325))
          (= ()
             (public-ledger 1 %kernel.3 ()
               claimZswapCoinReceive
               %tmp.47
               %tmp.48))
          (= (%selfAddr.49 %selfAddr.50)
             (public-ledger 1 %kernel.3 () self))
          (= ()
             (call 1 %createZswapInput.19
               %coin.38
               %coin.39
               %coin.40
               %coin.41
               %coin.42
               0))
          (= (%tmp.51 %tmp.52)
             (call 1 %persistentHash<.7
               %coin.38
               %coin.39
               %coin.40
               %coin.41
               %coin.42
               0
               %selfAddr.49
               %selfAddr.50
               121372461130861))
          (= ()
             (public-ledger 1 %kernel.3 ()
               claimZswapNullifier
               %tmp.51
               %tmp.52))
          (= (%t.53)
             (call 1 %degradeToTransient.14 %coin.38 %coin.39))
          (= (%t.54)
             (call 1 %transientHash.4
               10685258091935385184760267925849721347998787314052891846880509847917
               %t.53))
          (= (%t.55 %t.56) (call 1 %upgradeFromTransient.17 %t.54))
          (= ()
             (call 1 %createZswapOutput.26
               %t.55
               %t.56
               %coin.40
               %coin.41
               %coin.42
               0
               0
               0
               %target.43
               %target.44))
          (= (%tmp.57 %tmp.58)
             (call 1 %persistentHash<.7
               %t.55
               %t.56
               %coin.40
               %coin.41
               %coin.42
               0
               %target.43
               %target.44
               109277833225325))
          (= ()
             (public-ledger 1 %kernel.3 ()
               claimZswapCoinSpend
               %tmp.57
               %tmp.58))
          (0 0 0 0 0 0 %t.55 %t.56 %coin.40 %coin.41 %coin.42))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Field;"
      "circuit foo(x: Field, y: Field): Bytes<32> {"
      "  if (x == y) {"
      "    return x as Bytes<32>;"
      "  } else {"
      "    return disclose(W()) as Bytes<32>;"
      "  }"
      "}"
      "export circuit bar(x: Field): Bytes<32> {"
      "  return foo(x, x);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.2 () (Kernel)))
        (public-ledger-declaration ())
        (witness %W.3 () (ty ((afield)) ((tfield))))
        (circuit %bar.4 ((argument
                           (%x.0)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 32))
                 ((tfield 255)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= (%t.5 %t.6) (field->bytes 1 32 %x.0))
          (%t.5 %t.6))))
    )

  (test
    '(
      "export circuit foo(x: Uint<32>): Uint<8> {"
      "  if (x < 256) {"
      "    return x as Uint<8>;"
      "  } else {"
      "    return 0;"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.4 ((argument
                           (%x.0)
                           (ty ((abytes 4)) ((tfield 4294967295)))))
             (ty ((abytes 1)) ((tfield 255)))
          (= %t.1 (< 32 %x.0 256))
          (= %t.2 (downcast-unsigned %t.1 255 %x.0))
          (= %t.5 (select %t.1 %t.2 0))
          (%t.5))))
    )

  (test
    '(
      "witness W(): Uint<8>;"
      "export circuit foo(b: Boolean): Uint<16> {"
      "  return b ? disclose(W() * W()) : 0;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %W.4 () (ty ((abytes 1)) ((tfield 255))))
        (circuit %foo.5 ((argument
                           (%b.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty ((abytes 2)) ((tfield 65535)))
          (= (%t.2) (call %b.0 %W.4))
          (= (%t.1) (call %b.0 %W.4))
          (= %t.3 (* 16 %t.2 %t.1))
          (= %t.7 (select %b.0 %t.3 0))
          (%t.7))))
    )

  (test
    '(
      "export circuit foo(x: Boolean, y: Boolean): [] {"
      "  if (x) if (!y) 3;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.2 ((argument
                           (%x.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%y.1) (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: [Field, Boolean]): Boolean {"
      "  return x[0] == 0 && x[1] == false;"
      "}"
      "export circuit foo(): Boolean {"
      "  return bar(default<[Field, Boolean]>);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.1 () (ty ((abytes 1)) ((tfield 1))) (1))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Opaque<'string'>): Boolean {"
      "  return x == default<Opaque<'string'>> && default<Opaque<'string'>> == x;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.2 ((argument
                           (%x.0)
                           (ty ((acompress)) ((topaque "string")))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.3 (== %x.0 0))
          (%t.3))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(b: Boolean): [] {"
      "  assert(b, 'oops');"
      "}"
      "export circuit foo(x: Boolean): [] {"
      "  return bar(x);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration ())
        (circuit %foo.2 ((argument
                           (%x.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          (assert %x.0 "oops")
          ())))
    )

  (test
    '(
      "export circuit foo(x: Field): [Field] {"
      "  return [x];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%x.1)
                           (ty ((afield)) ((tfield)))))
             (ty ((afield)) ((tfield)))
          (%x.1))))
    )

  (test
    '(
      "// regression test for common-subexpression elimination in the case where the first occurrence is dropped"
      "export circuit foo(x: Field): [] {"
      "  if (false) {"
      "    assert((x != 0), 'oops1');"
      "  }"
      ""
      "  assert((x != 0), 'oops2');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.4 ((argument
                           (%x.0)
                           (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.2 (== %x.0 0))
          (= %t.3 (select %t.2 0 1))
          (assert %t.3 "oops2")
          ())))
    )

  ; pm-16853
  ; Internal compiler error: Exception: failed assertion (not (hashtable-contains? ref-ht var-name)) at line 1830, char 53 of compiler/circuit-passes.ss
  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger y: Boolean;"
      ""
      "export circuit foo(p: Boolean): [] {"
      "  const b = disclose(p);"
      "  if (b) {"
      "    y = b || y;"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.5 () (Kernel)))
        (public-ledger-declaration
          ((%y.3
             (0)
             (__compact_Cell (ty ((abytes 1)) ((tfield 1)))))))
        (circuit %foo.6 ((argument
                           (%p.4)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          (= () (public-ledger %p.4 %y.3 (0) write 1))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger m: Map<Field, Boolean>;"
      ""
      "export circuit foo(b0: Boolean, x0: Field): [] {"
      "  const b = disclose(b0);"
      "  const x = disclose(x0);"
      "  if (b) {"
      "    m.insert(x + 1, b || m.lookup(x));"
      "  } else {"
      "    m.insert(x - 1, !(b || m.lookup(x)));"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.13 () (Kernel)))
        (public-ledger-declaration
          ((%m.6
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((abytes 1)) ((tfield 1)))))))
        (circuit %foo.14 ((argument
                            (%b0.9)
                            (ty ((abytes 1)) ((tfield 1))))
                          (argument (%x0.10) (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.11 (select %b0.9 0 1))
          (= %tmp.3 (+ #f %x0.10 1))
          (= () (public-ledger %b0.9 %m.6 (0) insert %tmp.3 1))
          (= %tmp.7 (- #f %x0.10 1))
          (= (%t.12) (public-ledger %t.11 %m.6 (0) lookup %x0.10))
          (= %tmp.15 (select %t.12 0 1))
          (= () (public-ledger %t.11 %m.6 (0) insert %tmp.7 %tmp.15))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger m: Map<Field, Map<Field, Boolean>>;"
      ""
      "export circuit foo(b0: Boolean, x0: Field): [] {"
      "  const b = disclose(b0) && disclose(b0);"
      "  const x = 0 + disclose(x0);"
      "  if (b == b) {"
      "    m.lookup(x).insert(x + 1, b || m.lookup(x).lookup(x));"
      "  } else {"
      "    m.lookup(x).insert(x - 1, !(b || m.lookup(x).lookup(x)));"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.3 () (Kernel)))
        (public-ledger-declaration
          ((%m.4
             (0)
             (Map (ty ((afield)) ((tfield)))
                  (ty ((aadt))
                      ((Map (ty ((afield)) ((tfield)))
                            (ty ((abytes 1)) ((tfield 1))))))))))
        (circuit %foo.5 ((argument
                           (%b0.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%x0.1) (ty ((afield)) ((tfield)))))
             (ty () ())
          (= %t.6 (select %b0.0 0 1))
          (= %tmp.7 (+ #f %x0.1 1))
          (= (%t.2)
             (public-ledger %t.6 %m.4 (0 ((ty ((afield)) ((tfield))) %x0.1))
               lookup
               %x0.1))
          (= %tmp.8 (select %b0.0 1 %t.2))
          (= ()
             (public-ledger 1 %m.4 (0 ((ty ((afield)) ((tfield))) %x0.1))
               insert
               %tmp.7
               %tmp.8))
          ())))
    )

  (test
    '(
      "export circuit foo(x: Uint<16>, y: Uint<16>): Uint<32> {"
      "  const k = x == y ? x : x < y ? x + x : y + y;"
      "  return 7;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.8 ((argument
                           (%x.0)
                           (ty ((abytes 2)) ((tfield 65535))))
                         (argument (%y.1) (ty ((abytes 2)) ((tfield 65535)))))
             (ty ((abytes 4)) ((tfield 4294967295)))
          (7))))
    )

  (test
    '(
      "witness w(n: Uint<8>): [];"
      "export circuit foo(): [] {"
      "  for (const i of 3..15) {"
      "    w(i + 1);"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %w.0 ((argument
                         (%n.1)
                         (ty ((abytes 1)) ((tfield 255)))))
             (ty () ()))
        (circuit %foo.2 ()
             (ty () ())
          (= () (call 1 %w.0 4))
          (= () (call 1 %w.0 5))
          (= () (call 1 %w.0 6))
          (= () (call 1 %w.0 7))
          (= () (call 1 %w.0 8))
          (= () (call 1 %w.0 9))
          (= () (call 1 %w.0 10))
          (= () (call 1 %w.0 11))
          (= () (call 1 %w.0 12))
          (= () (call 1 %w.0 13))
          (= () (call 1 %w.0 14))
          (= () (call 1 %w.0 15))
          ())))
    )

  (test
    '(
      "witness w(n: Uint<8>): [];"
      "export circuit foo(): [] {"
      "  w(fold((a: Uint<8>, i: Uint<8>): Uint<8> => a + i as Uint<8>, 0, default<Vector<4, Uint<1>>>));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %w.0 ((argument
                         (%n.1)
                         (ty ((abytes 1)) ((tfield 255)))))
             (ty () ()))
        (circuit %foo.2 () (ty () ()) (= () (call 1 %w.0 0)) ())))
    )

  (test
    '(
      "witness w(n: Uint<8>): [];"
      "export circuit foo(): [] {"
      "  w(fold((a: Uint<8>, i: Uint<8>): Uint<8> => a + i as Uint<8>, 0, [0, 1, 2, 3]));"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (witness %w.0 ((argument
                         (%n.1)
                         (ty ((abytes 1)) ((tfield 255)))))
             (ty () ()))
        (circuit %foo.2 () (ty () ()) (= () (call 1 %w.0 6)) ())))
    )

  (test
    '(
      "export circuit test6(): [] {"
      "  const variable1 = default<Vector<10, Uint<8>>>;"
      "  const variable2 = variable1 as Bytes<10>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test6.0 () (ty () ()) ())))
    )

  (test
    '(
      "export circuit test8(param1: Bytes<10>): [] {"
      "  for(const i of param1 as Vector<10, Uint<8>>) {"
      ""
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test8.1 ((argument
                             (%param1.0)
                             (ty ((abytes 10))
                                 ((tfield 1208925819614629174706175)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "export circuit test13(param1: Bytes<5>): Vector<5, Uint<8>> {"
      "  return param1 as Vector<5, Uint<8>> as Bytes<5> as Vector<5, Uint<8>>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test13.7 ((argument
                              (%param1.0)
                              (ty ((abytes 5)) ((tfield 1099511627775)))))
             (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1))
                 ((tfield 255)
                   (tfield 255)
                   (tfield 255)
                   (tfield 255)
                   (tfield 255)))
          (= (%t.1 %t.2 %t.3 %t.4 %t.5) (bytes->vector %param1.0))
          (= %t.6 (vector->bytes %t.1 %t.2 %t.3 %t.4 %t.5))
          (= (%t.8 %t.9 %t.10 %t.11 %t.12) (bytes->vector %t.6))
          (%t.8 %t.9 %t.10 %t.11 %t.12))))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" (+ (field-bytes) 5))
      "export { foo }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.3 () (Kernel)))
        (public-ledger-declaration
          ((%v.4
             (0)
             (__compact_Cell
               (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                    (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                    (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                    (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                    (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                    (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                    (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                    (abytes 1))
                   ((tfield 255) (tfield 255) (tfield 255) (tfield 255)
                    (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                    (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                    (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                    (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                    (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                    (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                    (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                    (tfield 255) (tfield 255) (tfield 255) (tfield 255)))))))
        (circuit %foo.5 ((argument
                           (%bv.0 %bv.1)
                           (ty ((abytes 36))
                               ((tfield 1099511627775)
                                 (tfield
                                   452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1))
                 ((tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)))
          (= (%tmp.6 %tmp.7 %tmp.8 %tmp.9 %tmp.10)
             (bytes->vector %bv.0))
          (= (%tmp.2 %tmp.11 %tmp.12 %tmp.13 %tmp.14 %tmp.15 %tmp.16
              %tmp.17 %tmp.18 %tmp.19 %tmp.20 %tmp.21 %tmp.22 %tmp.23
              %tmp.24 %tmp.25 %tmp.26 %tmp.27 %tmp.28 %tmp.29 %tmp.30
              %tmp.31 %tmp.32 %tmp.33 %tmp.34 %tmp.35 %tmp.36 %tmp.37
              %tmp.38 %tmp.39 %tmp.40)
             (bytes->vector %bv.1))
          (= ()
             (public-ledger 1 %v.4 (0) write
               %tmp.2 %tmp.11 %tmp.12 %tmp.13 %tmp.14 %tmp.15 %tmp.16 %tmp.17
               %tmp.18 %tmp.19 %tmp.20 %tmp.21 %tmp.22 %tmp.23 %tmp.24 %tmp.25
               %tmp.26 %tmp.27 %tmp.28 %tmp.29 %tmp.30 %tmp.31 %tmp.32 %tmp.33
               %tmp.34 %tmp.35 %tmp.36 %tmp.37 %tmp.38 %tmp.39 %tmp.40 %tmp.6
               %tmp.7 %tmp.8 %tmp.9 %tmp.10))
          (= (%t.41 %t.42 %t.43 %t.44 %t.45 %t.46 %t.47 %t.48 %t.49 %t.50
              %t.51 %t.52 %t.53 %t.54 %t.55 %t.56 %t.57 %t.58 %t.59 %t.60
              %t.61 %t.62 %t.63 %t.64 %t.65 %t.66 %t.67 %t.68 %t.69 %t.70
              %t.71 %t.72 %t.73 %t.74 %t.75 %t.76)
             (public-ledger 1 %v.4 (0) read))
          (%t.41 %t.42 %t.43 %t.44 %t.45 %t.46 %t.47 %t.48 %t.49 %t.50
           %t.51 %t.52 %t.53 %t.54 %t.55 %t.56 %t.57 %t.58 %t.59 %t.60
           %t.61 %t.62 %t.63 %t.64 %t.65 %t.66 %t.67 %t.68 %t.69 %t.70
           %t.71 %t.72 %t.73 %t.74 %t.75 %t.76))))
    )

  (test
    (let ([n (* (field-bytes) 2)])
      `(
        ,(format "export circuit foo(): Bytes<~d> {" n)
        ,(format "  return [~{~d~^, ~}] as Bytes<~d>;"
           (map (let ([s "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"])
                  (lambda (i) (char->integer (string-ref s (mod i (string-length s))))))
                (iota n))
           n)
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 62))
                 ((tfield
                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (#x393837363534333231305A595857565554535251504F4E4D4C4B4A49484746
           #x45444342417A797877767574737271706F6E6D6C6B6A696867666564636261))))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" (+ (field-bytes) 5))
      "export { foo }"
      )
    (returns
      (program
        (kernel-declaration (%kernel.36 () (Kernel)))
        (public-ledger-declaration
          ((%bv.37
             (0)
             (__compact_Cell
               (ty ((abytes 36))
                   ((tfield 1099511627775)
                     (tfield
                       452312848583266388373324160190187140051835877600158453279131187530910662655)))))))
        (circuit %foo.38 ((argument
                            (%v.5 %v.6 %v.7 %v.8 %v.9 %v.10 %v.11 %v.12 %v.13
                             %v.14 %v.15 %v.16 %v.17 %v.18 %v.19 %v.20 %v.21
                             %v.22 %v.23 %v.24 %v.25 %v.26 %v.27 %v.28 %v.29
                             %v.30 %v.31 %v.32 %v.33 %v.34 %v.35 %v.0 %v.1 %v.2
                             %v.3 %v.4)
                            (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                                 (abytes 1) (abytes 1) (abytes 1) (abytes 1))
                                ((tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)
                                 (tfield 255) (tfield 255) (tfield 255)))))
             (ty ((abytes 36))
                 ((tfield 1099511627775)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= %tmp.39 (vector->bytes %v.0 %v.1 %v.2 %v.3 %v.4))
          (= %tmp.40
             (vector->bytes %v.5 %v.6 %v.7 %v.8 %v.9 %v.10 %v.11 %v.12
              %v.13 %v.14 %v.15 %v.16 %v.17 %v.18 %v.19 %v.20 %v.21 %v.22
              %v.23 %v.24 %v.25 %v.26 %v.27 %v.28 %v.29 %v.30 %v.31 %v.32
              %v.33 %v.34 %v.35))
          (= () (public-ledger 1 %bv.37 (0) write %tmp.39 %tmp.40))
          (= (%t.41 %t.42) (public-ledger 1 %bv.37 (0) read))
          (%t.41 %t.42))))
    )

  (test
    (let ([n (+ (field-bytes) 5)])
      `(
        ,(format "export circuit test13(param1: Bytes<~d>): Vector<~:*~d, Uint<8>> {" n)
        ,(format "  return param1 as Vector<~d, Uint<8>> as Bytes<~:*~d> as Vector<~:*~d, Uint<8>>;" n)
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test13.40 ((argument
                               (%param1.0 %param1.1)
                               (ty ((abytes 36))
                                   ((tfield 1099511627775)
                                     (tfield
                                       452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1))
                 ((tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)))
          (= (%t.2 %t.3 %t.4 %t.5 %t.6) (bytes->vector %param1.0))
          (= (%t.7 %t.8 %t.9 %t.10 %t.11 %t.12 %t.13 %t.14 %t.15 %t.16
              %t.17 %t.18 %t.19 %t.20 %t.21 %t.22 %t.23 %t.24 %t.25 %t.26
              %t.27 %t.28 %t.29 %t.30 %t.31 %t.32 %t.33 %t.34 %t.35 %t.36
              %t.37)
             (bytes->vector %param1.1))
          (= %t.38 (vector->bytes %t.2 %t.3 %t.4 %t.5 %t.6))
          (= %t.39
             (vector->bytes %t.7 %t.8 %t.9 %t.10 %t.11 %t.12 %t.13 %t.14
              %t.15 %t.16 %t.17 %t.18 %t.19 %t.20 %t.21 %t.22 %t.23 %t.24
              %t.25 %t.26 %t.27 %t.28 %t.29 %t.30 %t.31 %t.32 %t.33 %t.34
              %t.35 %t.36 %t.37))
          (= (%t.41 %t.42 %t.43 %t.44 %t.45) (bytes->vector %t.38))
          (= (%t.46 %t.47 %t.48 %t.49 %t.50 %t.51 %t.52 %t.53 %t.54 %t.55
              %t.56 %t.57 %t.58 %t.59 %t.60 %t.61 %t.62 %t.63 %t.64 %t.65
              %t.66 %t.67 %t.68 %t.69 %t.70 %t.71 %t.72 %t.73 %t.74 %t.75
              %t.76)
             (bytes->vector %t.39))
          (%t.46 %t.47 %t.48 %t.49 %t.50 %t.51 %t.52 %t.53 %t.54 %t.55
           %t.56 %t.57 %t.58 %t.59 %t.60 %t.61 %t.62 %t.63 %t.64 %t.65
           %t.66 %t.67 %t.68 %t.69 %t.70 %t.71 %t.72 %t.73 %t.74 %t.75
           %t.76 %t.41 %t.42 %t.43 %t.44 %t.45))))
    )

  (test
    (let ([n (+ (field-bytes) 5)])
      `(
        ,(format "export circuit test20(param1: Bytes<~d>) : Field {" n)
        ,(format "  return fold((a: Field, x: Uint<8>): Field => a + x as Field, 0 as Uint<8>, param1 as Vector<~d, Uint<8>>);" n)
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test20.72 ((argument
                               (%param1.0 %param1.1)
                               (ty ((abytes 36))
                                   ((tfield 1099511627775)
                                     (tfield
                                       452312848583266388373324160190187140051835877600158453279131187530910662655)))))
             (ty ((afield)) ((tfield)))
          (= (%t.63 %t.65 %t.67 %t.69 %t.71)
             (bytes->vector %param1.0))
          (= (%t.2 %t.3 %t.5 %t.7 %t.9 %t.11 %t.13 %t.15 %t.17 %t.19 %t.21
              %t.23 %t.25 %t.27 %t.29 %t.31 %t.33 %t.35 %t.37 %t.39 %t.41
              %t.43 %t.45 %t.47 %t.49 %t.51 %t.53 %t.55 %t.57 %t.59 %t.61)
             (bytes->vector %param1.1))
          (= %a.4 (+ #f %t.2 %t.3))
          (= %a.6 (+ #f %a.4 %t.5))
          (= %a.8 (+ #f %a.6 %t.7))
          (= %a.10 (+ #f %a.8 %t.9))
          (= %a.12 (+ #f %a.10 %t.11))
          (= %a.14 (+ #f %a.12 %t.13))
          (= %a.16 (+ #f %a.14 %t.15))
          (= %a.18 (+ #f %a.16 %t.17))
          (= %a.20 (+ #f %a.18 %t.19))
          (= %a.22 (+ #f %a.20 %t.21))
          (= %a.24 (+ #f %a.22 %t.23))
          (= %a.26 (+ #f %a.24 %t.25))
          (= %a.28 (+ #f %a.26 %t.27))
          (= %a.30 (+ #f %a.28 %t.29))
          (= %a.32 (+ #f %a.30 %t.31))
          (= %a.34 (+ #f %a.32 %t.33))
          (= %a.36 (+ #f %a.34 %t.35))
          (= %a.38 (+ #f %a.36 %t.37))
          (= %a.40 (+ #f %a.38 %t.39))
          (= %a.42 (+ #f %a.40 %t.41))
          (= %a.44 (+ #f %a.42 %t.43))
          (= %a.46 (+ #f %a.44 %t.45))
          (= %a.48 (+ #f %a.46 %t.47))
          (= %a.50 (+ #f %a.48 %t.49))
          (= %a.52 (+ #f %a.50 %t.51))
          (= %a.54 (+ #f %a.52 %t.53))
          (= %a.56 (+ #f %a.54 %t.55))
          (= %a.58 (+ #f %a.56 %t.57))
          (= %a.60 (+ #f %a.58 %t.59))
          (= %a.62 (+ #f %a.60 %t.61))
          (= %a.64 (+ #f %a.62 %t.63))
          (= %a.66 (+ #f %a.64 %t.65))
          (= %a.68 (+ #f %a.66 %t.67))
          (= %a.70 (+ #f %a.68 %t.69))
          (= %t.73 (+ #f %a.70 %t.71))
          (%t.73))))
    )

  (test
    '(
      "export circuit test25(param1: Uint<8>, param2: Vector<0, Uint<8>>) : Vector<0, Uint<8>> {"
      "  return param1 == 0 ? param2 : default<Bytes<0>> as Vector<0, Uint<8>>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test25.2 ((argument
                              (%param1.0)
                              (ty ((abytes 1)) ((tfield 255))))
                            (argument () (ty () ())))
             (ty () ())
          ())))
    )

  (test
    '(
      "export circuit test24(): Bytes<5> {"
      "  return [1 as Uint<8>,2 as Uint<8>,3 as Uint<8>,4 as Uint<8>,5 as Uint<8>] as Bytes<5>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test24.0 ()
             (ty ((abytes 5)) ((tfield 1099511627775)))
          (#x504030201))))
    )

  (test
    (let ([n (* (field-bytes) 2)])
      `(
        ,(format "export circuit test24(): Bytes<~d> {" n)
        ,(format "  return [~{~a~^, ~}] as Bytes<~d>;"
           (map (lambda (i) (format "~d as Uint<8>" i)) (iota n))
           n)
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test24.0 ()
             (ty ((abytes 62))
                 ((tfield
                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (#x3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F
           #x1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100))))
    )

  (test
    (let ([n (* (field-bytes) 2)])
      `(
        ,(format "export circuit test24(): Bytes<~d> {" n)
        ,(format "  return [~{~d~^, ~}] as Bytes<~d>;" (iota n) n)
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test24.0 ()
             (ty ((abytes 62))
                 ((tfield
                    452312848583266388373324160190187140051835877600158453279131187530910662655)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (#x3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F
           #x1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100))))
    )

  (test
    (let ([n (+ (field-bytes) 5)])
      `(
        ,(format "export circuit foo(): Bytes<~d> {" n)
        ,(format "  return [~{~d~^, ~}] as Bytes<~d>;"
           (map (let ([s "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"])
                  (lambda (i) (char->integer (string-ref s (mod i (string-length s))))))
                (iota n))
           n)
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 36))
                 ((tfield 1099511627775)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (#x4A49484746
           #x45444342417A797877767574737271706F6E6D6C6B6A696867666564636261))))
    )

  (test
    (let ([n (+ (field-bytes) 5)])
      `(
        ,(format "export circuit foo(): Bytes<~d> {" (+ n 3))
        ,(format "  return [~{~d, ~}0, 0, 0] as Bytes<~d>;"
           (map (let ([s "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"])
                  (lambda (i) (char->integer (string-ref s (mod i (string-length s))))))
                (iota n))
           (+ n 3))
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 39))
                 ((tfield 18446744073709551615)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (#x4A49484746
           #x45444342417A797877767574737271706F6E6D6C6B6A696867666564636261))))
    )

  (test
    (let ([n (+ (field-bytes) 5)])
      `(
        ,(format "export circuit foo(x: Uint<8>): Bytes<~d> {" (+ n 3))
        ,(format "  return [~{~d, ~}x, 0, 0] as Bytes<~d>;"
           (map (let ([s "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"])
                  (lambda (i) (char->integer (string-ref s (mod i (string-length s))))))
                (iota n))
           (+ n 3))
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%x.0)
                           (ty ((abytes 1)) ((tfield 255)))))
             (ty ((abytes 39))
                 ((tfield 18446744073709551615)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (= %t.2 (vector->bytes 70 71 72 73 74 %x.0))
          (%t.2
            122383579515264484277446527239169866061122741007141276322279342944460956257))))
    )

  (test
    (let ([n (+ (field-bytes) 5)])
      `(
        ,(format "export circuit foo(): Bytes<~d> {" n)
        ,(format "  return '~a';"
           (let* ([s "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"]
                  [sn (string-length s)])
             (let f ([n n])
               (if (fx<= n sn)
                   (substring s 0 n)
                   (string-append s (f (- n sn)))))))
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 36))
                 ((tfield 1099511627775)
                   (tfield
                     452312848583266388373324160190187140051835877600158453279131187530910662655)))
          (#x4A49484746
           #x45444342417A797877767574737271706F6E6D6C6B6A696867666564636261))))
    )

  (test
    (let ([n (+ (field-bytes) 5)])
      `(
        ,(format "export circuit foo(): Vector<~d, Uint<8>> {" n)
        ,(format "  return '~a' as Vector<~d, Uint<8>>;"
           (let* ([s "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"]
                  [sn (string-length s)])
             (let f ([n n])
               (if (fx<= n sn)
                   (substring s 0 n)
                   (string-append s (f (- n sn))))))
           n)
        "}"
        ))
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ()
             (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                  (abytes 1))
                 ((tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                  (tfield 255) (tfield 255) (tfield 255) (tfield 255)))
          (97 98 99 100 101 102 103 104 105 106 107 108 109 110 111
           112 113 114 115 116 117 118 119 120 121 122 65 66 67 68 69
           70 71 72 73 74))))
    )

  (test
    '(
      "export circuit test24(): Bytes<5> {"
      "  return '12345';"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test24.0 ()
             (ty ((abytes 5)) ((tfield 1099511627775)))
          (#x3534333231))))
    )

  (test
    '(
      "export circuit test24(): Bytes<5> {"
      "  return [ 0x31, 0x32, 0x33, 0x34, 0x35 ] as Bytes<5>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test24.0 ()
             (ty ((abytes 5)) ((tfield 1099511627775)))
          (#x3534333231))))
    )

  (test
    '(
      "export circuit test24(): Bytes<5> {"
      "  return [ 0x35, 0x34, 0x33, 0x32, 0x31 ] as Bytes<5>;"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test24.0 ()
             (ty ((abytes 5)) ((tfield 1099511627775)))
          (#x3132333435))))
    )

  (test
    '(
      "export circuit test24(): Vector<5, Uint<8>> {"
      "  return '12345' as [Uint<8>, Uint<8>, Uint<8>, Uint<8>, Uint<8>];"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %test24.0 ()
             (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1))
                 ((tfield 255)
                   (tfield 255)
                   (tfield 255)
                   (tfield 255)
                   (tfield 255)))
          (49 50 51 52 53))))
    )

  ; pm-17201
  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "circuit bar(n: Uint<8>, m: Uint<8>): Uint<8> {"
      "  return n >= m ? n - m : n;"
      "}"
      "export circuit foo(v: Vector<10, Uint<16>>): Uint<64> {"
      "  for (const i of 5..14) {"
      "    counter += disclose(v[bar(i, 10)]);"
      "  }"
      "  return counter;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration ((%counter.1 (0) (Counter))))
        (circuit %foo.2 ((argument
                           (%v.3 %v.4 %v.5 %v.6 %v.7 %v.8 %v.9 %v.10 %v.11
                             %v.12)
                           (ty ((abytes 2) (abytes 2) (abytes 2) (abytes 2) (abytes 2)
                                 (abytes 2) (abytes 2) (abytes 2) (abytes 2)
                                 (abytes 2))
                               ((tfield 65535) (tfield 65535) (tfield 65535) (tfield 65535)
                                 (tfield 65535) (tfield 65535) (tfield 65535)
                                 (tfield 65535) (tfield 65535)
                                 (tfield 65535)))))
             (ty ((abytes 8)) ((tfield 18446744073709551615)))
          (= () (public-ledger 1 %counter.1 (0) increment %v.8))
          (= () (public-ledger 1 %counter.1 (0) increment %v.9))
          (= () (public-ledger 1 %counter.1 (0) increment %v.10))
          (= () (public-ledger 1 %counter.1 (0) increment %v.11))
          (= () (public-ledger 1 %counter.1 (0) increment %v.12))
          (= () (public-ledger 1 %counter.1 (0) increment %v.3))
          (= () (public-ledger 1 %counter.1 (0) increment %v.4))
          (= () (public-ledger 1 %counter.1 (0) increment %v.5))
          (= () (public-ledger 1 %counter.1 (0) increment %v.6))
          (= (%t.13) (public-ledger 1 %counter.1 (0) read))
          (%t.13))))
    )

  ; pm-17201
  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "circuit bar(n: Uint<8>, m: Uint<8>): Uint<8> {"
      "  return n > m ? n - m : n;"
      "}"
      "export circuit foo(v: Vector<10, Uint<16>>): Uint<64> {"
      "  for (const i of 5..14) {"
      "    counter += disclose(v[bar(i, 10)]);"
      "  }"
      "  return counter;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 25" "invalid vector index ~d for vector of length ~d" (10 10)))
    )

  ; pm-17201
  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "circuit bar(n: Uint<8>, m: Uint<8>): Uint<8> {"
      "  return n - m;"
      "}"
      "export circuit foo(v: Vector<10, Uint<16>>): Uint<64> {"
      "  for (const i of 5..14) {"
      "    counter += disclose(v[bar(i, 20)]);"
      "  }"
      "  return counter;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 25" "vector index did not reduce to a constant nonnegative value at compile time" ()))
    )

  ; pm-17201
  (test
    '(
      "import CompactStandardLibrary;"
      "ledger counter: Counter;"
      "circuit bar(n: Uint<8>, m: Uint<8>): Uint<8> {"
      "  return n >= m ? n - m : n;"
      "}"
      "export circuit foo(v: Vector<10, Uint<16>>, j: Uint<8>): Uint<64> {"
      "  for (const i of 5..14) {"
      "    counter += disclose(v[bar(i + j as Uint<8>, 10)]);"
      "  }"
      "  return counter;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 25" "vector index did not reduce to a constant nonnegative value at compile time" ()))
    )

  ; pm-17201
  ; if bar is exported, i doesn't reduce to a constant ...
  (test
    '(
      "export circuit bar(v: Vector<5, Field>, i: Uint<0..6>): Field {"
      "  return v[i];"
      "}"
      "export circuit foo(v: Vector<5, Field>): Field {"
      "  return bar(v, 3);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 10" "vector index did not reduce to a constant nonnegative value at compile time" ()))
    )

  ; ... but if bar is not exported, i does reduce to a constant at the only place where bar is called
  (test
    '(
      "circuit bar(v: Vector<5, Field>, i: Uint<0..6>): Field {"
      "  return v[i];"
      "}"
      "export circuit foo(v: Vector<5, Field>): Field {"
      "  return bar(v, 3);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%v.1 %v.2 %v.3 %v.4 %v.5)
                           (ty ((afield) (afield) (afield) (afield) (afield))
                               ((tfield)
                                 (tfield)
                                 (tfield)
                                 (tfield)
                                 (tfield)))))
             (ty ((afield)) ((tfield)))
          (%v.4))))
    )

  (test
    '(
      "export circuit foo(v: Vector<0, Field>): Field {"
      "  const k = 0;"
      "  return v[k];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "expected a non-empty vector or tuple type, received ~a" ("Vector<0, Field>")))
    )

  (test
    '(
      "export circuit foo(v: []): [] {"
      "  const k = 0;"
      "  return v[k];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "expected a non-empty vector or tuple type, received ~a" ("[]")))
    )

  (test
    '(
      "export circuit foo(v: Vector<0, Field>): Vector<0, Field> {"
      "  const k = 0;"
      "  return slice<0>(v, k);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument () (ty () ()))) (ty () ()) ())))
    )

  (test
    '(
      "export circuit foo(v: []): [] {"
      "  const k = 0;"
      "  return slice<0>(v, k);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument () (ty () ()))) (ty () ()) ())))
    )

  (test
    '(
      "export circuit foo(v: Vector<0, Field>): Vector<0, Field> {"
      "  const k = 1;"
      "  return slice<0>(v, k);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "invalid slice index ~d and length ~d for vector of length ~d" (1 0 0)))
    )

  (test
    '(
      "export circuit foo(v: []): [] {"
      "  const k = 1;"
      "  return slice<0>(v, k);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "invalid slice index ~d and length ~d for vector of length ~d" (1 0 0)))
    )

  (test
    '(
      "ledger V1: Vector<10, Uint<8>>;"
      "ledger V2: Vector<10, Uint<8>>;"
      "export circuit foo(bv: Bytes<10>): Vector<10, Uint<8>> {"
      "  V1 = disclose(bv) as Vector<10, Uint<8>>;"
      "  V2 = disclose(bv) as Vector<10, Uint<8>>;"
      "  return bv as Vector<10, Uint<8>>;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.1 () (Kernel)))
        (public-ledger-declaration
          ((%V1.2
             (0)
             (__compact_Cell
               (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                     (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1))
                   ((tfield 255) (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                     (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                     (tfield 255)))))
           (%V2.3
             (1)
             (__compact_Cell
               (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                     (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1))
                   ((tfield 255) (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                     (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                     (tfield 255)))))))
        (circuit %foo.4 ((argument
                           (%bv.0)
                           (ty ((abytes 10))
                               ((tfield 1208925819614629174706175)))))
             (ty ((abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1)
                   (abytes 1) (abytes 1) (abytes 1) (abytes 1) (abytes 1))
                 ((tfield 255) (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                   (tfield 255) (tfield 255) (tfield 255) (tfield 255)
                   (tfield 255)))
          (= (%tmp.5 %tmp.6 %tmp.7 %tmp.8 %tmp.9 %tmp.10 %tmp.11
              %tmp.12 %tmp.13 %tmp.14)
             (bytes->vector %bv.0))
          (= ()
             (public-ledger 1 %V1.2 (0) write
               %tmp.5 %tmp.6 %tmp.7 %tmp.8 %tmp.9 %tmp.10 %tmp.11 %tmp.12
               %tmp.13 %tmp.14))
          (= ()
             (public-ledger 1 %V2.3 (1) write
               %tmp.5 %tmp.6 %tmp.7 %tmp.8 %tmp.9 %tmp.10 %tmp.11 %tmp.12
               %tmp.13 %tmp.14))
          (%tmp.5 %tmp.6 %tmp.7 %tmp.8 %tmp.9 %tmp.10 %tmp.11 %tmp.12
            %tmp.13 %tmp.14))))
    )

  (test
    '(
      "ledger F: Boolean;"
      "export circuit foo(a : Boolean): [] {"
      "  if (disclose(a)) assert(F, 'oops');"
      "  if (disclose(F)) assert(a, 'oops');"
      "}"
     )
    (returns
      (program
        (kernel-declaration (%kernel.5 () (Kernel)))
        (public-ledger-declaration
          ((%F.6
             (0)
             (__compact_Cell (ty ((abytes 1)) ((tfield 1)))))))
        (circuit %foo.7 ((argument
                           (%a.0)
                           (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          (= (%t.1) (public-ledger %a.0 %F.6 (0) read))
          (= %t.2 (select %a.0 %t.1 1))
          (assert %t.2 "oops")
          (= (%t.3) (public-ledger 1 %F.6 (0) read))
          (= %t.4 (select %t.3 %a.0 1))
          (assert %t.4 "oops")
          ())))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(a : Boolean, b: Boolean, c: Boolean): [] {"
      "  F = 37;"
      "  if (a) if (b) if (c) assert(a, 'oops');"
      "}"
     )
    (returns
      (program
        (kernel-declaration (%kernel.4 () (Kernel)))
        (public-ledger-declaration
          ((%F.5 (0) (__compact_Cell (ty ((afield)) ((tfield)))))))
        (circuit %foo.6 ((argument
                           (%a.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%b.1) (ty ((abytes 1)) ((tfield 1))))
                         (argument (%c.3) (ty ((abytes 1)) ((tfield 1)))))
             (ty () ())
          (= () (public-ledger 1 %F.5 (0) write 37))
          ())))
    )

  (test
    '(
      "ledger F: Field;"
      "witness w(): Vector<3, Opaque<'string'>>;"
      "export circuit foo(b: Boolean, s: Opaque<'string'>): [] {"
      "  F = 37;"
      "  if (b) {"
      "    const t = disclose(w());"
      "    assert(t[1] == s, 'oops');"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.10 () (Kernel)))
        (public-ledger-declaration
          ((%F.11 (0) (__compact_Cell (ty ((afield)) ((tfield)))))))
        (witness %w.3 ()
             (ty ((acompress) (acompress) (acompress))
                 ((topaque "string") (topaque "string") (topaque "string"))))
        (circuit %foo.12 ((argument
                            (%b.5)
                            (ty ((abytes 1)) ((tfield 1))))
                          (argument
                            (%s.7)
                            (ty ((acompress)) ((topaque "string")))))
             (ty () ())
          (= () (public-ledger 1 %F.11 (0) write 37))
          (= (%t.13 %t.6 %t.14) (call %b.5 %w.3))
          (= %t.8 (== %t.6 %s.7))
          (= %t.9 (select %b.5 %t.8 1))
          (assert %t.9 "oops")
          ())))
    )

  (test
    '(
      "struct S { a: Uint<16> };"
      "ledger F: S;"
      "export circuit foo(is: S): S {"
      "  const s = disclose(is);"
      "  const a = s.a;"
      "  if (a == s.a) {"
      "    F = s;"
      "    return F;"
      "  } else {"
      "    F = S { a: a as Uint<8> };"
      "    return F;"
      "  }"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.0 () (Kernel)))
        (public-ledger-declaration
          ((%F.1
             (0)
             (__compact_Cell (ty ((abytes 2)) ((tfield 65535)))))))
        (circuit %foo.2 ((argument
                           (%is.3)
                           (ty ((abytes 2)) ((tfield 65535)))))
             (ty ((abytes 2)) ((tfield 65535)))
          (= () (public-ledger 1 %F.1 (0) write %is.3))
          (= (%t.4) (public-ledger 1 %F.1 (0) read))
          (%t.4))))
    )

  (test
    '(
      "export circuit foo(x: Uint<16>): [] {"
      "  if (x == 0) assert(x == 0, 'oops');"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.2 ((argument
                           (%x.0)
                           (ty ((abytes 2)) ((tfield 65535)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "export circuit foo(x: Uint<16>): [] {"
      "  if (x + 7 != x + 7) {"
      "    assert(x == 0, 'oops');"
      "  }"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.1 ((argument
                           (%x.0)
                           (ty ((abytes 2)) ((tfield 65535)))))
             (ty () ())
          ())))
    )

  (test
    '(
      "ledger B1: Bytes<10>;"
      "ledger B2: Bytes<10>;"
      "export circuit foo(ia: Boolean, ib: Boolean, ix: Field): Vector<2, Bytes<10>> {"
      "  const a = disclose(ia), b = disclose(ib), x = disclose(ix);"
      "  B1 = a ? x as Bytes<10> : default<Bytes<10>>;"
      "  B2 = b ? x as Bytes<10> : default<Bytes<10>>;"
      "  return [B1, B2];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.5 () (Kernel)))
        (public-ledger-declaration
          ((%B1.6
             (0)
             (__compact_Cell
               (ty ((abytes 10)) ((tfield 1208925819614629174706175)))))
           (%B2.7
             (1)
             (__compact_Cell
               (ty ((abytes 10)) ((tfield 1208925819614629174706175)))))))
        (circuit %foo.8 ((argument
                           (%ia.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%ib.3) (ty ((abytes 1)) ((tfield 1))))
                         (argument (%ix.1) (ty ((afield)) ((tfield)))))
             (ty ((abytes 10) (abytes 10))
                 ((tfield 1208925819614629174706175)
                   (tfield 1208925819614629174706175)))
          (= (%t.9 %t.2) (field->bytes %ia.0 10 %ix.1))
          (= %tmp.10 (select %ia.0 %t.2 0))
          (= () (public-ledger 1 %B1.6 (0) write %tmp.10))
          (= (%t.11 %t.4) (field->bytes %ib.3 10 %ix.1))
          (= %tmp.12 (select %ib.3 %t.4 0))
          (= () (public-ledger 1 %B2.7 (1) write %tmp.12))
          (= (%t.13) (public-ledger 1 %B1.6 (0) read))
          (= (%t.14) (public-ledger 1 %B2.7 (1) read))
          (%t.13 %t.14))))
    )

  (test
    '(
      "ledger B1: Bytes<10>;"
      "ledger B2: Bytes<10>;"
      "export circuit foo(ib: Boolean, ix: Field): Vector<2, Bytes<10>> {"
      "  const b = disclose(ib), x = disclose(ix);"
      "  B1 = b ? x as Bytes<10> : default<Bytes<10>>;"
      "  B2 = b ? x as Bytes<10> : default<Bytes<10>>;"
      "  return [B1, B2];"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.3 () (Kernel)))
        (public-ledger-declaration
          ((%B1.4
             (0)
             (__compact_Cell
               (ty ((abytes 10)) ((tfield 1208925819614629174706175)))))
           (%B2.5
             (1)
             (__compact_Cell
               (ty ((abytes 10)) ((tfield 1208925819614629174706175)))))))
        (circuit %foo.6 ((argument
                           (%ib.0)
                           (ty ((abytes 1)) ((tfield 1))))
                         (argument (%ix.1) (ty ((afield)) ((tfield)))))
             (ty ((abytes 10) (abytes 10))
                 ((tfield 1208925819614629174706175)
                   (tfield 1208925819614629174706175)))
          (= (%t.7 %t.2) (field->bytes %ib.0 10 %ix.1))
          (= %tmp.8 (select %ib.0 %t.2 0))
          (= () (public-ledger 1 %B1.4 (0) write %tmp.8))
          (= () (public-ledger 1 %B2.5 (1) write %tmp.8))
          (= (%t.9) (public-ledger 1 %B1.4 (0) read))
          (= (%t.10) (public-ledger 1 %B2.5 (1) read))
          (%t.9 %t.10))))
    )

  (test
    '(
      "ledger F: Field;"
      "ledger B: Boolean;"
      "export circuit foo(ix: Field): Boolean {"
      "  const x = disclose(ix);"
      "  if (x == 0) if (x != 0) { const b = B; return b; }"
      "  return x == 0;"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.2 () (Kernel)))
        (public-ledger-declaration
          ((%F.3 (0) (__compact_Cell (ty ((afield)) ((tfield)))))
           (%B.4 (1) (__compact_Cell (ty ((abytes 1)) ((tfield 1)))))))
        (circuit %foo.5 ((argument
                           (%ix.0)
                           (ty ((afield)) ((tfield)))))
             (ty ((abytes 1)) ((tfield 1)))
          (= %t.1 (== %ix.0 0))
          (%t.1))))
    )
)

(run-tests print-zkir
  (test
    "examples/tiny.compact"
    (output-file "compiler/testdir/zkir/public_key.zkir" #f)
    (output-file "compiler/testdir/zkir/get.zkir"
                 "examples/outputs/tiny.compact/zkir/get.zkir")
    (output-file "compiler/testdir/zkir/set.zkir"
                 "examples/outputs/tiny.compact/zkir/set.zkir")
    (output-file "compiler/testdir/zkir/clear.zkir"
                 "examples/outputs/tiny.compact/zkir/clear.zkir")
    )

  (test
    "examples/election.compact"
    (output-file "compiler/testdir/zkir/vote$commit.zkir"
                 "examples/outputs/election.compact/zkir/vote$commit.zkir")
    (output-file "compiler/testdir/zkir/vote$reveal.zkir"
                 "examples/outputs/election.compact/zkir/vote$reveal.zkir")
    (output-file "compiler/testdir/zkir/add_voter.zkir"
                 "examples/outputs/election.compact/zkir/add_voter.zkir")
    (output-file "compiler/testdir/zkir/set_topic.zkir"
                 "examples/outputs/election.compact/zkir/set_topic.zkir")
    (output-file "compiler/testdir/zkir/advance.zkir"
                 "examples/outputs/election.compact/zkir/advance.zkir")
    )

  (test
    "examples/zerocash.compact"
    (output-file "compiler/testdir/zkir/spend.zkir"
                 "examples/outputs/zerocash.compact/zkir/spend.zkir")
    (output-file "compiler/testdir/zkir/zerocash_mint.zkir"
                 "examples/outputs/zerocash.compact/zkir/zerocash_mint.zkir")
  )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "module M {"
      "  export circuit foo(a : Uint<0..1>): Boolean { forcenonpure(); return a == 0; }"
      "}"
      ""
      "import M prefix A;"
      "import M prefix B;"
      "export { Afoo, Bfoo };"
      )
    (output-file "compiler/testdir/zkir/Bfoo.zkir"
                 "compiler/testdir/zkir/Afoo.zkir")
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<0..1>): Boolean { forcenonpure(); return a == 0; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"constrain_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<0..1>): Boolean { forcenonpure(); return a != 0; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"constrain_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 3, \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<16>): Boolean { forcenonpure(); return a < 5; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 2, \"bits\": 16 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<16>): Boolean { forcenonpure(); return a < a + 5; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 2 },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 3, \"bits\": 17 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<0..1>): Boolean { forcenonpure(); return a <= 0; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"constrain_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"less_than\", \"a\": 1, \"b\": 0, \"bits\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 3, \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(a : Boolean): Boolean {"
      "  return a;
      }"
      ""
      "export circuit bar(a: Boolean): Boolean {"
      "  return foo(a);"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir" #f)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Boolean): Boolean {"
      "  forcenonpure();"
      "  return a;
      }"
      ""
      "export circuit bar(a: Boolean): Boolean {"
      "  return foo(a);"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Boolean): Boolean {"
      "  return a;"
      "}"
      ""
      "export circuit bar(a: Boolean): Boolean {"
      "  forcenonpure();"
      "  return foo(a);"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness forcenonpure(): [];"
      ""
      "struct Foo {"
      "  a: Field;"
      "  b: Boolean;"
      "}"
      "struct Bar {"
      "  a: Vector<2, Foo>;"
      "  b: Bytes<0>;"
      "  c: Uint<32>;"
      "  d: Opaque<'string'>;"
      "}"
      "export circuit foo(): Bar {"
      "  forcenonpure();"
      "  return default<Bar>;"
      "}"
      "export circuit bar(x: Opaque<'string'>): Bar {"
      "  forcenonpure();"
      "  return Bar{ a: [Foo{ a: 0, b: false }, Foo{ a: 0, b: false }], b: '', c: 0, d: x };"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness forcenonpure(): [];"
      ""
      "export circuit bar(x: Bytes<32>, y: Uint<32>, z: Uint<16>): Field {"
      "  forcenonpure();"
      "  const q = x as Field;"
      "  return q + y * z - q * (y - z);"
      "}"
      )
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 32 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 0, \"modulus\": 1, \"bits\": 248 },"
        "    { \"op\": \"mul\", \"a\": 2, \"b\": 3 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 6 },"
        "    { \"op\": \"less_than\", \"a\": 2, \"b\": 3, \"bits\": 32 },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 9, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 10 },"
        "    { \"op\": \"neg\", \"a\": 3 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 11 },"
        "    { \"op\": \"mul\", \"a\": 5, \"b\": 12 },"
        "    { \"op\": \"neg\", \"a\": 13 },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 14 },"
        "    { \"op\": \"output\", \"var\": 15 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness forcenonpure(): [];"
      "export circuit foo(x: Field): Uint<16> {"
      "  forcenonpure();"
      "  return x as Uint<16>;"
      "}"
      "export circuit bar(x: Uint<32>): Uint<16> {"
      "  forcenonpure();"
      "  return x as Uint<16>;"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 16 },"
        "    { \"op\": \"copy\", \"var\": 0 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 32 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 16 },"
        "    { \"op\": \"copy\", \"var\": 0 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(p1: CurvePoint, p2: CurvePoint): CurvePoint {"
      "  return ecAdd(ecAdd(ecAdd(ecMul(p1, transientHash<Vector<2, Field>>([p1.x, p2.x])), ecMulGenerator(17)), hashToCurve<ContractAddress>(kernel.self())), hashToCurve<Vector<0, Field>>([]));"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"transient_hash\", \"inputs\": [0, 2] },"
        "    { \"op\": \"ec_mul\", \"a_x\": 0, \"a_y\": 1, \"scalar\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"ec_mul_generator\", \"scalar\": 8 },"
        "    { \"op\": \"ec_add\", \"a_x\": 6, \"a_y\": 7, \"b_x\": 9, \"b_y\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"60\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"hash_to_curve\", \"inputs\": [16, 17] },"
        "    { \"op\": \"ec_add\", \"a_x\": 11, \"a_y\": 12, \"b_x\": 20, \"b_y\": 21 },"
        "    { \"op\": \"hash_to_curve\", \"inputs\": [] },"
        "    { \"op\": \"ec_add\", \"a_x\": 22, \"a_y\": 23, \"b_x\": 24, \"b_y\": 25 },"
        "    { \"op\": \"output\", \"var\": 26 },"
        "    { \"op\": \"output\", \"var\": 27 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field0: Map<Boolean, Field>;"
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "export circuit identity(q: Field): Field {"
      "  return q + 1;"
      "}"
      ""
      "export circuit init0(b: Boolean): [] {"
      "  field0.insert(disclose(b), default<Field>);"
      "}"
      ""
      "export circuit ismember(b: Boolean): Boolean {"
      "  return field1.member(disclose(b));"
      "}"
      ""
      "export circuit init1(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Counter>);"
      "}"
      ""
      "export circuit update(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(disclose(b)) += disclose(n);"
      "}"
      ""
      "export circuit get(b: Boolean): Uint<64> {"
      "  return field1.lookup(disclose(b));"
      "}"
      )
    (output-file "compiler/testdir/zkir/identity.zkir" #f)
    (output-file "compiler/testdir/zkir/init0.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/ismember.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 6 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/init1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/update.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "}"
      ""
      "export circuit put(b: Boolean, n: Uint<16>, q: Field): [] {"
      "  field1.lookup(b).insert(disclose(n), disclose(q));"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
      )
    (output-file "compiler/testdir/zkir/init.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/put.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field): Boolean {"
      "  const x = !(n == 1);"
      "  return ((x) => x && n == 0)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo(n+1) ? n - 1 : n + 1;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 6, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 6, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 8, \"b\": 3 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 10 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 11, \"b\": 6 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "export { foo }"
      "include \"test-center/compact/bar\";"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Boolean {"
      "  impure = true;"
      "  const x = true;"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(): Boolean {"
      "  const x = true;"
      "  return x;"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo() ? n - 1 : n + 1;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field): Boolean {"
      "  const x = !(n == 1);"
      "  return ((x) => x && n == 0)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo(n+1) ? n - 1 : n + 1;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 6, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 6, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 8, \"b\": 3 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 10 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 11, \"b\": 6 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field): Field {"
      "  const x = n == 0;"
      "  return 1 + ((x) => x == false ? n + 7 : n + 13)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo(n-1) * foo(n-2) * 3;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"test_eq\", \"a\": 7, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 9, \"b\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 11 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 13 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 12, \"b\": 14 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 15 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"neg\", \"a\": 17 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 18 },"
        "    { \"op\": \"test_eq\", \"a\": 19, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 20, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 21, \"b\": 3 },"
        "    { \"op\": \"add\", \"a\": 19, \"b\": 11 },"
        "    { \"op\": \"add\", \"a\": 19, \"b\": 13 },"
        "    { \"op\": \"cond_select\", \"bit\": 22, \"a\": 23, \"b\": 24 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 25 },"
        "    { \"op\": \"mul\", \"a\": 16, \"b\": 26 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"mul\", \"a\": 27, \"b\": 28 },"
        "    { \"op\": \"output\", \"var\": 29 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Field): Field {"
      "  return 1 + (() => x)();"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo(n) * foo(n+1) * 3;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 0 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 6 },"
        "    { \"op\": \"mul\", \"a\": 6, \"b\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"mul\", \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean, x: Field): Field {"
      "  impure = true;"
      "  return 1 + ((b: Field, x: Boolean): Field => x ? b - 1 : b + 1)(x + 1, !b);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"neg\", \"a\": 2 },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 8 },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 2 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 10, \"b\": 9 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field, b: Boolean): Field {"
      "  return b ? n + 1 : n - 1;"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Vector<7, Field> {"
      "  impure = true;"
      "  return map(foo, nv, bv);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 14,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 7 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 8 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 9 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 10 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 11 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 12 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 20 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 19, \"b\": 21 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 24 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 23, \"b\": 25 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 28 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 27, \"b\": 29 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 32 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 31, \"b\": 33 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 36 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 35, \"b\": 37 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 40 },"
        "    { \"op\": \"cond_select\", \"bit\": 12, \"a\": 39, \"b\": 41 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 44 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 43, \"b\": 45 },"
        "    { \"op\": \"output\", \"var\": 22 },"
        "    { \"op\": \"output\", \"var\": 26 },"
        "    { \"op\": \"output\", \"var\": 30 },"
        "    { \"op\": \"output\", \"var\": 34 },"
        "    { \"op\": \"output\", \"var\": 38 },"
        "    { \"op\": \"output\", \"var\": 42 },"
        "    { \"op\": \"output\", \"var\": 46 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field, b: Boolean): Field {"
      "  impure = true;"
      "  return b ? n + 1 : n - 1;"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Vector<7, Field> {"
      "  impure = true;"
      "  return map(foo, map(foo, nv, bv), bv);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 14,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 7 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 8 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 9 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 10 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 11 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 12 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 20 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 19, \"b\": 21 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 24 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 23, \"b\": 25 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 28 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 27, \"b\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 32 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 31, \"b\": 33 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 36 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 35, \"b\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 40 },"
        "    { \"op\": \"cond_select\", \"bit\": 12, \"a\": 39, \"b\": 41 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 44 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 43, \"b\": 45 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 22, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 22, \"b\": 48 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 47, \"b\": 49 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 26, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 26, \"b\": 52 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 51, \"b\": 53 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 30, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 30, \"b\": 56 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 55, \"b\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 34, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 34, \"b\": 60 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 59, \"b\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 38, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 38, \"b\": 64 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 63, \"b\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 42, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 42, \"b\": 68 },"
        "    { \"op\": \"cond_select\", \"bit\": 12, \"a\": 67, \"b\": 69 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 46, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 46, \"b\": 72 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 71, \"b\": 73 },"
        "    { \"op\": \"output\", \"var\": 50 },"
        "    { \"op\": \"output\", \"var\": 54 },"
        "    { \"op\": \"output\", \"var\": 58 },"
        "    { \"op\": \"output\", \"var\": 62 },"
        "    { \"op\": \"output\", \"var\": 66 },"
        "    { \"op\": \"output\", \"var\": 70 },"
        "    { \"op\": \"output\", \"var\": 74 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness spam(): Bytes<32>;"
      "export circuit foo(): Field {"
      "  return disclose(spam()) as Field;"
      "}"
     )
      (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 248 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 1, \"modulus\": 2, \"bits\": 248 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(a: Field, n: Field, b: Boolean): Field {"
      "  impure = true;"
      "  return a + (b ? n + 1 : n - 1);"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Field {"
      "  impure = true;"
      "  return fold(foo, 17, nv, bv);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 14,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 7 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 8 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 9 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 10 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 11 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 12 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 20 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 19, \"b\": 21 },"
        "    { \"op\": \"add\", \"a\": 17, \"b\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 25 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 24, \"b\": 26 },"
        "    { \"op\": \"add\", \"a\": 23, \"b\": 27 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 30 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 29, \"b\": 31 },"
        "    { \"op\": \"add\", \"a\": 28, \"b\": 32 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 35 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 34, \"b\": 36 },"
        "    { \"op\": \"add\", \"a\": 33, \"b\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 40 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 39, \"b\": 41 },"
        "    { \"op\": \"add\", \"a\": 38, \"b\": 42 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 45 },"
        "    { \"op\": \"cond_select\", \"bit\": 12, \"a\": 44, \"b\": 46 },"
        "    { \"op\": \"add\", \"a\": 43, \"b\": 47 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 50 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 49, \"b\": 51 },"
        "    { \"op\": \"add\", \"a\": 48, \"b\": 52 },"
        "    { \"op\": \"output\", \"var\": 53 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Bytes<6> {"
      "  impure = true;"
      "  const x = 'hello!';"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"68656C6C6F21\" },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Vector<3, Vector<1, Field>> {"
      "  impure = true;"
      "  const x = [[7], [11], [19]];"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"output\", \"var\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0B\" },"
        "    { \"op\": \"output\", \"var\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"13\" },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "struct S { x: Field; y: Field; }"
      "export circuit foo(): S {"
      "  impure = true;"
      "  const x = S{ x: 23, y: 31 };"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"17\" },"
        "    { \"op\": \"output\", \"var\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"1F\" },"
        "    { \"op\": \"output\", \"var\": 6 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "witness W(x: S): S;"
      "export circuit foo(x : S): S {"
      "  return disclose(W(x));"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"output\", \"var\": 3 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "witness state(x: S): S;"
      "export circuit foo(x : S): S {"
      "  return disclose(state(x));"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"output\", \"var\": 3 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum Weasleys { Bill, Charley, Percy, Fred, George, Ron, Ginny }"
      "export circuit foo(): Weasleys {"
      "  impure = true;"
      "  const x = Weasleys.Fred;"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x: Field): [] {"
      "  impure = true;"
      "  assert(x == 17, 'oops');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 6 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Field): [] {"
      "  impure = true;"
      "  assert(x == 17, 'oops');"
      "}"
      "export circuit bar(x: Field): Field {"
      "  impure = true;"
      "  return (foo(x), x + 5);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 7 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Field): [] {"
      "  impure = true;"
      "  assert(x == 17, 'oops');"
      "}"
      "export circuit bar(x: Field): Field {"
      "  impure = true;"
      "  return (foo(x), x + 5) * 10;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"mul\", \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "module M {"
      "  ledger impure: Boolean;"
      "  export circuit bar(n: Field) : Field {"
      "    impure = true;"
      "    return foo() ? foo(n) : 17;"
      "}"
      "  export circuit foo() : Boolean { return true; }"
      "  export circuit foo(b: Boolean) : Boolean { return b; }"
      "}"
      "import M;"
      "circuit foo() : Boolean { return false; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export {bar}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x: Opaque<'string'>) : Vector<2, Opaque<'string'>> {"
      "  impure = true;"
      "  return map((ignore: Field): Opaque<'string'> => x,"
      "             [1, 2]);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum Names { karen, katy, kenny, kulta }"
      "export circuit foo(x: Names, y: Opaque<'string'>, z: Opaque<'string'>): Field {"
      "  impure = true;"
      "  return (x == Names.kenny ? 1 : 0) + (y == z ? 2 : 0);\n"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 8 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 8, \"b\": 5 },"
        "    { \"op\": \"add\", \"a\": 9, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x: Boolean, y: Boolean): Field {"
      "  impure = true;"
      "  return x == y ? 17 : 23;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"17\" },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 5, \"b\": 8 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum Names { karen, katy, kenny, kulta }"
      "struct T { name: Names, mt: Vector<0, Names>, eh: Boolean, p: Opaque<'string'>}"
      "struct S { x: Vector<2, Bytes<3>>, y: T, z: Field, w: Uint<32> }"
      "circuit foo(s1: S, s2: S) : Boolean { return s1 == s2; }"
      "export circuit bar1(x: Opaque<'string'>, y: Field) : Boolean {"
      "  impure = true;"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: y as Uint<32> },"
      "             S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: y as Uint<32> });"
      "}"
      "export circuit bar2(x: Opaque<'string'>) : Boolean {"
      "  impure = true;"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 },"
      "             S{ x: ['abc', 'd3f'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 });"
      "}"
      "export circuit bar3(x: Opaque<'string'>) : Boolean {"
      "  impure = true;"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 },"
      "             S{ x: ['abc', 'def'], y: T{ name: Names.kulta, mt: [], eh: true, p: x }, z: 101, w: 73 });"
      "}"
      "export circuit bar4(x: Opaque<'string'>) : Boolean {"
      "  impure = true;"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 },"
      "             S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: false, p: x }, z: 101, w: 73 });"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 32 },"
        "    { \"op\": \"copy\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar2.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar3.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar4.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Vector<0, Field>) : Field { return x == [] ? 1 : 2; }"
      "export circuit bar() : Field {"
      "  impure = true;"
      "  return foo([]);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit add(x: Field, y: Field): Field { return x + y; }"
      "circuit foo(x: Field): Boolean {"
      "  return x == fold(add, 1, []);"
      "}"
      "export circuit bar() : Boolean {"
      "  impure = true;"
      "  return foo(1);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit bar(x: Field): [] {"
      "  impure = true;"
      "  if (!(x == 0)) assert(x == 1, 'oops');"
      "}"
     )
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"assert\", \"cond\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'abc\\u1234def');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'abc\\xDCdef');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'bob\\'s \\\"fish\\\"\\r\\0\\b\\f\\t\\v\\n');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'abc\\x02\\x7f\\x85\\u2028def');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'abc\"def');"
      "  assert(!b, \"abc'def\");"
      "  assert(b, 'abc\\\\def');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 6 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field) : Field {"
      "  impure = true;"
      "  return x + 3 - x + 4;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"neg\", \"a\": 0 },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"add\", \"a\": 9, \"b\": 10 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Boolean, y: Boolean) : Field {"
      "  impure = true;"
      "  return 10 * ((x ? y : false) ? 3 + 4 : y ? 5 + 6 : 17);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 1, \"b\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0B\" },"
        "    { \"op\": \"cond_select\", \"bit\": 1, \"a\": 8, \"b\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 10, \"b\": 9 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"mul\", \"a\": 12, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 13 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  impure = true;"
      "  return x == y == (y == z);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"test_eq\", \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  impure = true;"
      "  return x == 0 || y == 0;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 5 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 3, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  impure = true;"
      "  return x == 0 && y == 0;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 5 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 9, \"b\": 5 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  impure = true;"
      "  return !(x == 0 && y == 0);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 5 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 9, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 5, \"b\": 3 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field) : Boolean {"
      "  impure = true;"
      "  return x + x * 3 - 4 == 20 || x == 5 && !(x * 3 + x == 8);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"mul\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"neg\", \"a\": 9 },"
        "    { \"op\": \"add\", \"a\": 8, \"b\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"14\" },"
        "    { \"op\": \"test_eq\", \"a\": 11, \"b\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 14 },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"test_eq\", \"a\": 8, \"b\": 16 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 15, \"a\": 18, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 1, \"b\": 19 },"
        "    { \"op\": \"output\", \"var\": 20 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field) : Vector<3, Field> {"
      "  impure = true;"
      "  return [x, x * 3, x * 7];"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"mul\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"mul\", \"a\": 0, \"b\": 8 },"
        "    { \"op\": \"output\", \"var\": 0 },"
        "    { \"op\": \"output\", \"var\": 7 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit baz(arg: Bytes<5>) : Field {"
      "  impure = true;"
      "  return arg as Field;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 40 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit baz(arg: Bytes<40>) : Field {"
      "  impure = true;"
      "  return arg as Field;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 72 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 0, \"modulus\": 1, \"bits\": 248 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit baz(arg: Boolean) : Field {"
      "  impure = true;"
      "  return arg as Field;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum E { a, b, c }"
      "export circuit baz(arg: E) : Field {"
      "  impure = true;"
      "  return arg as Field;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 1, \"bits\": 2 },"
        "    { \"op\": \"assert\", \"cond\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit baz(arg: Field) : Boolean {"
      "  impure = true;"
      "  return arg as Boolean;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x: Field) : Vector<1, Field> {"
      "  impure = true;"
      "  return foo(x == 0);"
      "}"
      "circuit foo(x: Boolean) : Vector<1, Field> { return x ? [1] : [2]; }"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(arg: Field) : Bytes<5> {"
      "  impure = true;"
      "  return arg as Bytes<5>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 40 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Boolean) : Vector<1, Field> { return x ? [1] : [2]; }"
      "export circuit foo(x: Field) : Vector<1, Field> {"
      "  impure = true;"
      "  return foo(x == 0);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1.read();"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "constructor(state: Uint<16>) { field1 += disclose(state); }"
      ""
      "export circuit foo(x: Bytes<32>): Field {"
      "  kernel.claimZswapNullifier(disclose(x));"
      "  return field1.read();"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"40\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"80\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "witness merkle_path_root(foo: Foo): MerkleTreeDigest;"
      ""
      "ledger field1: Map<Field, Foo>;"
      "ledger field2: HistoricMerkleTree<10, Foo>;"
      "ledger field3: Boolean;"
      ""
      "export circuit foo(n: Field, foo: Foo): Boolean {"
      "  field3.write(field1.lookup(disclose(n)).baz);"
      "  const q = field1.lookup(disclose(n));"
      "  assert(!(q == default<Foo>), 'entry not found');"
      "  return field2.checkRoot(disclose(merkle_path_root(q)));"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 248 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 18, \"b\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 19, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 21, \"a\": 22, \"b\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 20, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 23, \"a\": 24, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 25, \"a\": 7, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 26 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 30 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 29 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "witness merkle_path_root(foo: Foo): MerkleTreeDigest;"
      ""
      "ledger field1: Map<Field, Foo>;"
      "ledger field2: HistoricMerkleTree<10, Foo>;"
      "ledger field3: Boolean;"
      ""
      "export circuit foo(n: Field, foo: Foo): Boolean {"
      "  field3.write(field1.lookup(disclose(n)).baz);"
      "  const q = field1.lookup(disclose(n));"
      "  assert(q != default<Foo>, 'entry not found');"
      "  return field2.checkRoot(disclose(merkle_path_root(q)));"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 248 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 18, \"b\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 19, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 21, \"a\": 22, \"b\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 20, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 23, \"a\": 24, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 25, \"a\": 7, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 26 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 30 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 29 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Boolean {"
      "  impure = true;"
      "  return default<Boolean>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Field {"
      "  impure = true;"
      "  return default<Field>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Uint<0..11> {"
      "  impure = true;"
      "  return default<Uint<0..11>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Bytes<10> {"
      "  impure = true;"
      "  return default<Bytes<10>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Bytes<8> {"
      "  impure = true;"
      "  return default<Bytes<8>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum E { a, b, c }"
      "export circuit foo(): E {"
      "  impure = true;"
      "  return default<E>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Opaque<'string'> {"
      "  impure = true;"
      "  return default<Opaque<'string'>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Vector<10, Field> {"
      "  impure = true;"
      "  return default<Vector<10, Field>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "struct Foo {"
      "  a: Field;"
      "  b: Boolean;"
      "}"
      "export circuit foo(): Foo {"
      "  impure = true;"
      "  return default<Foo>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "struct Foo {"
      "  a: Vector<2, Field>;"
      "  b: Boolean;"
      "}"
      "struct Bar {"
      "  a: Vector<3, Foo>;"
      "  c: Boolean;"
      "}"
      "export circuit foo(): Bar {"
      "  impure = true;"
      "  return default<Bar>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export { Maybe }"
      "export circuit foo(x: Maybe<Boolean>): Boolean {"
      "  impure = true;"
      "  return x.is_some && x.value;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 1, \"b\": 4 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean, x: Uint<10>): Uint<10> {"
      "  impure = true;"
      "  return b ? x + 1023 as Uint<10> : 0;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"FF03\" },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 10 },"
        "    { \"op\": \"copy\", \"var\": 8 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 9, \"b\": 4 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean, x: Uint<10>): Uint<10> {"
      "  impure = true;"
      "  return b ? x + 1024 as Uint<10> : 0;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0004\" },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 10 },"
        "    { \"op\": \"copy\", \"var\": 8 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 9, \"b\": 4 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "  rats: Vector<1, CoinInfo>;"
      "  mice: Uint<16>;"
      "}"
      ""
      "ledger field0: Counter;"
      "ledger field1: Boolean;"
      "ledger field2: Set<Field>;"
      "ledger field3: Map<Field, Foo>;"
      "ledger field4: List<Foo>;"
      "ledger field5: MerkleTree<10, Foo>;"
      "ledger field6: HistoricMerkleTree<10, Field>;"
      "ledger field7: QualifiedCoinInfo;"
      "ledger field8: Set<QualifiedCoinInfo>;"
      "ledger field9: Map<Field, QualifiedCoinInfo>;"
      "ledger field10: List<QualifiedCoinInfo>;"
      ""
      "export circuit foo(x: Field, y: Foo, ci: CoinInfo): Boolean {"
      "  field0.resetToDefault();"
      "  field0.increment(5);"
      "  field0.decrement(2);"
      "  assert(field0.lessThan(4), 'oops 1');"
      "  field1.write(true);"
      "  const q = field1.read();"
      "  field2.resetToDefault();"
      "  assert(field2.isEmpty(), 'oops 2a');"
      "  assert(field2.size() == 0, 'oops 2b');"
      "  assert(!field2.member(disclose(x)), 'oops 2c');"
      "  field2.insert(disclose(x));"
      "  field2.insert(disclose(x) + 1);"
      "  field2.insert(disclose(x) + 2);"
      "  field2.insert(disclose(x) + 1);"
      "  assert(field2.size() == 3, 'oops 2d');"
      "  field2.remove(disclose(x )+ 1);"
      "  assert(field2.size() == 2, 'oops 2e');"
      "  assert(!field2.isEmpty(), 'oops 2f');"
      "  assert(field2.member(disclose(x)), 'oops 2g');"
      "  assert(!field2.member(disclose(x )+ 1), 'oops 2h');"
      "  assert(field2.member(disclose(x )+ 2), 'oops 2i');"
      "  field3.resetToDefault();"
      "  field3.insert(disclose(x), disclose(y));"
      "  field4.resetToDefault();"
      "  field5.resetToDefault();"
      "  field6.resetToDefault();"
      "  field7.writeCoin(disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field8.resetToDefault();"
      "  field8.insertCoin(disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field9.resetToDefault();"
      "  field9.insertCoin(disclose(x), disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field10.resetToDefault();"
      "  field10.pushFrontCoin(disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  return q;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 15,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 248 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 3 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 128 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 16 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 11, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 14, \"bits\": 128 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0F\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 26 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 30 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 30 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 33 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 32 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 34 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 34 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 35 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"test_eq\", \"a\": 35, \"b\": 17 },"
        "    { \"op\": \"assert\", \"cond\": 36 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 39 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"cond_select\", \"bit\": 39, \"a\": 17, \"b\": 15 },"
        "    { \"op\": \"assert\", \"cond\": 40 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 25 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 42 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 43 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"test_eq\", \"a\": 43, \"b\": 44 },"
        "    { \"op\": \"assert\", \"cond\": 45 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"19\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 46 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 47 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"test_eq\", \"a\": 47, \"b\": 25 },"
        "    { \"op\": \"assert\", \"cond\": 48 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 49 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"cond_select\", \"bit\": 49, \"a\": 17, \"b\": 15 },"
        "    { \"op\": \"assert\", \"cond\": 50 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 51 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 51 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 52 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"cond_select\", \"bit\": 52, \"a\": 17, \"b\": 15 },"
        "    { \"op\": \"assert\", \"cond\": 53 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 42 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 54 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 54 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"06\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 55 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"33\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"23\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"A4\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 58 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 59 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 55 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 59 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 62 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"60\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 64 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 66 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 64 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 65 },"
        "    { \"op\": \"load_imm\", \"imm\": \"6D646E3A6363\" },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 16, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 1, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }], \"inputs\": [10, 11, 12, 13, 14, 17, 67, 68, 69] },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 71 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"61\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-01\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 11 },"
        "    { \"op\": \"load_imm\", \"imm\": \"40\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"17\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"5B\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 77 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 78 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"34\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 79 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 77 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 78 },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 16, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 1, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }], \"inputs\": [10, 11, 12, 13, 14, 17, 80, 81, 69] },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 82 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 83 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"09\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 84 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 85 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 86 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 84 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"35\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 87 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 85 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 86 },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 16, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 1, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }], \"inputs\": [10, 11, 12, 13, 14, 17, 88, 89, 69] },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 90 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 91 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 92 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 93 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"37\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 94 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 92 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 93 },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 16, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 1, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }], \"inputs\": [10, 11, 12, 13, 14, 17, 95, 96, 69] },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 97 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 98 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 62 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 32 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit foo(c: CurvePoint): CurvePoint {"
      "  impure = true;"
      "  return ecAdd(c, ecMul(c, 3));"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"ec_mul\", \"a_x\": 0, \"a_y\": 1, \"scalar\": 7 },"
        "    { \"op\": \"ec_add\", \"a_x\": 0, \"a_y\": 1, \"b_x\": 8, \"b_y\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "witness bar(x: Field): Uint<0..36>;"
      "export circuit foo(x: Uint<0..36>): Uint<0..36> {"
      "  impure = true;"
      "  return x - x as Uint<0..36>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"24\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 1, \"bits\": 6 },"
        "    { \"op\": \"assert\", \"cond\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export struct Q<a> { x: a, y: Field }"
      "export enum Names { bill, sally, fred, george, }"
      "export circuit uno(q: Q<Boolean>): Names {"
      "  impure = true;"
      "  return q.x ? Names.sally : Names.fred;"
      "}"
      "export circuit dos(q: Q<Field>): Names {"
      "  impure = true;"
      "  return q.x == q.y ? Names.bill : Names.george;"
      "}"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 2, \"b\": 7 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/dos.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 4, \"b\": 8 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export struct Q<a, b> { x: a, y: b }"
      "export enum Names { bill, sally, fred, george, }"
      "export circuit uno(q: Q<Boolean, Vector<3, Uint<32>>>): Names {"
      "  impure = true;"
      "  return q.x ? Names.sally : Names.fred;"
      "}"
      "export circuit dos(q: Q<Vector<3, Field>,Vector<3,Field>>): Names {"
      "  impure = true;"
      "  return q.x == q.y ? Names.bill : Names.george;"
      "}"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 32 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 32 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 32 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 4, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/dos.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 6,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 6, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 6, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 6, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 4 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 12, \"b\": 8 },"
        "    { \"op\": \"test_eq\", \"a\": 2, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 14, \"b\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"cond_select\", \"bit\": 15, \"a\": 8, \"b\": 16 },"
        "    { \"op\": \"output\", \"var\": 17 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export struct Q<a, #n> { x: Vector<n, a>, y: Uint<12>, z: Opaque<'string'> }"
      "export circuit uno(q: Q<Boolean, 3>): Uint<32> {"
      "  impure = true;"
      "  return q.x[2] ? q.y + 1 : q.y - 1;"
      "}"
      "export circuit dos(q: Q<Field, 2>): Opaque<'string'> {"
      "  impure = true;"
      "  assert(q.x[0] == q.x[1], 'oops');"
      "  return q.z;"
      "}"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 5,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 2 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 5, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 5, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 5, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 5 },"
        "    { \"op\": \"less_than\", \"a\": 3, \"b\": 5, \"bits\": 12 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 7, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 2, \"a\": 5, \"b\": 12 },"
        "    { \"op\": \"assert\", \"cond\": 13 },"
        "    { \"op\": \"neg\", \"a\": 5 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 14 },"
        "    { \"op\": \"cond_select\", \"bit\": 2, \"a\": 10, \"b\": 15 },"
        "    { \"op\": \"output\", \"var\": 16 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/dos.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 9 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export struct Q<a, #n> { x: Vector<n, a>, y: a }"
      "module M1 {"
      "  export circuit uno(q: Q<Uint<12>, 2>): Uint<32> {"
      "    impure = true;"
      "    return q.x[0] + q.x[1] - q.y;"
      "  }"
      "}"
      "module M2 {"
      "  export circuit dos(q: Q<Boolean, 2>): Boolean {"
      "    impure = true;"
      "    return q.x[0] && q.x[1] || q.y;"
      "  }"
      "}"
      "module M3 {"
      "  struct Q { x: Vector<2, Uint<12>>, y: Boolean }"
      "  export circuit tres(q: Q): Uint<32> {"
      "    impure = true;"
      "    return q.y ? q.x[0] + q.x[1] : q.x[0] * q.x[1];"
      "  }"
      "}"
      "import M1;"
      "import M2;"
      "import M3;"
      "export { uno, dos, tres }"
     ) 
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"less_than\", \"a\": 8, \"b\": 2, \"bits\": 13 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 5, \"b\": 3 },"
        "    { \"op\": \"assert\", \"cond\": 10 },"
        "    { \"op\": \"neg\", \"a\": 2 },"
        "    { \"op\": \"add\", \"a\": 8, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/dos.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 1, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 3, \"b\": 2 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/tres.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 12 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"mul\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 2, \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "module M0<b> {"
      "  export struct Q<a, #n> { x: Vector<n, a>, y: b }"
      "}"
      "import M0<Uint<12>>;"
      "export { Q }"
      "module M1 {"
      "  ledger impure: Boolean;"
      "  import M0<Field>;"
      "  export circuit uno(q: Q<Field, 2>): Field {"
      "    impure = true;"
      "    return q.x[0] + q.x[1] - q.y;"
      "  }"
      "}"
      "import M1;"
      "export { uno }"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"neg\", \"a\": 2 },"
        "    { \"op\": \"add\", \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "module M0<b> {"
      "  export struct Q<a, #n> { x: Vector<n, a>, y: b }"
      "}"
      "import M0<Field>;"
      "export { Q }"
      "module M1 {"
      "  ledger impure: Boolean;"
      "  import M0<Uint<12>>;"
      "  export circuit uno(q: Q<Uint<12>, 2>): Uint<32> {"
      "    impure = true;"
      "    return q.x[0] + q.x[1] - q.y;"
      "  }"
      "}"
      "import M1;"
      "export { uno }"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"less_than\", \"a\": 8, \"b\": 2, \"bits\": 13 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 5, \"b\": 3 },"
        "    { \"op\": \"assert\", \"cond\": 10 },"
        "    { \"op\": \"neg\", \"a\": 2 },"
        "    { \"op\": \"add\", \"a\": 8, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit hello(): Opaque<'string'> {"
      "  return greeting;"
      "}"
      "ledger greeting: Opaque<'string'>;"
      "constructor(x: Opaque<'string'>) { greeting = disclose(x); }"
     )
    (output-file "compiler/testdir/zkir/hello.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"-01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export { Maybe }"
      "ledger rat: Field;"
      "constructor(witnesses: Field) { rat = disclose(witnesses); }"
      "witness witnesses(witnesses: Field): Field;"
      "export circuit state(x: Field): Field { return disclose(witnesses(x)) + 5; }"
      "export circuit context(x: Field): Field { return state(x + 3); }"
      "export circuit transcript(x: Field): Field { return context(x + 7); }"
      "export circuit Contract(x: Field): Field { return transcript(x) + 2; }"
      "export circuit arguments(eval: Field, arguments: Field, witnesses: Field): Field { return Contract(eval + arguments + witnesses) + rat; }"
      "export circuit functions(Maybe: Maybe<Field>): Field { return Maybe.value + 17; }"
      "export circuit finalize(): Field { return functions(some<Field>(3)); }"
     )
    (output-file "compiler/testdir/zkir/arguments.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"add\", \"a\": 10, \"b\": 11 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"add\", \"a\": 12, \"b\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"add\", \"a\": 14, \"b\": 18 },"
        "    { \"op\": \"output\", \"var\": 21 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit red_guess(my_guess: Field): [] {"
      "  impure = true;"
      "  return my_guess - 1;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Field" "[]" "circuit red_guess")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit red_guess(my_guess: Field): Field {"
      "  impure = true;"
      "  return my_guess - 1;"
      "}"
     )
    (output-file "compiler/testdir/zkir/red_guess.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit foo(x: Uint<12>): Field {"
      "  impure = true;"
      "  return transientCommit<Uint<12>>(x, 0);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"transient_hash\", \"inputs\": [3, 0] },"
        "    { \"op\": \"output\", \"var\": 6 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit foo(x: Uint<12>): Bytes<32> {"
      "  impure = true;"
      "  const rand : Bytes<32> = '12345678901234567890123456789012' as Bytes<32>;"
      "  return persistentCommit<Uint<12>>(x, rand);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"31323334353637383930313233343536373839303132333435363738393031\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 2, \"tag\": \"bytes\" } }], \"inputs\": [7, 6, 0] },"
        "    { \"op\": \"output\", \"var\": 8 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit foo(x: Boolean): CurvePoint {"
      "  impure = true;"
      "  return hashToCurve<Boolean>(x);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"hash_to_curve\", \"inputs\": [0] },"
        "    { \"op\": \"output\", \"var\": 6 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger foo: Field;"
      "ledger bar: Set<Field>;"
      "ledger baz: MerkleTree<2, Field>;"
      ""
      "export circuit rat(): [] {"
      "  foo = 42;"
      "  bar.insert(23);"
      "  baz.insert(71);"
      "}"
      ""
      "export circuit root_of(path: MerkleTreePath<2, Field>): MerkleTreeDigest {"
      "  return merkleTreePathRoot<2, Field>(path);"
      "}"
     )
    (output-file "compiler/testdir/zkir/rat.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"2A\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"17\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"47\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"6D646E3A6C68\" },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"tag\": \"field\" } }], \"inputs\": [14, 10] },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/root_of.zkir" #f)
    )

  (test
    '(
      "pragma language_version >= 0.4.0;"
      ""
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit bar(): Field {"
      "  impure = true;"
      "  return 3;"
      "}"
     )
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "pragma language_version >= 0.4.0 && < 0.99.0;"
      "pragma compiler_version >= 0.4.2 && < 0.99.0;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit bar(): Field {"
      "  impure = true;"
      "  return 3;"
      "}"
     )
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum LedgerState { setup, commit, reveal, final, }"
      ""
      "ledger organizer: Bytes<32>;"
      "ledger state: LedgerState;"
      "ledger topic: Maybe<Opaque<'string'>>;"
      "ledger beneficiary: Maybe<ZswapCoinPublicKey>;"
      "ledger yes: Counter;"
      "ledger no: Counter;"
      "ledger round: Counter;"
      "ledger committed_votes: MerkleTree<10, Bytes<32>>;"
      "ledger eligible_voters: HistoricMerkleTree<10, Bytes<32>>;"
      "ledger committed: Set<Bytes<32>>;"
      "ledger revealed: Set<Bytes<32>>;"
      ""
      "ledger pot: QualifiedCoinInfo;"
      "ledger pot_has_coin: Boolean;"
      ""
      "constructor(organizer_secret_key: Bytes<32>) {"
      "  organizer = public_key(disclose(organizer_secret_key));"
      "  state = LedgerState.setup;"
      "}"
      ""
      "circuit public_key(sk: Bytes<32>): Bytes<32> {"
      "  return persistentHash<Vector<2, Bytes<32>>>([pad(32, 'lares:udao:pk:'), sk]);"
      "}"
     )
    (output-file "compiler/testdir/zkir/public_key.zkir" #f)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger eligible_voters: HistoricMerkleTree<10, Bytes<32>>;"
      ""
      "circuit foo(pk: Bytes<32>): MerkleTreePath<10, Bytes<32>> {"
      "  const path = eligible_voters.find_path_for_leaf(pk);"
      "  return path;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 31" "~s ~s is a runtime-only method, but was invoked in-circuit" (HistoricMerkleTree find_path_for_leaf)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger rats: MerkleTree<10, Field>;"
      "ledger impure: Boolean;"
      ""
      "export circuit foo(x: Field): [] {"
      "  rats.insert(disclose(x));"
      "}"
      ""
      "export circuit root_of(path: MerkleTreePath<10, Field>): MerkleTreeDigest {"
      "  return merkleTreePathRoot<10, Field>(path);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"6D646E3A6C68\" },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"tag\": \"field\" } }], \"inputs\": [7, 0] },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/root_of.zkir" #f)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger bar: List<Field>;"
      ""
      "constructor() {"
      "  bar.pushFront(42);"
      "}"
      ""
      "export circuit baz(): Field {"
      "  kernel.mint(pad(32, ''), 5);"
      "  return bar.length();"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"40\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"80\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"31\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"12\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"60\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-01\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"14\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 20 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field0: Map<Field, Field>;"
      ""
      "export circuit foo(): [] {"
      "  field0.insert(1, 1);"
      "  field0.insert(2, 3);"
      "  field0.insert(3, 5);"
      "  field0.insert(4, 7);"
      "  field0.insert(5, 9);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"09\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field0: List<Field>;"
      ""
      "export circuit foo(): Maybe<Field> {"
      "  field0.pushFront(1);"
      "  field0.pushFront(3);"
      "  field0.pushFront(5);"
      "  field0.pushFront(7);"
      "  field0.pushFront(9);"
      "  return field0.head();"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"33\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"40\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"09\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"12\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"16\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"26\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"13\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0B\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 7 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 26 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 6 },"
        "    { \"op\": \"output\", \"var\": 24 },"
        "    { \"op\": \"output\", \"var\": 25 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean, n: Field): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "  field1.lookup(b).insert(disclose(n), default<Field>);"
      "}"
      "export circuit put(b: Boolean, n: Uint<16>, q: Field): [] {"
      "  field1.lookup(b).lookup(n).write(disclose(q));"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 19" "expected ~:r argument of ~s to have type ~a but received ~a" (1 insert "Uint<16>" "Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "  field1.lookup(b).insert(disclose(n), default<Field>);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
     )
    (output-file "compiler/testdir/zkir/init.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum E { a, b, c }"
      "struct S { x: Boolean, y: Bytes<10>, z: Vector<2, E> }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, S>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "  field1.lookup(b).insert(disclose(n), default<S>);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): S {"
      "  return field1.lookup(b).lookup(n);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 9" "expected ~:r argument of ~s to have type ~a but received ~a" (2 insert "Map<Uint<16>, struct S<x: Boolean, y: Bytes<10>, z: Vector<2, Enum<E, a, b, c>>>>" "Map<Uint<16>, Field>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum E { a, b, c }"
      "struct S { x: Boolean, y: Bytes<10>, z: Vector<2, E> }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, S>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, S>>);"
      "  field1.lookup(b).insert(disclose(n), default<Field>);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): S {"
      "  return field1.lookup(b).lookup(n);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 19" "expected ~:r argument of ~s to have type ~a but received ~a" (2 insert "struct S<x: Boolean, y: Bytes<10>, z: Vector<2, Enum<E, a, b, c>>>" "Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum E { a, b, c }"
      "struct S { x: Boolean, y: Bytes<10>, z: Vector<2, E> }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, S>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, S>>);"
      "  field1.lookup(b).insert(disclose(n), default<S>);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): S {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
     )
    (output-file "compiler/testdir/zkir/init.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 10 },"
        "    { \"op\": \"output\", \"var\": 8 },"
        "    { \"op\": \"output\", \"var\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "}"
      ""
      "export circuit put(b: Boolean, n: Uint<16>, q: Field): [] {"
      "  field1.lookup(b).insert(disclose(n), disclose(q));"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
     )
    (output-file "compiler/testdir/zkir/init.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/put.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "// nested ADT fields must be initialized to null before first use"
      "export circuit init_nested_counter(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Counter>);"
      "}"
      ""
      "// ADT values are not first-class objects, so when accessing a nested"
      "// ADT, the entire indirection chain must be used"
      "export circuit incr_nested_counter(b: Boolean, k: Uint<16>): [] {"
      "  field1.lookup(b).increment(disclose(k));"
      "}"
      ""
      "// when the last lookup is a read of a regular type one can include the read explicitly:"
      "export circuit read_nested_counter1(b: Boolean): Uint<64> {"
      "  return field1.lookup(b).read();"
      "}"
      ""
      "// ... or leave it off, in which case the read is implicit:"
      "export circuit read_nested_counter2(b: Boolean): Uint<64> {"
      "  return field1.lookup(b);"
      "}"
     )
    (output-file "compiler/testdir/zkir/init_nested_counter.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/incr_nested_counter.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/read_nested_counter1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/read_nested_counter2.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field2: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit init_nested_map(n: Field): [] {"
      "  field2.insert(n, default<Map<Field, Field>>);"
      "}"
      ""
      "export circuit insert_nested_map(n1: Field, n2: Field, n3: Field): [] {"
      "  field2.lookup(n1).insert(n2, n3);"
      "}"
      ""
      "export circuit lookup_nested_map(n1: Field, n2: Field): Field {"
      "  return field2.lookup(disclose(n1)).lookup(disclose(n2));"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 9" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter n of exported circuit init_nested_map at line 5 char 32" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the first argument to insert at line 6 char 9")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 20" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter n2 of exported circuit insert_nested_map at line 9 char 45" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the first argument to insert at line 10 char 20")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 20" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter n3 of exported circuit insert_nested_map at line 9 char 56" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the second argument to insert at line 10 char 20"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field2: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit init_nested_map(n: Field): [] {"
      "  field2.insert(disclose(n), default<Map<Field, Field>>);"
      "}"
      ""
      "export circuit insert_nested_map(n1: Field, n2: Field, n3: Field): [] {"
      "  field2.lookup(n1).insert(disclose(n2), disclose(n3));"
      "}"
      ""
      "export circuit lookup_nested_map(n1: Field, n2: Field): Field {"
      "  return field2.lookup(disclose(n1)).lookup(disclose(n2));"
      "}"
     )
    (output-file "compiler/testdir/zkir/init_nested_map.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/insert_nested_map.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/lookup_nested_map.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: Map<Boolean, Map<Field, Counter>>;"
      ""
      "export circuit init_nested_map(b: Boolean): [] {"
      "  fld.insert(b, default<Map<Field, Counter>>);"
      "}"
      ""
      "export circuit init_nested_counter(b: Boolean, n: Field): [] {"
      "  fld.lookup(b).insert(n, default<Counter>);"
      "}"
      ""
      "export circuit increment_nested_counter(b: Boolean, n: Field, k: Uint<16>): [] {"
      "  fld.lookup(b).lookup(n).increment(k);"
      "}"
      ""
      "export circuit read_nested_counter1(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n).read();"
      "}"
      ""
      "export circuit read_nested_counter2(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 6" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit init_nested_map at line 5 char 32" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the first argument to insert at line 6 char 6")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 16" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter n of exported circuit init_nested_counter at line 9 char 48" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the first argument to insert at line 10 char 16")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 14 char 26" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter k of exported circuit increment_nested_counter at line 13 char 63" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the argument to increment at line 14 char 26"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: Map<Boolean, Map<Field, Counter>>;"
      ""
      "export circuit init_nested_map(b: Boolean): [] {"
      "  fld.insert(disclose(b), default<Map<Field, Counter>>);"
      "}"
      ""
      "export circuit init_nested_counter(b: Boolean, n: Field): [] {"
      "  fld.lookup(b).insert(disclose(n), default<Counter>);"
      "}"
      ""
      "export circuit increment_nested_counter(b: Boolean, n: Field, k: Uint<16>): [] {"
      "  fld.lookup(b).lookup(n).increment(disclose(k));"
      "}"
      ""
      "export circuit read_nested_counter1(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n).read();"
      "}"
      ""
      "export circuit read_nested_counter2(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n);"
      "}"
     )
    (output-file "compiler/testdir/zkir/init_nested_map.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/init_nested_counter.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/increment_nested_counter.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"72\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A3\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/read_nested_counter1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"52\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 10 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/read_nested_counter2.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"52\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 10 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: Map<Boolean, Map<Field, Counter>>;"
      ""
      "export circuit bogus(): [] {"
      "  fld.lookup(true);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 6" "incomplete chain of ledger indirects: final result must be a regular type, but received ADT type ~a" ("Map<Field, Counter>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Set<Counter>;"
      ""
      "export circuit foo(): Field {"
      "  field1.write(default<Counter>);"
      "  return field1.read();"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 20" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("non-ADT type" "ledger ADT type" value_type "<standard library>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit foo(): Field {"
      "  impure = true;"
      "  return default<Set<Field>>;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Set<Field>" "Field" "circuit foo")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit foo(): Field {"
      "  impure = true;"
      "  return default<MerkleTree<3, Field>>;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("MerkleTree<3, Field>" "Field" "circuit foo")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit foo(q: Opaque<'string'>): Boolean {"
      "  impure = true;"
      "  const x = default<Opaque<'string'>>;"
      "  return x == q;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 3, \"b\": 0 },"
        "    { \"op\": \"output\", \"var\": 6 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit foo(q: Opaque<'string'>): Boolean {"
      "  impure = true;"
      "  const x = default<Opaque<'string'>>;"
      "  return x != q;"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 3, \"b\": 0 },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  ; FIXME uncomment for CC print-TS pass implementation
  #|
  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export circuit barr(): Bytes<32> { return pad(32, ''); }"
         )
       )
     (succeeds))
    ((create-file "UseC.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.foo(contract_c.read().barr()); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("UseC.compact line 2 char 1" "contract types are not yet implemented" ()))
     ))
  |#

  (test
    '(
      "module M1 {"
      "  import CompactStandardLibrary;"
      "  export { QualifiedCoinInfo, CoinInfo, ZswapCoinPublicKey, ContractAddress };"
      "  export { left, ownPublicKey, createZswapInput, createZswapOutput };"
      "}"
      "import M1 prefix std$;"
      "circuit foo(qcoin: std$QualifiedCoinInfo, coin: std$CoinInfo): [] {"
      "  std$createZswapInput(qcoin);"
      "  std$createZswapOutput(coin, std$left<std$ZswapCoinPublicKey, std$ContractAddress>(std$ownPublicKey()));"
      "}"
      "module M2 {"
      "  import CompactStandardLibrary;"
      "  export circuit bar(qcoin: QualifiedCoinInfo, coin: CoinInfo): [] {"
      "    createZswapInput(qcoin);"
      "    createZswapOutput(coin, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));"
      "  }"
      "}"
      "import M2;"
      "import M2 prefix M2$;"
      "export { foo, bar, M2$bar };"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 11,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 128 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 64 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 128 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 248 },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" }"
        "  ]"
        "}"))

    (output-file "compiler/testdir/zkir/bar.zkir"
                 "compiler/testdir/zkir/foo.zkir")
    (output-file "compiler/testdir/zkir/M2$bar.zkir"
                 "compiler/testdir/zkir/foo.zkir")
    )

  (test
    '(
      "witness W(): Field;"
      "module A<#n, t> {"
      "  export circuit foo(v : Vector<n, t>, b : Bytes<n>): Field {"
      "    return disclose(W()) + 17;"
      "  }"
      "}"
      "module B {"
      "  circuit foo(x : Field): Field { return x + disclose(W()); }"
      "  circuit bar(x : Field): Field { return x - disclose(W()); }"
      "  import A<7, Field> prefix AA;"
      "  import A<30, Boolean> prefix AAA;"
      "  export {foo, AAfoo, AAAfoo, bar}"
      "}"
      "import B;"
      "import B prefix BB;"
      "import B<> prefix BBB;"
      "export {foo, AAfoo, BBfoo, BBAAfoo, BBAAAfoo, BBBfoo, BBBAAAfoo, bar, BBbar, BBBbar}"
      )
    (output-file "compiler/testdir/zkir/BBfoo.zkir"
                 "compiler/testdir/zkir/foo.zkir")
    (output-file "compiler/testdir/zkir/BBBfoo.zkir"
                 "compiler/testdir/zkir/foo.zkir")
    (output-file "compiler/testdir/zkir/BBAAfoo.zkir"
                 "compiler/testdir/zkir/AAfoo.zkir")
    (output-file "compiler/testdir/zkir/BBBAAAfoo.zkir"
                 "compiler/testdir/zkir/BBAAAfoo.zkir")
    (output-file "compiler/testdir/zkir/BBbar.zkir"
                 "compiler/testdir/zkir/bar.zkir")
    (output-file "compiler/testdir/zkir/BBBbar.zkir"
                 "compiler/testdir/zkir/bar.zkir")
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(qcoin: QualifiedCoinInfo, coin: CoinInfo): [] {"
      "  createZswapInput(qcoin);"
      "  createZswapOutput(coin, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 11,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 128 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 64 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 128 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 248 },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger allowances: Map<Bytes<32>, Map<Bytes<32>, Uint<32>>>;"
      "export circuit allowance(b: Boolean, owner: Bytes<32>, spender: Bytes<32>): Uint<32> {"
      "  return disclose(b) ? allowances.lookup(disclose(owner)).lookup(disclose(spender)) : 0;"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Vector<2, Field>>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Vector<2, Field>>>);"
      "  field1.lookup(b).insert(disclose(n), default<Vector<2, Field>>);"
      "}"
     )
    (returns
      (program
        (kernel-declaration (%kernel.2 () (Kernel)))
        (public-ledger-declaration
          ((%field1.3
             (0)
             (Map (ty ((abytes 1)) ((tfield 1)))
                  (ty ((aadt))
                      ((Map (ty ((abytes 2)) ((tfield 65535)))
                            (ty ((afield) (afield)) ((tfield) (tfield))))))))))
        (circuit %init.4 ((argument
                            (%b.0)
                            (ty ((abytes 1)) ((tfield 1))))
                          (argument (%n.1) (ty ((abytes 2)) ((tfield 65535)))))
             (ty () ())
          (= () (public-ledger 1 %field1.3 (0) insert %b.0 0))
          (= ()
             (public-ledger 1 %field1.3 (0 ((ty ((abytes 1)) ((tfield 1)))
                                           %b.0)) insert
               %n.1
               ; two zeros
               0
               0))
          ())))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field0: S;"
      "ledger field1: Opaque<'string'>;"
      ""
      "struct S { x: Bytes<1024>, y: Bytes<8> }"
      "export circuit one(x: Field): S {"
      "  field0 = disclose(S { x * x - 1 as Bytes<1024>, x + x - 1 as Bytes<8> });"
      "  return field0;"
      "}"
      ""
      "export circuit two(s: Opaque<'string'>, x: Field): Field {"
      "  field1 = disclose(s);"
      "  const q = persistentCommit<Field>(x, upgradeFromTransient(x));"
      "  return transientCommit<Bytes<32>>(q, x);"
      "}"
      ""
      "export circuit three(): [S, Bytes<32>] {"
      "  return [field0, persistentHash<Opaque<'string'>>(field1)];"
      "}"
     )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: [Field, Field];"
      ""
      "export circuit foo(x: Bytes<1024>, y: Bytes<8>): [] {"
      "  fld = disclose([x as Field, y as Field]);"
      "}"
     )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger f00: Field;"
      "export ledger f01: Field;"
      "export ledger f02: Field;"
      "export ledger f03: Field;"
      "export ledger f04: Field;"
      "export ledger f05: Field;"
      "export ledger f06: Field;"
      "export ledger f07: Field;"
      "export ledger f08: Field;"
      "export ledger f09: Field;"
      "export ledger f10: Field;"
      "export ledger f11: Field;"
      "export ledger f12: Field;"
      "export ledger f13: Field;"
      "export ledger f14: Field;"
      "export ledger f15: Field;"
      "export ledger f16: Field;"
      "export ledger f17: Field;"
      "export ledger f18: Field;"
      "export ledger f19: Field;"
      "export ledger f20: Field;"
      "export ledger f21: Field;"
      "export ledger f22: Field;"
      "export ledger f23: Field;"
      "export ledger f24: Field;"
      "export ledger f25: Field;"
      "export ledger f26: Field;"
      "export ledger f27: Field;"
      "export ledger f28: Field;"
      "export ledger f29: Field;"
      "export ledger f30: Field;"
      "export ledger f31: Field;"
      "export ledger f32: Field;"
      "export ledger f33: Field;"
      "export ledger f34: Field;"
      "export ledger f35: Field;"
      "export ledger f36: Field;"
      "export ledger f37: Field;"
      "export ledger f38: Field;"
      "export ledger f39: Field;"
      "constructor() {"
      "  f17 = 101;"
      "}"
      "export circuit foo(): [Field, Field] {"
      "  return [f11, f38];"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger merkleTree: MerkleTree<4, Field>;"
      "export circuit test(): [] {"
      "  // Test: insertIndexDefault inserts default value at a specific index"
      "  const defaultIndex = 3;"
      "  merkleTree.insertIndexDefault(defaultIndex);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger c: Map<Field, List<Field>>;"
      ""
      "export circuit foo1(): [] {"
      "  assert(c.isEmpty() == true, 'Structure should be empty');"
      "  assert(c.size() == 0, 'Size should be 0');"
      "}"
      ""
      "export circuit foo2(): [] {"
      "  c.insert(0, default<List<Field>>);"
      "  assert(c.size() == 1, 'Size should be 1');"
      "  assert(c.lookup(0).length() == 0, 'Key 0 should have value 1');"
      "}"
      ""
      "export circuit foo3(): [] {"
      "  c.insertDefault(1);"
      "  assert(c.size() == 2, 'Size should be 2');"
      "  assert(c.lookup(1).length() == 0, 'Key 1 should have value 0');"
      "  assert(c.member(1) == true, 'Key 1 should be member');"
      "}"
      ""
      "export circuit foo4(): [] {"
      "  c.remove(0);"
      "  assert(c.size() == 1, 'Size should be 1');"
      "  assert(c.lookup(0).length() == 0, 'What should happen here');"
      "}"
      ""
      "export circuit foo5(): [] {"
      "  c.resetToDefault();"
      "  assert(c.size() == 0, 'Size should be 0');"
      "  assert(c.isEmpty() == true, 'Structure should be empty');"
      "}"
      )
    (succeeds)
    )

  ;; Regression tests for PM-15412, a bug in indexing parameters that were
  ;; constrained to be Uint with a size that wasn't a power of two.
  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<0..5>): [] {"
      "  forceImpure();"
      "  assert(x == 0, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 1, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<0..5>, y: Uint<0..6>): [] {"
      "  forceImpure();"
      "  assert(x == y, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 2, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"06\" },"
        "    { \"op\": \"less_than\", \"a\": 1, \"b\": 4, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<0..5>, y: Uint<0..6>, z: Uint<0..7>): [] {"
      "  forceImpure();"
      "  assert(x + y == z, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 3, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"06\" },"
        "    { \"op\": \"less_than\", \"a\": 1, \"b\": 5, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"less_than\", \"a\": 2, \"b\": 7, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 10, \"b\": 2 },"
        "    { \"op\": \"assert\", \"cond\": 11 }"
        "  ]"
        "}"))
    )

  ;; Mix powers of two with non-powers of two.
  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<0..5>, y: Uint<4>): [] {"
      "  forceImpure();"
      "  assert(x == y, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 2, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 3 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<4>, y: Uint<0..5>): [] {"
      "  forceImpure();"
      "  assert(x == y, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 1, \"b\": 2, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<4>, y: Uint<4>): [] {"
      "  forceImpure();"
      "  assert(x == y, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 4 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger fld: Vector<1, Field>;"
      "export circuit foo(v: Vector<1, Field>): [] {"
      "  fld = disclose(v);"
      "}"
      "export circuit Foo(x: Field): [] {"
      "  fld = [disclose(x)];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 1" "the exported impure circuit name ~a is identical to the exported circuit name ~s at ~a modulo case; please rename to avoid zkir and prover-key filename clashes on case-insensitive filesystems" ("Foo" "foo" "line 2 char 1")))
    )

  (test
    '(
      "ledger fld: Vector<1, Field>;"
      "circuit Mfoo(v: Vector<1, Field>): [] {"
      "  fld = disclose(v);"
      "}"
      "module M {"
      "  export circuit Foo(x: Field): [] {"
      "    fld = [disclose(x)];"
      "  }"
      "}"
      "import M prefix M;"
      "export { Mfoo, MFoo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 3" "the exported impure circuit name ~a is identical to the exported circuit name ~s at ~a modulo case; please rename to avoid zkir and prover-key filename clashes on case-insensitive filesystems" ("MFoo for Foo" "Mfoo" "line 2 char 1")))
    )

  (test
    '(
      "circuit bar(v: Vector<5, Field>, i: Uint<0..5>): Field {"
      "  return v[i];"
      "}"
      "export circuit foo(v: Vector<5, Field>): Field {"
      "  return bar(v, 3);"
      "}"
      )
    (returns
      (program
        (public-ledger-declaration ())
        (circuit %foo.0 ((argument
                           (%v.1 %v.2 %v.3 %v.4 %v.5)
                           (ty ((afield) (afield) (afield) (afield) (afield))
                               ((tfield)
                                 (tfield)
                                 (tfield)
                                 (tfield)
                                 (tfield)))))
             (ty ((afield)) ((tfield)))
          (%v.4))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger x: Counter;"
      "export circuit foo(v: Vector<5, Uint<16>>): [] {"
      "  for (const i of 2..5) x += disclose(v[i] - v[i-1]);"
      "}"
      )
    (returns
      (program
        (kernel-declaration (%kernel.14 () (Kernel)))
        (public-ledger-declaration ((%x.15 (0) (Counter))))
        (circuit %foo.16 ((argument
                            (%v.10 %v.0 %v.1 %v.4 %v.7)
                            (ty ((abytes 2)
                                  (abytes 2)
                                  (abytes 2)
                                  (abytes 2)
                                  (abytes 2))
                                ((tfield 65535)
                                  (tfield 65535)
                                  (tfield 65535)
                                  (tfield 65535)
                                  (tfield 65535)))))
             (ty () ())
          (= %t.2 (< 16 %v.1 %v.0))
          (= %t.3 (select %t.2 0 1))
          (assert %t.3 "result of subtraction would be negative")
          (= %tmp.11 (- 16 %v.1 %v.0))
          (= () (public-ledger 1 %x.15 (0) increment %tmp.11))
          (= %t.5 (< 16 %v.4 %v.1))
          (= %t.6 (select %t.5 0 1))
          (assert %t.6 "result of subtraction would be negative")
          (= %tmp.12 (- 16 %v.4 %v.1))
          (= () (public-ledger 1 %x.15 (0) increment %tmp.12))
          (= %t.8 (< 16 %v.7 %v.4))
          (= %t.9 (select %t.8 0 1))
          (assert %t.9 "result of subtraction would be negative")
          (= %tmp.13 (- 16 %v.7 %v.4))
          (= () (public-ledger 1 %x.15 (0) increment %tmp.13))
          ())))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" 0)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" 1)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" 5)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 40 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 12 },"
        "    { \"op\": \"output\", \"var\": 17 },"
        "    { \"op\": \"output\", \"var\": 18 },"
        "    { \"op\": \"output\", \"var\": 19 },"
        "    { \"op\": \"output\", \"var\": 20 },"
        "    { \"op\": \"output\", \"var\": 21 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" (field-bytes))
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 248 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 11, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 13, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 15, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 17, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 19, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 21, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 23, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 25, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 27, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 29, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 31, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 33, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 35, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 37, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 39, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 41, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 43, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 45, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 47, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 49, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 51, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 53, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 55, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 57, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 62 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"1F\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 64 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 26 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 30 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 32 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 34 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 36 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 40 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 42 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 46 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 48 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 50 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 52 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 54 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 58 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 59 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 65 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 66 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 67 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 68 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 100 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 69 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 71 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 77 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 78 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 79 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 80 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 81 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 82 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 83 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 84 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 85 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 86 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 87 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 88 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 89 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 90 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 91 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 92 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 93 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 94 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 95 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 96 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 97 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 98 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 99 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 64 },"
        "    { \"op\": \"output\", \"var\": 69 },"
        "    { \"op\": \"output\", \"var\": 70 },"
        "    { \"op\": \"output\", \"var\": 71 },"
        "    { \"op\": \"output\", \"var\": 72 },"
        "    { \"op\": \"output\", \"var\": 73 },"
        "    { \"op\": \"output\", \"var\": 74 },"
        "    { \"op\": \"output\", \"var\": 75 },"
        "    { \"op\": \"output\", \"var\": 76 },"
        "    { \"op\": \"output\", \"var\": 77 },"
        "    { \"op\": \"output\", \"var\": 78 },"
        "    { \"op\": \"output\", \"var\": 79 },"
        "    { \"op\": \"output\", \"var\": 80 },"
        "    { \"op\": \"output\", \"var\": 81 },"
        "    { \"op\": \"output\", \"var\": 82 },"
        "    { \"op\": \"output\", \"var\": 83 },"
        "    { \"op\": \"output\", \"var\": 84 },"
        "    { \"op\": \"output\", \"var\": 85 },"
        "    { \"op\": \"output\", \"var\": 86 },"
        "    { \"op\": \"output\", \"var\": 87 },"
        "    { \"op\": \"output\", \"var\": 88 },"
        "    { \"op\": \"output\", \"var\": 89 },"
        "    { \"op\": \"output\", \"var\": 90 },"
        "    { \"op\": \"output\", \"var\": 91 },"
        "    { \"op\": \"output\", \"var\": 92 },"
        "    { \"op\": \"output\", \"var\": 93 },"
        "    { \"op\": \"output\", \"var\": 94 },"
        "    { \"op\": \"output\", \"var\": 95 },"
        "    { \"op\": \"output\", \"var\": 96 },"
        "    { \"op\": \"output\", \"var\": 97 },"
        "    { \"op\": \"output\", \"var\": 98 },"
        "    { \"op\": \"output\", \"var\": 99 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" (+ (field-bytes) 5))
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 40 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 10, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 14, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 16, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 18, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 20, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 22, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 24, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 26, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 28, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 30, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 32, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 34, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 36, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 38, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 40, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 42, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 44, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 46, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 48, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 50, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 52, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 54, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 56, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 58, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 60, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 62, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 64, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 66, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 71 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"24\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 33 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 35 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 39 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 43 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 45 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 47 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 49 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 51 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 53 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 55 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 59 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 67 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 69 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 68 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 75 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 77 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 114 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 78 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 79 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 80 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 81 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 82 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 83 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 84 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 85 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 86 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 87 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 88 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 89 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 90 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 91 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 92 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 93 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 94 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 95 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 96 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 97 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 98 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 99 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 100 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 101 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 102 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 103 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 104 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 105 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 106 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 107 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 108 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 109 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 110 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 111 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 112 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 113 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 74 },"
        "    { \"op\": \"output\", \"var\": 78 },"
        "    { \"op\": \"output\", \"var\": 79 },"
        "    { \"op\": \"output\", \"var\": 80 },"
        "    { \"op\": \"output\", \"var\": 81 },"
        "    { \"op\": \"output\", \"var\": 82 },"
        "    { \"op\": \"output\", \"var\": 83 },"
        "    { \"op\": \"output\", \"var\": 84 },"
        "    { \"op\": \"output\", \"var\": 85 },"
        "    { \"op\": \"output\", \"var\": 86 },"
        "    { \"op\": \"output\", \"var\": 87 },"
        "    { \"op\": \"output\", \"var\": 88 },"
        "    { \"op\": \"output\", \"var\": 89 },"
        "    { \"op\": \"output\", \"var\": 90 },"
        "    { \"op\": \"output\", \"var\": 91 },"
        "    { \"op\": \"output\", \"var\": 92 },"
        "    { \"op\": \"output\", \"var\": 93 },"
        "    { \"op\": \"output\", \"var\": 94 },"
        "    { \"op\": \"output\", \"var\": 95 },"
        "    { \"op\": \"output\", \"var\": 96 },"
        "    { \"op\": \"output\", \"var\": 97 },"
        "    { \"op\": \"output\", \"var\": 98 },"
        "    { \"op\": \"output\", \"var\": 99 },"
        "    { \"op\": \"output\", \"var\": 100 },"
        "    { \"op\": \"output\", \"var\": 101 },"
        "    { \"op\": \"output\", \"var\": 102 },"
        "    { \"op\": \"output\", \"var\": 103 },"
        "    { \"op\": \"output\", \"var\": 104 },"
        "    { \"op\": \"output\", \"var\": 105 },"
        "    { \"op\": \"output\", \"var\": 106 },"
        "    { \"op\": \"output\", \"var\": 107 },"
        "    { \"op\": \"output\", \"var\": 108 },"
        "    { \"op\": \"output\", \"var\": 109 },"
        "    { \"op\": \"output\", \"var\": 110 },"
        "    { \"op\": \"output\", \"var\": 111 },"
        "    { \"op\": \"output\", \"var\": 112 },"
        "    { \"op\": \"output\", \"var\": 113 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" 0)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 3 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" 1)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"copy\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" 5)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 5,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 4, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 5, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 6, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 7, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 17 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" (field-bytes))
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 31,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 11, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 14, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 15, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 16, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 17, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 18, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 19, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 20, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 21, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 22, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 23, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 24, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 25, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 26, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 27, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 28, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 29, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 30, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 30, \"modulus\": 29, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 31, \"modulus\": 28, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 32, \"modulus\": 27, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 33, \"modulus\": 26, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 34, \"modulus\": 25, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 35, \"modulus\": 24, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 36, \"modulus\": 23, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 37, \"modulus\": 22, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 38, \"modulus\": 21, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 39, \"modulus\": 20, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 40, \"modulus\": 19, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 41, \"modulus\": 18, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 42, \"modulus\": 17, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 43, \"modulus\": 16, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 44, \"modulus\": 15, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 45, \"modulus\": 14, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 46, \"modulus\": 13, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 47, \"modulus\": 12, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 48, \"modulus\": 11, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 49, \"modulus\": 10, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 50, \"modulus\": 9, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 51, \"modulus\": 8, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 52, \"modulus\": 7, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 53, \"modulus\": 6, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 54, \"modulus\": 5, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 55, \"modulus\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 56, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 57, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 58, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 59, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 62 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"1F\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 64 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 66 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 67 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 68 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 69 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 69 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" (- (* (field-bytes) 2) 1))
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 61,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 11, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 14, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 15, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 16, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 17, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 18, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 19, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 20, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 21, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 22, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 23, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 24, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 25, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 26, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 27, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 28, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 29, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 30, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 31, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 32, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 33, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 34, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 35, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 36, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 37, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 38, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 39, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 40, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 41, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 42, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 43, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 44, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 45, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 46, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 47, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 48, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 49, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 50, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 51, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 52, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 53, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 54, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 55, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 56, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 57, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 58, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 59, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 60, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 60, \"modulus\": 59, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 61, \"modulus\": 58, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 62, \"modulus\": 57, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 63, \"modulus\": 56, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 64, \"modulus\": 55, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 65, \"modulus\": 54, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 66, \"modulus\": 53, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 67, \"modulus\": 52, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 68, \"modulus\": 51, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 69, \"modulus\": 50, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 70, \"modulus\": 49, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 71, \"modulus\": 48, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 72, \"modulus\": 47, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 73, \"modulus\": 46, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 74, \"modulus\": 45, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 75, \"modulus\": 44, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 76, \"modulus\": 43, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 77, \"modulus\": 42, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 78, \"modulus\": 41, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 79, \"modulus\": 40, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 80, \"modulus\": 39, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 81, \"modulus\": 38, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 82, \"modulus\": 37, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 83, \"modulus\": 36, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 84, \"modulus\": 35, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 85, \"modulus\": 34, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 86, \"modulus\": 33, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 87, \"modulus\": 32, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 88, \"modulus\": 31, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 30, \"modulus\": 29, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 90, \"modulus\": 28, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 91, \"modulus\": 27, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 92, \"modulus\": 26, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 93, \"modulus\": 25, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 94, \"modulus\": 24, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 95, \"modulus\": 23, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 96, \"modulus\": 22, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 97, \"modulus\": 21, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 98, \"modulus\": 20, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 99, \"modulus\": 19, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 100, \"modulus\": 18, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 101, \"modulus\": 17, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 102, \"modulus\": 16, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 103, \"modulus\": 15, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 104, \"modulus\": 14, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 105, \"modulus\": 13, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 106, \"modulus\": 12, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 107, \"modulus\": 11, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 108, \"modulus\": 10, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 109, \"modulus\": 9, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 110, \"modulus\": 8, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 111, \"modulus\": 7, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 112, \"modulus\": 6, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 113, \"modulus\": 5, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 114, \"modulus\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 115, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 116, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 117, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 118, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 121 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 122 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"3D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 123 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 124 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 89 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 119 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 125 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 126 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 127 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 122 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 130 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 124 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 128 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 129 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 5 },"
        "    { \"op\": \"output\", \"var\": 128 },"
        "    { \"op\": \"output\", \"var\": 129 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger round: Counter;"
      "export circuit test10(param1: Vector<1, Uint<8>>): [] {"
      "  round.increment(disclose(param1[0]));"
      ""
      "  const p = param1 as Bytes<1>;"
      "  round.increment((disclose(p) as Vector<1, Uint<8>>)[0]);"
      "}"
      )
    (output-file "compiler/testdir/zkir/test10.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"copy\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger round: Counter;"
      "export circuit test10(param1: Vector<10, Uint<8>>): [] {"
      "  round.increment(disclose(param1[0]));"
      ""
      "  const p = param1 as Bytes<10>;"
      "  round.increment((disclose(p) as Vector<10, Uint<8>>)[0]);"
      "}"
      )
    (output-file "compiler/testdir/zkir/test10.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 10,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 1 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 9, \"modulus\": 8, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 15, \"modulus\": 7, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 16, \"modulus\": 6, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 17, \"modulus\": 5, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 18, \"modulus\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 19, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 20, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 21, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 22, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 23, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 24, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 26, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 28, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 30, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 32, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 34, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 36, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 38, \"bits\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 1 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger val5: Bytes<10>;"
      ""
      "export circuit test5(param1: Vector<10, Uint<8>>): Bytes<10> {"
      "  val5 = disclose(param1) as Bytes<10>;"
      "  return val5;"
      "}"
      )
    (output-file "compiler/testdir/zkir/test5.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 10,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 9, \"modulus\": 8, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 10, \"modulus\": 7, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 11, \"modulus\": 6, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 12, \"modulus\": 5, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 13, \"modulus\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 14, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 15, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 16, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 17, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 26 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 27 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger m: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit test0(): Field {"
      "  return m.lookup(1000).lookup(2000);"
      "}"
      "export circuit test1(x: Field): Field {"
      "  return m.lookup(1000).lookup(disclose(x));"
      "}"
      "export circuit test2(x: Field): Field {"
      "  return m.lookup(disclose(x)).lookup(1000);"
      "}"
      "export circuit test3(x: Field, y: Field): Field {"
      "  return m.lookup(disclose(x)).lookup(disclose(y));"
      "}"
      )
    (output-file "compiler/testdir/zkir/test0.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"E803\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"D007\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/test1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"E803\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/test2.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"E803\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/test3.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 2, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )
)

(parameterize ([zkir-v3 #t])
(run-tests print-zkir-v3
  (test
    "examples/tiny.compact"
    (output-file "compiler/testdir/zkir/public_key.zkir" #f)
    (output-file "compiler/testdir/zkir/get.zkir"
                 "examples/outputs/tiny.compact/zkir/get.zkir3")
    (output-file "compiler/testdir/zkir/set.zkir"
                 "examples/outputs/tiny.compact/zkir/set.zkir3")
    (output-file "compiler/testdir/zkir/clear.zkir"
                 "examples/outputs/tiny.compact/zkir/clear.zkir3")
    )

  (test
    "examples/election.compact"
    (output-file "compiler/testdir/zkir/vote$commit.zkir"
                 "examples/outputs/election.compact/zkir/vote$commit.zkir3")
    (output-file "compiler/testdir/zkir/vote$reveal.zkir"
                 "examples/outputs/election.compact/zkir/vote$reveal.zkir3")
    (output-file "compiler/testdir/zkir/add_voter.zkir"
                 "examples/outputs/election.compact/zkir/add_voter.zkir3")
    (output-file "compiler/testdir/zkir/set_topic.zkir"
                 "examples/outputs/election.compact/zkir/set_topic.zkir3")
    (output-file "compiler/testdir/zkir/advance.zkir"
                 "examples/outputs/election.compact/zkir/advance.zkir3")
    )

  (test
    "examples/zerocash.compact"
    (output-file "compiler/testdir/zkir/spend.zkir"
                 "examples/outputs/zerocash.compact/zkir/spend.zkir3")
    (output-file "compiler/testdir/zkir/zerocash_mint.zkir"
                 "examples/outputs/zerocash.compact/zkir/zerocash_mint.zkir3")
  )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "module M {"
      "  export circuit foo(a : Uint<0..1>): Boolean { forcenonpure(); return a == 0; }"
      "}"
      ""
      "import M prefix A;"
      "import M prefix B;"
      "export { Afoo, Bfoo };"
      )
    (output-file "compiler/testdir/zkir/Bfoo.zkir"
                 "compiler/testdir/zkir/Afoo.zkir")
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<0..1>): Boolean { forcenonpure(); return a == 0; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"constrain_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<0..1>): Boolean { forcenonpure(); return a != 0; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"constrain_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 3, \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<16>): Boolean { forcenonpure(); return a < 5; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 2, \"bits\": 16 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<16>): Boolean { forcenonpure(); return a < a + 5; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 2 },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 3, \"bits\": 17 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Uint<0..1>): Boolean { forcenonpure(); return a <= 0; }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"constrain_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"less_than\", \"a\": 1, \"b\": 0, \"bits\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 3, \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(a : Boolean): Boolean {"
      "  return a;
    }"
      ""
      "export circuit bar(a: Boolean): Boolean {"
      "  return foo(a);"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir" #f)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Boolean): Boolean {"
      "  forcenonpure();"
      "  return a;
    }"
      ""
      "export circuit bar(a: Boolean): Boolean {"
      "  return foo(a);"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness forcenonpure(): [];"
      ""
      "export circuit foo(a : Boolean): Boolean {"
      "  return a;"
      "}"
      ""
      "export circuit bar(a: Boolean): Boolean {"
      "  forcenonpure();"
      "  return foo(a);"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness forcenonpure(): [];"
      ""
      "struct Foo {"
      "  a: Field;"
      "  b: Boolean;"
      "}"
      "struct Bar {"
      "  a: Vector<2, Foo>;"
      "  b: Bytes<0>;"
      "  c: Uint<32>;"
      "  d: Opaque<'string'>;"
      "}"
      "export circuit foo(): Bar {"
      "  forcenonpure();"
      "  return default<Bar>;"
      "}"
      "export circuit bar(x: Opaque<'string'>): Bar {"
      "  forcenonpure();"
      "  return Bar{ a: [Foo{ a: 0, b: false }, Foo{ a: 0, b: false }], b: '', c: 0, d: x };"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness forcenonpure(): [];"
      ""
      "export circuit bar(x: Bytes<32>, y: Uint<32>, z: Uint<16>): Field {"
      "  forcenonpure();"
      "  const q = x as Field;"
      "  return q + y * z - q * (y - z);"
      "}"
      )
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 32 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 0, \"modulus\": 1, \"bits\": 248 },"
        "    { \"op\": \"mul\", \"a\": 2, \"b\": 3 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 6 },"
        "    { \"op\": \"less_than\", \"a\": 2, \"b\": 3, \"bits\": 32 },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 9, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 10 },"
        "    { \"op\": \"neg\", \"a\": 3 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 11 },"
        "    { \"op\": \"mul\", \"a\": 5, \"b\": 12 },"
        "    { \"op\": \"neg\", \"a\": 13 },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 14 },"
        "    { \"op\": \"output\", \"var\": 15 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness forcenonpure(): [];"
      "export circuit foo(x: Field): Uint<16> {"
      "  forcenonpure();"
      "  return x as Uint<16>;"
      "}"
      "export circuit bar(x: Uint<32>): Uint<16> {"
      "  forcenonpure();"
      "  return x as Uint<16>;"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 16 },"
        "    { \"op\": \"copy\", \"var\": 0 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 32 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 16 },"
        "    { \"op\": \"copy\", \"var\": 0 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(p1: CurvePoint, p2: CurvePoint): CurvePoint {"
      "  return ecAdd(ecAdd(ecAdd(ecMul(p1, transientHash<Vector<2, Field>>([p1.x, p2.x])), ecMulGenerator(17)), hashToCurve<ContractAddress>(kernel.self())), hashToCurve<Vector<0, Field>>([]));"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"transient_hash\", \"inputs\": [0, 2] },"
        "    { \"op\": \"ec_mul\", \"a_x\": 0, \"a_y\": 1, \"scalar\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"ec_mul_generator\", \"scalar\": 8 },"
        "    { \"op\": \"ec_add\", \"a_x\": 6, \"a_y\": 7, \"b_x\": 9, \"b_y\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"60\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"hash_to_curve\", \"inputs\": [16, 17] },"
        "    { \"op\": \"ec_add\", \"a_x\": 11, \"a_y\": 12, \"b_x\": 20, \"b_y\": 21 },"
        "    { \"op\": \"hash_to_curve\", \"inputs\": [] },"
        "    { \"op\": \"ec_add\", \"a_x\": 22, \"a_y\": 23, \"b_x\": 24, \"b_y\": 25 },"
        "    { \"op\": \"output\", \"var\": 26 },"
        "    { \"op\": \"output\", \"var\": 27 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field0: Map<Boolean, Field>;"
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "export circuit identity(q: Field): Field {"
      "  return q + 1;"
      "}"
      ""
      "export circuit init0(b: Boolean): [] {"
      "  field0.insert(disclose(b), default<Field>);"
      "}"
      ""
      "export circuit ismember(b: Boolean): Boolean {"
      "  return field1.member(disclose(b));"
      "}"
      ""
      "export circuit init1(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Counter>);"
      "}"
      ""
      "export circuit update(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(disclose(b)) += disclose(n);"
      "}"
      ""
      "export circuit get(b: Boolean): Uint<64> {"
      "  return field1.lookup(disclose(b));"
      "}"
      )
    (output-file "compiler/testdir/zkir/identity.zkir" #f)
    (output-file "compiler/testdir/zkir/init0.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/ismember.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 6 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/init1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/update.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "}"
      ""
      "export circuit put(b: Boolean, n: Uint<16>, q: Field): [] {"
      "  field1.lookup(b).insert(disclose(n), disclose(q));"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
      )
    (output-file "compiler/testdir/zkir/init.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/put.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field): Boolean {"
      "  const x = !(n == 1);"
      "  return ((x) => x && n == 0)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo(n+1) ? n - 1 : n + 1;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 6, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 6, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 8, \"b\": 3 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 10 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 11, \"b\": 6 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "export { foo }"
      "include \"test-center/compact/bar\";"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 }"
        "  ]"
        "}"))
    )


  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Boolean {"
      "  impure = true;"
      "  const x = true;"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(): Boolean {"
      "  const x = true;"
      "  return x;"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo() ? n - 1 : n + 1;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field): Boolean {"
      "  const x = !(n == 1);"
      "  return ((x) => x && n == 0)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo(n+1) ? n - 1 : n + 1;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 6, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 6, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 8, \"b\": 3 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 10 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 11, \"b\": 6 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field): Field {"
      "  const x = n == 0;"
      "  return 1 + ((x) => x == false ? n + 7 : n + 13)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo(n-1) * foo(n-2) * 3;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"test_eq\", \"a\": 7, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 9, \"b\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 11 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 13 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 12, \"b\": 14 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 15 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"neg\", \"a\": 17 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 18 },"
        "    { \"op\": \"test_eq\", \"a\": 19, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 20, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 21, \"b\": 3 },"
        "    { \"op\": \"add\", \"a\": 19, \"b\": 11 },"
        "    { \"op\": \"add\", \"a\": 19, \"b\": 13 },"
        "    { \"op\": \"cond_select\", \"bit\": 22, \"a\": 23, \"b\": 24 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 25 },"
        "    { \"op\": \"mul\", \"a\": 16, \"b\": 26 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"mul\", \"a\": 27, \"b\": 28 },"
        "    { \"op\": \"output\", \"var\": 29 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Field): Field {"
      "  return 1 + (() => x)();"
      "}"
      "export circuit bar(n: Field): Field {"
      "  impure = true;"
      "  return foo(n) * foo(n+1) * 3;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 0 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 6 },"
        "    { \"op\": \"mul\", \"a\": 6, \"b\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"mul\", \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean, x: Field): Field {"
      "  impure = true;"
      "  return 1 + ((b: Field, x: Boolean): Field => x ? b - 1 : b + 1)(x + 1, !b);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"neg\", \"a\": 2 },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 8 },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 2 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 10, \"b\": 9 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field, b: Boolean): Field {"
      "  return b ? n + 1 : n - 1;"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Vector<7, Field> {"
      "  impure = true;"
      "  return map(foo, nv, bv);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 14,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 7 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 8 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 9 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 10 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 11 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 12 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 20 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 19, \"b\": 21 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 24 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 23, \"b\": 25 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 28 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 27, \"b\": 29 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 32 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 31, \"b\": 33 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 36 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 35, \"b\": 37 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 40 },"
        "    { \"op\": \"cond_select\", \"bit\": 12, \"a\": 39, \"b\": 41 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 44 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 43, \"b\": 45 },"
        "    { \"op\": \"output\", \"var\": 22 },"
        "    { \"op\": \"output\", \"var\": 26 },"
        "    { \"op\": \"output\", \"var\": 30 },"
        "    { \"op\": \"output\", \"var\": 34 },"
        "    { \"op\": \"output\", \"var\": 38 },"
        "    { \"op\": \"output\", \"var\": 42 },"
        "    { \"op\": \"output\", \"var\": 46 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field, b: Boolean): Field {"
      "  return b ? n + 1 : n - 1;"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Vector<7, Field> {"
      "  impure = true;"
      "  return map(foo, nv, bv);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 14,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 7 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 8 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 9 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 10 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 11 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 12 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 20 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 19, \"b\": 21 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 24 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 23, \"b\": 25 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 28 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 27, \"b\": 29 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 32 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 31, \"b\": 33 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 36 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 35, \"b\": 37 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 40 },"
        "    { \"op\": \"cond_select\", \"bit\": 12, \"a\": 39, \"b\": 41 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 44 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 43, \"b\": 45 },"
        "    { \"op\": \"output\", \"var\": 22 },"
        "    { \"op\": \"output\", \"var\": 26 },"
        "    { \"op\": \"output\", \"var\": 30 },"
        "    { \"op\": \"output\", \"var\": 34 },"
        "    { \"op\": \"output\", \"var\": 38 },"
        "    { \"op\": \"output\", \"var\": 42 },"
        "    { \"op\": \"output\", \"var\": 46 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(n: Field, b: Boolean): Field {"
      "  impure = true;"
      "  return b ? n + 1 : n - 1;"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Vector<7, Field> {"
      "  impure = true;"
      "  return map(foo, map(foo, nv, bv), bv);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 14,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 7 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 8 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 9 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 10 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 11 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 12 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 20 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 19, \"b\": 21 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 24 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 23, \"b\": 25 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 28 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 27, \"b\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 32 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 31, \"b\": 33 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 36 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 35, \"b\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 40 },"
        "    { \"op\": \"cond_select\", \"bit\": 12, \"a\": 39, \"b\": 41 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 44 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 43, \"b\": 45 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 22, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 22, \"b\": 48 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 47, \"b\": 49 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 26, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 26, \"b\": 52 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 51, \"b\": 53 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 30, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 30, \"b\": 56 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 55, \"b\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 34, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 34, \"b\": 60 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 59, \"b\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 38, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 38, \"b\": 64 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 63, \"b\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 42, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 42, \"b\": 68 },"
        "    { \"op\": \"cond_select\", \"bit\": 12, \"a\": 67, \"b\": 69 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 46, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 46, \"b\": 72 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 71, \"b\": 73 },"
        "    { \"op\": \"output\", \"var\": 50 },"
        "    { \"op\": \"output\", \"var\": 54 },"
        "    { \"op\": \"output\", \"var\": 58 },"
        "    { \"op\": \"output\", \"var\": 62 },"
        "    { \"op\": \"output\", \"var\": 66 },"
        "    { \"op\": \"output\", \"var\": 70 },"
        "    { \"op\": \"output\", \"var\": 74 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness spam(): Bytes<32>;"
      "export circuit foo(): Field {"
      "  return disclose(spam()) as Field;"
      "}"
     )
      (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 248 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 1, \"modulus\": 2, \"bits\": 248 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(a: Field, n: Field, b: Boolean): Field {"
      "  impure = true;"
      "  return a + (b ? n + 1 : n - 1);"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Field {"
      "  impure = true;"
      "  return fold(foo, 17, nv, bv);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 14,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 7 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 8 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 9 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 10 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 11 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 12 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 20 },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 19, \"b\": 21 },"
        "    { \"op\": \"add\", \"a\": 17, \"b\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 25 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 24, \"b\": 26 },"
        "    { \"op\": \"add\", \"a\": 23, \"b\": 27 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 2, \"b\": 30 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 29, \"b\": 31 },"
        "    { \"op\": \"add\", \"a\": 28, \"b\": 32 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 35 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 34, \"b\": 36 },"
        "    { \"op\": \"add\", \"a\": 33, \"b\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 40 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 39, \"b\": 41 },"
        "    { \"op\": \"add\", \"a\": 38, \"b\": 42 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 5, \"b\": 45 },"
        "    { \"op\": \"cond_select\", \"bit\": 12, \"a\": 44, \"b\": 46 },"
        "    { \"op\": \"add\", \"a\": 43, \"b\": 47 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 14, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 14 },"
        "    { \"op\": \"neg\", \"a\": 14 },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 50 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 49, \"b\": 51 },"
        "    { \"op\": \"add\", \"a\": 48, \"b\": 52 },"
        "    { \"op\": \"output\", \"var\": 53 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Bytes<6> {"
      "  impure = true;"
      "  const x = 'hello!';"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"68656C6C6F21\" },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Vector<3, Vector<1, Field>> {"
      "  impure = true;"
      "  const x = [[7], [11], [19]];"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"output\", \"var\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0B\" },"
        "    { \"op\": \"output\", \"var\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"13\" },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "struct S { x: Field; y: Field; }"
      "export circuit foo(): S {"
      "  impure = true;"
      "  const x = S{ x: 23, y: 31 };"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"17\" },"
        "    { \"op\": \"output\", \"var\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"1F\" },"
        "    { \"op\": \"output\", \"var\": 6 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "witness W(x: S): S;"
      "export circuit foo(x : S): S {"
      "  return disclose(W(x));"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"output\", \"var\": 3 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "witness state(x: S): S;"
      "export circuit foo(x : S): S {"
      "  return disclose(state(x));"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"output\", \"var\": 3 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum Weasleys { Bill, Charley, Percy, Fred, George, Ron, Ginny }"
      "export circuit foo(): Weasleys {"
      "  impure = true;"
      "  const x = Weasleys.Fred;"
      "  return x;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x: Field): [] {"
      "  impure = true;"
      "  assert(x == 17, 'oops');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 6 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Field): [] {"
      "  impure = true;"
      "  assert(x == 17, 'oops');"
      "}"
      "export circuit bar(x: Field): Field {"
      "  impure = true;"
      "  return (foo(x), x + 5);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 7 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Field): [] {"
      "  impure = true;"
      "  assert(x == 17, 'oops');"
      "}"
      "export circuit bar(x: Field): Field {"
      "  impure = true;"
      "  return (foo(x), x + 5) * 10;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"mul\", \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "module M {"
      "  ledger impure: Boolean;"
      "  export circuit bar(n: Field) : Field {"
      "    impure = true;"
      "    return foo() ? foo(n) : 17;"
      "}"
      "  export circuit foo() : Boolean { return true; }"
      "  export circuit foo(b: Boolean) : Boolean { return b; }"
      "}"
      "import M;"
      "circuit foo() : Boolean { return false; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export {bar}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x: Opaque<'string'>) : Vector<2, Opaque<'string'>> {"
      "  impure = true;"
      "  return map((ignore: Field): Opaque<'string'> => x,"
      "             [1, 2]);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum Names { karen, katy, kenny, kulta }"
      "export circuit foo(x: Names, y: Opaque<'string'>, z: Opaque<'string'>): Field {"
      "  impure = true;"
      "  return (x == Names.kenny ? 1 : 0) + (y == z ? 2 : 0);\n"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 8 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 8, \"b\": 5 },"
        "    { \"op\": \"add\", \"a\": 9, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x: Boolean, y: Boolean): Field {"
      "  impure = true;"
      "  return x == y ? 17 : 23;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"17\" },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 5, \"b\": 8 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum Names { karen, katy, kenny, kulta }"
      "struct T { name: Names, mt: Vector<0, Names>, eh: Boolean, p: Opaque<'string'>}"
      "struct S { x: Vector<2, Bytes<3>>, y: T, z: Field, w: Uint<32> }"
      "circuit foo(s1: S, s2: S) : Boolean { return s1 == s2; }"
      "export circuit bar1(x: Opaque<'string'>, y: Field) : Boolean {"
      "  impure = true;"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: y as Uint<32> },"
      "             S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: y as Uint<32> });"
      "}"
      "export circuit bar2(x: Opaque<'string'>) : Boolean {"
      "  impure = true;"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 },"
      "             S{ x: ['abc', 'd3f'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 });"
      "}"
      "export circuit bar3(x: Opaque<'string'>) : Boolean {"
      "  impure = true;"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 },"
      "             S{ x: ['abc', 'def'], y: T{ name: Names.kulta, mt: [], eh: true, p: x }, z: 101, w: 73 });"
      "}"
      "export circuit bar4(x: Opaque<'string'>) : Boolean {"
      "  impure = true;"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 },"
      "             S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: false, p: x }, z: 101, w: 73 });"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 32 },"
        "    { \"op\": \"copy\", \"var\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar2.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar3.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/bar4.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Vector<0, Field>) : Field { return x == [] ? 1 : 2; }"
      "export circuit bar() : Field {"
      "  impure = true;"
      "  return foo([]);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit add(x: Field, y: Field): Field { return x + y; }"
      "circuit foo(x: Field): Boolean {"
      "  return x == fold(add, 1, []);"
      "}"
      "export circuit bar() : Boolean {"
      "  impure = true;"
      "  return foo(1);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir" #f)
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit bar(x: Field): [] {"
      "  impure = true;"
      "  if (!(x == 0)) assert(x == 1, 'oops');"
      "}"
     )
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"assert\", \"cond\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'abc\\u1234def');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'abc\\xDCdef');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'bob\\'s \\\"fish\\\"\\r\\0\\b\\f\\t\\v\\n');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'abc\\x02\\x7f\\x85\\u2028def');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean): [] {"
      "  impure = true;"
      "  assert(b, 'abc\"def');"
      "  assert(!b, \"abc'def\");"
      "  assert(b, 'abc\\\\def');"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 0 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 6 },"
        "    { \"op\": \"assert\", \"cond\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field) : Field {"
      "  impure = true;"
      "  return x + 3 - x + 4;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"neg\", \"a\": 0 },"
        "    { \"op\": \"add\", \"a\": 7, \"b\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"add\", \"a\": 9, \"b\": 10 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Boolean, y: Boolean) : Field {"
      "  impure = true;"
      "  return 10 * ((x ? y : false) ? 3 + 4 : y ? 5 + 6 : 17);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 1, \"b\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0B\" },"
        "    { \"op\": \"cond_select\", \"bit\": 1, \"a\": 8, \"b\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 10, \"b\": 9 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"mul\", \"a\": 12, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 13 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  impure = true;"
      "  return x == y == (y == z);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 2 },"
        "    { \"op\": \"test_eq\", \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  impure = true;"
      "  return x == 0 || y == 0;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 5 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 3, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  impure = true;"
      "  return x == 0 && y == 0;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 5 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 9, \"b\": 5 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  impure = true;"
      "  return !(x == 0 && y == 0);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 5 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 9, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 10, \"a\": 5, \"b\": 3 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field) : Boolean {"
      "  impure = true;"
      "  return x + x * 3 - 4 == 20 || x == 5 && !(x * 3 + x == 8);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"mul\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"neg\", \"a\": 9 },"
        "    { \"op\": \"add\", \"a\": 8, \"b\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"14\" },"
        "    { \"op\": \"test_eq\", \"a\": 11, \"b\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 14 },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"test_eq\", \"a\": 8, \"b\": 16 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 15, \"a\": 18, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 1, \"b\": 19 },"
        "    { \"op\": \"output\", \"var\": 20 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x : Field) : Vector<3, Field> {"
      "  impure = true;"
      "  return [x, x * 3, x * 7];"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"mul\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"mul\", \"a\": 0, \"b\": 8 },"
        "    { \"op\": \"output\", \"var\": 0 },"
        "    { \"op\": \"output\", \"var\": 7 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit baz(arg: Bytes<5>) : Field {"
      "  impure = true;"
      "  return arg as Field;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 40 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit baz(arg: Bytes<40>) : Field {"
      "  impure = true;"
      "  return arg as Field;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 72 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 0, \"modulus\": 1, \"bits\": 248 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit baz(arg: Boolean) : Field {"
      "  impure = true;"
      "  return arg as Field;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum E { a, b, c }"
      "export circuit baz(arg: E) : Field {"
      "  impure = true;"
      "  return arg as Field;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 1, \"bits\": 2 },"
        "    { \"op\": \"assert\", \"cond\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit baz(arg: Field) : Boolean {"
      "  impure = true;"
      "  return arg as Boolean;"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(x: Field) : Vector<1, Field> {"
      "  impure = true;"
      "  return foo(x == 0);"
      "}"
      "circuit foo(x: Boolean) : Vector<1, Field> { return x ? [1] : [2]; }"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(arg: Field) : Bytes<5> {"
      "  impure = true;"
      "  return arg as Bytes<5>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 40 },"
        "    { \"op\": \"output\", \"var\": 0 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "circuit foo(x: Boolean) : Vector<1, Field> { return x ? [1] : [2]; }"
      "export circuit foo(x: Field) : Vector<1, Field> {"
      "  impure = true;"
      "  return foo(x == 0);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1.read();"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "constructor(state: Uint<16>) { field1 += disclose(state); }"
      ""
      "export circuit foo(x: Bytes<32>): Field {"
      "  kernel.claimZswapNullifier(disclose(x));"
      "  return field1.read();"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"40\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"80\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "witness merkle_path_root(foo: Foo): MerkleTreeDigest;"
      ""
      "ledger field1: Map<Field, Foo>;"
      "ledger field2: HistoricMerkleTree<10, Foo>;"
      "ledger field3: Boolean;"
      ""
      "export circuit foo(n: Field, foo: Foo): Boolean {"
      "  field3.write(field1.lookup(disclose(n)).baz);"
      "  const q = field1.lookup(disclose(n));"
      "  assert(!(q == default<Foo>), 'entry not found');"
      "  return field2.checkRoot(disclose(merkle_path_root(q)));"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 248 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 18, \"b\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 19, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 21, \"a\": 22, \"b\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 20, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 23, \"a\": 24, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 25, \"a\": 7, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 26 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 30 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 29 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "witness merkle_path_root(foo: Foo): MerkleTreeDigest;"
      ""
      "ledger field1: Map<Field, Foo>;"
      "ledger field2: HistoricMerkleTree<10, Foo>;"
      "ledger field3: Boolean;"
      ""
      "export circuit foo(n: Field, foo: Foo): Boolean {"
      "  field3.write(field1.lookup(disclose(n)).baz);"
      "  const q = field1.lookup(disclose(n));"
      "  assert(q != default<Foo>, 'entry not found');"
      "  return field2.checkRoot(disclose(merkle_path_root(q)));"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 248 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 18, \"b\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 19, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 21, \"a\": 22, \"b\": 7 },"
        "    { \"op\": \"test_eq\", \"a\": 20, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 23, \"a\": 24, \"b\": 7 },"
        "    { \"op\": \"cond_select\", \"bit\": 25, \"a\": 7, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 26 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 30 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 29 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Boolean {"
      "  impure = true;"
      "  return default<Boolean>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Field {"
      "  impure = true;"
      "  return default<Field>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Uint<0..11> {"
      "  impure = true;"
      "  return default<Uint<0..11>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Bytes<10> {"
      "  impure = true;"
      "  return default<Bytes<10>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Bytes<8> {"
      "  impure = true;"
      "  return default<Bytes<8>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "enum E { a, b, c }"
      "export circuit foo(): E {"
      "  impure = true;"
      "  return default<E>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Opaque<'string'> {"
      "  impure = true;"
      "  return default<Opaque<'string'>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(): Vector<10, Field> {"
      "  impure = true;"
      "  return default<Vector<10, Field>>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "struct Foo {"
      "  a: Field;"
      "  b: Boolean;"
      "}"
      "export circuit foo(): Foo {"
      "  impure = true;"
      "  return default<Foo>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "struct Foo {"
      "  a: Vector<2, Field>;"
      "  b: Boolean;"
      "}"
      "struct Bar {"
      "  a: Vector<3, Foo>;"
      "  c: Boolean;"
      "}"
      "export circuit foo(): Bar {"
      "  impure = true;"
      "  return default<Bar>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 },"
        "    { \"op\": \"output\", \"var\": 2 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export { Maybe }"
      "export circuit foo(x: Maybe<Boolean>): Boolean {"
      "  impure = true;"
      "  return x.is_some && x.value;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 1, \"b\": 4 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean, x: Uint<10>): Uint<10> {"
      "  impure = true;"
      "  return b ? x + 1023 as Uint<10> : 0;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"FF03\" },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 10 },"
        "    { \"op\": \"copy\", \"var\": 8 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 9, \"b\": 4 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export circuit foo(b: Boolean, x: Uint<10>): Uint<10> {"
      "  impure = true;"
      "  return b ? x + 1024 as Uint<10> : 0;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0004\" },"
        "    { \"op\": \"add\", \"a\": 1, \"b\": 7 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 10 },"
        "    { \"op\": \"copy\", \"var\": 8 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 9, \"b\": 4 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "  rats: Vector<1, CoinInfo>;"
      "  mice: Uint<16>;"
      "}"
      ""
      "ledger field0: Counter;"
      "ledger field1: Boolean;"
      "ledger field2: Set<Field>;"
      "ledger field3: Map<Field, Foo>;"
      "ledger field4: List<Foo>;"
      "ledger field5: MerkleTree<10, Foo>;"
      "ledger field6: HistoricMerkleTree<10, Field>;"
      "ledger field7: QualifiedCoinInfo;"
      "ledger field8: Set<QualifiedCoinInfo>;"
      "ledger field9: Map<Field, QualifiedCoinInfo>;"
      "ledger field10: List<QualifiedCoinInfo>;"
      ""
      "export circuit foo(x: Field, y: Foo, ci: CoinInfo): Boolean {"
      "  field0.resetToDefault();"
      "  field0.increment(5);"
      "  field0.decrement(2);"
      "  assert(field0.lessThan(4), 'oops 1');"
      "  field1.write(true);"
      "  const q = field1.read();"
      "  field2.resetToDefault();"
      "  assert(field2.isEmpty(), 'oops 2a');"
      "  assert(field2.size() == 0, 'oops 2b');"
      "  assert(!field2.member(disclose(x)), 'oops 2c');"
      "  field2.insert(disclose(x));"
      "  field2.insert(disclose(x) + 1);"
      "  field2.insert(disclose(x) + 2);"
      "  field2.insert(disclose(x) + 1);"
      "  assert(field2.size() == 3, 'oops 2d');"
      "  field2.remove(disclose(x )+ 1);"
      "  assert(field2.size() == 2, 'oops 2e');"
      "  assert(!field2.isEmpty(), 'oops 2f');"
      "  assert(field2.member(disclose(x)), 'oops 2g');"
      "  assert(!field2.member(disclose(x )+ 1), 'oops 2h');"
      "  assert(field2.member(disclose(x )+ 2), 'oops 2i');"
      "  field3.resetToDefault();"
      "  field3.insert(disclose(x), disclose(y));"
      "  field4.resetToDefault();"
      "  field5.resetToDefault();"
      "  field6.resetToDefault();"
      "  field7.writeCoin(disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field8.resetToDefault();"
      "  field8.insertCoin(disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field9.resetToDefault();"
      "  field9.insertCoin(disclose(x), disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field10.resetToDefault();"
      "  field10.pushFrontCoin(disclose(ci), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  return q;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 15,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 248 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 3 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 128 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 16 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 11, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 14, \"bits\": 128 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0F\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 26 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 30 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 30 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 33 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 32 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 34 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 34 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 35 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"test_eq\", \"a\": 35, \"b\": 17 },"
        "    { \"op\": \"assert\", \"cond\": 36 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 39 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"cond_select\", \"bit\": 39, \"a\": 17, \"b\": 15 },"
        "    { \"op\": \"assert\", \"cond\": 40 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 25 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 42 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 43 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"test_eq\", \"a\": 43, \"b\": 44 },"
        "    { \"op\": \"assert\", \"cond\": 45 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"19\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 46 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 47 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"test_eq\", \"a\": 47, \"b\": 25 },"
        "    { \"op\": \"assert\", \"cond\": 48 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 49 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"cond_select\", \"bit\": 49, \"a\": 17, \"b\": 15 },"
        "    { \"op\": \"assert\", \"cond\": 50 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 51 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 51 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 52 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"cond_select\", \"bit\": 52, \"a\": 17, \"b\": 15 },"
        "    { \"op\": \"assert\", \"cond\": 53 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 42 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 54 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 54 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"06\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 55 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"33\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"23\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"A4\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 58 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 59 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 55 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 59 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 62 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"60\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 64 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 66 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 64 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 65 },"
        "    { \"op\": \"load_imm\", \"imm\": \"6D646E3A6363\" },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 16, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 1, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }], \"inputs\": [10, 11, 12, 13, 14, 17, 67, 68, 69] },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 71 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"61\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-01\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 11 },"
        "    { \"op\": \"load_imm\", \"imm\": \"40\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"17\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"5B\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 77 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 78 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"34\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 79 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 77 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 78 },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 16, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 1, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }], \"inputs\": [10, 11, 12, 13, 14, 17, 80, 81, 69] },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 82 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 83 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"09\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 84 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 85 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 86 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 84 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"35\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 87 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 85 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 86 },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 16, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 1, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }], \"inputs\": [10, 11, 12, 13, 14, 17, 88, 89, 69] },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 90 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 91 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 92 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 93 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"37\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 94 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 92 },"
        "    { \"op\": \"cond_select\", \"bit\": 17, \"a\": 17, \"b\": 93 },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 16, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 1, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }], \"inputs\": [10, 11, 12, 13, 14, 17, 95, 96, 69] },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 97 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 98 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 62 },"
        "    { \"op\": \"pi_skip\", \"guard\": 15, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 32 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit foo(c: CurvePoint): CurvePoint {"
      "  impure = true;"
      "  return ecAdd(c, ecMul(c, 3));"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"ec_mul\", \"a_x\": 0, \"a_y\": 1, \"scalar\": 7 },"
        "    { \"op\": \"ec_add\", \"a_x\": 0, \"a_y\": 1, \"b_x\": 8, \"b_y\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "witness bar(x: Field): Uint<0..36>;"
      "export circuit foo(x: Uint<0..36>): Uint<0..36> {"
      "  impure = true;"
      "  return x - x as Uint<0..36>;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"24\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 1, \"bits\": 6 },"
        "    { \"op\": \"assert\", \"cond\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export struct Q<a> { x: a, y: Field }"
      "export enum Names { bill, sally, fred, george, }"
      "export circuit uno(q: Q<Boolean>): Names {"
      "  impure = true;"
      "  return q.x ? Names.sally : Names.fred;"
      "}"
      "export circuit dos(q: Q<Field>): Names {"
      "  impure = true;"
      "  return q.x == q.y ? Names.bill : Names.george;"
      "}"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 2, \"b\": 7 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/dos.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"cond_select\", \"bit\": 7, \"a\": 4, \"b\": 8 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export struct Q<a, b> { x: a, y: b }"
      "export enum Names { bill, sally, fred, george, }"
      "export circuit uno(q: Q<Boolean, Vector<3, Uint<32>>>): Names {"
      "  impure = true;"
      "  return q.x ? Names.sally : Names.fred;"
      "}"
      "export circuit dos(q: Q<Vector<3, Field>,Vector<3,Field>>): Names {"
      "  impure = true;"
      "  return q.x == q.y ? Names.bill : Names.george;"
      "}"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 32 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 32 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 32 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 4, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/dos.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 6,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 6, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 6, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 6, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 3 },"
        "    { \"op\": \"test_eq\", \"a\": 1, \"b\": 4 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 12, \"b\": 8 },"
        "    { \"op\": \"test_eq\", \"a\": 2, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 13, \"a\": 14, \"b\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"cond_select\", \"bit\": 15, \"a\": 8, \"b\": 16 },"
        "    { \"op\": \"output\", \"var\": 17 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export struct Q<a, #n> { x: Vector<n, a>, y: Uint<12>, z: Opaque<'string'> }"
      "export circuit uno(q: Q<Boolean, 3>): Uint<32> {"
      "  impure = true;"
      "  return q.x[2] ? q.y + 1 : q.y - 1;"
      "}"
      "export circuit dos(q: Q<Field, 2>): Opaque<'string'> {"
      "  impure = true;"
      "  assert(q.x[0] == q.x[1], 'oops');"
      "  return q.z;"
      "}"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 5,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 2 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 5, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 5, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 5, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 5 },"
        "    { \"op\": \"less_than\", \"a\": 3, \"b\": 5, \"bits\": 12 },"
        "    { \"op\": \"cond_select\", \"bit\": 11, \"a\": 7, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 2, \"a\": 5, \"b\": 12 },"
        "    { \"op\": \"assert\", \"cond\": 13 },"
        "    { \"op\": \"neg\", \"a\": 5 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 14 },"
        "    { \"op\": \"cond_select\", \"bit\": 2, \"a\": 10, \"b\": 15 },"
        "    { \"op\": \"output\", \"var\": 16 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/dos.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 4,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 4, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 9 },"
        "    { \"op\": \"output\", \"var\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger impure: Boolean;"
      "export struct Q<a, #n> { x: Vector<n, a>, y: a }"
      "module M1 {"
      "  export circuit uno(q: Q<Uint<12>, 2>): Uint<32> {"
      "    impure = true;"
      "    return q.x[0] + q.x[1] - q.y;"
      "  }"
      "}"
      "module M2 {"
      "  export circuit dos(q: Q<Boolean, 2>): Boolean {"
      "    impure = true;"
      "    return q.x[0] && q.x[1] || q.y;"
      "  }"
      "}"
      "module M3 {"
      "  struct Q { x: Vector<2, Uint<12>>, y: Boolean }"
      "  export circuit tres(q: Q): Uint<32> {"
      "    impure = true;"
      "    return q.y ? q.x[0] + q.x[1] : q.x[0] * q.x[1];"
      "  }"
      "}"
      "import M1;"
      "import M2;"
      "import M3;"
      "export { uno, dos, tres }"
     ) 
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"less_than\", \"a\": 8, \"b\": 2, \"bits\": 13 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 5, \"b\": 3 },"
        "    { \"op\": \"assert\", \"cond\": 10 },"
        "    { \"op\": \"neg\", \"a\": 2 },"
        "    { \"op\": \"add\", \"a\": 8, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/dos.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 1 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 0, \"a\": 1, \"b\": 5 },"
        "    { \"op\": \"cond_select\", \"bit\": 8, \"a\": 3, \"b\": 2 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/tres.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 12 },"
        "    { \"op\": \"constrain_to_boolean\", \"var\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"mul\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"cond_select\", \"bit\": 2, \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "module M0<b> {"
      "  export struct Q<a, #n> { x: Vector<n, a>, y: b }"
      "}"
      "import M0<Uint<12>>;"
      "export { Q }"
      "module M1 {"
      "  ledger impure: Boolean;"
      "  import M0<Field>;"
      "  export circuit uno(q: Q<Field, 2>): Field {"
      "    impure = true;"
      "    return q.x[0] + q.x[1] - q.y;"
      "  }"
      "}"
      "import M1;"
      "export { uno }"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"neg\", \"a\": 2 },"
        "    { \"op\": \"add\", \"a\": 8, \"b\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "module M0<b> {"
      "  export struct Q<a, #n> { x: Vector<n, a>, y: b }"
      "}"
      "import M0<Field>;"
      "export { Q }"
      "module M1 {"
      "  ledger impure: Boolean;"
      "  import M0<Uint<12>>;"
      "  export circuit uno(q: Q<Uint<12>, 2>): Uint<32> {"
      "    impure = true;"
      "    return q.x[0] + q.x[1] - q.y;"
      "  }"
      "}"
      "import M1;"
      "export { uno }"
     )
    (output-file "compiler/testdir/zkir/uno.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 12 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"less_than\", \"a\": 8, \"b\": 2, \"bits\": 13 },"
        "    { \"op\": \"cond_select\", \"bit\": 9, \"a\": 5, \"b\": 3 },"
        "    { \"op\": \"assert\", \"cond\": 10 },"
        "    { \"op\": \"neg\", \"a\": 2 },"
        "    { \"op\": \"add\", \"a\": 8, \"b\": 11 },"
        "    { \"op\": \"output\", \"var\": 12 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit hello(): Opaque<'string'> {"
      "  return greeting;"
      "}"
      "ledger greeting: Opaque<'string'>;"
      "constructor(x: Opaque<'string'>) { greeting = disclose(x); }"
     )
    (output-file "compiler/testdir/zkir/hello.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-01\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 4 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export { Maybe }"
      "ledger rat: Field;"
      "constructor(witnesses: Field) { rat = disclose(witnesses); }"
      "witness witnesses(witnesses: Field): Field;"
      "export circuit state(x: Field): Field { return disclose(witnesses(x)) + 5; }"
      "export circuit context(x: Field): Field { return state(x + 3); }"
      "export circuit transcript(x: Field): Field { return context(x + 7); }"
      "export circuit Contract(x: Field): Field { return transcript(x) + 2; }"
      "export circuit arguments(eval: Field, arguments: Field, witnesses: Field): Field { return Contract(eval + arguments + witnesses) + rat; }"
      "export circuit functions(Maybe: Maybe<Field>): Field { return Maybe.value + 17; }"
      "export circuit finalize(): Field { return functions(some<Field>(3)); }"
     )
    (output-file "compiler/testdir/zkir/arguments.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"add\", \"a\": 3, \"b\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"add\", \"a\": 4, \"b\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"add\", \"a\": 6, \"b\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"add\", \"a\": 10, \"b\": 11 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"add\", \"a\": 12, \"b\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"add\", \"a\": 14, \"b\": 18 },"
        "    { \"op\": \"output\", \"var\": 21 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit red_guess(my_guess: Field): [] {"
      "  impure = true;"
      "  return my_guess - 1;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Field" "[]" "circuit red_guess")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit red_guess(my_guess: Field): Field {"
      "  impure = true;"
      "  return my_guess - 1;"
      "}"
     )
    (output-file "compiler/testdir/zkir/red_guess.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"neg\", \"a\": 1 },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 6 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit foo(x: Uint<12>): Field {"
      "  impure = true;"
      "  return transientCommit<Uint<12>>(x, 0);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"transient_hash\", \"inputs\": [3, 0] },"
        "    { \"op\": \"output\", \"var\": 6 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit foo(x: Uint<12>): Bytes<32> {"
      "  impure = true;"
      "  const rand : Bytes<32> = '12345678901234567890123456789012' as Bytes<32>;"
      "  return persistentCommit<Uint<12>>(x, rand);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 12 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"31323334353637383930313233343536373839303132333435363738393031\" },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 32, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"length\": 2, \"tag\": \"bytes\" } }], \"inputs\": [6, 7, 0] },"
        "    { \"op\": \"output\", \"var\": 8 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger impure: Boolean;"
      "export circuit foo(x: Boolean): CurvePoint {"
      "  impure = true;"
      "  return hashToCurve<Boolean>(x);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"hash_to_curve\", \"inputs\": [0] },"
        "    { \"op\": \"output\", \"var\": 6 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger foo: Field;"
      "ledger bar: Set<Field>;"
      "ledger baz: MerkleTree<2, Field>;"
      ""
      "export circuit rat(): [] {"
      "  foo = 42;"
      "  bar.insert(23);"
      "  baz.insert(71);"
      "}"
      ""
      "export circuit root_of(path: MerkleTreePath<2, Field>): MerkleTreeDigest {"
      "  return merkleTreePathRoot<2, Field>(path);"
      "}"
     )
    (output-file "compiler/testdir/zkir/rat.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"2A\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"17\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"47\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"6D646E3A6C68\" },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"tag\": \"field\" } }], \"inputs\": [14, 10] },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/root_of.zkir" #f)
    )

  (test
    '(
      "pragma language_version >= 0.4.0;"
      ""
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit bar(): Field {"
      "  impure = true;"
      "  return 3;"
      "}"
     )
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "pragma language_version >= 0.4.0 && < 0.99.0;"
      "pragma compiler_version >= 0.4.2 && < 0.99.0;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit bar(): Field {"
      "  impure = true;"
      "  return 3;"
      "}"
     )
    (output-file "compiler/testdir/zkir/bar.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum LedgerState { setup, commit, reveal, final, }"
      ""
      "ledger organizer: Bytes<32>;"
      "ledger state: LedgerState;"
      "ledger topic: Maybe<Opaque<'string'>>;"
      "ledger beneficiary: Maybe<ZswapCoinPublicKey>;"
      "ledger yes: Counter;"
      "ledger no: Counter;"
      "ledger round: Counter;"
      "ledger committed_votes: MerkleTree<10, Bytes<32>>;"
      "ledger eligible_voters: HistoricMerkleTree<10, Bytes<32>>;"
      "ledger committed: Set<Bytes<32>>;"
      "ledger revealed: Set<Bytes<32>>;"
      ""
      "ledger pot: QualifiedCoinInfo;"
      "ledger pot_has_coin: Boolean;"
      ""
      "constructor(organizer_secret_key: Bytes<32>) {"
      "  organizer = public_key(disclose(organizer_secret_key));"
      "  state = LedgerState.setup;"
      "}"
      ""
      "circuit public_key(sk: Bytes<32>): Bytes<32> {"
      "  return persistentHash<Vector<2, Bytes<32>>>([pad(32, 'lares:udao:pk:'), sk]);"
      "}"
     )
    (output-file "compiler/testdir/zkir/public_key.zkir" #f)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger eligible_voters: HistoricMerkleTree<10, Bytes<32>>;"
      ""
      "circuit foo(pk: Bytes<32>): MerkleTreePath<10, Bytes<32>> {"
      "  const path = eligible_voters.find_path_for_leaf(pk);"
      "  return path;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 31" "~s ~s is a runtime-only method, but was invoked in-circuit" (HistoricMerkleTree find_path_for_leaf)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger rats: MerkleTree<10, Field>;"
      "ledger impure: Boolean;"
      ""
      "export circuit foo(x: Field): [] {"
      "  rats.insert(disclose(x));"
      "}"
      ""
      "export circuit root_of(path: MerkleTreePath<10, Field>): MerkleTreeDigest {"
      "  return merkleTreePathRoot<10, Field>(path);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"6D646E3A6C68\" },"
        "    { \"op\": \"persistent_hash\", \"alignment\": [{ \"tag\": \"atom\", \"value\": { \"length\": 6, \"tag\": \"bytes\" } }, { \"tag\": \"atom\", \"value\": { \"tag\": \"field\" } }], \"inputs\": [6, 0] },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/root_of.zkir" #f)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger bar: List<Field>;"
      ""
      "constructor() {"
      "  bar.pushFront(42);"
      "}"
      ""
      "export circuit baz(): Field {"
      "  kernel.mint(pad(32, ''), 5);"
      "  return bar.length();"
      "}"
     )
    (output-file "compiler/testdir/zkir/baz.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"40\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"80\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"20\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"31\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"18\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"12\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"32\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"60\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-01\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"14\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 20 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field0: Map<Field, Field>;"
      ""
      "export circuit foo(): [] {"
      "  field0.insert(1, 1);"
      "  field0.insert(2, 3);"
      "  field0.insert(3, 5);"
      "  field0.insert(4, 7);"
      "  field0.insert(5, 9);"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"09\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field0: List<Field>;"
      ""
      "export circuit foo(): Maybe<Field> {"
      "  field0.pushFront(1);"
      "  field0.pushFront(3);"
      "  field0.pushFront(5);"
      "  field0.pushFront(7);"
      "  field0.pushFront(9);"
      "  return field0.head();"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"33\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"40\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"03\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"09\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"12\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"16\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"26\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"13\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0B\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 7 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 26 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 6 },"
        "    { \"op\": \"output\", \"var\": 24 },"
        "    { \"op\": \"output\", \"var\": 25 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean, n: Field): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "  field1.lookup(b).insert(disclose(n), default<Field>);"
      "}"
      "export circuit put(b: Boolean, n: Uint<16>, q: Field): [] {"
      "  field1.lookup(b).lookup(n).write(disclose(q));"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 19" "expected ~:r argument of ~s to have type ~a but received ~a" (1 insert "Uint<16>" "Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "  field1.lookup(b).insert(disclose(n), default<Field>);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
     )
    (output-file "compiler/testdir/zkir/init.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum E { a, b, c }"
      "struct S { x: Boolean, y: Bytes<10>, z: Vector<2, E> }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, S>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "  field1.lookup(b).insert(disclose(n), default<S>);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): S {"
      "  return field1.lookup(b).lookup(n);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 9" "expected ~:r argument of ~s to have type ~a but received ~a" (2 insert "Map<Uint<16>, struct S<x: Boolean, y: Bytes<10>, z: Vector<2, Enum<E, a, b, c>>>>" "Map<Uint<16>, Field>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum E { a, b, c }"
      "struct S { x: Boolean, y: Bytes<10>, z: Vector<2, E> }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, S>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, S>>);"
      "  field1.lookup(b).insert(disclose(n), default<Field>);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): S {"
      "  return field1.lookup(b).lookup(n);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 19" "expected ~:r argument of ~s to have type ~a but received ~a" (2 insert "struct S<x: Boolean, y: Bytes<10>, z: Vector<2, Enum<E, a, b, c>>>" "Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum E { a, b, c }"
      "struct S { x: Boolean, y: Bytes<10>, z: Vector<2, E> }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, S>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, S>>);"
      "  field1.lookup(b).insert(disclose(n), default<S>);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): S {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
     )
    (output-file "compiler/testdir/zkir/init.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"04\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 10 },"
        "    { \"op\": \"output\", \"var\": 8 },"
        "    { \"op\": \"output\", \"var\": 9 },"
        "    { \"op\": \"output\", \"var\": 10 },"
        "    { \"op\": \"output\", \"var\": 11 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "}"
      ""
      "export circuit put(b: Boolean, n: Uint<16>, q: Field): [] {"
      "  field1.lookup(b).insert(disclose(n), disclose(q));"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
     )
    (output-file "compiler/testdir/zkir/init.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/put.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/get.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "// nested ADT fields must be initialized to null before first use"
      "export circuit init_nested_counter(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Counter>);"
      "}"
      ""
      "// ADT values are not first-class objects, so when accessing a nested"
      "// ADT, the entire indirection chain must be used"
      "export circuit incr_nested_counter(b: Boolean, k: Uint<16>): [] {"
      "  field1.lookup(b).increment(disclose(k));"
      "}"
      ""
      "// when the last lookup is a read of a regular type one can include the read explicitly:"
      "export circuit read_nested_counter1(b: Boolean): Uint<64> {"
      "  return field1.lookup(b).read();"
      "}"
      ""
      "// ... or leave it off, in which case the read is implicit:"
      "export circuit read_nested_counter2(b: Boolean): Uint<64> {"
      "  return field1.lookup(b);"
      "}"
     )
    (output-file "compiler/testdir/zkir/init_nested_counter.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/incr_nested_counter.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/read_nested_counter1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/read_nested_counter2.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field2: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit init_nested_map(n: Field): [] {"
      "  field2.insert(n, default<Map<Field, Field>>);"
      "}"
      ""
      "export circuit insert_nested_map(n1: Field, n2: Field, n3: Field): [] {"
      "  field2.lookup(n1).insert(n2, n3);"
      "}"
      ""
      "export circuit lookup_nested_map(n1: Field, n2: Field): Field {"
      "  return field2.lookup(disclose(n1)).lookup(disclose(n2));"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 9" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter n of exported circuit init_nested_map at line 5 char 32" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the first argument to insert at line 6 char 9")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 20" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter n2 of exported circuit insert_nested_map at line 9 char 45" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the first argument to insert at line 10 char 20")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 20" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter n3 of exported circuit insert_nested_map at line 9 char 56" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the second argument to insert at line 10 char 20"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field2: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit init_nested_map(n: Field): [] {"
      "  field2.insert(disclose(n), default<Map<Field, Field>>);"
      "}"
      ""
      "export circuit insert_nested_map(n1: Field, n2: Field, n3: Field): [] {"
      "  field2.lookup(n1).insert(disclose(n2), disclose(n3));"
      "}"
      ""
      "export circuit lookup_nested_map(n1: Field, n2: Field): Field {"
      "  return field2.lookup(disclose(n1)).lookup(disclose(n2));"
      "}"
     )
    (output-file "compiler/testdir/zkir/init_nested_map.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/insert_nested_map.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/lookup_nested_map.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: Map<Boolean, Map<Field, Counter>>;"
      ""
      "export circuit init_nested_map(b: Boolean): [] {"
      "  fld.insert(b, default<Map<Field, Counter>>);"
      "}"
      ""
      "export circuit init_nested_counter(b: Boolean, n: Field): [] {"
      "  fld.lookup(b).insert(n, default<Counter>);"
      "}"
      ""
      "export circuit increment_nested_counter(b: Boolean, n: Field, k: Uint<16>): [] {"
      "  fld.lookup(b).lookup(n).increment(k);"
      "}"
      ""
      "export circuit read_nested_counter1(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n).read();"
      "}"
      ""
      "export circuit read_nested_counter2(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 6" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter b of exported circuit init_nested_map at line 5 char 32" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the first argument to insert at line 6 char 6")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 16" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter n of exported circuit init_nested_counter at line 9 char 48" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the first argument to insert at line 10 char 16")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 14 char 26" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter k of exported circuit increment_nested_counter at line 13 char 63" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the argument to increment at line 14 char 26"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: Map<Boolean, Map<Field, Counter>>;"
      ""
      "export circuit init_nested_map(b: Boolean): [] {"
      "  fld.insert(disclose(b), default<Map<Field, Counter>>);"
      "}"
      ""
      "export circuit init_nested_counter(b: Boolean, n: Field): [] {"
      "  fld.lookup(b).insert(disclose(n), default<Counter>);"
      "}"
      ""
      "export circuit increment_nested_counter(b: Boolean, n: Field, k: Uint<16>): [] {"
      "  fld.lookup(b).lookup(n).increment(disclose(k));"
      "}"
      ""
      "export circuit read_nested_counter1(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n).read();"
      "}"
      ""
      "export circuit read_nested_counter2(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n);"
      "}"
     )
    (output-file "compiler/testdir/zkir/init_nested_map.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/init_nested_counter.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"71\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A2\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/increment_nested_counter.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 16 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"72\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 10 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A3\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 3, \"count\": 1 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/read_nested_counter1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"52\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 10 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/read_nested_counter2.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_to_boolean\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"52\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 10 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0D\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"08\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: Map<Boolean, Map<Field, Counter>>;"
      ""
      "export circuit bogus(): [] {"
      "  fld.lookup(true);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 6" "incomplete chain of ledger indirects: final result must be a regular type, but received ADT type ~a" ("Map<Field, Counter>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Set<Counter>;"
      ""
      "export circuit foo(): Field {"
      "  field1.write(default<Counter>);"
      "  return field1.read();"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 20" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("non-ADT type" "ledger ADT type" value_type "<standard library>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit foo(): Field {"
      "  impure = true;"
      "  return default<Set<Field>>;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Set<Field>" "Field" "circuit foo")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit foo(): Field {"
      "  impure = true;"
      "  return default<MerkleTree<3, Field>>;"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("MerkleTree<3, Field>" "Field" "circuit foo")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit foo(q: Opaque<'string'>): Boolean {"
      "  impure = true;"
      "  const x = default<Opaque<'string'>>;"
      "  return x == q;"
      "}"
     )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 3, \"b\": 0 },"
        "    { \"op\": \"output\", \"var\": 6 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger impure: Boolean;"
      ""
      "export circuit foo(q: Opaque<'string'>): Boolean {"
      "  impure = true;"
      "  const x = default<Opaque<'string'>>;"
      "  return x != q;"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 3, \"b\": 0 },"
        "    { \"op\": \"cond_select\", \"bit\": 6, \"a\": 3, \"b\": 1 },"
        "    { \"op\": \"output\", \"var\": 7 }"
        "  ]"
        "}"))
    )

  ;; ; FIXME uncomment for CC print-TS pass implementation
  ;; #|
  ;; (test-group
  ;;   ((create-file "C.compact"
  ;;      '(
  ;;        "export circuit foo(x: Bytes<32>): [] { return; }"
  ;;        "export circuit barr(): Bytes<32> { return pad(32, ''); }"
  ;;        )
  ;;      )
  ;;    (succeeds))
  ;;   ((create-file "UseC.compact"
  ;;      '(
  ;;        "import CompactStandardLibrary;"
  ;;        "contract C {"
  ;;        "  circuit foo(x: Bytes<32>): [];"
  ;;        "  pure circuit barr(): Bytes<32>;"
  ;;        "}"
  ;;        "ledger contract_c: C;"
  ;;        "constructor (c: C) { contract_c = disclose(c); }"
  ;;        "export circuit hello(): [] { return contract_c.foo(contract_c.read().barr()); }"
  ;;        ))
  ;;    (oops
  ;;      message: "~a:\n  ~?"
  ;;      irritants: '("UseC.compact line 2 char 1" "contract types are not yet implemented" ()))
  ;;    ))
  ;; |#

  (test
    '(
      "module M1 {"
      "  import CompactStandardLibrary;"
      "  export { QualifiedCoinInfo, CoinInfo, ZswapCoinPublicKey, ContractAddress };"
      "  export { left, ownPublicKey, createZswapInput, createZswapOutput };"
      "}"
      "import M1 prefix std$;"
      "circuit foo(qcoin: std$QualifiedCoinInfo, coin: std$CoinInfo): [] {"
      "  std$createZswapInput(qcoin);"
      "  std$createZswapOutput(coin, std$left<std$ZswapCoinPublicKey, std$ContractAddress>(std$ownPublicKey()));"
      "}"
      "module M2 {"
      "  import CompactStandardLibrary;"
      "  export circuit bar(qcoin: QualifiedCoinInfo, coin: CoinInfo): [] {"
      "    createZswapInput(qcoin);"
      "    createZswapOutput(coin, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));"
      "  }"
      "}"
      "import M2;"
      "import M2 prefix M2$;"
      "export { foo, bar, M2$bar };"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 11,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 128 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 64 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 128 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 248 },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" }"
        "  ]"
        "}"))

    (output-file "compiler/testdir/zkir/bar.zkir"
                 "compiler/testdir/zkir/foo.zkir")
    (output-file "compiler/testdir/zkir/M2$bar.zkir"
                 "compiler/testdir/zkir/foo.zkir")
    )

  (test
    '(
      "witness W(): Field;"
      "module A<#n, t> {"
      "  export circuit foo(v : Vector<n, t>, b : Bytes<n>): Field {"
      "    return disclose(W()) + 17;"
      "  }"
      "}"
      "module B {"
      "  circuit foo(x : Field): Field { return x + disclose(W()); }"
      "  circuit bar(x : Field): Field { return x - disclose(W()); }"
      "  import A<7, Field> prefix AA;"
      "  import A<30, Boolean> prefix AAA;"
      "  export {foo, AAfoo, AAAfoo, bar}"
      "}"
      "import B;"
      "import B prefix BB;"
      "import B<> prefix BBB;"
      "export {foo, AAfoo, BBfoo, BBAAfoo, BBAAAfoo, BBBfoo, BBBAAAfoo, bar, BBbar, BBBbar}"
      )
    (output-file "compiler/testdir/zkir/BBfoo.zkir"
                 "compiler/testdir/zkir/foo.zkir")
    (output-file "compiler/testdir/zkir/BBBfoo.zkir"
                 "compiler/testdir/zkir/foo.zkir")
    (output-file "compiler/testdir/zkir/BBAAfoo.zkir"
                 "compiler/testdir/zkir/AAfoo.zkir")
    (output-file "compiler/testdir/zkir/BBBAAAfoo.zkir"
                 "compiler/testdir/zkir/BBAAAfoo.zkir")
    (output-file "compiler/testdir/zkir/BBbar.zkir"
                 "compiler/testdir/zkir/bar.zkir")
    (output-file "compiler/testdir/zkir/BBBbar.zkir"
                 "compiler/testdir/zkir/bar.zkir")
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(qcoin: QualifiedCoinInfo, coin: CoinInfo): [] {"
      "  createZswapInput(qcoin);"
      "  createZswapOutput(coin, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));"
      "}"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 11,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 128 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 64 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 248 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 128 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"private_input\", \"guard\": null },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 248 },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger allowances: Map<Bytes<32>, Map<Bytes<32>, Uint<32>>>;"
      "export circuit allowance(b: Boolean, owner: Bytes<32>, spender: Bytes<32>): Uint<32> {"
      "  return disclose(b) ? allowances.lookup(disclose(owner)).lookup(disclose(spender)) : 0;"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Vector<2, Field>>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Vector<2, Field>>>);"
      "  field1.lookup(b).insert(disclose(n), default<Vector<2, Field>>);"
      "}"
     )
    (returns
      (program
        (circuit (init) 2
          (constrain_to_boolean 0)
          (constrain_bits 1 16)
          (load_imm 1)
          (load_imm 0)
          (load_imm 112)
          (declare_pub_input 4)
          (declare_pub_input 2)
          (declare_pub_input 2)
          (declare_pub_input 3)
          (pi_skip 2 4)
          (load_imm 16)
          (declare_pub_input 5)
          (declare_pub_input 2)
          (declare_pub_input 2)
          (declare_pub_input 2)
          (declare_pub_input 0)
          (pi_skip 2 5)
          (load_imm 17)
          (load_imm 2)
          (declare_pub_input 6)
          (declare_pub_input 7)
          (pi_skip 2 2)
          (load_imm 145)
          (declare_pub_input 8)
          (pi_skip 2 1)
          (load_imm 161)
          (declare_pub_input 9)
          (pi_skip 2 1)
          (load_imm 113)
          (declare_pub_input 10)
          (declare_pub_input 2)
          (declare_pub_input 2)
          (declare_pub_input 3)
          (declare_pub_input 2)
          (declare_pub_input 2)
          (declare_pub_input 0)
          (pi_skip 2 7)
          (declare_pub_input 5)
          (declare_pub_input 2)
          (declare_pub_input 2)
          (declare_pub_input 7)
          (declare_pub_input 1)
          (pi_skip 2 5)
          (load_imm -2)
          (declare_pub_input 6)
          (declare_pub_input 2)
          (declare_pub_input 7)
          (declare_pub_input 11)
          (declare_pub_input 11)
          (declare_pub_input 3)
          (declare_pub_input 3)
          (pi_skip 2 7)
          (declare_pub_input 8)
          (pi_skip 2 1)
          (load_imm 162)
          (declare_pub_input 12)
          (pi_skip 2 1))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field0: S;"
      "ledger field1: Opaque<'string'>;"
      ""
      "struct S { x: Bytes<1024>, y: Bytes<8> }"
      "export circuit one(x: Field): S {"
      "  field0 = disclose(S { x * x - 1 as Bytes<1024>, x + x - 1 as Bytes<8> });"
      "  return field0;"
      "}"
      ""
      "export circuit two(s: Opaque<'string'>, x: Field): Field {"
      "  field1 = disclose(s);"
      "  const q = persistentCommit<Field>(x, upgradeFromTransient(x));"
      "  return transientCommit<Bytes<32>>(q, x);"
      "}"
      ""
      "export circuit three(): [S, Bytes<32>] {"
      "  return [field0, persistentHash<Opaque<'string'>>(field1)];"
      "}"
     )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: [Field, Field];"
      ""
      "export circuit foo(x: Bytes<1024>, y: Bytes<8>): [] {"
      "  fld = disclose([x as Field, y as Field]);"
      "}"
     )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger f00: Field;"
      "export ledger f01: Field;"
      "export ledger f02: Field;"
      "export ledger f03: Field;"
      "export ledger f04: Field;"
      "export ledger f05: Field;"
      "export ledger f06: Field;"
      "export ledger f07: Field;"
      "export ledger f08: Field;"
      "export ledger f09: Field;"
      "export ledger f10: Field;"
      "export ledger f11: Field;"
      "export ledger f12: Field;"
      "export ledger f13: Field;"
      "export ledger f14: Field;"
      "export ledger f15: Field;"
      "export ledger f16: Field;"
      "export ledger f17: Field;"
      "export ledger f18: Field;"
      "export ledger f19: Field;"
      "export ledger f20: Field;"
      "export ledger f21: Field;"
      "export ledger f22: Field;"
      "export ledger f23: Field;"
      "export ledger f24: Field;"
      "export ledger f25: Field;"
      "export ledger f26: Field;"
      "export ledger f27: Field;"
      "export ledger f28: Field;"
      "export ledger f29: Field;"
      "export ledger f30: Field;"
      "export ledger f31: Field;"
      "export ledger f32: Field;"
      "export ledger f33: Field;"
      "export ledger f34: Field;"
      "export ledger f35: Field;"
      "export ledger f36: Field;"
      "export ledger f37: Field;"
      "export ledger f38: Field;"
      "export ledger f39: Field;"
      "constructor() {"
      "  f17 = 101;"
      "}"
      "export circuit foo(): [Field, Field] {"
      "  return [f11, f38];"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger merkleTree: MerkleTree<4, Field>;"
      "export circuit test(): [] {"
      "  // Test: insertIndexDefault inserts default value at a specific index"
      "  const defaultIndex = 3;"
      "  merkleTree.insertIndexDefault(defaultIndex);"
      "}"
      )
    (succeeds)
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger c: Map<Field, List<Field>>;"
      ""
      "export circuit foo1(): [] {"
      "  assert(c.isEmpty() == true, 'Structure should be empty');"
      "  assert(c.size() == 0, 'Size should be 0');"
      "}"
      ""
      "export circuit foo2(): [] {"
      "  c.insert(0, default<List<Field>>);"
      "  assert(c.size() == 1, 'Size should be 1');"
      "  assert(c.lookup(0).length() == 0, 'Key 0 should have value 1');"
      "}"
      ""
      "export circuit foo3(): [] {"
      "  c.insertDefault(1);"
      "  assert(c.size() == 2, 'Size should be 2');"
      "  assert(c.lookup(1).length() == 0, 'Key 1 should have value 0');"
      "  assert(c.member(1) == true, 'Key 1 should be member');"
      "}"
      ""
      "export circuit foo4(): [] {"
      "  c.remove(0);"
      "  assert(c.size() == 1, 'Size should be 1');"
      "  assert(c.lookup(0).length() == 0, 'What should happen here');"
      "}"
      ""
      "export circuit foo5(): [] {"
      "  c.resetToDefault();"
      "  assert(c.size() == 0, 'Size should be 0');"
      "  assert(c.isEmpty() == true, 'Structure should be empty');"
      "}"
      )
    (succeeds)
    )

  ;; Regression tests for PM-15412, a bug in indexing parameters that were
  ;; constrained to be Uint with a size that wasn't a power of two.
  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<0..5>): [] {"
      "  forceImpure();"
      "  assert(x == 0, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 1, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<0..5>, y: Uint<0..6>): [] {"
      "  forceImpure();"
      "  assert(x == y, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 2, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"06\" },"
        "    { \"op\": \"less_than\", \"a\": 1, \"b\": 4, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 7 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<0..5>, y: Uint<0..6>, z: Uint<0..7>): [] {"
      "  forceImpure();"
      "  assert(x + y == z, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 3,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 3, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"06\" },"
        "    { \"op\": \"less_than\", \"a\": 1, \"b\": 5, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"07\" },"
        "    { \"op\": \"less_than\", \"a\": 2, \"b\": 7, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"add\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"test_eq\", \"a\": 10, \"b\": 2 },"
        "    { \"op\": \"assert\", \"cond\": 11 }"
        "  ]"
        "}"))
    )

  ;; Mix powers of two with non-powers of two.
  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<0..5>, y: Uint<4>): [] {"
      "  forceImpure();"
      "  assert(x == y, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 0, \"b\": 2, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 3 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<4>, y: Uint<0..5>): [] {"
      "  forceImpure();"
      "  assert(x == y, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"less_than\", \"a\": 1, \"b\": 2, \"bits\": 4 },"
        "    { \"op\": \"assert\", \"cond\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 5 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "witness forceImpure(): [];"
      "export circuit test(x: Uint<4>, y: Uint<4>): [] {"
      "  forceImpure();"
      "  assert(x == y, \"failed\");"
      "}"
      )
    (output-file "compiler/testdir/zkir/test.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 4 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"test_eq\", \"a\": 0, \"b\": 1 },"
        "    { \"op\": \"assert\", \"cond\": 3 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger fld: Vector<1, Field>;"
      "export circuit foo(v: Vector<1, Field>): [] {"
      "  fld = disclose(v);"
      "}"
      "export circuit Foo(x: Field): [] {"
      "  fld = [disclose(x)];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 1" "the exported impure circuit name ~a is identical to the exported circuit name ~s at ~a modulo case; please rename to avoid zkir and prover-key filename clashes on case-insensitive filesystems" ("Foo" "foo" "line 2 char 1")))
    )

  (test
    '(
      "ledger fld: Vector<1, Field>;"
      "circuit Mfoo(v: Vector<1, Field>): [] {"
      "  fld = disclose(v);"
      "}"
      "module M {"
      "  export circuit Foo(x: Field): [] {"
      "    fld = [disclose(x)];"
      "  }"
      "}"
      "import M prefix M;"
      "export { Mfoo, MFoo }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 3" "the exported impure circuit name ~a is identical to the exported circuit name ~s at ~a modulo case; please rename to avoid zkir and prover-key filename clashes on case-insensitive filesystems" ("MFoo for Foo" "Mfoo" "line 2 char 1")))
    )

  (test
    '(
      "circuit bar(v: Vector<5, Field>, i: Uint<0..5>): Field {"
      "  return v[i];"
      "}"
      "export circuit foo(v: Vector<5, Field>): Field {"
      "  return bar(v, 3);"
      "}"
      )
    (returns (program (circuit (foo) 5 (output 3))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger x: Counter;"
      "export circuit foo(v: Vector<5, Uint<16>>): [] {"
      "  for (const i of 2..5) x += disclose(v[i] - v[i-1]);"
      "}"
      )
    (returns
      (program
        (circuit (foo) 5
          (constrain_bits 0 16)
          (constrain_bits 1 16)
          (constrain_bits 2 16)
          (constrain_bits 3 16)
          (constrain_bits 4 16)
          (less_than 2 1 16)
          (load_imm 0)
          (load_imm 1)
          (cond_select 5 6 7)
          (assert 8)
          (neg 1)
          (add 2 9)
          (load_imm 112)
          (declare_pub_input 11)
          (declare_pub_input 7)
          (declare_pub_input 7)
          (declare_pub_input 6)
          (pi_skip 7 4)
          (load_imm 14)
          (declare_pub_input 12)
          (declare_pub_input 10)
          (pi_skip 7 2)
          (load_imm 161)
          (declare_pub_input 13)
          (pi_skip 7 1)
          (less_than 3 2 16)
          (cond_select 14 6 7)
          (assert 15)
          (neg 2)
          (add 3 16)
          (declare_pub_input 11)
          (declare_pub_input 7)
          (declare_pub_input 7)
          (declare_pub_input 6)
          (pi_skip 7 4)
          (declare_pub_input 12)
          (declare_pub_input 17)
          (pi_skip 7 2)
          (declare_pub_input 13)
          (pi_skip 7 1)
          (less_than 4 3 16)
          (cond_select 18 6 7)
          (assert 19)
          (neg 3)
          (add 4 20)
          (declare_pub_input 11)
          (declare_pub_input 7)
          (declare_pub_input 7)
          (declare_pub_input 6)
          (pi_skip 7 4)
          (declare_pub_input 12)
          (declare_pub_input 21)
          (pi_skip 7 2)
          (declare_pub_input 13)
          (pi_skip 7 1))))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" 0)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 3 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 2 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" 1)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" 5)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 40 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 13 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 12 },"
        "    { \"op\": \"output\", \"var\": 17 },"
        "    { \"op\": \"output\", \"var\": 18 },"
        "    { \"op\": \"output\", \"var\": 19 },"
        "    { \"op\": \"output\", \"var\": 20 },"
        "    { \"op\": \"output\", \"var\": 21 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" (field-bytes))
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 248 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 11, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 13, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 15, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 17, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 19, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 21, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 23, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 25, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 27, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 29, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 31, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 33, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 35, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 37, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 39, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 41, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 43, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 45, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 47, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 49, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 51, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 53, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 55, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 57, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 62 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"1F\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 64 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 26 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 30 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 32 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 34 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 36 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 38 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 40 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 42 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 44 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 46 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 48 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 50 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 52 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 54 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 56 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 58 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 59 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 65 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 66 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 67 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 68 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 100 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 69 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 71 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 77 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 78 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 79 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 80 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 81 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 82 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 83 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 84 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 85 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 86 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 87 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 88 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 89 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 90 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 91 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 92 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 93 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 94 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 95 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 96 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 97 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 98 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 99 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 64 },"
        "    { \"op\": \"output\", \"var\": 69 },"
        "    { \"op\": \"output\", \"var\": 70 },"
        "    { \"op\": \"output\", \"var\": 71 },"
        "    { \"op\": \"output\", \"var\": 72 },"
        "    { \"op\": \"output\", \"var\": 73 },"
        "    { \"op\": \"output\", \"var\": 74 },"
        "    { \"op\": \"output\", \"var\": 75 },"
        "    { \"op\": \"output\", \"var\": 76 },"
        "    { \"op\": \"output\", \"var\": 77 },"
        "    { \"op\": \"output\", \"var\": 78 },"
        "    { \"op\": \"output\", \"var\": 79 },"
        "    { \"op\": \"output\", \"var\": 80 },"
        "    { \"op\": \"output\", \"var\": 81 },"
        "    { \"op\": \"output\", \"var\": 82 },"
        "    { \"op\": \"output\", \"var\": 83 },"
        "    { \"op\": \"output\", \"var\": 84 },"
        "    { \"op\": \"output\", \"var\": 85 },"
        "    { \"op\": \"output\", \"var\": 86 },"
        "    { \"op\": \"output\", \"var\": 87 },"
        "    { \"op\": \"output\", \"var\": 88 },"
        "    { \"op\": \"output\", \"var\": 89 },"
        "    { \"op\": \"output\", \"var\": 90 },"
        "    { \"op\": \"output\", \"var\": 91 },"
        "    { \"op\": \"output\", \"var\": 92 },"
        "    { \"op\": \"output\", \"var\": 93 },"
        "    { \"op\": \"output\", \"var\": 94 },"
        "    { \"op\": \"output\", \"var\": 95 },"
        "    { \"op\": \"output\", \"var\": 96 },"
        "    { \"op\": \"output\", \"var\": 97 },"
        "    { \"op\": \"output\", \"var\": 98 },"
        "    { \"op\": \"output\", \"var\": 99 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger v: Vector<N, Uint<8>>;"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<8>> {"
      "    v = disclose(bv) as Vector<N, Uint<8>>;"
      "    return v;"
      "  }"
      "}"
      ,(format "import M<~d>;" (+ (field-bytes) 5))
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 40 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 248 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 10, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 14, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 16, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 18, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 20, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 22, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 24, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 26, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 28, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 30, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 32, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 34, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 36, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 38, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 40, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 42, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 44, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 46, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 48, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 50, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 52, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 54, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 56, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 58, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 60, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 62, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 64, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 66, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 71 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"24\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 73 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 29 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 31 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 33 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 35 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 37 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 39 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 41 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 43 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 45 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 47 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 49 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 51 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 53 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 55 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 57 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 59 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 67 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 69 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 68 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 75 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 75 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 76 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 77 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 72 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 114 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 74 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 78 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 79 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 80 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 81 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 82 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 83 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 84 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 85 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 86 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 87 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 88 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 89 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 90 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 91 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 92 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 93 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 94 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 95 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 96 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 97 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 98 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 99 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 100 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 101 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 102 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 103 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 104 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 105 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 106 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 107 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 108 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 109 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 110 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 111 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 112 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 113 },"
        "    { \"op\": \"pi_skip\", \"guard\": 70, \"count\": 74 },"
        "    { \"op\": \"output\", \"var\": 78 },"
        "    { \"op\": \"output\", \"var\": 79 },"
        "    { \"op\": \"output\", \"var\": 80 },"
        "    { \"op\": \"output\", \"var\": 81 },"
        "    { \"op\": \"output\", \"var\": 82 },"
        "    { \"op\": \"output\", \"var\": 83 },"
        "    { \"op\": \"output\", \"var\": 84 },"
        "    { \"op\": \"output\", \"var\": 85 },"
        "    { \"op\": \"output\", \"var\": 86 },"
        "    { \"op\": \"output\", \"var\": 87 },"
        "    { \"op\": \"output\", \"var\": 88 },"
        "    { \"op\": \"output\", \"var\": 89 },"
        "    { \"op\": \"output\", \"var\": 90 },"
        "    { \"op\": \"output\", \"var\": 91 },"
        "    { \"op\": \"output\", \"var\": 92 },"
        "    { \"op\": \"output\", \"var\": 93 },"
        "    { \"op\": \"output\", \"var\": 94 },"
        "    { \"op\": \"output\", \"var\": 95 },"
        "    { \"op\": \"output\", \"var\": 96 },"
        "    { \"op\": \"output\", \"var\": 97 },"
        "    { \"op\": \"output\", \"var\": 98 },"
        "    { \"op\": \"output\", \"var\": 99 },"
        "    { \"op\": \"output\", \"var\": 100 },"
        "    { \"op\": \"output\", \"var\": 101 },"
        "    { \"op\": \"output\", \"var\": 102 },"
        "    { \"op\": \"output\", \"var\": 103 },"
        "    { \"op\": \"output\", \"var\": 104 },"
        "    { \"op\": \"output\", \"var\": 105 },"
        "    { \"op\": \"output\", \"var\": 106 },"
        "    { \"op\": \"output\", \"var\": 107 },"
        "    { \"op\": \"output\", \"var\": 108 },"
        "    { \"op\": \"output\", \"var\": 109 },"
        "    { \"op\": \"output\", \"var\": 110 },"
        "    { \"op\": \"output\", \"var\": 111 },"
        "    { \"op\": \"output\", \"var\": 112 },"
        "    { \"op\": \"output\", \"var\": 113 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" 0)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 3 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" 1)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"copy\", \"var\": 0 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 9 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" 5)
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 5,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 4, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 5, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 6, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 7, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"05\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 15 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 16 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 17 },"
        "    { \"op\": \"pi_skip\", \"guard\": 9, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 17 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" (field-bytes))
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 31,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 11, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 14, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 15, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 16, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 17, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 18, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 19, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 20, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 21, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 22, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 23, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 24, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 25, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 26, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 27, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 28, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 29, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 30, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 30, \"modulus\": 29, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 31, \"modulus\": 28, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 32, \"modulus\": 27, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 33, \"modulus\": 26, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 34, \"modulus\": 25, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 35, \"modulus\": 24, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 36, \"modulus\": 23, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 37, \"modulus\": 22, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 38, \"modulus\": 21, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 39, \"modulus\": 20, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 40, \"modulus\": 19, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 41, \"modulus\": 18, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 42, \"modulus\": 17, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 43, \"modulus\": 16, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 44, \"modulus\": 15, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 45, \"modulus\": 14, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 46, \"modulus\": 13, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 47, \"modulus\": 12, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 48, \"modulus\": 11, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 49, \"modulus\": 10, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 50, \"modulus\": 9, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 51, \"modulus\": 8, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 52, \"modulus\": 7, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 53, \"modulus\": 6, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 54, \"modulus\": 5, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 55, \"modulus\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 56, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 57, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 58, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 59, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 62 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"1F\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 64 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 60 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 66 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 67 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 68 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 63 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 70 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 61 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 65 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 69 },"
        "    { \"op\": \"pi_skip\", \"guard\": 61, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 69 }"
        "  ]"
        "}"))
    )

  (test
    `(
      "module M<#N> {"
      "  ledger bv: Bytes<N>;"
      "  export circuit foo(v: Vector<N, Uint<8>>): Bytes<N> {"
      "    bv = disclose(v) as Bytes<N>;"
      "    return bv;"
      "  }"
      "}"
      ,(format "import M<~d>;" (- (* (field-bytes) 2) 1))
      "export { foo }"
      )
    (output-file "compiler/testdir/zkir/foo.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 61,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 10, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 11, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 12, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 13, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 14, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 15, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 16, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 17, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 18, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 19, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 20, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 21, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 22, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 23, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 24, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 25, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 26, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 27, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 28, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 29, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 30, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 31, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 32, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 33, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 34, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 35, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 36, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 37, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 38, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 39, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 40, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 41, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 42, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 43, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 44, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 45, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 46, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 47, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 48, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 49, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 50, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 51, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 52, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 53, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 54, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 55, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 56, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 57, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 58, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 59, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 60, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 60, \"modulus\": 59, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 61, \"modulus\": 58, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 62, \"modulus\": 57, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 63, \"modulus\": 56, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 64, \"modulus\": 55, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 65, \"modulus\": 54, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 66, \"modulus\": 53, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 67, \"modulus\": 52, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 68, \"modulus\": 51, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 69, \"modulus\": 50, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 70, \"modulus\": 49, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 71, \"modulus\": 48, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 72, \"modulus\": 47, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 73, \"modulus\": 46, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 74, \"modulus\": 45, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 75, \"modulus\": 44, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 76, \"modulus\": 43, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 77, \"modulus\": 42, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 78, \"modulus\": 41, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 79, \"modulus\": 40, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 80, \"modulus\": 39, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 81, \"modulus\": 38, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 82, \"modulus\": 37, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 83, \"modulus\": 36, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 84, \"modulus\": 35, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 85, \"modulus\": 34, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 86, \"modulus\": 33, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 87, \"modulus\": 32, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 88, \"modulus\": 31, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 30, \"modulus\": 29, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 90, \"modulus\": 28, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 91, \"modulus\": 27, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 92, \"modulus\": 26, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 93, \"modulus\": 25, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 94, \"modulus\": 24, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 95, \"modulus\": 23, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 96, \"modulus\": 22, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 97, \"modulus\": 21, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 98, \"modulus\": 20, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 99, \"modulus\": 19, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 100, \"modulus\": 18, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 101, \"modulus\": 17, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 102, \"modulus\": 16, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 103, \"modulus\": 15, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 104, \"modulus\": 14, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 105, \"modulus\": 13, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 106, \"modulus\": 12, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 107, \"modulus\": 11, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 108, \"modulus\": 10, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 109, \"modulus\": 9, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 110, \"modulus\": 8, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 111, \"modulus\": 7, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 112, \"modulus\": 6, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 113, \"modulus\": 5, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 114, \"modulus\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 115, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 116, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 117, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 118, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 121 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 122 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"3D\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 123 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 124 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 89 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 119 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 6 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 125 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 126 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 127 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 122 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 130 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 120 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 124 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 128 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 129 },"
        "    { \"op\": \"pi_skip\", \"guard\": 120, \"count\": 5 },"
        "    { \"op\": \"output\", \"var\": 128 },"
        "    { \"op\": \"output\", \"var\": 129 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger round: Counter;"
      "export circuit test10(param1: Vector<1, Uint<8>>): [] {"
      "  round.increment(disclose(param1[0]));"
      ""
      "  const p = param1 as Bytes<1>;"
      "  round.increment((disclose(p) as Vector<1, Uint<8>>)[0]);"
      "}"
      )
    (output-file "compiler/testdir/zkir/test10.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"copy\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger round: Counter;"
      "export circuit test10(param1: Vector<10, Uint<8>>): [] {"
      "  round.increment(disclose(param1[0]));"
      ""
      "  const p = param1 as Bytes<10>;"
      "  round.increment((disclose(p) as Vector<10, Uint<8>>)[0]);"
      "}"
      )
    (output-file "compiler/testdir/zkir/test10.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 10,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"70\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 4 },"
        "    { \"op\": \"load_imm\", \"imm\": \"0E\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 2 },"
        "    { \"op\": \"load_imm\", \"imm\": \"A1\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 1 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 9, \"modulus\": 8, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 15, \"modulus\": 7, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 16, \"modulus\": 6, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 17, \"modulus\": 5, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 18, \"modulus\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 19, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 20, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 21, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 22, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 23, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 24, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 26, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 28, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 30, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 32, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 34, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 36, \"bits\": 8 },"
        "    { \"op\": \"div_mod_power_of_two\", \"var\": 38, \"bits\": 8 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 11 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 10 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 12 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 13 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 14 },"
        "    { \"op\": \"pi_skip\", \"guard\": 10, \"count\": 1 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "ledger val5: Bytes<10>;"
      ""
      "export circuit test5(param1: Vector<10, Uint<8>>): Bytes<10> {"
      "  val5 = disclose(param1) as Bytes<10>;"
      "  return val5;"
      "}"
      )
    (output-file "compiler/testdir/zkir/test5.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 10,"
        "  \"instructions\": ["
        "    { \"op\": \"constrain_bits\", \"var\": 0, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 1, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 2, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 3, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 4, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 5, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 6, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 7, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 8, \"bits\": 8 },"
        "    { \"op\": \"constrain_bits\", \"var\": 9, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 9, \"modulus\": 8, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 10, \"modulus\": 7, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 11, \"modulus\": 6, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 12, \"modulus\": 5, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 13, \"modulus\": 4, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 14, \"modulus\": 3, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 15, \"modulus\": 2, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 16, \"modulus\": 1, \"bits\": 8 },"
        "    { \"op\": \"reconstitute_field\", \"divisor\": 17, \"modulus\": 0, \"bits\": 8 },"
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"10\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 20 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"11\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"0A\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 22 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 18 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 5 },"
        "    { \"op\": \"load_imm\", \"imm\": \"91\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 24 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 25 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 26 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 21 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 28 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 19 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 23 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 27 },"
        "    { \"op\": \"pi_skip\", \"guard\": 19, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 27 }"
        "  ]"
        "}"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger m: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit test0(): Field {"
      "  return m.lookup(1000).lookup(2000);"
      "}"
      "export circuit test1(x: Field): Field {"
      "  return m.lookup(1000).lookup(disclose(x));"
      "}"
      "export circuit test2(x: Field): Field {"
      "  return m.lookup(disclose(x)).lookup(1000);"
      "}"
      "export circuit test3(x: Field, y: Field): Field {"
      "  return m.lookup(disclose(x)).lookup(disclose(y));"
      "}"
      )
    (output-file "compiler/testdir/zkir/test0.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 0,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"E803\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"D007\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 0, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/test1.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"E803\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/test2.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 1,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"E803\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 1, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    (output-file "compiler/testdir/zkir/test3.zkir"
      '(
        "{"
        "  \"version\": { \"major\": 3, \"minor\": 0 },"
        "  \"do_communications_commitment\": true,"
        "  \"num_inputs\": 2,"
        "  \"instructions\": ["
        "    { \"op\": \"load_imm\", \"imm\": \"01\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"30\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 3 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 1 },"
        "    { \"op\": \"load_imm\", \"imm\": \"51\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"00\" },"
        "    { \"op\": \"load_imm\", \"imm\": \"-02\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 4 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 5 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 0 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 7 },"
        "    { \"op\": \"load_imm\", \"imm\": \"50\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 7 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 1 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"public_input\", \"guard\": null },"
        "    { \"op\": \"load_imm\", \"imm\": \"0C\" },"
        "    { \"op\": \"declare_pub_input\", \"var\": 9 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 2 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 6 },"
        "    { \"op\": \"declare_pub_input\", \"var\": 8 },"
        "    { \"op\": \"pi_skip\", \"guard\": 2, \"count\": 4 },"
        "    { \"op\": \"output\", \"var\": 8 }"
        "  ]"
        "}"))
    )
  )
)

(run-tests print-typescript
  (test-group
    ((create-file "C1.compact"
       '(
         "witness c1(x: Field): Field;"
         "export circuit bar(): [] { return; }"
         ))
      (succeeds))
    ((create-file "C2.compact"
       '(
         "export enum E { F }"
         "witness c2(x: Boolean): Boolean;"
         "export circuit foo(x: E): E { return x; }"
         ))
     (custom-check
       (lambda (pass-name x)
         (let ([fn (format "~a/C2/compiler/contract-info.json" testdir)])
           (replace-value-in-json fn '("witnesses") '())))))
    ((create-file "testfile.compact"
       '(
         "enum E { F }"
         "witness c3(): [];"
         "contract C2 { circuit foo(x: E): E; }"
         ))
      (oops
       message: "malformed contract-info file ~a for ~s: ~a; try recompiling ~a"
       irritants: '("compiler/testdir/C2/compiler/contract-info.json" C2 "\"witnesses\" is not associated with a vector" C2))
     ))

  (test-group ; test of stage-javascript's handling of multiple contracts
    ((create-file "testfile1.compact"
       '(
         "import CompactStandardLibrary;"
         "export circuit foo(): Field {"
         "  return 3;"
         "}"
         ))
     ; each contract needs a stage-javascript form with a different contractCode name
     ; the contractCode name is otherwise optional and defaults to contractCode
     ; the list of test-code lines can be empty, in which case the stage-javascript form is
     ; effectively the same as a (succeeds) form
     (stage-javascript contractCode1 '()))
    ((create-file "testfile2.compact"
       '(
         "import CompactStandardLibrary;"
         "export circuit foo(): Field {"
         "  return 7;"
         "}"
         ))
     ; the list of test-code lines should not be empty for the final stage-javascript,
     ; which is presumably for the consumer of the other contracts.  but stage-javascript
     ; won't complain if it is.
     (stage-javascript contractCode2
       '(
         ; each contract should be visible under its contractCode name
         "test('check 1', () => {"
         "  const [C, Ctxt] = startContract(contractCode1, {}, 0);"
         "  expect(C.circuits.foo(Ctxt).result).toEqual(3n);"
         "});"
         "test('check 2', () => {"
         "  const [C, Ctxt] = startContract(contractCode2, {}, 0);"
         "  expect(C.circuits.foo(Ctxt).result).toEqual(7n);"
         "});"
         )))
    )

  (test
    '(
      "ledger field7: List<QualifiedCoinInfo>;"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 21" "unbound identifier ~s" (QualifiedCoinInfo)))
    )

  (test
    '(
      "ledger field7: MerkleTree<10, Field>;"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 16" "unbound identifier ~s" (MerkleTree)))
    )

  (test
    '(
      "export circuit foo() : Bytes<32> { nativeToken(); }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 36" "unbound identifier ~s" (nativeToken)))
    )

  (test
    '(
      "export circuit foo(x: Either<Bytes<32>, Field>) : Bytes<32>  { left(x); }"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "unbound identifier ~s" (Either)))
    )

  (test
    '(
      "ledger field: List<QualifiedCoinInf>;"
       )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 20" "unbound identifier ~s" (QualifiedCoinInf)))
    )

  (test
    '(
      "circuit t_c<a>(value: a, rand: Field): Field;"
      "export circuit foo(x: Uint<12>): Field {"
      "  return t_c<Uint<12>>(x, 0);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 1" "unrecognized native entry ~s" (t_c)))
    )

  (test-group
    ((create-file "Calculator.compact"
       '(
         "import CompactStandardLibrary;"
         "ledger square: Map<Field, Field>;"
         "constructor() {"
         "  for (const i of 0..100) square.insert(i, i*i);"
         "}"
         ""
         "export circuit get_square(i: Field): Field {"
         "  return square.lookup(disclose(i));"
         "}"
         ))
      (succeeds))
    ((create-file "Root.compact"
       '(
         "import CompactStandardLibrary;"
         "contract Calculator {"
         "  circuit get_square(x: Field): Field;"
         "}"
         ""
         "export ledger calc: Calculator;"
         ""
         "constructor (c: Calculator) {"
         "  calc = disclose(c);"
         "}"
        ))
     (returns
       (program
         (type-descriptors
           (%descriptor.0 (tunsigned 18446744073709551615))
           (%descriptor.1 (tboolean))
           (%descriptor.2 (tbytes 32))
           (%descriptor.3 (tstruct ContractAddress
                            (bytes (tbytes 32))))
           (%descriptor.4 (tunsigned 255))
           (%descriptor.5 (tunsigned
                            340282366920938463463374607431768211455)))
         (kernel-declaration (%kernel.6 () (Kernel)))
         (public-ledger-declaration
           ((%calc.7
              (0)
              (__compact_Cell
                (tcontract Calculator
                  (get_square #f ((tfield)) (tfield))))))
           (constructor ([%c.8 (tcontract Calculator
                                 (get_square #f ((tfield)) (tfield)))])
             (seq (public-ledger %calc.7 (0) write %c.8) (tuple))))))
      ))

  (test
    '(
      "circuit foo(n: Field): Boolean {"
      "  const x = !(n == 1);"
      "  return ((x) => x && n == 0)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  return foo(n+1) ? n - 1 : n + 1;"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.45 (tfield))
          (%descriptor.46 (tboolean))
          (%descriptor.47 (tunsigned 255))
          (%descriptor.48 (tunsigned 18446744073709551615))
          (%descriptor.49
            (tunsigned 340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %foo.10 ([%n.11 (tfield)])
             (tboolean)
          (seq
            (const [%x.12 (tboolean)]
              (not (== %n.11 (safe-cast (tfield) (tunsigned 1) 1))))
            (seq
              (const [%x.13 (tboolean)] (not %x.12))
              (and %x.13 (== %n.11 (safe-cast (tfield) (tunsigned 0) 0))))))
        (circuit %bar.14 ([%n.15 (tfield)])
             (tfield)
          (if (call %foo.10 (+ #f %n.15 (safe-cast (tfield) (tunsigned 1) 1)))
              (- #f %n.15 (safe-cast (tfield) (tunsigned 1) 1))
              (+ #f %n.15 (safe-cast (tfield) (tunsigned 1) 1))))))
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "}"
        ""
        "export type PureCircuits = {"
        "  bar(n_0: bigint): bigint;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  bar(context: __compactRuntime.CircuitContext<PS>, n_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type Ledger = {"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 5n).result).toEqual(6n);"
        "  expect(contractCode.pureCircuits.bar(5n)).toEqual(6n);"
        "  });"
        ))
    )

  (test
    '(
      "circuit foo(n: Field): Boolean {"
      "  const x = (n != 1);"
      "  return ((x) => x && n == 0)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  return foo(n+1) ? n - 1 : n + 1;"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.7 (tfield))
          (%descriptor.8 (tboolean))
          (%descriptor.9 (tunsigned 255))
          (%descriptor.10 (tunsigned 18446744073709551615))
          (%descriptor.6 (tunsigned
                           340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %foo.11 ([%n.12 (tfield)])
             (tboolean)
          (seq
            (const [%x.12 (tboolean)]
              (!= %n.11 (safe-cast (tfield) (tunsigned 1) 1)))
            (seq
              (const [%x.13 (tboolean)] (not %x.12))
              (and %x.13 (== %n.11 (safe-cast (tfield) (tunsigned 0) 0))))))
        (circuit %bar.14 ([%n.15 (tfield)])
             (tfield)
          (if (call %foo.10 (+ #f %n.15 (safe-cast (tfield) (tunsigned 1) 1)))
              (- #f %n.15 (safe-cast (tfield) (tunsigned 1) 1))
              (+ #f %n.15 (safe-cast (tfield) (tunsigned 1) 1))))))
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "}"
        ""
        "export type PureCircuits = {"
        "  bar(n_0: bigint): bigint;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  bar(context: __compactRuntime.CircuitContext<PS>, n_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type Ledger = {"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 5n).result).toEqual(6n);"
        "  });"
        ))
    )

  (test
    '(
      "circuit foo(n: Uint<0..65>): Boolean {"
      "  const x = (n <= 1);"
      "  return ((x) => x && n <= 0)(!x);"
      "}"
      "export circuit bar(n: Uint<0..65>): Uint<0..65> {"
      "  return foo(n - 1) ? n -1 : n - 2;"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.14 (tunsigned 64))
          (%descriptor.15 (tboolean))
          (%descriptor.16 (tunsigned 255))
          (%descriptor.17 (tunsigned 18446744073709551615))
          (%descriptor.13 (tunsigned
                            340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %foo.18 ([%n.19 (tunsigned 64)])
             (tboolean)
          (seq
            (const [%x.19 (tboolean)]
              (<= %n.18 (safe-cast (tunsigned 64) (tunsigned 1) 1)))
            (seq
              (const [%x.20 (tboolean)] (not %x.19))
              (and %x.20 (<= %n.18 (safe-cast (tunsigned 64) (tunsigned 0) 0))))))
        (circuit %bar.21 ([%n.22 (tunsigned 64)])
             (tunsigned 64)
          (if (call %foo.18
                (seq
                  (assert
                    (not (< %n.22 (safe-cast (tunsigned 64) (tunsigned 1) 1)))
                    "result of subtraction would be negative")
                  (- 7 %n.22 (safe-cast (tunsigned 64) (tunsigned 1) 1))))
              (seq
                (assert
                  (not (< %n.22 (safe-cast (tunsigned 64) (tunsigned 1) 1)))
                  "result of subtraction would be negative")
                (- 7 %n.22 (safe-cast (tunsigned 64) (tunsigned 1) 1)))
              (seq
                (assert
                  (not (< %n.22 (safe-cast (tunsigned 64) (tunsigned 2) 2)))
                  "result of subtraction would be negative")
                (- 7 %n.22 (safe-cast (tunsigned 64) (tunsigned 2) 2)))))))
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "}"
        ""
        "export type PureCircuits = {"
        "  bar(n_0: bigint): bigint;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  bar(context: __compactRuntime.CircuitContext<PS>, n_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type Ledger = {"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 5n).result).toEqual(3n);"
        "  });"
        ))
    )

  (test
    '(
      "circuit foo(n: Uint<64>): Boolean {"
      "  const x = (n <= 1);"
      "  return ((x) => x && n <= 0)(!x);"
      "}"
      "export circuit bar(n: Uint<64>): Uint<64> {"
      "  return foo(n - 1) ? n -1 : n - 2;"
      "}"
      )
   (returns
      (program
        (type-descriptors
          (%descriptor.14 (tunsigned 18446744073709551615))
          (%descriptor.15 (tboolean))
          (%descriptor.16 (tunsigned 255))
          (%descriptor.13 (tunsigned
                            340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %foo.17 ([%n.18 (tunsigned 18446744073709551615)])
             (tboolean)
          (seq
            (const [%x.18 (tboolean)]
              (<= %n.17 (safe-cast (tunsigned 18446744073709551615) (tunsigned 1) 1)))
            (seq
              (const [%x.19 (tboolean)] (not %x.18))
              (and %x.19
                   (<= %n.17 (safe-cast (tunsigned 18446744073709551615) (tunsigned 0) 0))))))
        (circuit %bar.20 ([%n.21 (tunsigned 18446744073709551615)])
             (tunsigned 18446744073709551615)
          (if (call %foo.17
                (seq
                  (assert
                    (not (< %n.21 (safe-cast (tunsigned 18446744073709551615) (tunsigned 1) 1)))
                    "result of subtraction would be negative")
                  (- 64 %n.21 (safe-cast (tunsigned 18446744073709551615) (tunsigned 1) 1))))
              (seq
                (assert
                  (not (< %n.21 (safe-cast (tunsigned 18446744073709551615) (tunsigned 1) 1)))
                  "result of subtraction would be negative")
                (- 64 %n.21 (safe-cast (tunsigned 18446744073709551615) (tunsigned 1) 1)))
              (seq
                (assert
                  (not (< %n.21 (safe-cast (tunsigned 18446744073709551615) (tunsigned 2) 2)))
                  "result of subtraction would be negative")
                (- 64 %n.21 (safe-cast (tunsigned 18446744073709551615) (tunsigned 2) 2)))))))
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "}"
        ""
        "export type PureCircuits = {"
        "  bar(n_0: bigint): bigint;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  bar(context: __compactRuntime.CircuitContext<PS>, n_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type Ledger = {"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 5n).result).toEqual(3n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n: Uint<16>): Boolean {"
      "  return n < 16;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 14n).result).toEqual(true);"
        "  expect(C.circuits.foo(Ctxt, 16n).result).toEqual(false);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n: Uint<16>): Boolean {"
      "  return n <= 16;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 14n).result).toEqual(true);"
        "  expect(C.circuits.foo(Ctxt, 16n).result).toEqual(true);"
        "  expect(C.circuits.foo(Ctxt, 17n).result).toEqual(false);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n: Uint<16>): Boolean {"
      "  return n > 16;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 14n).result).toEqual(false);"
        "  expect(C.circuits.foo(Ctxt, 16n).result).toEqual(false);"
        "  expect(C.circuits.foo(Ctxt, 17n).result).toEqual(true);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n: Uint<16>): Boolean {"
      "  return n >= 16;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 14n).result).toEqual(false);"
        "  expect(C.circuits.foo(Ctxt, 16n).result).toEqual(true);"
        "  expect(C.circuits.foo(Ctxt, 17n).result).toEqual(true);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit bar(nv: Vector<4, Uint<16>>, bv: Vector<4, Uint<16>>): Vector<4, Boolean> {"
      "  return map((x:Uint<16>, y:Uint<16>) : Boolean => x < y, nv, bv);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, [3n,5n,7n,11n], [4n,3n,7n,12n]).result).toEqual([true, false, false, true]);"
        "});"
        ))
    )

  (test
    '(
      "export circuit bar(nv: Vector<4, Uint<16>>, bv: Vector<4, Uint<16>>): Vector<4, Boolean> {"
      "  return map((x, y) => x < y, nv, bv);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, [3n,5n,7n,11n], [4n,3n,7n,12n]).result).toEqual([true, false, false, true]);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n1: Field, n2: Field): Boolean {"
      "  return n1 != n2;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 4n, 5n).result).toEqual(true);"
        "  expect(C.circuits.foo(Ctxt, 4n, 4n).result).toEqual(false);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n1: Vector<2,Field>, n2: Vector<2,Field>): Boolean {"
      "  return n1 != n2;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [1n, 2n], [1n, 5n]).result).toEqual(true);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S {f1: Field, f2: Boolean}"
      "export circuit foo(n1: S, n2: S): Boolean {"
      "  return n1 != n2;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, {f1: 1n, f2: true}, {f1: 1n, f2: true}).result).toEqual(false);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n1: Bytes<2>, n2: Bytes<2>): Boolean {"
      "  return n1 != n2;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([0, 1]), new Uint8Array([0, 0])).result).toEqual(true);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n1: Field, n2: Field): Boolean {"
      "  return n1 == n2;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 4n, 5n).result).toEqual(false);"
        "  expect(C.circuits.foo(Ctxt, 4n, 4n).result).toEqual(true);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n1: Vector<2,Field>, n2: Vector<2,Field>): Boolean {"
      "  return n1 == n2;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [1n, 2n], [1n, 5n]).result).toEqual(false);"
        "  expect(C.circuits.foo(Ctxt, [1n, 2n], [1n, 2n]).result).toEqual(true);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S {f1: Field, f2: Boolean}"
      "export circuit foo(n1: S, n2: S): Boolean {"
      "  return n1 == n2;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, {f1: 1n, f2: true}, {f1: 1n, f2: true}).result).toEqual(true);"
        "  expect(C.circuits.foo(Ctxt, {f1: 1n, f2: true}, {f1: 1n, f2: false}).result).toEqual(false);"
        "  expect(C.circuits.foo(Ctxt, {f1: 1n, f2: true}, {f1: 2n, f2: true}).result).toEqual(false);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(n1: Bytes<2>, n2: Bytes<2>): Boolean {"
      "  return n1 == n2;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([0, 1]), new Uint8Array([0, 0])).result).toEqual(false);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([0, 0]), new Uint8Array([0, 0])).result).toEqual(true);"
        "  });"
        ))
    )

  (test
    '(
      "export { foo }"
      "include \"test-center/compact/bar\";"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([]);"
        "});"
        ))
    )

  (test
    '(
      "export { foo };"
      "include \"test-center/compact/bar\";"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([]);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(): Boolean {"
      "  const x = true;"
      "  return x;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(): Boolean {"
      "  const x = true;"
      "  return x;"
      "}"
      "export circuit bar(n: Field): Field {"
      "  return foo() ? n - 1 : n + 1;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 10n).result).toEqual(9n);"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(n: Field): Boolean {"
      "  const x = !(n == 1);"
      "  return ((x) => x && n == 0)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  return foo(n+1) ? n - 1 : n + 1;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 5n).result).toEqual(6n);"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(n: Field): Field {"
      "  const x = n == 0;"
      "  return 1 + ((x) => x == false ? n + 7 : n + 13)(!x);"
      "}"
      "export circuit bar(n: Field): Field {"
      "  return foo(n-1) * foo(n-2) * 3;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 2n).result).toEqual(360n);"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(x: Field): Field {"
      "  return 1 + (() => x)();"
      "}"
      "export circuit bar(n: Field): Field {"
      "  return foo(n) * foo(n+1) * 3;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 2n).result).toEqual(36n);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Field): Field {"
      "  return 1 + ((b, x) => x ? b - 1 : b + 1)(x + 1, !b);"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.7 (tboolean))
          (%descriptor.8 (tfield))
          (%descriptor.9 (tunsigned 255))
          (%descriptor.10 (tunsigned 18446744073709551615))
          (%descriptor.6 (tunsigned
                           340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %foo.12 ([%b.13 (tboolean)] [%x.14 (tfield)])
             (tfield)
          (seq
            (const ([%b.2 (tfield)] [%x.6 (tboolean)]))
            (+ #f
               (safe-cast (tfield) (tunsigned 1) 1)
               (seq
                 (= %b.2 (+ #f %x.14 (safe-cast (tfield) (tunsigned 1) 1)))
                 (= %x.6 (not %b.13))
                 (if %x.6
                     (- #f %b.2 (safe-cast (tfield) (tunsigned 1) 1))
                     (+ #f %b.2 (safe-cast (tfield) (tunsigned 1) 1)))))))))
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, 3n).result).toEqual(6n);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, 3n).result).toEqual(4n);"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(n: Field, b: Boolean): Field {"
      "  return b ? n + 1 : n - 1;"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Vector<7, Field> {"
      "  return map(foo, nv, bv);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, [3n,5n,7n,11n,13n,17n,19n], [true, false, false, true, false, true, true]).result).toEqual([ 4n,  4n,  6n, 12n, 12n, 18n, 20n ]);"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(n: Field, b: Boolean): Field {"
      "  return b ? n + 1 : n - 1;"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Vector<7, Field> {"
      "  return map(foo, map(foo, nv, bv), bv);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, [3n,5n,7n,11n,13n,17n,19n], [true, false, false, true, false, true, true]).result).toEqual([ 5n,  3n,  5n, 13n, 11n, 19n, 21n ]);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, <any>[3n,5n,7n,11n,13n,17,19n], [true, false, false, true, false, true, true])).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, <any>[3n,5n,7n,11n,13n,17,19n], [true, false, false, true, false, true, true])).toThrow(/type error: bar argument 1 at testfile\\.compact line 4 char 1; expected value of type Vector<7, Field> but received/);"
        "});"
        "test('check 3a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, [3n,5n,7n,11n,13n,17n,19n], <any>[true, false, false, true, 13, true, true])).toThrow(runtime.CompactError);"
        "});"
        "test('check 3b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, [3n,5n,7n,11n,13n,17n,19n], <any>[true, false, false, true, 13, true, true])).toThrow(/type error: bar argument 2 at testfile\\.compact line 4 char 1; expected value of type Vector<7, Boolean> but received/);"
        "});"
        "test('check 4a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => (<any>C.circuits.bar)(Ctxt, [3n,5n,7n,11n,13n,17n,19n])).toThrow(runtime.CompactError);"
        "});"
        "test('check 4b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => (<any>C.circuits.bar)(Ctxt, [3n,5n,7n,11n,13n,17n,19n])).toThrow('bar: expected 2 arguments (as invoked from Typescript), received 1');"
        "});"
        "test('check 5a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => (<any>C.circuits.bar)(Ctxt, [3n,5n,7n,11n,13n,17n,19n], [true, false, false, true, false, true, true], 'extra!')).toThrow(runtime.CompactError);"
        "});"
        "test('check 5b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => (<any>C.circuits.bar)(Ctxt, [3n,5n,7n,11n,13n,17n,19n], [true, false, false, true, false, true, true], 'extra!')).toThrow('bar: expected 2 arguments (as invoked from Typescript), received 3');"
        "});"
        ;; "test('check 6a', () => {"
        ;; "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ;; ;; FIXME this and following fail. expected: null. received: undefined
        ;; "  // @ts-expect-error"
        ;; "  expect(() => (<any>C.circuits.bar)(7773n, [3n,5n,7n,11n,13n,17n,19n], [true, false, false, true, false, true, true])).toThrow(runtime.CompactError);"
        ;; "});"
        ;; "test('check 6b', () => {"
        ;; "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ;; "  // @ts-expect-error"
        ;; "  expect(() => (<any>C.circuits.bar)(7773n, [3n,5n,7n,11n,13n,17n,19n], [true, false, false, true, false, true, true])).toThrow('type error: bar argument 1 (as invoked from Typescript) at testfile.compact line 4 char 1; expected value of type CircuitContext but received 7773n');"
        ;; "});"
        ))
    )

  (test
    '(
      "witness spam(): Bytes<32>;"
      "export circuit foo(): Field {"
      "  return disclose(spam()) as Field;"
      "}"
      )
    (stage-javascript
      '(
        "const witnesses1 = { spam({privateState}: runtime.WitnessContext<{}, number>): [number, Uint8Array] { return [privateState, new Uint8Array([1,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) ]; } };"
        "const contract1 = () => new contractCode.Contract(witnesses1);"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses1, 0);"
        "  expect(contract1().circuits.foo(Ctxt).result).toEqual(0x030201n);"
        "});"
        "const witnesses2 = { spam({privateState}: runtime.WitnessContext<{}, number>): [number, Uint8Array] { return [privateState, <any>72n]; } };"
        "const contract2 = () => new contractCode.Contract(witnesses2);"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses2, 0);"
        "  expect(() => contract2().circuits.foo(Ctxt)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses2, 0);"
        "  expect(() => contract2().circuits.foo(Ctxt)).toThrow('type error: spam return value at testfile.compact line 1 char 1; expected value of type Bytes<32> but received 72n');"
        "});"
        "const witnesses3 = <any>{};"
        "test('check 3a', () => {"
        "  expect(() => startContract((contractCode as any), witnesses3, 0)).toThrow(runtime.CompactError);"
        "});"
        "test('check 3b', () => {"
        "  expect(() => startContract((contractCode as any), witnesses3, 0)).toThrow('first (witnesses) argument to Contract constructor does not contain a function-valued field named spam');"
        "});"
        "const witnesses4 = <any>'oops';"
        "test('check 4a', () => {"
        "  expect(() => startContract((contractCode as any), witnesses4, 0)).toThrow(runtime.CompactError);"
        "});"
        "test('check 4b', () => {"
        "  expect(() => startContract((contractCode as any), witnesses4, 0)).toThrow('first (witnesses) argument to Contract constructor is not an object');"
        "});"
        "const witnesses5 = <any>{ spam: 'oops' };"
        "test('check 5a', () => {"
        "  expect(() => startContract(contractCode, witnesses5, 0)).toThrow(runtime.CompactError);"
        "});"
        "test('check 5b', () => {"
        "  expect(() => startContract(contractCode, witnesses5, 0)).toThrow('first (witnesses) argument to Contract constructor does not contain a function-valued field named spam');"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(a: Field, n: Field, b: Boolean): Field {"
      "  return a + (b ? n + 1 : n - 1);"
      "}"
      "export circuit bar(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Field {"
      "  return fold(foo, 17, nv, bv);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, [3n,5n,7n,11n,13n,17n,19n], [true, false, false, true, false, true, true]).result).toEqual(93n);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(): Bytes<6> {"
      "  const x = 'hello!';"
      "  return x;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(new Uint8Array([ 104, 101, 108, 108, 111, 33 ]));"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(): Vector<3, Vector<1, Field>> {"
      "  const x = [[7], [11], [19]];"
      "  return x;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([ [ 7n ], [ 11n ], [ 19n ] ]);"
        "});"
        ))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "export circuit foo(): S {"
      "  const x = S{ x: 23, y: 31 };"
      "  return x;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual({ x: 23n, y: 31n });"
        "});"
        ))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "witness W(x: S): S;"
      "export circuit foo(x : S): S {"
      "  return disclose(W(x));"
      "}"
      )
    (stage-javascript
      '(
        "const witnesses = { W(private_state: any, x: {x: bigint, y: bigint}): [any, {x: bigint, y: bigint}] { return [private_state, {x: x.x + 1n, y: x.y + 1n}]; }};"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.foo(Ctxt, {x: 3n, y: 4n}).result).toEqual({ x: 4n, y: 5n });"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(() => C.circuits.foo(Ctxt, <any>{y: 7n})).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(() => C.circuits.foo(Ctxt, <any>{y: 7n})).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 3 char 1; expected value of type struct S<x: Field, y: Field> but received { y: 7n }');"
        "});"
        ))
    )

  (test
    '(
      "struct S { x: Field; y: Field; }"
      "witness state(x: S): S;"
      "export circuit foo(x : S): S {"
      "  return disclose(state(x));"
      "}"
      )
    (stage-javascript
      '(
        "const witnesses = { state(private_state: any, x: {x: bigint, y: bigint}): [any, {x: bigint, y: bigint}] { return [private_state, {x: x.x + 1n, y: x.y + 1n}]; }};"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.foo(Ctxt, {x: 3n, y: 4n}).result).toEqual({ x: 4n, y: 5n });"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(() => C.circuits.foo(Ctxt, <any>{y: 7n})).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(() => C.circuits.foo(Ctxt, <any>{y: 7n})).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 3 char 1; expected value of type struct S<x: Field, y: Field> but received { y: 7n }');"
        "});"
        ))
    )

  (test
    '(
      "enum Weasleys { Bill, Charley, Percy, Fred, George, Ron, Ginny }"
      "export circuit foo(): Weasleys {"
      "  const x = Weasleys.Fred;"
      "  return x;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(3);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x: Field): [] {"
      "  assert(x == 17, 'oops');"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 17n).result).toEqual([]);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 19n)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 19n)).toThrow('failed assert: oops');"
        "});"
        "test('check 3a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, <any>'hello')).toThrow(runtime.CompactError);"
        "});"
        "test('check 3b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, <any>'hello')).toThrow(\"type error: foo argument 1 at testfile.compact line 1 char 1; expected value of type Field but received 'hello'\");"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(x: Field): [] {"
      "  assert(x == 17, 'oops');"
      "}"
      "export circuit bar(x: Field): Field {"
      "  return (foo(x), x + 5);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 17n).result).toEqual(22n);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, 19n)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, 19n)).toThrow('failed assert: oops');"
        "});"
        "test('check 3a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, <any>'hello')).toThrow(runtime.CompactError);"
        "});"
        "test('check 3b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, <any>'hello')).toThrow(\"type error: bar argument 1 at testfile.compact line 4 char 1; expected value of type Field but received 'hello'\");"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(x: Field): [] {"
      "  assert(x == 17, 'oops');"
      "}"
      "export circuit bar(x: Field): Field {"
      "  return (foo(x), x + 5) * 10;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 17n).result).toEqual(220n);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, 19n)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, 19n)).toThrow('failed assert: oops');"
        "});"
        "test('check 3a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, <any>[1, 2, 3])).toThrow(runtime.CompactError);"
        "});"
        "test('check 3b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, <any>[1, 2, 3])).toThrow('type error: bar argument 1 at testfile.compact line 4 char 1; expected value of type Field but received [ 1, 2, 3 ]');"
        "});"
        ))
    )

  (test
    '(
      "module M {"
      "  export circuit bar(n: Field) : Field { return foo() ? foo(n) : 17; }"
      "  export circuit foo() : Boolean { return true; }"
      "  export circuit foo(b: Boolean) : Boolean { return b; }"
      "}"
      "import M;"
      "circuit foo() : Boolean { return false; }"
      "circuit foo(a: Field) : Field { return a; }"
      "circuit foo(b: Boolean) : Boolean { return b; }"
      "export {bar}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 53n).result).toEqual(53n);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, <any>53)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, <any>53)).toThrow('type error: bar argument 1 at testfile.compact line 2 char 3; expected value of type Field but received 53');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x: Opaque<'string'>) : Vector<2, Opaque<'string'>> {"
      "  return map((ignore): Opaque<'string'> => x,"
      "             [1, 2]);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, {a: 29, b: false}).result).toEqual([ { a: 29, b: false }, { a: 29, b: false } ]);"
        "});"
        ))
    )

  (test
    '(
      "enum Names { karen, katy, kenny, kulta }"
      "export circuit foo(x: Names, y: Opaque<'string'>, z: Opaque<'string'>): Field {"
      "  return (x == Names.kenny ? 1 : 0) + (y == z ? 2 : 0);\n"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 1, {a: 91, b: true}, {a: 97, b: false}).result).toEqual(0n);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 2, {a: 91, b: true}, {a: 97, b: false}).result).toEqual(1n);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0, {a: 91, b: true}, {a: 97, b: true}).result).toEqual(0n);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 2, {a: 91, b: true}, {a: 91, b: true}).result).toEqual(1n);"
        "});"
        "const x = {a: 91, b: true};"
        "test('check 5', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 3, x, x).result).toEqual(2n);"
        "});"
        "test('check 6', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 2, x, x).result).toEqual(3n);"
        "});"
        "test('check 7a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, <any>4, x, x)).toThrow(runtime.CompactError);"
        "});"
        "test('check 7b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 4, x, x)).toThrow('type error: foo argument 1 at testfile.compact line 2 char 1; expected value of type Enum<Names, karen, katy, kenny, kulta> but received 4');"
        "});"
        "test('check 8a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 4n, x, x)).toThrow(runtime.CompactError);"
        "});"
        "test('check 8b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 4n, x, x)).toThrow('type error: foo argument 1 at testfile.compact line 2 char 1; expected value of type Enum<Names, karen, katy, kenny, kulta> but received 4n');"
        "});"
        "test('check 9a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false, x, x)).toThrow(runtime.CompactError);"
        "});"
        "test('check 9b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false, x, x)).toThrow('type error: foo argument 1 at testfile.compact line 2 char 1; expected value of type Enum<Names, karen, katy, kenny, kulta> but received false');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x: Boolean, y: Boolean): Field {"
      "  return x == y ? 17 : 23;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, false).result).toEqual(17n);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, true).result).toEqual(23n);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, false).result).toEqual(23n);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, true).result).toEqual(17n);"
        "});"
        ))
    )

  (test
    '(
      "enum Names { karen, katy, kenny, kulta }"
      "struct T { name: Names, mt: Vector<0, Names>, eh: Boolean, p: Opaque<'string'>}"
      "struct S { x: Vector<2, Bytes<3>>, y: T, z: Field, w: Uint<32> }"
      "circuit foo(s1: S, s2: S) : Boolean { return s1 == s2; }"
      "export circuit bar1(x: Opaque<'string'>, y: Field) : Boolean {"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: y as Uint<32> },"
      "             S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: y as Uint<32> });"
      "}"
      "export circuit bar2(x: Opaque<'string'>) : Boolean {"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 },"
      "             S{ x: ['abc', 'd3f'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 });"
      "}"
      "export circuit bar3(x: Opaque<'string'>) : Boolean {"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 },"
      "             S{ x: ['abc', 'def'], y: T{ name: Names.kulta, mt: [], eh: true, p: x }, z: 101, w: 73 });"
      "}"
      "export circuit bar4(x: Opaque<'string'>) : Boolean {"
      "  return foo(S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: true, p: x }, z: 101, w: 73 },"
      "             S{ x: ['abc', 'def'], y: T{ name: Names.katy, mt: [], eh: false, p: x }, z: 101, w: 73 });"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar1(Ctxt, {a: 3, b: true}, 73n).result).toEqual(true);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar2(Ctxt, {a: 3, b: true}).result).toEqual(false);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar3(Ctxt, {a: 3, b: true}).result).toEqual(false);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar4(Ctxt, {a: 3, b: true}).result).toEqual(false);"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(x: Vector<0, Field>) : Field { return x == [] ? 1 : 2; }"
      "export circuit bar() : Field {"
      "  return foo([]);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt).result).toEqual(1n);"
        "});"
        ))
    )

  (test
    '(
      "circuit add(x: Field, y: Field): Field { return x + y; }"
      "circuit foo(x: Field): Boolean {"
      "  return x == fold(add, 1, []);"
      "}"
      "export circuit bar() : Boolean {"
      "  return foo(1);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt).result).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "export circuit bar(x: Field): [] {"
      "  if (!(x == 0)) assert(x == 1, 'oops');"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 0n).result).toEqual([]);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 1n).result).toEqual([]);"
        "});"
        "test('check 3a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, 2n)).toThrow(runtime.CompactError);"
        "});"
        "test('check 3b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.bar(Ctxt, 2n)).toThrow('failed assert: oops');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(b: Boolean): [] {"
      "  assert(b, 'abc\\u1234def');"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true).result).toEqual([]);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow('failed assert: abcሴdef');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(b: Boolean): [] {"
      "  assert(b, 'abc\\xDCdef');"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true).result).toEqual([]);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow('failed assert: abcÜdef');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(b: Boolean): [] {"
      "  assert(b, 'bob\\'s \\\"fish\\\"\\r\\0\\b\\f\\t\\v\\n');"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true).result).toEqual([]);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow('failed assert: bob\\'s \\\"fish\\\"\\r\\0\\b\\f\\t\\v\\n');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(b: Boolean): [] {"
      "  assert(b, 'abc\\x02\\x7f\\x85\\u2028def');"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true).result).toEqual([]);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow('failed assert: abc\\x02\\x7f\\x85\\u2028def');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(b: Boolean): [] {"
      "  assert(b, 'abc\"def');"
      "  assert(!b, \"abc'def\");"
      "  assert(b, 'abc\\\\def');"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, true)).toThrow(runtime.CompactError);"
        "});"
        "test('check 1b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, true)).toThrow('failed assert: abc\\'def');"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, false)).toThrow(\"failed assert: abc\\\"def\");"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x : Field) : Field { return x + 3 - x + 4; }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 7n).result).toEqual(7n);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x : Boolean, y: Boolean) : Field {"
      "  return 10 * ((x ? y : false) ? 3 + 4 : y ? 5 + 6 : 17);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, false).result).toEqual(170n);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, true).result).toEqual(110n);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, false).result).toEqual(170n);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, true).result).toEqual(70n);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  return x == y == (y == z);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 3n, 3n, 3n).result).toEqual(true);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 3n, 4n, 4n).result).toEqual(false);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 3n, 4n, 5n).result).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  return x == 0 || y == 0;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 1n, 2n, 3n).result).toEqual(false);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n, 2n, 3n).result).toEqual(true);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 1n, 0n, 3n).result).toEqual(true);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n, 0n, 3n).result).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  return x == 0 && y == 0;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 1n, 2n, 3n).result).toEqual(false);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n, 2n, 3n).result).toEqual(false);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 1n, 0n, 3n).result).toEqual(false);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n, 0n, 3n).result).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x : Field, y: Field, z: Field) : Boolean {"
      "  return !(x == 0 && y == 0);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 1n, 2n, 3n).result).toEqual(true);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n, 2n, 3n).result).toEqual(true);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 1n, 0n, 3n).result).toEqual(true);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n, 0n, 3n).result).toEqual(false);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x : Field) : Boolean {"
      "  return x + x * 3 - 4 == 20 || x == 5 && !(x * 3 + x == 8);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 4n).result).toEqual(false);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 5n).result).toEqual(true);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 6n).result).toEqual(true);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 7n).result).toEqual(false);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x : Field) : Vector<3, Field> {"
      "  return [x, x * 3, x * 7];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 5n).result).toEqual([ 5n, 15n, 35n ]);"
        "});"
        ))
    )

  (test
    '(
      "export circuit baz(arg: Bytes<5>) : Field { return arg as Field; }"
      )
    (stage-javascript
      `(
        ,(format "test('check 1', () => { const [C, Ctxt] = startContract(contractCode, {}, 0); expect(C.circuits.baz(Ctxt, new Uint8Array([1, 2, 3, 4, 5])).result).toEqual(~dn) });" #x0504030201)
        ))
    )

  (test
    '(
      "export circuit baz(arg: Bytes<60>) : Field { return arg as Field; }"
      )
    (stage-javascript
      `(
        ,(format "test('check 1', () => { const [C, Ctxt] = startContract(contractCode, {}, 0); expect(C.circuits.baz(Ctxt, new Uint8Array([6,7,8,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])).result).toEqual(~dn) });" #x09080706)
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.baz(Ctxt, new Uint8Array([9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4]))).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.baz(Ctxt, new Uint8Array([9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4]))).toThrow('range error at testfile.compact line 1 char 53: the integer value of 9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4 is greater than the maximum value of a Field');"
        "});"
        ))
    )

  (test
    '(
      "export circuit baz(arg: Boolean) : Field { return arg as Field; }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.baz(Ctxt, true).result).toEqual(1n);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.baz(Ctxt, false).result).toEqual(0n);"
        "});"
        ))
    )

  (test
    '(
      "enum E { a, b, c }"
      "export circuit baz(arg: E) : Field { return arg as Field; }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.baz(Ctxt, 0).result).toEqual(0n);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.baz(Ctxt, 1).result).toEqual(1n);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.baz(Ctxt, 2).result).toEqual(2n);"
        "});"
        ))
    )

  (test
    '(
      "export circuit baz(arg: Field) : Boolean { return arg as Boolean; }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.baz(Ctxt, 1n).result).toEqual(true);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.baz(Ctxt, 0n).result).toEqual(false);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.baz(Ctxt, 3n).result).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x: Field) : Vector<1, Field> { return foo(x == 0); }"
      "circuit foo(x: Boolean) : Vector<1, Field> { return x ? [1] : [2]; }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n).result).toEqual([ 1n ]);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 7n).result).toEqual([ 2n ]);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(arg: Field) : Bytes<5> { return arg as Bytes<5>; }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0x04030201n).result).toEqual(new Uint8Array([ 1, 2, 3, 4, 0 ]));"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 0x060504030201n)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 0x060504030201n)).toThrow('range error at testfile.compact line 1 char 52: Field or Uint value 6618611909121 does not fit into 5 bytes');"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(x: Boolean) : Vector<1, Field> { return x ? [1] : [2]; }"
      "export circuit foo(x: Field) : Vector<1, Field> { return foo(x == 0); }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n).result).toEqual([ 1n ]);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 7n).result).toEqual([ 2n ]);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      ""
      "export circuit foo(): Field {"
      "  return field1.read();"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.0 (tunsigned 18446744073709551615))
          (%descriptor.1 (tfield))
          (%descriptor.2 (tboolean))
          (%descriptor.3 (tbytes 32))
          (%descriptor.4 (tstruct ContractAddress
                           (bytes (tbytes 32))))
          (%descriptor.5 (tunsigned 255))
          (%descriptor.6 (tunsigned
                           340282366920938463463374607431768211455)))
        (kernel-declaration (%kernel.7 () (Kernel)))
        (public-ledger-declaration
          ((%field1.8 (0) (Counter)))
          (constructor () (tuple)))
        (circuit %foo.9 ()
             (tfield)
          (safe-cast (tfield)
                     (tunsigned 18446744073709551615)
            (public-ledger %field1.8 (0) read)))))
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(0n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "constructor(b1: Boolean, b2: Boolean) {"
      "  field1.insert(1, default<Map<Field, Boolean>>);"
      "  field1.lookup(1).insert(2, disclose(b1));"
      "  field1.lookup(1).insert(7, disclose(b2));"
      "}"
      ""
      "export circuit foo(a: Field, b: Field): Boolean {"
      "  return field1.lookup(disclose(a)).lookup(disclose(b));"
      "}"
      "export circuit call_foo(n: Field, m: Field): Boolean {"
      "  return foo(n, m);"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, true, false);"
        "  expect(C.circuits.call_foo(Ctxt, 1n, 2n).result).toEqual(true);"
        "  expect(C.circuits.call_foo(Ctxt, 1n, 2n).result).toEqual(true);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, true, false);"
        "  expect(() => C.circuits.call_foo(Ctxt, 2n, 7n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.call_foo(Ctxt, 2n, 7n)).toThrow('Error: invalid operation for type');"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, true, false);"
        "  expect(() => C.circuits.call_foo(Ctxt, 1n, 11n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.call_foo(Ctxt, 1n, 11n)).toThrow('Error: expected a cell');"
        "});"
        )))

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Map<Field, Map<Field, Boolean>>;"
      ""
      "constructor([b1, b2] : [Boolean, Boolean]) {"
      "  field1.insert(1, default<Map<Field, Boolean>>);"
      "  field1.lookup(1).insert(2, disclose(b1));"
      "  field1.lookup(1).insert(7, disclose(b2));"
      "}"
      ""
      "export circuit foo(a: Field, b: Field): Boolean {"
      "  return field1.lookup(disclose(a)).lookup(disclose(b));"
      "}"
      "export circuit call_foo(n: Field, m: Field): Boolean {"
      "  return foo(n, m);"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, [true, false]);"
        "  expect(C.circuits.call_foo(Ctxt, 1n, 2n).result).toEqual(true);"
        "  expect(C.circuits.call_foo(Ctxt, 1n, 2n).result).toEqual(true);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, [true, false]);"
        "  expect(() => C.circuits.call_foo(Ctxt, 2n, 7n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.call_foo(Ctxt, 2n, 7n)).toThrow('Error: invalid operation for type');"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, [true, false]);"
        "  expect(() => C.circuits.call_foo(Ctxt, 1n, 11n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.call_foo(Ctxt, 1n, 11n)).toThrow('Error: expected a cell');"
        "});"
        )))

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger field1: Counter;"
      "constructor(state: Uint<16>) { field1 += disclose(state); }"
      ""
      "export circuit foo(x: Bytes<32>): Field {"
      "  kernel.claimZswapNullifier(disclose(x));"
      "  return field1.read();"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.0 (tunsigned 18446744073709551615))
          (%descriptor.1 (tbytes 32))
          (%descriptor.2 (tfield))
          (%descriptor.3 (tboolean))
          (%descriptor.4 (tstruct ContractAddress
                           (bytes (tbytes 32))))
          (%descriptor.5 (tunsigned 65535))
          (%descriptor.6 (tunsigned 255))
          (%descriptor.7 (tunsigned
                           340282366920938463463374607431768211455)))
        (kernel-declaration (%kernel.8 () (Kernel)))
        (public-ledger-declaration
          ((%field1.9 (0) (Counter)))
          (constructor ([%state.10 (tunsigned 65535)])
            (seq
              (public-ledger %field1.9 (0) increment %state.10)
              (tuple))))
        (circuit %foo.11 ([%x.12 (tbytes 32)])
             (tfield)
          (safe-cast (tfield)
                     (tunsigned 18446744073709551615)
            (seq
              (public-ledger %kernel.8 () claimZswapNullifier %x.12)
              (public-ledger %field1.9 (0) read))))))
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, 91n);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([108, 97, 114, 101, 115, 58, 116, 105, 110, 121, 58, 112, 107, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])).result).toEqual(91n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "}"
      ""
      "witness merkle_path_root(foo: Foo): MerkleTreeDigest;"
      ""
      "ledger field1: Map<Field, Foo>;"
      "ledger field2: HistoricMerkleTree<10, Foo>;"
      "ledger field3: Boolean;"
      ""
      "export circuit foo(n: Field, foo: Foo): Boolean {"
      "  field3.write(field1.lookup(disclose(n)).baz);"
      "  const q = field1.lookup(disclose(n));"
      "  assert(!(q == default<Foo>), 'entry not found');"
      "  return field2.checkRoot(disclose(merkle_path_root(q)));"
      "}"
      )
    (stage-javascript
      `(
        "const witnesses = { merkle_path_root(foo: any): any { return { field: 0n }; } };"
        "test('check 1a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 23n, { bar: new Uint8Array(32), baz: false })).toThrow(runtime.CompactError);"
        "});"
        "test('check 1b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 23n, { bar: new Uint8Array(32), baz: false })).toThrow('expected a cell');"
        "});"
        ))
   )

  (test
    '(
      "export circuit foo(): Boolean {"
      "  return default<Boolean>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(false);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(): Field {"
      "  return default<Field>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(0n);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(): Uint<0..11> {"
      "  return default<Uint<0..11>>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(0n);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(): Bytes<10> {"
      "  return default<Bytes<10>>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(): Bytes<8> {"
      "  return default<Bytes<8>>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]));"
        "});"
        ))
    )

  (test
    '(
      "enum E { a, b, c }"
      "export circuit foo(): E {"
      "  return default<E>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(0);"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(): Opaque<'string'> {"
      "  return default<Opaque<'string'>>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual('');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(): Vector<10, Field> {"
      "  return default<Vector<10, Field>>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([0n, 0n, 0n, 0n, 0n, 0n, 0n, 0n, 0n, 0n]);"
        "});"
        ))
    )

  (test
    '(
      "struct Foo {"
      "  a: Field;"
      "  b: Boolean;"
      "}"
      "export circuit foo(): Foo {"
      "  return default<Foo>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual({ a: 0n, b: false });"
        "});"
        ))
    )

  (test
    '(
      "struct Foo {"
      "  a: Vector<2, Field>;"
      "  b: Boolean;"
      "}"
      "struct Bar {"
      "  a: Vector<3, Foo>;"
      "  c: Boolean;"
      "}"
      "export circuit foo(): Bar {"
      "  return default<Bar>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual({a: [{a: [0n, 0n], b: false}, {a: [0n, 0n], b: false}, {a: [0n, 0n], b: false}], c: false});"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export { Maybe }"
      "export circuit foo(x: Maybe<Boolean>): Boolean {"
      "  return x.is_some && x.value;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, {is_some: false, value: false}).result).toEqual(false);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, {is_some: false, value: true}).result).toEqual(false);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, {is_some: true, value: false}).result).toEqual(false);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, {is_some: true, value: true}).result).toEqual(true);"
        "});"
        "test('check 5a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, <any>{is_some: true, xalue: true})).toThrow(runtime.CompactError);"
        "});"
        "test('check 5b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, <any>{is_some: true, xalue: true})).toThrow('type error: foo argument 1 at testfile.compact line 3 char 1; expected value of type struct Maybe<is_some: Boolean, value: Boolean> but received { is_some: true, xalue: true }');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Uint<10>): Uint<10> {"
      "  return b ? x + 1023 as Uint<10> : 0;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, 1023n).result).toEqual(0n);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, 0n).result).toEqual(1023n);"
        "});"
        "test('check 3a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, true, 1023n)).toThrow(runtime.CompactError);"
        "});"
        "test('check 3b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, true, 1023n)).toThrow('testfile.compact line 2 char 14: cast from Field or Uint value to smaller Uint value failed: 2046 is greater than 1023');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(b: Boolean, x: Uint<10>): Uint<10> {"
      "  return b ? x + 1024 as Uint<10> : 0;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, 1023n).result).toEqual(0n);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, true, 0n)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, true, 0n)).toThrow('testfile.compact line 2 char 14: cast from Field or Uint value to smaller Uint value failed: 1024 is greater than 1023');"
        "});"
        "test('check 3a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, true, 1023n)).toThrow(runtime.CompactError);"
        "});"
        "test('check 3b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, true, 1023n)).toThrow('testfile.compact line 2 char 14: cast from Field or Uint value to smaller Uint value failed: 2047 is greater than 1023');"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "struct Foo {"
      "  bar: Bytes<32>;"
      "  baz: Boolean;"
      "  rats: Vector<1, CoinInfo>;"
      "  mice: Uint<16>;"
      "}"
      ""
      "ledger field0: Counter;"
      "ledger field1: Boolean;"
      "ledger field2: Set<Field>;"
      "ledger field3: Map<Field, Foo>;"
      "ledger field4: List<Foo>;"
      "ledger field5: MerkleTree<10, Foo>;"
      "ledger field6: HistoricMerkleTree<10, Field>;"
      "ledger field7: QualifiedCoinInfo;"
      "ledger field8: Set<QualifiedCoinInfo>;"
      "ledger field9: Map<Field, QualifiedCoinInfo>;"
      "ledger field10: List<QualifiedCoinInfo>;"
      ""
      "export circuit foo(x0: Field, y0: Foo, ci0: CoinInfo): Boolean {"
      "  const x = disclose(x0); const y = disclose(y0); const ci = disclose(ci0);"
      "  field0.resetToDefault();"
      "  field0.increment(5);"
      "  field0.decrement(2);"
      "  assert(field0.lessThan(4), 'oops 1');"
      "  field1.write(true);"
      "  const q = field1.read();"
      "  field2.resetToDefault();"
      "  assert(field2.isEmpty(), 'oops 2a');"
      "  assert(field2.size() == 0, 'oops 2b');"
      "  assert(!field2.member(x), 'oops 2c');"
      "  field2.insert(x);"
      "  field2.insert(x + 1);"
      "  field2.insert(x + 2);"
      "  field2.insert(x + 1);"
      "  assert(field2.size() == 3, 'oops 2d');"
      "  field2.remove(x + 1);"
      "  assert(field2.size() == 2, 'oops 2e');"
      "  assert(!field2.isEmpty(), 'oops 2f');"
      "  assert(field2.member(x), 'oops 2g');"
      "  assert(!field2.member(x + 1), 'oops 2h');"
      "  assert(field2.member(x + 2), 'oops 2i');"
      "  field3.resetToDefault();"
      "  field3.insert(x, y);"
      "  field4.resetToDefault();"
      "  field5.resetToDefault();"
      "  field6.resetToDefault();"
      "  field7.writeCoin(ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field8.resetToDefault();"
      "  field8.insertCoin(ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field9.resetToDefault();"
      "  field9.insertCoin(x, ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  field10.resetToDefault();"
      "  field10.pushFrontCoin(ci, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "  return q;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(typeof(C.circuits)).toEqual('object');"
        "});"
        ))
    )

  #|
  (test ;;FIXME uncomment composable contract
    "test-center/compact/test.compact"
    (stage-javascript
      `(
        "const witnesses = { C(a: any, b: any): Uint8Array { return new Uint8Array(10); }, W(a: any, b: any): undefined { return; }};"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0, 20n);"
        "  expect(typeof(C.circuits)).toEqual('object');"
        "});"
        "test('check 2a', () => {"
        "  expect(() => startContract(contractCode, witnesses, 0, <any>[1, 2, 3])).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  expect(() => startContract(contractCode, witnesses, 0, <any>[1, 2, 3])).toThrow('type error: Contract state constructor argument 1 (argument 2 as invoked from Typescript) at test.compact line 111 char 1; expected value of type Field but received [ 1, 2, 3 ]');"
        "});"
        ))
    )
  |#

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit foo(): Field {"
      "  return 1;"
      "}"
       )
    (stage-javascript
      `(
        "test('check', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  // @ts-expect-error"
        "  expect(() => C.foo()).toThrow('C.foo is not a function');"
        "})")))

  (test
    `(
      "import CompactStandardLibrary;"
      "witness next_fib(): Field;"
      "export circuit fib() : Field{"
      "  return disclose(next_fib());"
      "}")
    (stage-javascript
      `(
        "const w = ({privateState}: runtime.WitnessContext<{}, {n1: bigint, n2: bigint}>) : [{n1: bigint, n2: bigint}, bigint] => {const n = privateState.n1 + privateState.n2; return [{n1: privateState.n2, n2: n}, n];}"
        "const witnesses = { next_fib: w };"
        "test('check', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, {n1 : 1n, n2 : 1n});"
        "  const x = C.circuits.fib(Ctxt);"
        "  expect(x.result).toEqual(2n);"
        "  expect(x.proofData.privateTranscriptOutputs.length).toEqual(1);"
        "  const x2 = C.circuits.fib(x.context);"
        "  expect(x2.result).toEqual(3n);"
        "  const x3 = C.circuits.fib(x2.context);"
        "  expect(x3.result).toEqual(5n);"
        "  expect(C.circuits.fib(Ctxt).result).toEqual(2n);"
        "})"
         )))

  (test
    `(
      "import CompactStandardLibrary;"
      "export circuit foo(): ZswapCoinPublicKey {"
      "  return ownPublicKey();"
      "}"
       )
    (stage-javascript
      `(
        "test('check', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const R = C.circuits.foo(Ctxt);"
        "  expect(R.proofData.privateTranscriptOutputs.length).toEqual(1);"
        "})"))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "struct S { x: Field, y: ZswapCoinPublicKey }"
      "witness next_fib(): Field;"
      "export circuit fib() : S {"
      "  return S{ x: disclose(next_fib()), y: ownPublicKey() };"
      "}")
    (stage-javascript
      `(
        "const w = ({privateState}: runtime.WitnessContext<{}, {n1: bigint, n2: bigint}>) : [{n1: bigint, n2: bigint}, bigint] => {const n = privateState.n1 + privateState.n2; return [{n1: privateState.n2, n2: n}, n];}"
        "const witnesses = { next_fib: w };"
        "test('check', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, {n1 : 1n, n2 : 1n});"
        "  const x = C.circuits.fib(Ctxt);"
        "  expect(x.result.x).toEqual(2n);"
        "  expect(x.proofData.privateTranscriptOutputs.length).toEqual(2);"
        "})"
         ))
    )

  (test
    "test-center/compact/block-time.compact"
    (stage-javascript "test-center/ts/block-time.ts"))

  (test
    "test-center/compact/threading.compact"
    (stage-javascript "test-center/ts/threading.ts"))

  (test
    "test-center/compact/threading.compact"
    (stage-javascript "test-center/ts/threading-hacky.ts"))

  (test
    "examples/tiny.compact"
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Maybe<T> = { is_some: boolean; value: T };"
        ""
        "export type Witnesses<PS> = {"
        "  private$secret_key(context: __compactRuntime.WitnessContext<Ledger, PS>): [PS, Uint8Array];"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "  set(context: __compactRuntime.CircuitContext<PS>, v_0: bigint): __compactRuntime.CircuitResults<PS, []>;"
        "  get(context: __compactRuntime.CircuitContext<PS>): __compactRuntime.CircuitResults<PS, Maybe<bigint>>;"
        "  clear(context: __compactRuntime.CircuitContext<PS>): __compactRuntime.CircuitResults<PS, []>;"
        "}"
        ""
        "export type PureCircuits = {"
        "  public_key(sk_0: Uint8Array): Uint8Array;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  set(context: __compactRuntime.CircuitContext<PS>, v_0: bigint): __compactRuntime.CircuitResults<PS, []>;"
        "  get(context: __compactRuntime.CircuitContext<PS>): __compactRuntime.CircuitResults<PS, Maybe<bigint>>;"
        "  clear(context: __compactRuntime.CircuitContext<PS>): __compactRuntime.CircuitResults<PS, []>;"
        "  public_key(context: __compactRuntime.CircuitContext<PS>, sk_0: Uint8Array): __compactRuntime.CircuitResults<PS, Uint8Array>;"
        "}"
        ""
        "export type Ledger = {"
        "  readonly value: bigint;"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>, v_0: bigint): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    ; WARNING: Do not replace this wholesale...maintain the structure of the first several
    ; lines to avoid hard-coding a specific runtime version string into the test
    (output-file "compiler/testdir/contract/index.js"
      `(
        "import * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ,(format "__compactRuntime.checkRuntimeVersion('~a');" runtime-version-string)
        ""
        "const _descriptor_0 = __compactRuntime.CompactTypeField;"
        ""
        "const _descriptor_1 = new __compactRuntime.CompactTypeBytes(32);"
        ""
        "const _descriptor_2 = new __compactRuntime.CompactTypeEnum(1, 1);"
        ""
        "const _descriptor_3 = __compactRuntime.CompactTypeBoolean;"
        ""
        "class _Maybe_0 {"
        "  alignment() {"
        "    return _descriptor_3.alignment().concat(_descriptor_0.alignment());"
        "  }"
        "  fromValue(value_0) {"
        "    return {"
        "      is_some: _descriptor_3.fromValue(value_0),"
        "      value: _descriptor_0.fromValue(value_0)"
        "    }"
        "  }"
        "  toValue(value_0) {"
        "    return _descriptor_3.toValue(value_0.is_some).concat(_descriptor_0.toValue(value_0.value));"
        "  }"
        "}"
        ""
        "const _descriptor_4 = new _Maybe_0();"
        ""
        "const _descriptor_5 = new __compactRuntime.CompactTypeVector(2, _descriptor_1);"
        ""
        "const _descriptor_6 = new __compactRuntime.CompactTypeUnsignedInteger(18446744073709551615n, 8);"
        ""
        "class _ContractAddress_0 {"
        "  alignment() {"
        "    return _descriptor_1.alignment();"
        "  }"
        "  fromValue(value_0) {"
        "    return {"
        "      bytes: _descriptor_1.fromValue(value_0)"
        "    }"
        "  }"
        "  toValue(value_0) {"
        "    return _descriptor_1.toValue(value_0.bytes);"
        "  }"
        "}"
        ""
        "const _descriptor_7 = new _ContractAddress_0();"
        ""
        "const _descriptor_8 = new __compactRuntime.CompactTypeUnsignedInteger(255n, 1);"
        ""
        "const _descriptor_9 = new __compactRuntime.CompactTypeUnsignedInteger(340282366920938463463374607431768211455n, 16);"
        ""
        "class Contract {"
        "  witnesses;"
        "  constructor(...args_0) {"
        "    if (args_0.length !== 1) {"
        "      throw new __compactRuntime.CompactError(`Contract constructor: expected 1 argument, received ${args_0.length}`);"
        "    }"
        "    const witnesses_0 = args_0[0];"
        "    if (typeof(witnesses_0) !== 'object') {"
        "      throw new __compactRuntime.CompactError('first (witnesses) argument to Contract constructor is not an object');"
        "    }"
        "    if (typeof(witnesses_0.private$secret_key) !== 'function') {"
        "      throw new __compactRuntime.CompactError('first (witnesses) argument to Contract constructor does not contain a function-valued field named private$secret_key');"
        "    }"
        "    this.witnesses = witnesses_0;"
        "    this.circuits = {"
        "      set: (...args_1) => {"
        "        if (args_1.length !== 2) {"
        "          throw new __compactRuntime.CompactError(`set: expected 2 arguments (as invoked from Typescript), received ${args_1.length}`);"
        "        }"
        "        const contextOrig_0 = args_1[0];"
        "        const v_0 = args_1[1];"
        "        if (!(typeof(contextOrig_0) === 'object' && contextOrig_0.currentQueryContext != undefined)) {"
        "          __compactRuntime.typeError('set',"
        "                                     'argument 1 (as invoked from Typescript)',"
        "                                     'tiny.compact line 82 char 1',"
        "                                     'CircuitContext',"
        "                                     contextOrig_0)"
        "        }"
        "        if (!(typeof(v_0) === 'bigint' && v_0 >= 0 && v_0 <= __compactRuntime.MAX_FIELD)) {"
        "          __compactRuntime.typeError('set',"
        "                                     'argument 1 (argument 2 as invoked from Typescript)',"
        "                                     'tiny.compact line 82 char 1',"
        "                                     'Field',"
        "                                     v_0)"
        "        }"
        "        const context = { ...contextOrig_0 };"
        "        const partialProofData = {"
        "          input: {"
        "            value: _descriptor_0.toValue(v_0),"
        "            alignment: _descriptor_0.alignment()"
        "          },"
        "          output: undefined,"
        "          publicTranscript: [],"
        "          privateTranscriptOutputs: []"
        "        };"
        "        const result_0 = this._set_0(context, partialProofData, v_0);"
        "        partialProofData.output = { value: [], alignment: [] };"
        "        return { result: result_0, context: context, proofData: partialProofData };"
        "      },"
        "      get: (...args_1) => {"
        "        if (args_1.length !== 1) {"
        "          throw new __compactRuntime.CompactError(`get: expected 1 argument (as invoked from Typescript), received ${args_1.length}`);"
        "        }"
        "        const contextOrig_0 = args_1[0];"
        "        if (!(typeof(contextOrig_0) === 'object' && contextOrig_0.currentQueryContext != undefined)) {"
        "          __compactRuntime.typeError('get',"
        "                                     'argument 1 (as invoked from Typescript)',"
        "                                     'tiny.compact line 100 char 1',"
        "                                     'CircuitContext',"
        "                                     contextOrig_0)"
        "        }"
        "        const context = { ...contextOrig_0 };"
        "        const partialProofData = {"
        "          input: { value: [], alignment: [] },"
        "          output: undefined,"
        "          publicTranscript: [],"
        "          privateTranscriptOutputs: []"
        "        };"
        "        const result_0 = this._get_0(context, partialProofData);"
        "        partialProofData.output = { value: _descriptor_4.toValue(result_0), alignment: _descriptor_4.alignment() };"
        "        return { result: result_0, context: context, proofData: partialProofData };"
        "      },"
        "      clear: (...args_1) => {"
        "        if (args_1.length !== 1) {"
        "          throw new __compactRuntime.CompactError(`clear: expected 1 argument (as invoked from Typescript), received ${args_1.length}`);"
        "        }"
        "        const contextOrig_0 = args_1[0];"
        "        if (!(typeof(contextOrig_0) === 'object' && contextOrig_0.currentQueryContext != undefined)) {"
        "          __compactRuntime.typeError('clear',"
        "                                     'argument 1 (as invoked from Typescript)',"
        "                                     'tiny.compact line 111 char 1',"
        "                                     'CircuitContext',"
        "                                     contextOrig_0)"
        "        }"
        "        const context = { ...contextOrig_0 };"
        "        const partialProofData = {"
        "          input: { value: [], alignment: [] },"
        "          output: undefined,"
        "          publicTranscript: [],"
        "          privateTranscriptOutputs: []"
        "        };"
        "        const result_0 = this._clear_0(context, partialProofData);"
        "        partialProofData.output = { value: [], alignment: [] };"
        "        return { result: result_0, context: context, proofData: partialProofData };"
        "      },"
        "      public_key(context, ...args_1) {"
        "        return { result: pureCircuits.public_key(...args_1), context };"
        "      }"
        "    };"
        "    this.impureCircuits = {"
        "      set: this.circuits.set,"
        "      get: this.circuits.get,"
        "      clear: this.circuits.clear"
        "    };"
        "  }"
        "  initialState(...args_0) {"
        "    if (args_0.length !== 2) {"
        "      throw new __compactRuntime.CompactError(`Contract state constructor: expected 2 arguments (as invoked from Typescript), received ${args_0.length}`);"
        "    }"
        "    const constructorContext_0 = args_0[0];"
        "    const v_0 = args_0[1];"
        "    if (typeof(constructorContext_0) !== 'object') {"
        "      throw new __compactRuntime.CompactError(`Contract state constructor: expected 'constructorContext' in argument 1 (as invoked from Typescript) to be an object`);"
        "    }"
        "    if (!('initialPrivateState' in constructorContext_0)) {"
        "      throw new __compactRuntime.CompactError(`Contract state constructor: expected 'initialPrivateState' in argument 1 (as invoked from Typescript)`);"
        "    }"
        "    if (!('initialZswapLocalState' in constructorContext_0)) {"
        "      throw new __compactRuntime.CompactError(`Contract state constructor: expected 'initialZswapLocalState' in argument 1 (as invoked from Typescript)`);"
        "    }"
        "    if (typeof(constructorContext_0.initialZswapLocalState) !== 'object') {"
        "      throw new __compactRuntime.CompactError(`Contract state constructor: expected 'initialZswapLocalState' in argument 1 (as invoked from Typescript) to be an object`);"
        "    }"
        "    if (!(typeof(v_0) === 'bigint' && v_0 >= 0 && v_0 <= __compactRuntime.MAX_FIELD)) {"
        "      __compactRuntime.typeError('Contract state constructor',"
        "                                 'argument 1 (argument 2 as invoked from Typescript)',"
        "                                 'tiny.compact line 55 char 1',"
        "                                 'Field',"
        "                                 v_0)"
        "    }"
        "    const state_0 = new __compactRuntime.ContractState();"
        "    let stateValue_0 = __compactRuntime.StateValue.newArray();"
        "    stateValue_0 = stateValue_0.arrayPush(__compactRuntime.StateValue.newNull());"
        "    stateValue_0 = stateValue_0.arrayPush(__compactRuntime.StateValue.newNull());"
        "    stateValue_0 = stateValue_0.arrayPush(__compactRuntime.StateValue.newNull());"
        "    state_0.data = stateValue_0;"
        "    state_0.setOperation('set', new __compactRuntime.ContractOperation());"
        "    state_0.setOperation('get', new __compactRuntime.ContractOperation());"
        "    state_0.setOperation('clear', new __compactRuntime.ContractOperation());"
        "    const context = __compactRuntime.createCircuitContext(__compactRuntime.DUMMY_ADDRESS, constructorContext_0.initialZswapLocalState.coinPublicKey, state_0.data, constructorContext_0.initialPrivateState)"
        "    const partialProofData = {"
        "      input: { value: [], alignment: [] },"
        "      output: undefined,"
        "      publicTranscript: [],"
        "      privateTranscriptOutputs: []"
        "    };"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(0n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_1.toValue(new Uint8Array(32)),"
        "                                                                                              alignment: _descriptor_1.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(1n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_0.toValue(0n),"
        "                                                                                              alignment: _descriptor_0.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(2n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_2.toValue(0),"
        "                                                                                              alignment: _descriptor_2.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    const sk_0 = this._private$secret_key_0(context, partialProofData);"
        "    const tmp_0 = this._public_key_0(sk_0);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(0n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_1.toValue(tmp_0),"
        "                                                                                              alignment: _descriptor_1.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(1n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_0.toValue(v_0),"
        "                                                                                              alignment: _descriptor_0.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(2n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_2.toValue(1),"
        "                                                                                              alignment: _descriptor_2.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    state_0.data = context.currentQueryContext.state;"
        "    return {"
        "      currentContractState: state_0,"
        "      currentPrivateState: context.currentPrivateState,"
        "      currentZswapLocalState: context.currentZswapLocalState"
        "    }"
        "  }"
        "  _some_0(value_0) { return { is_some: true, value: value_0 }; }"
        "  _none_0() { return { is_some: false, value: 0n }; }"
        "  _persistentHash_0(value_0) {"
        "    const result_0 = __compactRuntime.persistentHash(_descriptor_5, value_0);"
        "    return result_0;"
        "  }"
        "  _private$secret_key_0(context, partialProofData) {"
        "    const witnessContext_0 = __compactRuntime.createWitnessContext(ledger(context.currentQueryContext.state), context.currentPrivateState, context.currentQueryContext.address);"
        "    const [nextPrivateState_0, result_0] = this.witnesses.private$secret_key(witnessContext_0);"
        "    context.currentPrivateState = nextPrivateState_0;"
        "    if (!(result_0.buffer instanceof ArrayBuffer && result_0.BYTES_PER_ELEMENT === 1 && result_0.length === 32)) {"
        "      __compactRuntime.typeError('private$secret_key',"
        "                                 'return value',"
        "                                 'tiny.compact line 70 char 1',"
        "                                 'Bytes<32>',"
        "                                 result_0)"
        "    }"
        "    partialProofData.privateTranscriptOutputs.push({"
        "      value: _descriptor_1.toValue(result_0),"
        "      alignment: _descriptor_1.alignment()"
        "    });"
        "    return result_0;"
        "  }"
        "  _in_state_0(context, partialProofData, s_0) {"
        "    return _descriptor_2.fromValue(__compactRuntime.queryLedgerState(context,"
        "                                                                     partialProofData,"
        "                                                                     ["
        "                                                                      { dup: { n: 0 } },"
        "                                                                      { idx: { cached: false,"
        "                                                                               pushPath: false,"
        "                                                                               path: ["
        "                                                                                      { tag: 'value',"
        "                                                                                        value: { value: _descriptor_8.toValue(2n),"
        "                                                                                                 alignment: _descriptor_8.alignment() } }] } },"
        "                                                                      { popeq: { cached: false,"
        "                                                                                 result: undefined } }]).value)"
        "           ==="
        "           s_0;"
        "  }"
        "  _set_0(context, partialProofData, v_0) {"
        "    __compactRuntime.assert(this._in_state_0(context, partialProofData, 0),"
        "                            'set: attempted to overwrite recorded value');"
        "    const sk_0 = this._private$secret_key_0(context, partialProofData);"
        "    const apk_0 = this._public_key_0(sk_0);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(0n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_1.toValue(apk_0),"
        "                                                                                              alignment: _descriptor_1.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(1n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_0.toValue(v_0),"
        "                                                                                              alignment: _descriptor_0.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(2n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_2.toValue(1),"
        "                                                                                              alignment: _descriptor_2.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    return [];"
        "  }"
        "  _get_0(context, partialProofData) {"
        "    if (this._in_state_0(context, partialProofData, 1)) {"
        "      return this._some_0(_descriptor_0.fromValue(__compactRuntime.queryLedgerState(context,"
        "                                                                                    partialProofData,"
        "                                                                                    ["
        "                                                                                     { dup: { n: 0 } },"
        "                                                                                     { idx: { cached: false,"
        "                                                                                              pushPath: false,"
        "                                                                                              path: ["
        "                                                                                                     { tag: 'value',"
        "                                                                                                       value: { value: _descriptor_8.toValue(1n),"
        "                                                                                                                alignment: _descriptor_8.alignment() } }] } },"
        "                                                                                     { popeq: { cached: false,"
        "                                                                                                result: undefined } }]).value));"
        "    } else {"
        "      return this._none_0();"
        "    }"
        "  }"
        "  _clear_0(context, partialProofData) {"
        "    __compactRuntime.assert(this._in_state_0(context, partialProofData, 1),"
        "                            'clear: no value is currently recorded');"
        "    const sk_0 = this._private$secret_key_0(context, partialProofData);"
        "    const apk_0 = this._public_key_0(sk_0);"
        "    __compactRuntime.assert(this._equal_0(apk_0,"
        "                                          _descriptor_1.fromValue(__compactRuntime.queryLedgerState(context,"
        "                                                                                                    partialProofData,"
        "                                                                                                    ["
        "                                                                                                     { dup: { n: 0 } },"
        "                                                                                                     { idx: { cached: false,"
        "                                                                                                              pushPath: false,"
        "                                                                                                              path: ["
        "                                                                                                                     { tag: 'value',"
        "                                                                                                                       value: { value: _descriptor_8.toValue(0n),"
        "                                                                                                                                alignment: _descriptor_8.alignment() } }] } },"
        "                                                                                                     { popeq: { cached: false,"
        "                                                                                                                result: undefined } }]).value)),"
        "                            'clear: attempted clear without proper authorization');"
        "    const tmp_0 = new Uint8Array(32);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(0n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_1.toValue(tmp_0),"
        "                                                                                              alignment: _descriptor_1.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(1n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_0.toValue(0n),"
        "                                                                                              alignment: _descriptor_0.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    __compactRuntime.queryLedgerState(context,"
        "                                      partialProofData,"
        "                                      ["
        "                                       { push: { storage: false,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_8.toValue(2n),"
        "                                                                                              alignment: _descriptor_8.alignment() }).encode() } },"
        "                                       { push: { storage: true,"
        "                                                 value: __compactRuntime.StateValue.newCell({ value: _descriptor_2.toValue(0),"
        "                                                                                              alignment: _descriptor_2.alignment() }).encode() } },"
        "                                       { ins: { cached: false, n: 1 } }]);"
        "    return [];"
        "  }"
        "  _public_key_0(sk_0) {"
        "    return this._persistentHash_0([new Uint8Array([108, 97, 114, 101, 115, 58, 116, 105, 110, 121, 58, 112, 107, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),"
        "                                   sk_0]);"
        "  }"
        "  _equal_0(x0, y0) {"
        "    if (!x0.every((x, i) => y0[i] === x)) { return false; }"
        "    return true;"
        "  }"
        "}"
        "function ledger(state) {"
        "  const context = {"
        "    currentQueryContext: new __compactRuntime.QueryContext(state, __compactRuntime.dummyContractAddress())"
        "  };"
        "  const partialProofData = {"
        "    input: { value: [], alignment: [] },"
        "    output: undefined,"
        "    publicTranscript: [],"
        "    privateTranscriptOutputs: []"
        "  };"
        "  return {"
        "    get value() {"
        "      return _descriptor_0.fromValue(__compactRuntime.queryLedgerState(context,"
        "                                                                       partialProofData,"
        "                                                                       ["
        "                                                                        { dup: { n: 0 } },"
        "                                                                        { idx: { cached: false,"
        "                                                                                 pushPath: false,"
        "                                                                                 path: ["
        "                                                                                        { tag: 'value',"
        "                                                                                          value: { value: _descriptor_8.toValue(1n),"
        "                                                                                                   alignment: _descriptor_8.alignment() } }] } },"
        "                                                                        { popeq: { cached: false,"
        "                                                                                   result: undefined } }]).value);"
        "    }"
        "  };"
        "}"
        "const _emptyContext = {"
        "  currentQueryContext: new __compactRuntime.QueryContext(new __compactRuntime.ContractState().data, __compactRuntime.dummyContractAddress())"
        "};"
        "const _dummyContract = new Contract({"
        "  private$secret_key: (...args) => undefined"
        "});"
        "const pureCircuits = {"
        "  public_key: (...args_0) => {"
        "    if (args_0.length !== 1) {"
        "      throw new __compactRuntime.CompactError(`public_key: expected 1 argument (as invoked from Typescript), received ${args_0.length}`);"
        "    }"
        "    const sk_0 = args_0[0];"
        "    if (!(sk_0.buffer instanceof ArrayBuffer && sk_0.BYTES_PER_ELEMENT === 1 && sk_0.length === 32)) {"
        "      __compactRuntime.typeError('public_key',"
        "                                 'argument 1',"
        "                                 'tiny.compact line 125 char 1',"
        "                                 'Bytes<32>',"
        "                                 sk_0)"
        "    }"
        "    return _dummyContract._public_key_0(sk_0);"
        "  }"
        "};"
        "const contractReferenceLocations = { tag: 'publicLedgerArray', indices: { } };"
        "export { Contract, ledger, pureCircuits, contractReferenceLocations };"
        "//# sourceMappingURL=index.js.map"))
    (output-file "compiler/testdir/contract/index.js.map"
      '(
        "{"
        "  \"version\": 3,"
        "  \"file\": \"index.js\","
        "  \"sourceRoot\": \"../src/\","
        "  \"sources\": [\"examples/tiny.compact\", \"compiler/standard-library.compact\"],"
        "  \"names\": [],"
        "  \"mappings\": \";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsDA;;;;;;;;;;;;;MA2BA,AAAA,GAOC;;;;;cAPW,GAAQ;;;;;;;;;;;;;;;;;;yCAAR,GAAQ;;;;;;;gEAAR,GAAQ;;;OAOnB;MAWD,AAAA,GAEC;;;;;;;;;;;;;;;;;;;;;;OAAA;MASD,AAAA,KAQC;;;;;;;;;;;;;;;;;;;;;;OAAA;MAMD,AAAA,UAEC;;OAAA;;;;;;;GAnEA;EALD;;;;;UAAY,GAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAHpB;;;;;;;;;yEAA4B;IAC5B;;;;;;;;;yEAA2B;IAC3B;;;;;;;;;yEAAoB;UAEZ,IAAyB;UAC/B,KAAS,sBAAc,IAAE;IAAzB;;;;;;;2HAAA,KAAS;;yEAAA;IACT;;;;;;;2HAAiB,GAAC;;yEAAb;IACL;;;;;;;;;yEAAK;;;;;;;GACN;ECpCD,AAAA,OAEC,CAFsB,OAAQ,mCACU,OAAK,KAC7C;EAED,AAAA,OAEC,4CAAA;EAmBD,AAAA,iBAAsD,CAArB,OAAQ;oEAAR,OAAQ;;GAAa;EDqBtD,AAAA,qBAAwC;;0DAAxC,kBAAwC;;;;;;;;;;;;;;GAAA;EAQxC,AAAA,WAEC,4BAFgB,GAAQ;mCAChB;;;;;;;;;;;wGAAK;;WAAI,GAAC;GAClB;EAED,AAAA,MAOC,4BAPW,GAAQ;;;UAEZ,IAAyB;UACzB,KAAoB,sBAAH,IAAE;IACzB;;;;;;;2HAAY,KAAG;;yEAAN;IACT;;;;;;;2HAAiB,GAAC;;yEAAb;IACL;;;;;;;;;yEAAK;;GACN;EAWD,AAAA,MAEC;;kDAD0C;;;;;;;;;;;uHAAK;;;;GAC/C;EASD,AAAA,QAQC;;;UANO,IAAyB;UACzB,KAAoB,sBAAH,IAAE;0CAClB,KAAG;kEAAI;;;;;;;;;;;uIAAS;;UACvB,KAAS;IAAT;;;;;;;2HAAA,KAAS;;yEAAA;IACT;;;;;;;;;yEAAK;IACL;;;;;;;;;yEAAK;;GACN;EAMD,AAAA,aAEC,CAFkB,IAAa;;mCACmD,IAAE;GACpF;;;;;;;;;;;;;;;;;IA1ED;qCAAA;;;;;;;;;;;0GAA2B;KAAA;;;;;;;;;;EAwE3B,AAAA,UAEC;;;;UAFkB,IAAa;;;;;;;;wCAAb,IAAa;GAE/B;;;;\""
        "}"))
    (stage-javascript "test-center/ts/tiny.ts")
  )

  (test
    "examples/election.compact"
    (stage-javascript
      `(
        "const witnesses = {"
        "                  private$secret_key(): any { return; },"
        "                  private$state(): any { return; },"
        "                  private$state$advance(): any { return; },"
        "                  private$vote$record(x: any): any { return; },"
        "                  private$vote(): any { return; },"
        "                  context$eligible_voters$path_of(x: any): any { return; },"
        "                  context$committed_votes$path_of(x: any): any { return; }"
        "                 };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(typeof(C.circuits)).toEqual('object');"
        "});"
        ))
    )

  (test
    "examples/zerocash.compact"
    (stage-javascript
      `(
        "const witnesses = {"
        "                    private$zk_secret_key(): any { return; },"
        "                    private$remove_coin(coin: any): any { return; },"
        "                    private$zk_public_key(): any { return; },"
        "                    private$add_coin(coin: any): any { return; },"
        "                    context$path_of(cm: any): any { return; },"
        "                    context$new_coin_info(): any { return; },"
        "                    context$encrypt(pk: any, coin: any): any { return; }"
        "                   };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(typeof(C.circuits)).toEqual('object');"
        "});"
        ))
    )

  (test
   "test-center/midnight-contracts/packages/dao/contract/src/micro-dao.compact"
   (stage-javascript
     `(
       "const witnesses = {"
       "                   local_secret_key(): any { return; },"
       "                   local_state(): any { return; },"
       "                   local_advance_state(): any { return; },"
       "                   local_record_vote(vote: any): any { return; },"
       "                   local_vote_cast(): any { return; },"
       "                   local_path_of_cm(cm: any): any { return; }"
       "                   };"
       "test('check 1', () => {"
       "  const sk = new Uint8Array([108, 97, 114, 101, 115, 58, 116, 105, 110, 121, 58, 112, 107, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);"
       "  const [C, Ctxt] = startContract(contractCode, witnesses, 0, sk, {seed_dust: 2n, buy_in_dust: 2n});"
       "  expect(typeof(C.circuits)).toEqual('object');"
       "});"
       ))
   )

  (test
   "test-center/midnight-contracts/packages/bboard/contract/src/bboard.compact"
   (stage-javascript
     `(
       "const witnesses = {"
       "                  local_secret_key(): any { return; }"
       "                  };"
       "test('check 1', () => {"
       "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
       "  expect(typeof(C.circuits)).toEqual('object');"
       "});"
       ))
   )

  (test
   "test-center/midnight-contracts/packages/coracle/contract/src/coracle.compact"
   (stage-javascript
     `(
       "const witnesses = {"
       "                   local_secret_key(): any { return; },"
       "                   local_board(): any { return; },"
       "                   local_set_board(board: any): any { return; },"
       "                   fresh_nonce(): any { return; },"
       "                   ownPublicKey(): any { return; },"
       "                   createZswapInput(): any { return; },"
       "                   createZswapOutput(): any { return; }"
       "                  };"
       "test('check 1', () => {"
       "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
       "  expect(typeof(C.circuits)).toEqual('object');"
       "});"
       ))
   )

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/counter/contract/src/counter.compact"
    (stage-javascript
     `(
       "const witnesses = { private_increment(): any { return; } };"
       "test('check 1', () => {"
       "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
       "  expect(typeof(C.circuits)).toEqual('object');"
       "});"
       ))
    )

  (test ; just see if it succeeds
    "test-center/midnight-contracts/packages/welcome/contract/src/welcome.compact"
    (stage-javascript
     `(
       "const witnesses = {"
       "                   set_local_id(participant: any): any { return; },"
       "                   local_sk(ps: any): any { return [ps, {is_some: true, value: new Uint8Array([108, 97, 114, 101, 115, 58, 116, 105, 110, 121, 58, 112, 107, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])}];}"
       "                  };"
       "test('check 1', () => {"
       "class Maybe{is_some: boolean; value: string; constructor(is_some: boolean, value: string) { this.is_some = is_some; this.value = value;}}"
       "const p1 = new Maybe( true, 'p1' );"
       "const participants: Maybe[] = new Array(5000).fill(p1);"
       "  const [C, Ctxt] = startContract(contractCode, witnesses, 0, participants);"
       "  expect(typeof(C.circuits)).toEqual('object');"
       "});"
       )))

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(c: CurvePoint): CurvePoint {"
      "  return ecAdd(c, ecMul(c, 3));"
      "}"
      "export circuit bar(x: Field): CurvePoint {"
      "  return ecMulGenerator(x);"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 0n).result).toEqual({ x: 0n, y: 1n });"
        "  expect(C.circuits.bar(Ctxt, 1n).result).toEqual({ x: 28336281903124990867587793011069573392383982287722241916350956173377953689573n, y: 39385640392217313770878525135509063452020585410343666726093009378539878503883n });"
        "  expect(C.circuits.foo(Ctxt, C.circuits.bar(Ctxt, 1n).result).result).toEqual({x: 52314913592789878805517974153014629220250507019089108027564561641173449264214n, y: 316401541904675051751671509748590036265704531513998184420066319217098126774n });"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness bar(x: Field): Uint<0..36>;"
      "export circuit foo(x: Uint<0..36>): Uint<0..36> {"
      "  return x - x as Uint<0..36>;"
      "}"
      )
    (stage-javascript
      `(
        "const witnesses = { bar(x: bigint): bigint { return 101n; } };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.foo(Ctxt, 20n).result).toEqual(0n);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 37n)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(() => C.circuits.foo(Ctxt, 37n)).toThrow('type error: foo argument 1 at testfile.compact line 3 char 1; expected value of type Uint<0..36> but received 37n');"
        "});"
        ))
    )

  (test
    '(
      "export struct Q<a> { x: a, y: Field }"
      "export enum Names { bill, sally, fred, george, }"
      "export circuit uno(q: Q<Boolean>): Names {"
      "  return q.x ? Names.sally : Names.fred;"
      "}"
      "export circuit dos(q: Q<Field>): Names {"
      "  return q.x == q.y ? Names.bill : Names.george;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.uno(Ctxt, { x: true, y: 3n }).result).toEqual(1);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.uno(Ctxt, { x: false, y: 3n }).result).toEqual(2);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.dos(Ctxt, { x: 5n, y: 3n }).result).toEqual(3);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.dos(Ctxt, { x: 3n, y: 3n }).result).toEqual(0);"
        "});"
        "test('check 5a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.uno(Ctxt, <any>{ x: 3n, y: 4n })).toThrow(runtime.CompactError);"
        "});"
        "test('check 5b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.uno(Ctxt, <any>{ x: 3n, y: 4n })).toThrow('type error: uno argument 1 at testfile.compact line 3 char 1; expected value of type struct Q<x: Boolean, y: Field> but received { x: 3n, y: 4n }');"
        "});"
        "test('check 6a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, <any>{ x: true, y: 4n })).toThrow(runtime.CompactError);"
        "});"
        "test('check 6b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, <any>{ x: true, y: 4n })).toThrow('type error: dos argument 1 at testfile.compact line 6 char 1; expected value of type struct Q<x: Field, y: Field> but received { x: true, y: 4n }');"
        "});"
        ))
    )

  (test
    '(
      "export struct Q<a, b> { x: a, y: b }"
      "export enum Names { bill, sally, fred, george, }"
      "export circuit uno(q: Q<Boolean, Vector<3, Uint<32>>>): Names {"
      "  return q.x ? Names.sally : Names.fred;"
      "}"
      "export circuit dos(q: Q<Vector<3, Field>,Vector<3,Field>>): Names {"
      "  return q.x == q.y ? Names.bill : Names.george;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.uno(Ctxt, { x: true, y: [3n, 4n, 5n] }).result).toEqual(1);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.uno(Ctxt, { x: false, y: [3n, 4n, 5n] }).result).toEqual(2);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.dos(Ctxt, { x: [3n, 7n, 5n], y: [3n, 4n, 5n] }).result).toEqual(3);"
        "});"
        "test('check 4', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.dos(Ctxt, { x: [3n, 4n, 5n], y: [3n, 4n, 5n] }).result).toEqual(0);"
        "});"
        "test('check 5a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.uno(Ctxt, <any>{ x: 3n, y: 4n })).toThrow(runtime.CompactError);"
        "});"
        "test('check 5b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.uno(Ctxt, <any>{ x: 3n, y: 4n })).toThrow('type error: uno argument 1 at testfile.compact line 3 char 1; expected value of type struct Q<x: Boolean, y: Vector<3, Uint<0..4294967296>>> but received { x: 3n, y: 4n }');"
        "});"
        "test('check 6a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, <any>{ x: true, y: 4n })).toThrow(runtime.CompactError);"
        "});"
        "test('check 6b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, <any>{ x: true, y: 4n })).toThrow('type error: dos argument 1 at testfile.compact line 6 char 1; expected value of type struct Q<x: Vector<3, Field>, y: Vector<3, Field>> but received { x: true, y: 4n }');"
        "});"
        ))
    )

  (test
    '(
      "export struct Q<a, #n> { x: Vector<n, a>, y: Uint<12>, z: Opaque<'string'> }"
      "export circuit uno(q: Q<Boolean, 3>): Uint<32> {"
      "  return q.x[2] ? q.y + 1 : q.y - 1;"
      "}"
      "export circuit dos(q: Q<Field, 2>): Opaque<'string'> {"
      "  assert(q.x[0] == q.x[1], 'oops');"
      "  return q.z;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.uno(Ctxt, { x: [true, false, true], y: 53n, z: 'hola' }).result).toEqual(54n);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.uno(Ctxt, { x: [true, false, false], y: 53n, z: 'hola' }).result).toEqual(52n);"
        "});"
        "test('check 3', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.dos(Ctxt, { x: [3n, 3n], y: 53n, z: 'hola' }).result).toEqual('hola');"
        "});"
        "test('check 4a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, { x: [3n, 4n], y: 53n, z: 'hola' })).toThrow(runtime.CompactError);"
        "});"
        "test('check 4b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, { x: [3n, 4n], y: 53n, z: 'hola' })).toThrow('failed assert: oops');"
        "});"
        "test('check 5a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.uno(Ctxt, <any>{ x: 3n, y: 4n })).toThrow(runtime.CompactError);"
        "});"
        "test('check 5b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.uno(Ctxt, <any>{ x: 3n, y: 4n })).toThrow('type error: uno argument 1 at testfile.compact line 2 char 1; expected value of type struct Q<x: Vector<3, Boolean>, y: Uint<0..4096>, z: Opaque<\"string\">> but received { x: 3n, y: 4n }');"
        "});"
        "test('check 6a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, <any>{ x: true, y: 4n })).toThrow(runtime.CompactError);"
        "});"
        "test('check 6b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, <any>{ x: true, y: 4n })).toThrow('type error: dos argument 1 at testfile.compact line 5 char 1; expected value of type struct Q<x: Vector<2, Field>, y: Uint<0..4096>, z: Opaque<\"string\">> but received { x: true, y: 4n }');"
        "});"
        ))
    )

  (test
    '(
      "export struct Q<a, #n> { x: Vector<n, a>, y: a }"
      "module M1 {"
      "  export circuit uno(q: Q<Uint<12>, 2>): Uint<32> {"
      "    return q.x[0] + q.x[1] - q.y;"
      "  }"
      "}"
      "module M2 {"
      "  export circuit dos(q: Q<Boolean, 2>): Boolean {"
      "    return q.x[0] && q.x[1] || q.y;"
      "  }"
      "}"
      "module M3 {"
      "  struct Q { x: Vector<2, Uint<12>>, y: Boolean }"
      "  export circuit tres(q: Q): Uint<32> {"
      "    return q.y ? q.x[0] + q.x[1] : q.x[0] * q.x[1];"
      "  }"
      "}"
      "import M1;"
      "import M2;"
      "import M3;"
      "export { uno, dos, tres }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.uno(Ctxt, { x: [3n, 4n], y: 2n }).result).toEqual(5n);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.dos(Ctxt, { x: [true, false], y: true }).result).toEqual(true);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.dos(Ctxt, { x: [true, true], y: false }).result).toEqual(true);"
        "});"
        "test('check 2c', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.dos(Ctxt, { x: [false, true], y: false }).result).toEqual(false);"
        "});"
        "test('check 3a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.tres(Ctxt, { x: [7n, 4n], y: true }).result).toEqual(11n);"
        "});"
        "test('check 3b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.tres(Ctxt, { x: [7n, 4n], y: false }).result).toEqual(28n);"
        "});"
        "test('check 4a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.uno(Ctxt, <any>{ x: 3n, y: 4n })).toThrow(runtime.CompactError);"
        "});"
        "test('check 4b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.uno(Ctxt, <any>{ x: 3n, y: 4n })).toThrow('type error: uno argument 1 at testfile.compact line 3 char 3; expected value of type struct Q<x: Vector<2, Uint<0..4096>>, y: Uint<0..4096>> but received { x: 3n, y: 4n }');"
        "});"
        "test('check 5a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, <any>{ x: true, y: 4n })).toThrow(runtime.CompactError);"
        "});"
        "test('check 5b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.dos(Ctxt, <any>{ x: true, y: 4n })).toThrow('type error: dos argument 1 at testfile.compact line 8 char 3; expected value of type struct Q<x: Vector<2, Boolean>, y: Boolean> but received { x: true, y: 4n }');"
        "});"
        "test('check 6a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.tres(Ctxt, <any>{ x: true, y: 4n })).toThrow(runtime.CompactError);"
        "});"
        "test('check 6b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.tres(Ctxt, <any>{ x: true, y: 4n })).toThrow('type error: tres argument 1 at testfile.compact line 14 char 3; expected value of type struct Q<x: Vector<2, Uint<0..4096>>, y: Boolean> but received { x: true, y: 4n }');"
        "});"
        ))
    )

  (test
    '(
      "module M0<b> {"
      "  export struct Q<a, #n> { x: Vector<n, a>, y: b }"
      "}"
      "import M0<Uint<12>>;"
      "export { Q }"
      "module M1 {"
      "  import M0<Field>;"
      "  export circuit uno(q: Q<Field, 2>): Field {"
      "    return q.x[0] + q.x[1] - q.y;"
      "  }"
      "}"
      "import M1;"
      "export { uno }"
      )
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Q<a> = { x: a[]; y: bigint };"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "}"
        ""
        "export type PureCircuits = {"
        "  uno(q_0: Q<bigint>): bigint;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  uno(context: __compactRuntime.CircuitContext<PS>, q_0: Q<bigint>): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type Ledger = {"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.uno(Ctxt, { x: [3n, 4n], y: 2n }).result).toEqual(5n);"
        "});"
        ))
    )

  (test
    '(
      "module M0<b> {"
      "  export struct Q<a, #n> { x: Vector<n, a>, y: b }"
      "}"
      "import M0<Field>;"
      "export { Q }"
      "module M1 {"
      "  import M0<Uint<12>>;"
      "  export circuit uno(q: Q<Uint<12>, 2>): Uint<32> {"
      "    return q.x[0] + q.x[1] - q.y;"
      "  }"
      "}"
      "import M1;"
      "export { uno }"
      )
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Q<a> = { x: a[]; y: bigint };"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "}"
        ""
        "export type PureCircuits = {"
        "  uno(q_0: Q<bigint>): bigint;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  uno(context: __compactRuntime.CircuitContext<PS>, q_0: Q<bigint>): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type Ledger = {"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.uno(Ctxt, { x: [3n, 4n], y: 2n }).result).toEqual(5n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit hello(): Opaque<'string'> {"
      "  return greeting;"
      "}"
      "export ledger greeting: Opaque<'string'>;"
      "constructor(x: Opaque<'string'>) { greeting = disclose(x); }"
      )
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "  hello(context: __compactRuntime.CircuitContext<PS>): __compactRuntime.CircuitResults<PS, string>;"
        "}"
        ""
        "export type PureCircuits = {"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  hello(context: __compactRuntime.CircuitContext<PS>): __compactRuntime.CircuitResults<PS, string>;"
        "}"
        ""
        "export type Ledger = {"
        "  readonly greeting: string;"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>, x_0: string): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, 'hola');"
        "  expect(C.circuits.hello(Ctxt).result).toEqual('hola');"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export { Maybe }"
      "export ledger rat: Field;"
      "constructor(witnesses: Field) { rat = disclose(witnesses); }"
      "witness witnesses(witnesses: Field): Field;"
      "export circuit state(x: Field): Field { return disclose(witnesses(x)) + 5; }"
      "export circuit context(x: Field): Field { return state(x + 3); }"
      "export circuit transcript(x: Field): Field { return context(x + 7); }"
      "export circuit Contract(x: Field): Field { return transcript(x) + 2; }"
      "export circuit arguments(eval: Field, arguments: Field, witnesses: Field): Field { return Contract(eval + arguments + witnesses) + rat; }"
      "export circuit functions(Maybe: Maybe<Field>): Field { return Maybe.value + 17; }"
      "export circuit finalize(): Field { return functions(some<Field>(3)); }"
      )
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Maybe<T> = { is_some: boolean; value: T };"
        ""
        "export type Witnesses<PS> = {"
        "  witnesses(context: __compactRuntime.WitnessContext<Ledger, PS>,"
        "            witnesses_0: bigint): [PS, bigint];"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "  state(context: __compactRuntime.CircuitContext<PS>, x_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  context(context: __compactRuntime.CircuitContext<PS>, x_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  transcript(context: __compactRuntime.CircuitContext<PS>, x_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  Contract(context: __compactRuntime.CircuitContext<PS>, x_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  arguments(context: __compactRuntime.CircuitContext<PS>,"
        "            eval_0: bigint,"
        "            arguments_0: bigint,"
        "            witnesses_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type PureCircuits = {"
        "  functions(Maybe_0: Maybe<bigint>): bigint;"
        "  finalize(): bigint;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  state(context: __compactRuntime.CircuitContext<PS>, x_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  context(context: __compactRuntime.CircuitContext<PS>, x_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  transcript(context: __compactRuntime.CircuitContext<PS>, x_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  Contract(context: __compactRuntime.CircuitContext<PS>, x_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  arguments(context: __compactRuntime.CircuitContext<PS>,"
        "            eval_0: bigint,"
        "            arguments_0: bigint,"
        "            witnesses_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  functions(context: __compactRuntime.CircuitContext<PS>, Maybe_0: Maybe<bigint>): __compactRuntime.CircuitResults<PS, bigint>;"
        "  finalize(context: __compactRuntime.CircuitContext<PS>): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type Ledger = {"
        "  readonly rat: bigint;"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>,"
        "               witnesses_0: bigint): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    (stage-javascript
      `(
        "const witnesses = { witnesses(private_state: any, witnesses: bigint): [any, bigint] { return [private_state, witnesses + 11n]; } };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0, 73n);"
        "  expect(C.circuits.arguments(Ctxt, 11n, 7n, 13n).result).toEqual(132n);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0, 73n);"
        "  expect(C.circuits.finalize(Ctxt).result).toEqual(20n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit red_guess(my_guess: Field): Field { return my_guess - 1; }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.red_guess(Ctxt, 11n).result).toEqual(10n);"
        "});"
        "test('check 2a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => <any>(C.circuits.red_guess)(Ctxt, <any>11)).toThrow(runtime.CompactError);"
        "});"
        "test('check 2b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => <any>(C.circuits.red_guess)(Ctxt, <any>11)).toThrow('type error: red_guess argument 1 at testfile.compact line 2 char 1; expected value of type Field but received 11');"
        "});"
        "test('check 3a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => { let f: any = C.circuits.red_guess; return f(Ctxt, <any>11, <any>12); }).toThrow(runtime.CompactError);"
        "});"
        "test('check 3b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => { let f: any = C.circuits.red_guess; return f(Ctxt, <any>11, <any>12); }).toThrow('red_guess: expected 1 argument (as invoked from Typescript), received 2');"
        "});"
        "test('check 4a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => { let f: any = C.circuits.red_guess; return f(Ctxt, 11n, <any>12); }).toThrow(runtime.CompactError);"
        "});"
        "test('check 4b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => { let f: any = C.circuits.red_guess; return f(Ctxt, 11n, <any>12); }).toThrow('red_guess: expected 1 argument (as invoked from Typescript), received 2');"
        "});"
        "test('check 5a', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => { let f: any = C.circuits.red_guess; return f(Ctxt, 11n, 12n); }).toThrow(runtime.CompactError);"
        "});"
        "test('check 5b', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => { let f: any = C.circuits.red_guess; return f(Ctxt, 11n, 12n); }).toThrow('red_guess: expected 1 argument (as invoked from Typescript), received 2');"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Uint<12>): Field {"
      "  return transientCommit<Uint<12>>(x, 0);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const h1 = C.circuits.foo(Ctxt, 17n).result;"
        "  const h2 = C.circuits.foo(Ctxt, 17n).result;"
        "  const h3 = C.circuits.foo(Ctxt, 23n).result;"
        "  expect(typeof(h1)).toEqual('bigint');"
        "  expect(h2).toEqual(h1);"
        "  expect(h3).not.toEqual(h1);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Uint<12>): Bytes<32> {"
      "  const rand : Bytes<32> = '12345678901234567890123456789012' as Bytes<32>;"
      "  return persistentCommit<Uint<12>>(x, rand);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const h1 = C.circuits.foo(Ctxt, 17n).result;"
        "  const h2 = C.circuits.foo(Ctxt, 17n).result;"
        "  const h3 = C.circuits.foo(Ctxt, 23n).result;"
        "  expect(h2).toEqual(h1);"
        "  expect(h3).not.toEqual(h1);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Boolean): CurvePoint {"
      "  return hashToCurve<Boolean>(x);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const h1 = C.circuits.foo(Ctxt, true).result;"
        "  const h2 = C.circuits.foo(Ctxt, true).result;"
        "  const h3 = C.circuits.foo(Ctxt, false).result;"
        "  expect(h2).toEqual(h1);"
        "  expect(h3).not.toEqual(h1);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger foo: Field;"
      "export ledger bar: Set<Field>;"
      "export ledger baz: MerkleTree<2, Field>;"
      ""
      "export circuit rat(): [] {"
      "  foo = 42;"
      "  bar.insert(23);"
      "  baz.insert(71);"
      "}"
      ""
      "export circuit root_of(path: MerkleTreePath<2, Field>): MerkleTreeDigest {"
      "  return merkleTreePathRoot<2, Field>(path);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.rat(Ctxt).result).toEqual([]);"
        "});"
        "test('check 2', () => {"
        "  const [C, Ctxt0] = startContract(contractCode, {}, 0);"
        "  const L0 = contractCode.ledger(Ctxt0.currentQueryContext.state);"
        "  expect(L0.foo).toEqual(0n);"
        "  expect(L0.bar.member(17n)).toEqual(false);"
        "  expect(L0.bar.member(23n)).toEqual(false);"
        "  expect(L0.bar.isEmpty()).toEqual(true);"
        "  const Ctxt1 = C.circuits.rat(Ctxt0).context;"
        "  const L1 = contractCode.ledger(Ctxt1.currentQueryContext.state);"
        "  const Ctxt2 = C.circuits.rat(Ctxt1).context;"
        "  const L2 = contractCode.ledger(Ctxt2.currentQueryContext.state);"
        "  const Ctxt3 = C.circuits.rat(Ctxt2).context;"
        "  const L3 = contractCode.ledger(Ctxt3.currentQueryContext.state);"
        "  const Ctxt4 = C.circuits.rat(Ctxt3).context;"
        "  const L4 = contractCode.ledger(Ctxt4.currentQueryContext.state);"
        "  expect(L1.foo).toEqual(42n);"
        "  expect(L1.bar.isEmpty()).toEqual(false);"
        "  expect(L1.bar.size()).toEqual(1n);"
        "  expect(L1.bar.member(17n)).toEqual(false);"
        "  expect(L1.bar.member(23n)).toEqual(true);"
        "  var sum: bigint = 3n;"
        "  for(const elem of L1.bar) { sum = sum + elem; }"
        "  expect(sum).toEqual(26n);"
        "  expect(() => (<any>L1).bar.size(3n)).toThrow(runtime.CompactError);"
        "  expect(() => (<any>L1).bar.member()).toThrow(runtime.CompactError);"
        "  expect(() => (<any>L1).bar.member(3n, 5n)).toThrow(runtime.CompactError);"
        "  expect(() => (<any>L1).bar.member(true)).toThrow(runtime.CompactError);"
        "  expect(() => (<any>L1).bar.member([1, 2, 3])).toThrow(runtime.CompactError);"
        "  expect(L0.baz.firstFree()).toEqual(0n);"
        "  expect(L0.baz.isFull()).toEqual(false);"
        "  expect(L1.baz.firstFree()).toEqual(1n);"
        "  expect(L1.baz.isFull()).toEqual(false);"
        "  expect(L2.baz.firstFree()).toEqual(2n);"
        "  expect(L4.baz.isFull()).toEqual(true);"
        "  expect(contractCode.pureCircuits.root_of(L1.baz.findPathForLeaf(71n)!)).toEqual(L1.baz.root());"
        "  expect(contractCode.pureCircuits.root_of(L2.baz.pathForLeaf(1n, 71n))).toEqual(L2.baz.root());"
        "  expect(L1.baz.checkRoot(contractCode.pureCircuits.root_of(L1.baz.findPathForLeaf(71n)!))).toEqual(true);"
        "  expect(L2.baz.checkRoot(contractCode.pureCircuits.root_of(L1.baz.findPathForLeaf(71n)!))).toEqual(false);"
        ; FIXME: test more L1.baz operators
        "});"
        )
      )
    )

  (test
    '(
      "pragma language_version >= 0.4.0;"
      ""
      "import CompactStandardLibrary;"
      ""
      "export circuit bar(): Field {"
      "  return 3;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt).result).toEqual(3n);"
        "});"
        )
      )
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "pragma language_version >= 0.4.0 && < 0.99.0;"
      "pragma compiler_version >= 0.4.0 && < 0.99.0;"
      ""
      "export circuit bar(): Field {"
      "  return 3;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt).result).toEqual(3n);"
        "});"
        )
      )
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum LedgerState { setup, commit, reveal, final, }"
      ""
      "ledger organizer: Bytes<32>;"
      "ledger state: LedgerState;"
      "ledger topic: Maybe<Opaque<'string'>>;"
      "ledger beneficiary: Maybe<ZswapCoinPublicKey>;"
      "export ledger yes: Counter;"
      "ledger no: Counter;"
      "ledger round: Counter;"
      "export ledger committedVotes: MerkleTree<10, Bytes<32>>;"
      "export ledger eligibleVoters: HistoricMerkleTree<10, Bytes<32>>;"
      "ledger committed: Set<Bytes<32>>;"
      "ledger revealed: Set<Bytes<32>>;"
      ""
      "ledger pot: QualifiedCoinInfo;"
      "export ledger potHasCoin: Boolean;"
      ""
      "constructor(organizerSecretKey: Bytes<32>) {"
      "  organizer = publicKey(disclose(organizerSecretKey));"
      "  state = LedgerState.setup;"
      "}"
      ""
      "circuit publicKey(sk: Bytes<32>): Bytes<32> {"
      "  return persistentHash<Vector<2, Bytes<32>>>([pad(32, 'lares:udao:pk:'), sk]);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const sk = new Uint8Array([108, 97, 114, 101, 115, 58, 116, 105, 110, 121, 58, 112, 107, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, sk);"
        "  const L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.yes).toEqual(0n);"
        "  expect(L.potHasCoin).toEqual(false);"
        "  expect(typeof(L.committedVotes.root())).toEqual('object');"
        "  expect(typeof(L.eligibleVoters.history())).toEqual('object');"
        "});"
        )
      )
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger eligible_voters: HistoricMerkleTree<10, Bytes<32>>;"
      ""
      "circuit foo(pk: Bytes<32>): MerkleTreePath<10, Bytes<32>> {"
      "  const path = eligible_voters.find_path_for_leaf(pk);"
      "  return path;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 31" "~s ~s is a runtime-only method, but was invoked in-circuit" (HistoricMerkleTree find_path_for_leaf)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger rats: MerkleTree<10, Field>;"
      ""
      "export circuit foo(x: Field): [] {"
      "  rats.insert(disclose(x));"
      "}"
      ""
      "export circuit root_of(path: MerkleTreePath<10, Field>): MerkleTreeDigest {"
      "  return merkleTreePathRoot<10, Field>(path);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt0] = startContract(contractCode, {}, 0);"
        "  const Ctxt1 = C.circuits.foo(Ctxt0, 17n).context;"
        "  const L1 = contractCode.ledger(Ctxt1.currentQueryContext.state);"
        "  expect(contractCode.pureCircuits.root_of(L1.rats.findPathForLeaf(17n)!)).toEqual(L1.rats.root());"
        "  expect(L1.rats.findPathForLeaf(23n)).toEqual(undefined);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger rats: MerkleTree<10, Field>;"
      ""
      "export circuit foo(x: Field): [] {"
      "  rats.insert(disclose(x));"
      "}"
      ""
      "export pure circuit root_of(path: MerkleTreePath<10, Field>): MerkleTreeDigest {"
      "  return merkleTreePathRoot<10, Field>(path);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt0] = startContract(contractCode, {}, 0);"
        "  const Ctxt1 = C.circuits.foo(Ctxt0, 17n).context;"
        "  const L1 = contractCode.ledger(Ctxt1.currentQueryContext.state);"
        "  expect(contractCode.pureCircuits.root_of(L1.rats.findPathForLeaf(17n)!)).toEqual(L1.rats.root());"
        "  expect(L1.rats.findPathForLeaf(23n)).toEqual(undefined);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger rats: MerkleTree<10, Field>;"
      ""
      "export pure circuit foo(x: Field): [] {"
      "  rats.insert(x);"
      "}"
      ""
      "export circuit root_of(path: MerkleTreePath<10, Field>): MerkleTreeDigest {"
      "  return merkleTreePathRoot<10, Field>(path);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 1" "circuit ~a is marked pure but is actually impure because it ~a at ~a" (foo "accesses ledger field rats" "line 6 char 3")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger rats: MerkleTree<10, Field>;"
      ""
      "export circuit foo(x: Field): [] {"
      "  rats.insert(x);"
      "}"
      ""
      "export pure circuit itIsntPure(x: Field): [] {"
      "  const x = foo(1);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 1" "circuit ~a is marked pure but is actually impure because it calls (directly or indirectly) impure circuit ~a;\n    ~:*~a is impure because it ~a at ~a" (itIsntPure foo "accesses ledger field rats" "line 6 char 3")))
    )

  (test
    '(
      "witness foo(n: Field) : Boolean;"
      "export pure circuit itIsntPure(v: Vector<2, Field>): Vector<2, Boolean> {"
      "  return map(foo, v);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "circuit ~a is marked pure but is actually impure because it ~a at ~a" (itIsntPure "calls witness foo" "line 3 char 14")))
    )

    (test
    '(
      "ledger l: Field;"
      "export pure circuit isntPure(v: Vector<2, Field>): Vector<2, Field> {"
      "  return map("
      "    (x) => {"
      "      return x + l;"
      "    },"
      "    v);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "circuit ~a is marked pure but is actually impure because it ~a at ~a" (isntPure "accesses ledger field l" "line 5 char 18")))
    )

  (test
    '(
      "ledger l: Field;"
      "circuit foo (x: Field) : Field { return x + l; }"
      "export pure circuit isntPure(v: Vector<2, Field>): Vector<2, Field> {"
      "  return map(foo, v);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 1" "circuit ~a is marked pure but is actually impure because it calls (directly or indirectly) impure circuit ~a;\n    ~:*~a is impure because it ~a at ~a" (isntPure foo "accesses ledger field l" "line 2 char 45")))
    )

  (test
    '(
      "witness foo(n: Field) : Field;"
      "export pure circuit isntPure(v: Vector<2, Field>): Vector<2, Field> {"
      "  return map("
      "    (x) => {"
      "      return foo(x);"
      "    },"
      "    v);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "circuit ~a is marked pure but is actually impure because it ~a at ~a" (isntPure "calls witness foo" "line 5 char 14")))
    )

  (test
    '(
      "witness foo(n: Field) : Field;"
      "export pure circuit isntPure(v: Vector<2, Field>): Vector<2, Field> {"
      "  return map(foo, v);"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 1" "circuit ~a is marked pure but is actually impure because it ~a at ~a" (isntPure "calls witness foo" "line 3 char 14")))
    )

  (test
    '(
      "ledger l: Field;"
      "export circuit isntPure(v: Vector<2, Field>): Vector<2, Field> {"
      "  return map("
      "    (x) => {"
      "      return x + l;"
      "    },"
      "    v);"
      "}"
     )
    (succeeds))

  (test
    '(
      "ledger l: Field;"
      "circuit foo (x: Field) : Field { return x + l; }"
      "export circuit isntPure(v: Vector<2, Field>): Vector<2, Field> {"
      "  return map(foo, v);"
      "}"
     )
    (succeeds))

  (test
    '(
      "witness foo(n: Field) : Field;"
      "export circuit isntPure(v: Vector<2, Field>): Vector<2, Field> {"
      "  return map("
      "    (x) => {"
      "      return disclose(foo(x));"
      "    },"
      "    v);"
      "}"
     )
    (succeeds))

  (test
    '(
      "witness foo(n: Field) : Field;"
      "export circuit isntPure(v: Vector<2, Field>): Vector<2, Field> {"
      "  return disclose(map(foo, v));"
      "}"
     )
    (succeeds))

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger rats: HistoricMerkleTree<10, Field>;"
      ""
      "export circuit foo(x: Field): [] {"
      "  rats.insert(disclose(x));"
      "}"
      ""
      "export circuit root_of(path: MerkleTreePath<10, Field>): MerkleTreeDigest {"
      "  return merkleTreePathRoot<10, Field>(path);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt0] = startContract(contractCode, {}, 0);"
        "  const Ctxt1 = C.circuits.foo(Ctxt0, 17n).context;"
        "  const L1 = contractCode.ledger(Ctxt1.currentQueryContext.state);"
        "  expect(contractCode.pureCircuits.root_of(L1.rats.findPathForLeaf(17n)!)).toEqual(L1.rats.root());"
        "  expect(L1.rats.findPathForLeaf(23n)).toEqual(undefined);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger bar: List<Field>;"
      "constructor() {"
      "  bar.pushFront(42);"
      "}"
      ""
      "export circuit baz(): Field {"
      "  kernel.mint(pad(32, ''), 5);"
      "  return bar.length();"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.baz(Ctxt).result).toEqual(1n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger field0: Map<Field, Field>;"
      ""
      "export circuit foo(): [] {"
      "  field0.insert(1, 1);"
      "  field0.insert(2, 3);"
      "  field0.insert(3, 5);"
      "  field0.insert(4, 7);"
      "  field0.insert(5, 9);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp = C.circuits.foo(Ctxt);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  var sum: bigint = 20n;"
        "  for(const elem of L.field0) { const [key, value] = elem; sum = sum + value; }"
        "  expect(sum).toEqual(45n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger field0: List<Field>;"
      ""
      "export circuit foo(): Maybe<Field> {"
      "  field0.pushFront(1);"
      "  field0.pushFront(3);"
      "  field0.pushFront(5);"
      "  field0.pushFront(7);"
      "  field0.pushFront(9);"
      "  return field0.head();"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp = C.circuits.foo(Ctxt);"
        "  expect(tmp.result).toEqual({ is_some: true, value: 9n });"
        "  });"
        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp = C.circuits.foo(Ctxt);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  var sum: bigint = 20n;"
        "  for(const elem of L.field0) { sum = sum + elem; }"
        "  expect(sum).toEqual(45n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger field0: Map<Boolean, Field>;"
      "export ledger field1: Map<Boolean, Counter>;"
      ""
      "export circuit identity(q: Field): Field {"
      "  return q + 1;"
      "}"
      ""
      "export circuit init0(b: Boolean): [] {"
      "  field0.insert(disclose(b), default<Field>);"
      "}"
      ""
      "export circuit ismember(b: Boolean): Boolean {"
      "  return field1.member(disclose(b));"
      "}"
      ""
      "export circuit init1(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Counter>);"
      "}"
      ""
      "export circuit update(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(disclose(b)) += disclose(n);"
      "}"
      ""
      "export circuit get(b: Boolean): Uint<64> {"
      "  return field1.lookup(disclose(b));"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.identity(Ctxt, 73n);"
        "  expect(tmp.result).toEqual(74n);"
        "  tmp = C.circuits.init0(tmp.context, true);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.ismember(tmp.context, true);"
        "  expect(tmp.result).toEqual(false);"
        "  tmp = C.circuits.init1(tmp.context, true);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.ismember(tmp.context, true);"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.ismember(tmp.context, false);"
        "  expect(tmp.result).toEqual(false);"
        "  tmp = C.circuits.update(tmp.context, true, 7n);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.get(tmp.context, true);"
        "  expect(tmp.result).toEqual(7n);"
        "  tmp = C.circuits.update(tmp.context, true, 4n);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.get(tmp.context, true);"
        "  expect(tmp.result).toEqual(11n);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.field0.lookup(true)).toEqual(0n);"
        "  expect(() => L.field0.lookup(false)).toThrow(runtime.CompactError);"
        "  expect(L.field1.size()).toEqual(1n);"
        "  expect(L.field1.member(true)).toEqual(true);"
        "  expect(L.field1.member(false)).toEqual(false);"
        "  expect(L.field1.lookup(true).read()).toEqual(11n);"
        "  expect(() => L.field1.lookup(false)).toThrow(runtime.CompactError);"
        "  expect(() => L.field1.lookup(false)).toThrow(`Map value undefined for false`);"
        "  expect(() => L.field1.lookup(false).read()).toThrow(runtime.CompactError);"
        "  expect(() => L.field1.lookup(false).read()).toThrow(`Map value undefined for false`);"
        "  });"
        ))
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "  init0(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, []>;"
        "  ismember(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, boolean>;"
        "  init1(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, []>;"
        "  update(context: __compactRuntime.CircuitContext<PS>, b_0: boolean, n_0: bigint): __compactRuntime.CircuitResults<PS, []>;"
        "  get(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type PureCircuits = {"
        "  identity(q_0: bigint): bigint;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  identity(context: __compactRuntime.CircuitContext<PS>, q_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "  init0(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, []>;"
        "  ismember(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, boolean>;"
        "  init1(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, []>;"
        "  update(context: __compactRuntime.CircuitContext<PS>, b_0: boolean, n_0: bigint): __compactRuntime.CircuitResults<PS, []>;"
        "  get(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type Ledger = {"
        "  field0: {"
        "    isEmpty(): boolean;"
        "    size(): bigint;"
        "    member(key_0: boolean): boolean;"
        "    lookup(key_0: boolean): bigint;"
        "    [Symbol.iterator](): Iterator<[boolean, bigint]>"
        "  };"
        "  field1: {"
        "    isEmpty(): boolean;"
        "    size(): bigint;"
        "    member(key_0: boolean): boolean;"
        "    lookup(key_0: boolean): { read(): bigint }"
        "  };"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean, n: Field): [] {"
      "  field1.insert(b, default<Map<Uint<16>, Field>>);"
      "  field1.lookup(b).insert(n, default<Field>);"
      "}"
      "export circuit put(b: Boolean, n: Uint<16>, q: Field): [] {"
      "  field1.lookup(b).lookup(n).write(q);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(b).lookup(n);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 19" "expected ~:r argument of ~s to have type ~a but received ~a" (1 insert "Uint<16>" "Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger field1: Map<Boolean, Map<Uint<16>, List<Field>>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, List<Field>>>);"
      "  field1.lookup(b).insert(disclose(n), default<List<Field>>);"
      "}"
      ""
      "export circuit reset(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(b).lookup(n).resetToDefault();"
      "}"
      ""
      "export circuit put(b: Boolean, n: Uint<16>, q: Field): [] {"
      "  field1.lookup(b).lookup(n).pushFront(disclose(q));"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(b).lookup(n).head().value;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.init(Ctxt, true, 7n);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.reset(tmp.context, true, 7n);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.put(tmp.context, true, 7n, 999999999n);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.get(tmp.context, true, 7n);"
        "  expect(tmp.result).toEqual(999999999n);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.field1.size()).toEqual(1n);"
        "  expect(L.field1.member(true)).toEqual(true);"
        "  expect(L.field1.member(false)).toEqual(false);"
        "  expect(L.field1.lookup(true).lookup(7n).head()).toEqual({ is_some: true, value: 999999999n });"
        "  expect(() => L.field1.lookup(false)).toThrow(runtime.CompactError);"
        "  expect(() => L.field1.lookup(false)).toThrow(`Map value undefined for false`);"
        "  expect(() => L.field1.lookup(false).lookup(7n)).toThrow(runtime.CompactError);"
        "  expect(() => L.field1.lookup(false).lookup(7n)).toThrow(`Map value undefined for false`);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum E { a, b, c }"
      "struct S { x: Boolean, y: Bytes<10>, z: Vector<2, E> }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, List<S>>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(b, default<Map<Uint<16>, List<Field>>>);"
      "  field1.lookup(b).insert(n, default<List<S>>);"
      "}"
      ""
      "export circuit reset(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(b).lookup(n).resetToDefault();"
      "}"
      ""
      "export circuit put(b: Boolean, n: Uint<16>, q: S): [] {"
      "  field1.lookup(b).lookup(n).pushFront(q);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): S {"
      "  return field1.lookup(b).lookup(n).head().value;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 9" "expected ~:r argument of ~s to have type ~a but received ~a" (2 insert "Map<Uint<16>, List<struct S<x: Boolean, y: Bytes<10>, z: Vector<2, Enum<E, a, b, c>>>>>" "Map<Uint<16>, List<Field>>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum E { a, b, c }"
      "struct S { x: Boolean, y: Bytes<10>, z: Vector<2, E> }"
      ""
      "ledger field1: Map<Boolean, Map<Uint<16>, List<S>>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, List<S>>>);"
      "  field1.lookup(disclose(b)).insert(disclose(n), default<List<Field>>);"
      "}"
      ""
      "export circuit reset(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(disclose(b)).lookup(disclose(n)).resetToDefault();"
      "}"
      ""
      "export circuit put(b: Boolean, n: Uint<16>, q: S): [] {"
      "  field1.lookup(disclose(b)).lookup(disclose(n)).pushFront(q);"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): S {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n)).head().value;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 29" "expected ~:r argument of ~s to have type ~a but received ~a" (2 insert "List<struct S<x: Boolean, y: Bytes<10>, z: Vector<2, Enum<E, a, b, c>>>>" "List<Field>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "enum E { a, b, c }"
      "struct S { x: Boolean, y: Bytes<10>, z: Vector<2, E> }"
      ""
      "export ledger field1: Map<Boolean, Map<Uint<16>, List<S>>>;"
      ""
      "export circuit init(b: Boolean, n: Uint<16>): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, List<S>>>);"
      "  field1.lookup(disclose(b)).insert(disclose(n), default<List<S>>);"
      "}"
      ""
      "export circuit reset(b: Boolean, n: Uint<16>): [] {"
      "  field1.lookup(disclose(b)).lookup(disclose(n)).resetToDefault();"
      "}"
      ""
      "export circuit put(b: Boolean, n: Uint<16>, q: S): [] {"
      "  field1.lookup(disclose(b)).lookup(disclose(n)).pushFront(disclose(q));"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): S {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n)).head().value;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.init(Ctxt, true, 7n);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.reset(tmp.context, true, 7n);"
        "  expect(tmp.result).toEqual([]);"
        "  const val = { x: true, y: new Uint8Array(10), z: [0, 1] };"
        "  tmp = C.circuits.put(tmp.context, true, 7n, val);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.get(tmp.context, true, 7n);"
        "  expect(tmp.result).toEqual(val);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.field1.size()).toEqual(1n);"
        "  expect(L.field1.member(true)).toEqual(true);"
        "  expect(L.field1.member(false)).toEqual(false);"
        "  expect(L.field1.lookup(true).lookup(7n).head()).toEqual({ is_some: true, value: val });"
        "  expect(() => L.field1.lookup(false)).toThrow(runtime.CompactError);"
        "  expect(() => L.field1.lookup(false)).toThrow(`Map value undefined for false`);"
        "  expect(() => L.field1.lookup(false).lookup(7n)).toThrow(runtime.CompactError);"
        "  expect(() => L.field1.lookup(false).lookup(7n)).toThrow(`Map value undefined for false`);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger field1: Map<Boolean, Map<Uint<16>, Field>>;"
      ""
      "export circuit init(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Map<Uint<16>, Field>>);"
      "}"
      ""
      "export circuit put(b: Boolean, n: Uint<16>, q: Field): [] {"
      "  field1.lookup(b).insert(disclose(n), disclose(q));"
      "}"
      ""
      "export circuit get(b: Boolean, n: Uint<16>): Field {"
      "  return field1.lookup(disclose(b)).lookup(disclose(n));"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.init(Ctxt, true);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.put(tmp.context, true, 7n, 999999999n);"
        "  expect(tmp.result).toEqual([]);"
        "  tmp = C.circuits.get(tmp.context, true, 7n);"
        "  expect(tmp.result).toEqual(999999999n);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.field1.size()).toEqual(1n);"
        "  expect(L.field1.member(true)).toEqual(true);"
        "  expect(L.field1.member(false)).toEqual(false);"
        "  expect(L.field1.lookup(true).lookup(7n)).toEqual(999999999n);"
        "  expect(() => L.field1.lookup(false)).toThrow(runtime.CompactError);"
        "  expect(() => L.field1.lookup(false)).toThrow(`Map value undefined for false`);"
        "  expect(() => L.field1.lookup(false).lookup(7n)).toThrow(runtime.CompactError);"
        "  expect(() => L.field1.lookup(false).lookup(7n)).toThrow(`Map value undefined for false`);"
        "  });"

        "test('check 2', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.init(Ctxt, true);"
        "  tmp = C.circuits.put(tmp.context, true, 7n, 999999999n);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  var sum: bigint = 3n;"
        "  for(const elem of L.field1.lookup(true)) { const [key, value] = elem; sum = sum + value; }"
        "  expect(sum).toEqual(1000000002n);"
        "  });"
        ))
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "  init(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, []>;"
        "  put(context: __compactRuntime.CircuitContext<PS>,"
        "      b_0: boolean,"
        "      n_0: bigint,"
        "      q_0: bigint): __compactRuntime.CircuitResults<PS, []>;"
        "  get(context: __compactRuntime.CircuitContext<PS>, b_0: boolean, n_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type PureCircuits = {"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  init(context: __compactRuntime.CircuitContext<PS>, b_0: boolean): __compactRuntime.CircuitResults<PS, []>;"
        "  put(context: __compactRuntime.CircuitContext<PS>,"
        "      b_0: boolean,"
        "      n_0: bigint,"
        "      q_0: bigint): __compactRuntime.CircuitResults<PS, []>;"
        "  get(context: __compactRuntime.CircuitContext<PS>, b_0: boolean, n_0: bigint): __compactRuntime.CircuitResults<PS, bigint>;"
        "}"
        ""
        "export type Ledger = {"
        "  field1: {"
        "    isEmpty(): boolean;"
        "    size(): bigint;"
        "    member(key_0: boolean): boolean;"
        "    lookup(key_0: boolean): {"
        "      isEmpty(): boolean;"
        "      size(): bigint;"
        "      member(key_1: bigint): boolean;"
        "      lookup(key_1: bigint): bigint;"
        "      [Symbol.iterator](): Iterator<[bigint, bigint]>"
        "    }"
        "  };"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Map<Boolean, Counter>;"
      ""
      "// nested ADT fields must be initialized to null before first use"
      "export circuit init_nested_counter(b: Boolean): [] {"
      "  field1.insert(disclose(b), default<Counter>);"
      "}"
      ""
      "// ADT values are not first-class objects, so when accessing a nested"
      "// ADT, the entire indirection chain must be used"
      "export circuit incr_nested_counter(b: Boolean, k: Uint<16>): [] {"
      "  field1.lookup(b).increment(disclose(k));"
      "}"
      ""
      "// when the last lookup is a read of a regular type one can include the read explicitly:"
      "export circuit read_nested_counter1(b: Boolean): Uint<64> {"
      "  return field1.lookup(b).read();"
      "}"
      ""
      "// ... or leave it off, in which case the read is implicit:"
      "export circuit read_nested_counter2(b: Boolean): Uint<64> {"
      "  return field1.lookup(b);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.init_nested_counter(Ctxt, true);"
        "  tmp = C.circuits.incr_nested_counter(tmp.context, true, 7n);"
        "  tmp = C.circuits.read_nested_counter1(tmp.context, true);"
        "  expect(tmp.result).toEqual(7n);"
        "  tmp = C.circuits.incr_nested_counter(tmp.context, true, 10n);"
        "  tmp = C.circuits.read_nested_counter2(tmp.context, true);"
        "  expect(tmp.result).toEqual(17n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field2: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit init_nested_map(n: Field): [] {"
      "  field2.insert(disclose(n), default<Map<Field, Field>>);"
      "}"
      ""
      "export circuit insert_nested_map(n1: Field, n2: Field, n3: Field): [] {"
      "  field2.lookup(n1).insert(disclose(n2), disclose(n3));"
      "}"
      ""
      "export circuit lookup_nested_map(n1: Field, n2: Field): Field {"
      "  return field2.lookup(disclose(n1)).lookup(disclose(n2));"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.init_nested_map(Ctxt, 3n);"
        "  tmp = C.circuits.insert_nested_map(tmp.context, 3n, 7n, 11n);"
        "  tmp = C.circuits.lookup_nested_map(tmp.context, 3n, 7n);"
        "  expect(tmp.result).toEqual(11n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: Map<Boolean, Map<Field, Counter>>;"
      ""
      "export circuit init_nested_map(b: Boolean): [] {"
      "  fld.insert(disclose(b), default<Map<Field, Counter>>);"
      "}"
      ""
      "export circuit init_nested_counter(b: Boolean, n: Field): [] {"
      "  fld.lookup(b).insert(disclose(n), default<Counter>);"
      "}"
      ""
      "export circuit increment_nested_counter(b: Boolean, n: Field, k: Uint<16>): [] {"
      "  fld.lookup(b).lookup(n).increment(disclose(k));"
      "}"
      ""
      "export circuit read_nested_counter1(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n).read();"
      "}"
      ""
      "export circuit read_nested_counter2(b: Boolean, n: Field): Uint<64> {"
      "  return fld.lookup(b).lookup(n);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.init_nested_map(Ctxt, false);"
        "  tmp = C.circuits.init_nested_counter(tmp.context, false, 7n);"
        "  tmp = C.circuits.read_nested_counter1(tmp.context, false, 7n);"
        "  expect(tmp.result).toEqual(0n);"
        "  tmp = C.circuits.increment_nested_counter(tmp.context, false, 7n, 11n);"
        "  tmp = C.circuits.read_nested_counter1(tmp.context, false, 7n);"
        "  expect(tmp.result).toEqual(11n);"
        "  tmp = C.circuits.increment_nested_counter(tmp.context, false, 7n, 10n);"
        "  tmp = C.circuits.read_nested_counter2(tmp.context, false, 7n);"
        "  expect(tmp.result).toEqual(21n);"
        "  });"
        ))
    )
  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger list: List<Uint<64>>;"
      ""
      "export circuit head(): Maybe<Uint <64>> {"
      "  return list.head();"
      "}"
      ""
      "export circuit isEmpty(): Boolean {"
      "  return list.isEmpty();"
      "}"
      ""
      "export circuit length(): Uint<64> {"
      "  return list.length();"
      "}"
      ""
      "export circuit popFront(): [] {"
      "  list.popFront();"
      "}"
      ""
      "export circuit pushFront(b: Uint <64>): [] {"
      "  list.pushFront(disclose(b));"
      "}"
      )
    (stage-javascript
      '(
        "test('check list', () => {"
        "  let [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.isEmpty(Ctxt);"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.pushFront(tmp.context, 5n);"
        "  tmp = C.circuits.isEmpty(tmp.context);"
        "  expect(tmp.result).toEqual(false);"
        "  tmp = C.circuits.head(tmp.context);"
        "  expect(tmp.result).toEqual({is_some: true, value: 5n});"
        "  tmp = C.circuits.length(tmp.context);"
        "  expect(tmp.result).toEqual(1n);"
        "  tmp = C.circuits.popFront(tmp.context);"
        "  tmp = C.circuits.isEmpty(tmp.context);"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.pushFront(tmp.context, 5n);"
        "  tmp = C.circuits.pushFront(tmp.context, 7n);"
        "  tmp = C.circuits.pushFront(tmp.context, 11n);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.list.isEmpty()).toEqual(false);"
        "  expect(L.list.length()).toEqual(3n);"
        "  expect(L.list.head().is_some).toEqual(true);"
        "  expect(L.list.head().value).toEqual(11n);"
        "  var sum: bigint = 3n;"
        "  for(const n of L.list) { sum = sum + n; }"
        "  expect(sum).toEqual(26n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger mt: MerkleTree<2, Uint<64>>;"
      ""
      "export circuit insert(item: Uint<64>): [] {"
      "  mt.insert(disclose(item));"
      "}"
      ""
      "export circuit insertIndex(item: Uint<64>, index: Uint<64>): [] {"
      "  mt.insertIndex(disclose(item), disclose(index));"
      "}"
      ""
      "export circuit isFull(): Boolean {"
      "  return mt.isFull();"
      "}"
      )
    (stage-javascript
      '(
        "test('check hmt', () => {"
        "  let [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.insert(Ctxt, 5n);"
        "  tmp = C.circuits.isFull(tmp.context);"
        "  expect(tmp.result).toEqual(false);"
        "  tmp = C.circuits.insertIndex(tmp.context, 6n, 1n);"
        "  tmp = C.circuits.insertIndex(tmp.context, 7n, 2n);"
        "  tmp = C.circuits.insert(tmp.context, 8n);"
        "  tmp = C.circuits.isFull(tmp.context);"
        "  expect(tmp.result).toEqual(true);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.mt.isFull()).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger cell: Uint<64>;"
      ""
      "export circuit read(): Uint <64> {"
      "  return cell.read();"
      "}"
      ""
      "export circuit write(item: Uint<64>): [] {"
      "  cell.write(disclose(item));"
      "}"
      )
    (stage-javascript
      '(
        "test('check cell', () => {"
        "  let [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.write(Ctxt, 5n);"
        "  tmp = C.circuits.read(tmp.context);"
        "  expect(tmp.result).toEqual(5n);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.cell).toEqual(5n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger counter: Counter;"
      ""
      "export circuit increment(amount: Uint<16>): [] {"
      "  counter.increment(disclose(amount));"
      "}"
      ""
      "export circuit decrement(amount: Uint<16>): [] {"
      "  counter.decrement(disclose(amount));"
      "}"
      ""
      "export circuit lessThan(amount: Uint<16>): Boolean {"
      "  return counter.lessThan(disclose(amount));"
      "}"
      ""
      "export circuit read(): Uint<64> {"
      "  return counter.read();"
      "}"
      )
    (stage-javascript
      '(
        "test('check counter', () => {"
        "  let [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.increment(Ctxt, 5n);"
        "  tmp = C.circuits.read(tmp.context);"
        "  expect(tmp.result).toEqual(5n);"
        "  tmp = C.circuits.decrement(tmp.context, 1n);"
        "  tmp = C.circuits.read(tmp.context);"
        "  expect(tmp.result).toEqual(4n);"
        "  tmp = C.circuits.lessThan(tmp.context, 10n);"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.lessThan(tmp.context, 1n);"
        "  expect(tmp.result).toEqual(false);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.counter).toEqual(4n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger mt: HistoricMerkleTree<2, Uint<64>>;"
      ""
      "export circuit insert(item: Uint<64>): [] {"
      "  mt.insert(disclose(item));"
      "}"
      ""
      "export circuit insertIndex(item: Uint<64>, index: Uint<64>): [] {"
      "  mt.insertIndex(disclose(item), disclose(index));"
      "}"
      ""
      "export circuit isFull(): Boolean {"
      "  return mt.isFull();"
      "}"
      )
    (stage-javascript
      '(
        "test('check hmt', () => {"
        "  let [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.insert(Ctxt, 5n);"
        "  tmp = C.circuits.isFull(tmp.context);"
        "  expect(tmp.result).toEqual(false);"
        "  tmp = C.circuits.insertIndex(tmp.context, 6n, 1n);"
        "  tmp = C.circuits.insertIndex(tmp.context, 7n, 2n);"
        "  tmp = C.circuits.insert(tmp.context, 8n);"
        "  tmp = C.circuits.isFull(tmp.context);"
        "  expect(tmp.result).toEqual(true);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.mt.isFull()).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger set: Set<Uint<64>>;"
      ""
      "export circuit insert(item: Uint<64>): [] {"
      "  set.insert(disclose(item));"
      "}"
      ""
      "export circuit remove(item: Uint<64>): [] {"
      "  set.remove(disclose(item));"
      "}"
      ""
      "export circuit member(item: Uint<64>): Boolean {"
      "  return set.member(disclose(item));"
      "}"
      ""
      "export circuit isEmpty(): Boolean {"
      "  return set.isEmpty();"
      "}"
      ""
      "export circuit size(): Uint<64> {"
      "  return set.size();"
      "}"
      )
    (stage-javascript
      '(
        "test('check set', () => {"
        "  let [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.isEmpty(Ctxt);"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.insert(tmp.context, 6n);"
        "  tmp = C.circuits.isEmpty(tmp.context);"
        "  expect(tmp.result).toEqual(false);"
        "  tmp = C.circuits.size(tmp.context);"
        "  expect(tmp.result).toEqual(1n);"
        "  tmp = C.circuits.member(tmp.context, 6n);"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.remove(tmp.context, 6n);"
        "  tmp = C.circuits.member(tmp.context, 6n);"
        "  expect(tmp.result).toEqual(false);"
        "  tmp = C.circuits.insert(tmp.context, 6n);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.set.isEmpty()).toEqual(false);"
        "  expect(L.set.size()).toEqual(1n);"
        "  expect(L.set.member(6n)).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger fld: Map<Uint<64>, Boolean>;"
      ""
      "export circuit insert(key: Uint<64>, value: Boolean): [] {"
      "  fld.insert(disclose(key), disclose(value));"
      "}"
      ""
      "export circuit remove(key: Uint<64>): [] {"
      "  fld.remove(disclose(key));"
      "}"
      ""
      "export circuit member(key: Uint<64>): Boolean {"
      "  return fld.member(disclose(key));"
      "}"
      ""
      "export circuit lookup(key: Uint<64>): Boolean {"
      "  return fld.lookup(disclose(key));"
      "}"
      ""
      "export circuit isEmpty(): Boolean {"
      "  return fld.isEmpty();"
      "}"
      ""
      "export circuit size(): Uint<64> {"
      "  return fld.size();"
      "}"
      )
    (stage-javascript
      '(
        "test('check map', () => {"
        "  let [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.isEmpty(Ctxt);"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.insert(tmp.context, 6n, true);"
        "  tmp = C.circuits.isEmpty(tmp.context);"
        "  expect(tmp.result).toEqual(false);"
        "  tmp = C.circuits.size(tmp.context);"
        "  expect(tmp.result).toEqual(1n);"
        "  tmp = C.circuits.member(tmp.context, 6n);"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.lookup(tmp.context, 6n);"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.remove(tmp.context, 6n);"
        "  tmp = C.circuits.member(tmp.context, 6n);"
        "  expect(tmp.result).toEqual(false);"
        "  tmp = C.circuits.insert(tmp.context, 6n, true);"
        "  let L = contractCode.ledger(tmp.context.currentQueryContext.state);"
        "  expect(L.fld.isEmpty()).toEqual(false);"
        "  expect(L.fld.size()).toEqual(1n);"
        "  expect(L.fld.member(6n)).toEqual(true);"
        "  expect(L.fld.lookup(6n)).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: Map<Boolean, Map<Field, Counter>>;"
      ""
      "export circuit bogus(): [] {"
      "  fld.lookup(true);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 6" "incomplete chain of ledger indirects: final result must be a regular type, but received ADT type ~a" ("Map<Field, Counter>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger fld: Map<Boolean, Map<Field, Counter>>;"
      ""
      "export circuit bogus(v: Field): [] {"
      "  fld.lookup(true).lookup(v);"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.0 (tfield))
          (%descriptor.1 (tboolean))
          (%descriptor.2 (tunsigned 18446744073709551615))
          (%descriptor.3 (tbytes 32))
          (%descriptor.4 (tstruct ContractAddress
                           (bytes (tbytes 32))))
          (%descriptor.5 (tunsigned 255))
          (%descriptor.6 (tunsigned
                           340282366920938463463374607431768211455)))
        (kernel-declaration (%kernel.7 () (Kernel)))
        (public-ledger-declaration
          ((%fld.8 (0) (Map (tboolean) (Map (tfield) (Counter)))))
          (constructor () (tuple)))
        (circuit %bogus.9 ([%v.10 (tfield)])
             (ttuple)
          (seq
            (public-ledger %fld.8 (0 ((tboolean) #t) ((tfield) %v.10)) read)
            (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger field1: Set<Counter>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 20" "expected ~a but received ~a for generic parameter ~s declared at ~a" ("non-ADT type" "ledger ADT type" value_type "<standard library>")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "circuit foo(): Field {"
      "  return default<Set<Field>>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Set<Field>" "Field" "circuit foo")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "circuit foo(): Field {"
      "  return default<MerkleTree<3, Field>>;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("MerkleTree<3, Field>" "Field" "circuit foo")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export ledger x: Opaque<'spam'>;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 18" "opaque type ~a is not supported" ("spam")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(q: Opaque<'string'>): Boolean {"
      "  const x = default<Opaque<'string'>>;"
      "  return x == q;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let tmp;"
        "  tmp = C.circuits.foo(Ctxt, '');"
        "  expect(tmp.result).toEqual(true);"
        "  tmp = C.circuits.foo(Ctxt, 'hello');"
        "  expect(tmp.result).toEqual(false);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(q: Opaque<'spam'>): [] {"
      "  const x = default<Opaque<'spam'>>;"
      "  assert(x == q, 'oops');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 23" "opaque type ~a is not supported" ("spam")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(): [] {"
      "  const x = default<Opaque<'spam'>>;"
      "  assert(x == default<Opaque<'spam'>>, 'oops');"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 21" "opaque type ~a is not supported" ("spam")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export { Maybe, MerkleTreeDigest }"
      "export struct key_type {}"
      "export struct value_type {}"
      ""
      "export ledger fcell: value_type;"
      "export ledger fcounter: Counter;"
      "export ledger fset: Set<value_type>;"
      "export ledger fmap: Map<key_type, value_type>;"
      "export ledger flist: List<value_type>;"
      "export ledger fmerkeltree: MerkleTree<10, value_type>;"
      "export ledger fhistoricmerkletree: HistoricMerkleTree<10, value_type>;"
      )
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type key_type = {  };"
        ""
        "export type value_type = {  };"
        ""
        "export type Maybe<T> = { is_some: boolean; value: T };"
        ""
        "export type MerkleTreeDigest = { field: bigint };"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "}"
        ""
        "export type PureCircuits = {"
        "}"
        ""
        "export type Circuits<PS> = {"
        "}"
        ""
        "export type Ledger = {"
        "  readonly fcell: value_type;"
        "  readonly fcounter: bigint;"
        "  fset: {"
        "    isEmpty(): boolean;"
        "    size(): bigint;"
        "    member(elem_0: value_type): boolean;"
        "    [Symbol.iterator](): Iterator<value_type>"
        "  };"
        "  fmap: {"
        "    isEmpty(): boolean;"
        "    size(): bigint;"
        "    member(key_0: key_type): boolean;"
        "    lookup(key_0: key_type): value_type;"
        "    [Symbol.iterator](): Iterator<[key_type, value_type]>"
        "  };"
        "  flist: {"
        "    isEmpty(): boolean;"
        "    length(): bigint;"
        "    head(): Maybe<value_type>;"
        "    [Symbol.iterator](): Iterator<value_type>"
        "  };"
        "  fmerkeltree: {"
        "    isFull(): boolean;"
        "    checkRoot(rt_0: MerkleTreeDigest): boolean;"
        "    root(): __compactRuntime.MerkleTreeDigest;"
        "    firstFree(): bigint;"
        "    pathForLeaf(index_0: bigint, leaf_0: value_type): __compactRuntime.MerkleTreePath<value_type>;"
        "    findPathForLeaf(leaf_0: value_type): __compactRuntime.MerkleTreePath<value_type> | undefined"
        "  };"
        "  fhistoricmerkletree: {"
        "    isFull(): boolean;"
        "    checkRoot(rt_0: MerkleTreeDigest): boolean;"
        "    root(): __compactRuntime.MerkleTreeDigest;"
        "    firstFree(): bigint;"
        "    pathForLeaf(index_0: bigint, leaf_0: value_type): __compactRuntime.MerkleTreePath<value_type>;"
        "    findPathForLeaf(leaf_0: value_type): __compactRuntime.MerkleTreePath<value_type> | undefined;"
        "    history(): Iterator<__compactRuntime.MerkleTreeDigest>"
        "  };"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    )

  (test
    '()
    (returns
      (program
        (type-descriptors
          (%descriptor.1 (tunsigned 255))
          (%descriptor.2 (tunsigned 18446744073709551615))
          (%descriptor.0 (tunsigned
                           340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger foo: Set<Field>;"
      "constructor() {"
      "  const x = fold((a, n): Field => a + n, 0, [1, 2, 3, 4, 5]);"
      "}"
      "circuit bar(a: Field, n: Field, b: Boolean): Field {"
      "  return a + (b ? n + 1 : n - 1);"
      "}"
      "export circuit folding(nv: Vector<7, Field>, bv: Vector<7, Boolean>): Field {"
      "  return fold(bar, 17, nv, bv);"
      "}")
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const state = new contractCode.Contract({}).initialState(runtime.createConstructorContext(undefined, '0'.repeat(64))).currentContractState;"
        "  const viaSerialization = runtime.ContractState.deserialize(state.serialize(runtime.NetworkId.Undeployed), runtime.NetworkId.Undeployed);"
        "  expect(state.serialize(runtime.NetworkId.Undeployed)).toEqual(viaSerialization.serialize(runtime.NetworkId.Undeployed));"
        "})"
        "test('check 2', () => {"
        "  expect(contractCode.pureCircuits.folding([3n,5n,7n,11n,13n,17n,19n], [true, false, false, true, false, true, true])).toEqual(93n);"
        "});"
       ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger foo: Set<Field>;"
      "constructor() {"
      "  for (const i of 0..256) {"
      "    foo.insert(i);"
      "  }"
      "}")
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const state = new contractCode.Contract({}).initialState(runtime.createConstructorContext(undefined, '0'.repeat(64))).currentContractState;"
        "  const viaSerialization = runtime.ContractState.deserialize(state.serialize(runtime.NetworkId.Undeployed), runtime.NetworkId.Undeployed);"
        "  expect(state.serialize(runtime.NetworkId.Undeployed)).toEqual(viaSerialization.serialize(runtime.NetworkId.Undeployed));"
        "})"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger foo: Set<Field>;"
      "constructor() {"
      "  for (const i of 0..511) {"
      "    foo.insert(i);"
      "  }"
      "  for (const i of 512..1024) {"
      "    foo.insert(i);"
      "  }"
      "}")
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const state = new contractCode.Contract({}).initialState(runtime.createConstructorContext(undefined, '0'.repeat(64))).currentContractState;"
        "  const viaSerialization = runtime.ContractState.deserialize(state.serialize(runtime.NetworkId.Undeployed), runtime.NetworkId.Undeployed);"
        "  expect(state.serialize(runtime.NetworkId.Undeployed)).toEqual(viaSerialization.serialize(runtime.NetworkId.Undeployed));"
        "})"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(x: Opaque<'Uint8Array'>): Vector<2, Opaque<'Uint8Array'>> {"
      "  return [x, x];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const tmp = new Uint8Array(0);"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, tmp).result).toEqual([tmp, tmp]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M1 {"
      "  export struct Frob { x: Field, y: Boolean }"
      "  export circuit foo(x: Field): Frob {"
      "    return Frob{ x: x + 1, y: x == 0 };"
      "  }"
      "}"
      "import M1 prefix M1_;"
      "export struct Frob { a: Uint<32> }"
      "export circuit foo(x: Frob): Frob {"
      "  return Frob{ a: x.a * 2 as Uint<32> };"
      "}"
      "export {M1_Frob, M1_foo}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  var tmp = C.circuits.M1_foo(Ctxt, 7n);"
        "  expect(tmp.result).toEqual({x: 8n, y: false});"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  ledger fld: Set<Field>;"
      "  constructor() { fld.insert(75); }"
      "}"
      "import M;"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 3" "misplaced constructor: should appear only at the top level of a program" ()))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { q = n; }"
      "}"
      "import M prefix M$;"
      "constructor() { M$init(37); }"
      "export circuit foo(): Field { return M$q; }"
      "export { M$q }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  var t1 = C.circuits.foo(context);"
        "  context = t1.context;"
        "  expect(t1.result).toEqual(37n);"
        "  var L = contractCode.ledger(context.currentQueryContext.state);"
        "  expect(L.M$q).toEqual(37n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M {"
      "  export sealed ledger q: Field;"
      "  export circuit init(n: Field): [] { q = n; }"
      "}"
      "import M prefix M$;"
      "constructor() { M$init(37); }"
      "export circuit foo(): Field { M$init(73); return M$q; }"
      "export { M$q }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 1" "exported circuits cannot modify sealed ledger fields but ~a calls (directly or indirectly) ~a, which ~a at ~a" (foo init "modifies sealed field q" "line 4 char 39")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export sealed ledger p: Field;"
      "export sealed ledger q: Field;"
      "module M1 {"
      "  import M2;"
      "  export circuit f1(n: Field): [] { f2(n); p = n + 1; }"
      "  export circuit f3(n: Field): [] { f4(n); }"
      "}"
      "module M2 {"
      "  export circuit f2(n: Field): [] { f3(n); }"
      "  export circuit f4(n: Field): [] { q = n + 2; }"
      "}"
      "import M1;"
      "constructor() { f1(17); }"
      "export circuit foo(): Field { return p + q; }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  var t1 = C.circuits.foo(context);"
        "  context = t1.context;"
        "  expect(t1.result).toEqual(37n);"
        "  var L = contractCode.ledger(context.currentQueryContext.state);"
        "  expect(L.p).toEqual(18n);"
        "  expect(L.q).toEqual(19n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export sealed ledger p: Field;"
      "export ledger q: Field;"
      "module M1 {"
      "  import M2;"
      "  export circuit f1(n: Field): [] { f2(n); p = n + 1; }"
      "  export circuit f3(n: Field): [] { f4(n); }"
      "}"
      "module M2 {"
      "  export circuit f2(n: Field): [] { f3(n); }"
      "  export circuit f4(n: Field): [] { q = n + 2; }"
      "}"
      "import M1;"
      "constructor() { f1(17); }"
      "export circuit foo(): Field { f3(71); return p + q; }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  var L = contractCode.ledger(context.currentQueryContext.state);"
        "  expect(L.p).toEqual(18n);"
        "  expect(L.q).toEqual(19n);"
        "  var t1 = C.circuits.foo(context);"
        "  context = t1.context;"
        "  expect(t1.result).toEqual(91n);"
        "  var L = contractCode.ledger(context.currentQueryContext.state);"
        "  expect(L.p).toEqual(18n);"
        "  expect(L.q).toEqual(73n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export sealed ledger p: Field;"
      "export sealed ledger q: Field;"
      "module M1 {"
      "  import M2;"
      "  export circuit f1(n: Field): [] { f2(n); if (n == 0) p = n + 1; }"
      "  export circuit f3(n: Field): [] { f4(n); }"
      "}"
      "module M2 {"
      "  export circuit f2(n: Field): [] { f3(n); }"
      "  export circuit f4(n: Field): [] { if (n == 0) q = n + 2; }"
      "}"
      "circuit f5(n: Field): [] { p = 0; }"
      "import M1;"
      "constructor() { f1(17); q = q + 35; f5(87); }"
      "export circuit foo(): Field { f1(71); return p + q; }"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 16 char 1" "exported circuits cannot modify sealed ledger fields but ~a calls (directly or indirectly) ~a, which ~a at ~a" (foo f4 "modifies sealed field q" "line 11 char 49")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M1 {"
      "  module M2 {"
      "    ledger george: Counter;"
      "    export circuit foo2(): Field {"
      "      george += 1;"
      "      return george;"
      "    }"
      "  }"
      "  export struct Frob { x: Field, y: Boolean }"
      "  export circuit foo1(x: Field): Frob {"
      "    george.insert(disclose(x));"
      "    return Frob { x : george.size(), y : true };"
      "  }"
      "  export ledger george: Set<Field>;"
      "  import M2;"
      "  export {foo2};"
      "}"
      "export struct Frob { a: Uint<32> }"
      "constructor() { george.pushFront(Frob { a: 75 }); }"
      "ledger george: List<Frob>;"
      "import M1 prefix M1_;"
      "circuit foo(x: Frob): Uint<64> {"
      "  george.pushFront(disclose(x));"
      "  return george.length();"
      "}"
      "export {george, M1_george, M1_Frob, foo, M1_foo1, M1_foo2}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  var t1 = C.circuits.M1_foo2(context);"
        "  context = t1.context;"
        "  expect(t1.result).toEqual(1n);"
        "  var t2 = C.circuits.M1_foo2(context);"
        "  expect(t2.result).toEqual(2n);"
        "  context = t2.context;"
        "  var L = contractCode.ledger(context.currentQueryContext.state);"
        "  expect(L.M1_george.isEmpty()).toEqual(true);"
        "  expect(L.george.length()).toEqual(1n);"
        "  var t3 = C.circuits.M1_foo1(context, 13n);"
        "  context = t3.context;"
        "  expect(t3.result).toEqual({x: 1n, y: true});"
        "  var L = contractCode.ledger(context.currentQueryContext.state);"
        "  expect(L.M1_george.isEmpty()).toEqual(false);"
        "  expect(L.george.length()).toEqual(1n);"
        "  var t4 = C.circuits.foo(context, {a: 13n});"
        "  context = t4.context;"
        "  expect(t4.result).toEqual(2n);"
        "  var L = contractCode.ledger(context.currentQueryContext.state);"
        "  expect(L.M1_george.isEmpty()).toEqual(false);"
        "  expect(L.george.length()).toEqual(2n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger x: Uint<32>;"
      "constructor(n: Field) {"
      "  x = disclose(n )as Uint<32>;"
      "}"
       )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, 75n);"
        "  const L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.x).toEqual(75n);"
        "})"
        "test('check 2', () => {"
        "  expect(() => startContract(contractCode, {}, 0)).toThrow(runtime.CompactError);"
        "  expect(() => startContract(contractCode, {}, 0)).toThrow('Contract state constructor: expected 2 arguments (as invoked from Typescript), received 1');"
        "})"))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Field;"
      "export circuit foo(): Field {"
      "  return disclose(W());"
      "}"
      "module M {"
      "  witness W(): Field;"
      "  witness X(): Field;"
      "  export circuit bar(): Field {"
      "    return disclose(W() + X());"
      "  }"
      "}"
      "import M;"
      "export { bar };"
      )
    (stage-javascript
      '(
        "const witnesses = {"
        "                    W(private_state: any): [any, bigint] { return [private_state, 17n]; },"
        "                    X(private_state: any): [any, bigint] { return [private_state, 20n];}"
        "                  };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(17n);"
        "  expect(C.circuits.bar(Ctxt).result).toEqual(37n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness X(): Field;"
      "export circuit foo(): Field {"
      "  return disclose(X());"
      "}"
      "module M {"
      "  witness W(b: Boolean): Boolean;"
      "  witness X(): Field;"
      "  export circuit bar(b: Boolean): Field {"
      "    return disclose(X() + (W(b) ? 3 : 4));"
      "  }"
      "}"
      "import M;"
      "export { bar };"
      )
    (stage-javascript
      '(
        "const witnesses = {"
        "                   X(private_state: any): [any, bigint] { return [private_state, 17n]; },"
        "                   W(private_state: any, b: boolean): [any, boolean] { return [private_state, !b]; }"
        "                   };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(17n);"
        "  expect(C.circuits.bar(Ctxt, true).result).toEqual(21n);"
        "  expect(C.circuits.bar(Ctxt, false).result).toEqual(20n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Field;"
      "export circuit foo(): Field {"
      "  return W();"
      "}"
      "module M {"
      "  export witness W(b: Boolean): Boolean;"
      "  witness X(): Field;"
      "  export circuit bar(b: Boolean): Field {"
      "    return X() + (W(b) ? 3 : 4);"
      "  }"
      "}"
      "import M prefix M$;"
      "export { M$bar, M$W };"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 14 char 17" "cannot export ~s (~s) from the top level" (witness M$W)))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Field;"
      "export circuit foo(): Field {"
      "  return disclose(W());"
      "}"
      "module M {"
      "  export witness Y(b: Boolean): Boolean;"
      "  witness X(): Field;"
      "  export circuit bar(b: Boolean): Field {"
      "    return disclose(X() + (Y(b) ? 3 : 4));"
      "  }"
      "}"
      "import M prefix M$;"
      "export { M$bar };"
      )
    (stage-javascript
      '(
        "const witnesses = {"
        "                    W(private_state: any): [any, bigint] { return [private_state, 17n]; },"
        "                    X(private_state: any): [any, bigint] { return [private_state, 17n]; },"
        "                    Y(private_state: any, b: boolean): [any, boolean] { return [private_state, !b]; },"
        "                  };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(17n);"
        "  expect(C.circuits.M$bar(Ctxt, true).result).toEqual(21n);"
        "  expect(C.circuits.M$bar(Ctxt, false).result).toEqual(20n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness W(): Field;"
      "export circuit foo(): Field {"
      "  return disclose(W());"
      "}"
      "module M {"
      "  witness W(b: Boolean): Boolean;"
      "  witness X(): Field;"
      "  export circuit bar(b: Boolean): Field {"
      "    return disclose(X() + (W(b) ? 3 : 4));"
      "  }"
      "}"
      "import M;"
      "export { bar };"
      )
    (stage-javascript
      '(
        "const witnesses = {"
        "                   X(private_state: any): [any, bigint] { return [private_state, 17n]; },"
        "                   W(private_state: any, ...args: unknown[]): [any, any] { return [private_state, args.length == 0 ? 17n : !args[0]];},"
        "                  };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(17n);"
        "  expect(C.circuits.bar(Ctxt, true).result).toEqual(21n);"
        "  expect(C.circuits.bar(Ctxt, false).result).toEqual(20n);"
        "});"
        ))
    )

  ; FIXME uncomment for CC print-TS pass implementation
  #|
  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Bytes<32>): [] { return; }"
         "export circuit barr(): Bytes<32> { return pad(32, ''); }"
         )
       )
     (succeeds))
    ((create-file "UseC.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {"
         "  circuit foo(x: Bytes<32>): [];"
         "  pure circuit barr(): Bytes<32>;"
         "}"
         "ledger contract_c: C;"
         "constructor (c: C) { contract_c = disclose(c); }"
         "export circuit hello(): [] { return contract_c.foo(contract_c.read().barr()); }"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("UseC.compact line 8 char 69" "contract calls are not yet supported" ()))
     #|
     (stage-javascript
       '(
         "test('check 1', () => {"
         "  expect(3n).toEqual(17n);"
         "});"
         ))
     |#
     ))
  |#

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(): Field { return (0) + (1, 2) + (3, 4, 5) + (6, 7, 8, 9); }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(16n);"
        "});"
        ))
    )

  (test
    `(
      "import CompactStandardLibrary;"
      "ledger ctr : Counter;"
      "constructor(x: Uint<16>) {"
      "  ctr += disclose(x);"
      "}"
      "export circuit foo(): Field {"
      "  const t1 = ctr;"
      "  ctr += t1 + 1 as Uint<16>;"
      "  // make sure this actually redoes the read:"
      "  return ctr;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0, 7n);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(15n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(qcoin: QualifiedCoinInfo, coin: CoinInfo): [] {"
      "  createZswapInput(qcoin);"
      "  createZswapOutput(coin, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const qcoin = { nonce: new Uint8Array([1,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]), color: new Uint8Array([1,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]), value: 57n, mt_index: 3n };"
        "  const coin = { nonce: new Uint8Array([1,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]), color: new Uint8Array([1,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]), value: 73n };"
        "  const encodedOwnPublicKey = runtime.encodeCoinPublicKey('0'.repeat(64))"
        "  const expectedRecipient = { is_left: true, left: { bytes: encodedOwnPublicKey }, right: { bytes: new Uint8Array(32) } }"
        "  const circuitResult = C.circuits.foo(Ctxt, qcoin, coin)"
        "  expect(circuitResult.result).toEqual([]);"
        "  expect(circuitResult.context.currentZswapLocalState).toEqual({"
        "    coinPublicKey: { bytes: runtime.encodeCoinPublicKey('0'.repeat(64)) },"
        "    currentIndex: 1n,"
        "    outputs: [{ coinInfo: coin, recipient: expectedRecipient}],"
        "    inputs: [qcoin]"
        "  })"
        "});"
        ))
    )

  (test-group
    ((create-file "C.compact" '())
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {};"
         "ledger X: Field;"
         ))
     (stage-javascript
       '(
         "test('check 1', () => {"
         "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
         "  const lcl = contractCode.contractReferenceLocations;"
         "  expect(lcl['tag']).toEqual('publicLedgerArray');"
         "  expect(lcl['indices']).toEqual({});"
         "});"
         )))
    )

  (test-group
    ((create-file "C.compact" '())
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {};"
         "struct Struct1 {"
         "  a: Field;"
         "  b: C;"
         "}"
         "struct Struct2 {"
         "  c: Field;"
         "  d: Struct1;"
         "}"
         "ledger m1: Map<Field, C>;"
         "ledger m2: Map<C, Field>;"
         "ledger m3: Map<C, Map<C, Field>>;"
         "ledger s: Struct1;"
         "ledger r: Struct2;"
         "ledger t: C;"
         "ledger u: Field;"
         "ledger q: Vector<3, C>;"
         "ledger p: [C, Field];"
         ))
     (stage-javascript
       '(
         "test('check 1', () => {"
         "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
         "  const lcl = contractCode.contractReferenceLocations;"
         "  expect(lcl['tag']).toEqual('publicLedgerArray');"
         "  expect(lcl['indices']['0']['tag']).toEqual('map');"
         "  expect(lcl['indices']['1']['keyType']['tag']).toEqual('compactValue');"
         "  expect(lcl['indices']['1']['keyType']['descriptor']).toBeDefined();"
         "  expect(lcl['indices']['1']['keyType']['sparseType']).toEqual({tag: 'contractAddress'});"
         "  expect(lcl['indices']['2']['valueType']['keyType']['sparseType']).toEqual({tag: 'contractAddress'});"
         "  expect(lcl['indices']['4']['tag']).toEqual('cell');"
         "  expect(lcl['indices']['4']['valueType']['sparseType']).toEqual("
         "                               {"
         "                                tag: 'struct',"
         "                                elements: "
         "                                  {"
         "                                   d: {"
         "                                       tag: 'struct',"
         "                                       elements: "
         "                                         { b: { tag: 'contractAddress' } }"
         "                                      }"
         "                                  }"
         "                               });"
         "  expect(lcl['indices']['6']).toEqual(undefined);"
         "  expect(lcl['indices']['8']['valueType']['sparseType']).toEqual("
         "                               {"
         "                                tag: 'tuple',"
         "                                indices: { 0: { tag: 'contractAddress' } }"
         "                               });"
         "});"
         )))
    )

  (test-group
    ((create-file "C.compact" '())
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {};"
         "struct Struct1 {"
         "  a: Field;"
         "  b: C;"
         "}"
         "struct Struct2 {"
         "  c: Field;"
         "  d: Struct1;"
         "}"
         "ledger ls1: List<Field>;"
         "ledger ls2: List<C>;"
         "ledger ls3: List<Struct1>;"
         "ledger ls4: List<Struct2>;"
         "ledger ls5: List<Vector<3, Struct2>>;"
         "ledger ls6: List<Vector<0, Struct2>>;"
         "ledger s1: Set<Boolean>;"
         "ledger s2: Set<Struct2>;"
         "ledger mt1: MerkleTree<10, Uint<32>>;"
         "ledger mt2: MerkleTree<10, Struct2>;"
         "ledger hmt1: HistoricMerkleTree<10, Uint<32>>;"
         "ledger hmt2: HistoricMerkleTree<10, Vector<3, Struct2>>;"
         ))
     (stage-javascript
       '(
         "test('check 1', () => {"
         "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
         "  const lcl = contractCode.contractReferenceLocations;"
         "  expect(lcl['tag']).toEqual('publicLedgerArray');"
         "  expect(lcl['indices']['0']).toEqual(undefined);"
         "  expect(lcl['indices']['1']['tag']).toEqual('list');"
         "  expect(lcl['indices']['1']['valueType']['tag']).toEqual('compactValue');"
         "  expect(lcl['indices']['1']['valueType']['descriptor']).toBeDefined();"
         "  expect(lcl['indices']['1']['valueType']['sparseType']).toEqual({tag: 'contractAddress'});"
         "  expect(lcl['indices']['2']['valueType']['sparseType']).toEqual("
         "                                   {"
         "                                    tag: 'struct',"
         "                                    elements: "
         "                                      { b: { tag: 'contractAddress' } }"
         "                                   })"
         "  expect(lcl['indices']['3']['valueType']['sparseType']).toEqual("
         "                               {"
         "                                tag: 'struct',"
         "                                elements: "
         "                                  {"
         "                                   d: {"
         "                                       tag: 'struct',"
         "                                       elements: "
         "                                         { b: { tag: 'contractAddress' } }"
         "                                      }"
         "                                  }"
         "                               });"
         "  expect(lcl['indices']['4']['valueType']['sparseType']).toEqual("
         "                               {"
         "                                tag: 'vector',"
         "                                sparseType: {"
         "                                  tag: 'struct',"
         "                                  elements: "
         "                                    {"
         "                                     d: {"
         "                                         tag: 'struct',"
         "                                         elements: "
         "                                           { b: { tag: 'contractAddress' } }"
         "                                        }"
         "                                    }"
         "                                  }"
         "                               });"
         "  expect(lcl['indices']['5']).toEqual(undefined);"
         "  expect(lcl['indices']['6']).toEqual(undefined);"
         "  expect(lcl['indices']['7']['tag']).toEqual('set');"
         "  expect(lcl['indices']['7']['valueType']['sparseType']).toEqual("
         "                               {"
         "                                tag: 'struct',"
         "                                elements: "
         "                                  {"
         "                                   d: {"
         "                                       tag: 'struct',"
         "                                       elements: "
         "                                         { b: { tag: 'contractAddress' } }"
         "                                      }"
         "                                  }"
         "                               });"
         "  expect(lcl['indices']['8']).toEqual(undefined);"
         "  expect(lcl['indices']['9']).toEqual(undefined);"
         "  expect(lcl['indices']['10']).toEqual(undefined);"
         "  expect(lcl['indices']['11']).toEqual(undefined);"
         "});"
         )))
    )

  (test-group
    ((create-file "C.compact" '())
     (succeeds))
    ((create-file "testfile.compact"
       '(
         "import CompactStandardLibrary;"
         "contract C {};"
         "struct Struct1 {"
         "  a: Field;"
         "  b: C;"
         "}"
         "struct Struct2 {"
         "  c: Field;"
         "  d: Struct1;"
         "}"
         "ledger f1: Field;"
         "ledger f2: Field;"
         "ledger f3: Field;"
         "ledger f4: Field;"
         "ledger f5: Field;"
         "ledger f6: Field;"
         "ledger f7: Field;"
         "ledger f8: Field;"
         "ledger f9: Field;"
         "ledger f10: List<Struct2>;"
         "ledger f11: Field;"
         "ledger f12: Field;"
         "ledger f13: Field;"
         "ledger f14: Field;"
         "ledger f15: Field;"
         "ledger f16: Field;"
         "ledger f17: Field;"
         "ledger f18: Field;"
         "ledger f19: Field;"
         "ledger f20: Field;"
         "ledger f21: Field;"
         "ledger f22: Field;"
         "ledger f23: Field;"
         "ledger f24: Field;"
         "ledger f25: Field;"
         "ledger f26: Field;"
         "ledger f27: Field;"
         "ledger f28: Field;"
         "ledger f29: Field;"
         "ledger f30: Field;"
         ))
     (stage-javascript
       '(
         "test('check 1', () => {"
         "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
         "  const lcl = contractCode.contractReferenceLocations;"
         "  expect(lcl['tag']).toEqual('publicLedgerArray');"
         "  expect(lcl['indices']['0']['tag']).toEqual('publicLedgerArray');"
         "  expect(lcl['indices']['0']['indices']['9']['tag']).toEqual('list');"
         "  expect(lcl['indices']['0']['indices']['9']['valueType']['sparseType']).toEqual("
         "                               {"
         "                                tag: 'struct',"
         "                                elements: "
         "                                  {"
         "                                   d: {"
         "                                       tag: 'struct',"
         "                                       elements: "
         "                                         { b: { tag: 'contractAddress' } }"
         "                                      }"
         "                                  }"
         "                               });"
         "  expect(lcl['indices']['0']['indices']['8']).toEqual(undefined);"
         "  expect(lcl['indices']['1']).toEqual(undefined);"
         "  expect(lcl['indices']['2']).toEqual(undefined);"
         "});"
         )))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit foo(x: Uint<32>, y: Uint<64>): Uint<32> {"
      "  return x - y;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 12n, 10n).result).toEqual(2n);"
        "  expect(C.circuits.foo(context, 12n, 12n).result).toEqual(0n);"
        "  expect(() => C.circuits.foo(context, 12n, 14n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 12n, 14n)).toThrow('failed assert: result of subtraction would be negative');"
        "});"
        ))
    )

  (test
    '(
      "export struct S<T> {"
      "  x: T;"
      "}"
      "export circuit foo(s: S<S<Field>>): S<Field> {"
      "  return s.x;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, { x: { x: 29n } }).result).toEqual({ x: 29n });"
        "  expect(() => C.circuits.foo(context, { x: { y: 29n } })).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, { x: { y: 29n } })).toThrow('type error: foo argument 1 at testfile.compact line 4 char 1; expected value of type struct S<x: struct S<x: Field>> but received { x: { y: 29n } }');"
        "});"
        ))
    )

  (test
    '(
      "export struct Commitment<A> {"
      "  value: Field"
      "}"
      "export circuit foo(): Commitment<Field> {"
      "  return Commitment<Field>{ value: 10 };"
      "}"
      )
    (output-file "compiler/testdir/contract/index.d.ts"
      '(
        "import type * as __compactRuntime from '@midnight-ntwrk/compact-runtime';"
        ""
        "export type Commitment<A> = { value: bigint };"
        ""
        "export type Witnesses<PS> = {"
        "}"
        ""
        "export type ImpureCircuits<PS> = {"
        "}"
        ""
        "export type PureCircuits = {"
        "  foo(): Commitment<any>;"
        "}"
        ""
        "export type Circuits<PS> = {"
        "  foo(context: __compactRuntime.CircuitContext<PS>): __compactRuntime.CircuitResults<PS, Commitment<any>>;"
        "}"
        ""
        "export type Ledger = {"
        "}"
        ""
        "export type ContractReferenceLocations = any;"
        ""
        "export declare const contractReferenceLocations : ContractReferenceLocations;"
        ""
        "export declare class Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {"
        "  witnesses: W;"
        "  circuits: Circuits<PS>;"
        "  impureCircuits: ImpureCircuits<PS>;"
        "  constructor(witnesses: W);"
        "  initialState(context: __compactRuntime.ConstructorContext<PS>): __compactRuntime.ConstructorResult<PS>;"
        "}"
        ""
        "export declare function ledger(state: __compactRuntime.StateValue): Ledger;"
        "export declare const pureCircuits: PureCircuits;"))
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual({ value: 10n });"
        "});"
        ))
    )

 (test
    '(
      "circuit bar(x: Uint<7>): [] {"
      "  assert(!(x == 0), 'oops');"
      "}"
      "export circuit foo(x: Uint<3>): [] {"
      "  return x * (bar(x), x);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 3" "mismatch between actual return type ~a and declared return type ~a of ~a" ("Uint<0..50>" "[]" "circuit foo")))
    )

 (test
    '(
      "circuit bar(x: Uint<7>): [] {"
      "  assert(!(x == 0), 'oops');"
      "}"
      "export circuit foo(x: Uint<3>): [] {"
      "  const y = x * (bar(x), x);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 3n).result).toEqual([]);"
        "  expect(() => C.circuits.foo(context, 0n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 0n)).toThrow('failed assert: oops');"
        "});"
        ))
    )

  (test
    '(
      "struct S { x: Uint<32>, y: Boolean }"
      "export circuit make(a: Uint<32>, b: Boolean): S {"
      "  return S{a, b};"
      "}"
      "export circuit update_x(s: S, a: Uint<32>): S {"
      "  return S{...s, x: a};"
      "}"
      "export circuit update_y(s: S, b: Boolean): S {"
      "  return S{...s, y: b};"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  const s0 = C.circuits.make(context, 3n, true).result;"
        "  expect(s0).toEqual({x: 3n, y: true});"
        "  const s1 = C.circuits.update_x(context, s0, 5n).result;"
        "  expect(s1).toEqual({x: 5n, y: true});"
        "  const s2 = C.circuits.update_y(context, s1, false).result;"
        "  expect(s2).toEqual({x: 5n, y: false});"
        "});"
        ))
    )

  (test
    '(
      "struct S { x: Uint<32>, y: Boolean, z: Uint<64> }"
      "export circuit make0(a: Uint<32>, b: Boolean, c: Uint<64>): S {"
      "  return S{a, b, c};"
      "}"
      "export circuit make1(a: Uint<32>, b: Boolean, c: Uint<64>): S {"
      "  return S{ x: a, y: b, z: c };"
      "}"
      "export circuit make2(a: Uint<32>, b: Boolean, c: Uint<64>): S {"
      "  return S{ y: b, x: a, z: c };"
      "}"
      "export circuit make3(a: Uint<32>, b: Boolean, c: Uint<64>): S {"
      "  return S{ y: b, z: c, x: a };"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.make0(context, 3n, true, 7n).result).toEqual({x: 3n, y: true, z: 7n});"
        "  expect(C.circuits.make1(context, 11n, false, 13n).result).toEqual({x: 11n, y: false, z: 13n});"
        "  expect(C.circuits.make2(context, 11n, false, 13n).result).toEqual({x: 11n, y: false, z: 13n});"
        "  expect(C.circuits.make3(context, 11n, false, 13n).result).toEqual({x: 11n, y: false, z: 13n});"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x: Field) : Field {"
      "  return (() => assert(x != 0, 'oops'))(), x - 1;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 3n).result).toEqual(2n);"
        "  expect(() => C.circuits.foo(context, 0n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 0n)).toThrow('failed assert: oops');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(x: Field) : Field {"
      "  assert(x != 0, 'oops');"
      "  return x - 1;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 3n).result).toEqual(2n);"
        "  expect(() => C.circuits.foo(context, 0n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 0n)).toThrow('failed assert: oops');"
        "});"
        ))
    )

  (test
    '(
      "circuit bar(x: Field): Field {"
      "  assert(x != 2, 'oops');"
      "  return x;"
      "}"
      "export circuit foo(x: Field): Field {"
      "  return bar(x), bar(x - 1), bar(x - 2);"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.10 (tfield))
          (%descriptor.11 (tunsigned 255))
          (%descriptor.12 (tunsigned 18446744073709551615))
          (%descriptor.9 (tunsigned
                           340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %bar.13 ([%x.14 (tfield)])
             (tfield)
          (seq
            (assert (!= %x.9 (safe-cast (tfield) (tunsigned 2) 2)) "oops")
            %x.9))
        (circuit %foo.14 ([%x.15 (tfield)])
             (tfield)
          (seq
            (call %bar.13 %x.15)
            (call %bar.13 (- #f %x.15 (safe-cast (tfield) (tunsigned 1) 1)))
            (call %bar.13 (- #f %x.15 (safe-cast (tfield) (tunsigned 2) 2)))))))
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(context, 4n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 4n)).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, 3n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 3n)).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, 2n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 2n)).toThrow('failed assert: oops');"
        ,(format "  expect(C.circuits.foo(context, 1n).result).toEqual(~dn);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 0n).result).toEqual(~dn-1n);" (max-field))
        "});"
        ))
    )

  (test
    '(
      "circuit bar(x: Field): Field {"
      "  return x;"
      "}"
      "export circuit foo(x: Field): Field {"
      "  return bar(x), bar(x - 1), bar(x - 2);"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.2 (tfield))
          (%descriptor.3 (tunsigned 255))
          (%descriptor.4 (tunsigned 18446744073709551615))
          (%descriptor.1 (tunsigned
                           340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %bar.5 ([%x.6 (tfield)]) (tfield) %x.6)
        (circuit %foo.7 ([%x.8 (tfield)])
             (tfield)
          (seq
            (call %bar.4 %x.7)
            (call %bar.4 (- #f %x.7 (safe-cast (tfield) (tunsigned 1) 1)))
            (call %bar.4 (- #f %x.7 (safe-cast (tfield) (tunsigned 2) 2)))))))
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 3n).result).toEqual(1n);"
        "  expect(C.circuits.foo(context, 2n).result).toEqual(0n);"
        ,(format "  expect(C.circuits.foo(context, 1n).result).toEqual(~dn);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 0n).result).toEqual(~dn-1n);" (max-field))
        "});"
        ))
    )

  (test
    '(
      "circuit bar(x: Field): Field {"
      "  return x;"
      "}"
      "export circuit foo(x: Field): [] {"
      "  bar(x), bar(x - 1), bar(x - 2);"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.2 (tfield))
          (%descriptor.3 (tunsigned 255))
          (%descriptor.4 (tunsigned 18446744073709551615))
          (%descriptor.1 (tunsigned
                           340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %bar.5 ([%x.6 (tfield)]) (tfield) %x.6)
        (circuit %foo.7 ([%x.8 (tfield)])
             (ttuple)
          (seq
            (seq
              (call %bar.4 %x.7)
              (call %bar.4 (- #f %x.7 (safe-cast (tfield) (tunsigned 1) 1)))
              (call %bar.4 (- #f %x.7 (safe-cast (tfield) (tunsigned 2) 2))))
            (tuple)))))
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 3n).result).toEqual([]);"
        "  expect(C.circuits.foo(context, 2n).result).toEqual([]);"
        "  expect(C.circuits.foo(context, 1n).result).toEqual([]);"
        "  expect(C.circuits.foo(context, 0n).result).toEqual([]);"
        "});"
        ))
    )

  (test
    '(
      "circuit bar(x: Field): [] {"
      "  assert(x != 0, 'oops');"
      "}"
      "export circuit foo(x: Field): [] {"
      "  bar(x), bar(x - 1), bar(x - 2);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 3n).result).toEqual([]);"
        "  expect(() => C.circuits.foo(context, 2n)).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, 1n)).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, 0n)).toThrow('failed assert: oops');"
        "});"
        ))
    )

  (test
    '(
      "circuit bar(x: Field): [] {"
      "  assert(x != 0, 'oops');"
      "}"
      "export circuit foo(x: Field): Boolean {"
      "  if (bar(x), bar(x - 1), bar(x - 2), x == 3)"
      "     return true;"
      "  else"
      "     return false;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 4n).result).toEqual(false);"
        "  expect(C.circuits.foo(context, 3n).result).toEqual(true);"
        "  expect(() => C.circuits.foo(context, 2n)).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, 1n)).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, 0n)).toThrow('failed assert: oops');"
        "});"
        ))
    )

  (test
    '(
      "circuit bar(x: Field): [] {"
      "  assert(x != 0, 'oops');"
      "}"
      "export circuit foo(x: Field): Boolean {"
      "  if (bar(x), bar(x - 1), bar(x - 2), x == 3)"
      "     return true;"
      "  return false;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 4n).result).toEqual(false);"
        "  expect(C.circuits.foo(context, 3n).result).toEqual(true);"
        "  expect(() => C.circuits.foo(context, 2n)).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, 1n)).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, 0n)).toThrow('failed assert: oops');"
        "});"
        ))
    )

  (test
    '(
      "export circuit foo(v: Vector<2, Field>): Vector<2, Field> {"
      "  return map("
      "    (x) => {"
      "      assert(x != 2, 'oops');"
      "      return x;"
      "    },"
      "    v);"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.7 (tfield))
          (%descriptor.8 (tvector 2 (tfield)))
          (%descriptor.9 (tunsigned 255))
          (%descriptor.10 (tunsigned 18446744073709551615))
          (%descriptor.6 (tunsigned
                           340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %foo.11 ([%v.12 (tvector 2 (tfield))])
             (tvector 2 (tfield))
          (map
            (circuit ([%x.13 (tfield)])
                 (tfield)
              (seq
                (assert (!= %x.18 (safe-cast (tfield) (tunsigned 2) 2)) "oops")
                %x.18))
            %v.17))))
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, [3n, 4n]).result).toEqual([3n, 4n]);"
        "  expect(() => C.circuits.foo(context, [2n, 3n])).toThrow('failed assert: oops');"
        "});"
        ))
    )

  (test
    '(
      "circuit bar(x: Field): Field {"
      "  assert(x != 2, 'oops');"
      "  return x;"
      "}"
      "export circuit foo(v: Vector<2, Field>): Vector<2, Field> {"
      "  return map("
      "    (x) => { return bar(x), bar(x-1), bar(x-2); }"
      "    ,v);"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.18 (tfield))
          (%descriptor.19 (tvector 2 (tfield)))
          (%descriptor.20 (tunsigned 255))
          (%descriptor.21 (tunsigned 18446744073709551615))
          (%descriptor.22 (tunsigned
                            340282366920938463463374607431768211455)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %bar.22 ([%x.23 (tfield)])
             (tfield)
          (seq
            (assert (!= %x.23 (safe-cast (tfield) (tunsigned 2) 2)) "oops")
            %x.23))
        (circuit %foo.24 ([%v.25 (tvector 2 (tfield))])
             (tvector 2 (tfield))
          (map
            (circuit ([%x.26 (tfield)])
                 (tfield)
              (seq
                (call %bar.22 %x.26)
                (call %bar.22 (- #f %x.26 (safe-cast (tfield) (tunsigned 1) 1)))
                (call %bar.22 (- #f %x.26 (safe-cast (tfield) (tunsigned 2) 2)))))
            %v.25))))
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, [5n, 6n]).result).toEqual([3n, 4n]);"
        "  expect(() => C.circuits.foo(context, [2n, 3n])).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, [3n, 4n])).toThrow('failed assert: oops');"
        "  expect(() => C.circuits.foo(context, [4n, 5n])).toThrow('failed assert: oops');"
        ,(format "  expect(C.circuits.foo(context, [1n, 5n]).result).toEqual([~dn, 3n]);" (max-field))
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "enum OP { plus, minus, times }"
      "ledger accum: Field;"
      "circuit bar(op0: OP, x0: Field): [] {"
      "  const op = disclose(op0); const x = disclose(x0);"
      "  if (op == OP.plus)"
      "    accum = accum + x;"
      "  else if (op == OP.minus)"
      "    accum = accum - x;"
      "  else"
      "    accum = accum * x;"
      "}"
      "export circuit foo(n: Field, ops: Vector<3, OP>, vals: Vector<3, Field>): Field {"
      "  return (() => { accum = disclose(n); })(), bar(ops[0], vals[0]), bar(ops[1], vals[1]), bar(ops[2], vals[2]), accum;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 7n, [0, 1, 2], [3n, 5n, 7n]).result).toEqual(35n);"
        "  expect(C.circuits.foo(context, 7n, [2, 1, 0], [7n, 5n, 3n]).result).toEqual(47n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "enum OP { plus, minus, times }"
      "ledger accum: Field;"
      "circuit bar(op: OP, x: Field): [] {"
      "  if (op == OP.plus)"
      "    accum = accum + x;"
      "  else if (op == OP.minus)"
      "    accum = accum - x;"
      "  else"
      "    accum = accum * x;"
      "}"
      "export circuit foo(n: Field, ops: Vector<3, OP>, vals: Vector<3, Field>): Field {"
      "  return (() => { accum = n; })(), map(bar, ops, vals), accum;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 11" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter ops of exported circuit foo at line 12 char 30" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the first argument to bar at line 13 char 36\n      the comparison at line 5 char 7\n      the conditional branch at line 5 char 3")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 11" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter vals of exported circuit foo at line 12 char 50" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of an addition involving the witness value\n    via this path through the program:\n      the second argument to bar at line 13 char 36\n      the computation at line 6 char 13\n      the right-hand side of = at line 6 char 11")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 13" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter ops of exported circuit foo at line 12 char 30" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the first argument to bar at line 13 char 36\n      the comparison at line 5 char 7\n      the conditional branch at line 5 char 3")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 11" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter vals of exported circuit foo at line 12 char 50" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of a subtraction involving the witness value\n    via this path through the program:\n      the second argument to bar at line 13 char 36\n      the computation at line 8 char 13\n      the right-hand side of = at line 8 char 11")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 11" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter ops of exported circuit foo at line 12 char 30" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the first argument to bar at line 13 char 36\n      the comparison at line 7 char 12\n      the conditional branch at line 7 char 8")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 13" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter ops of exported circuit foo at line 12 char 30" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the first argument to bar at line 13 char 36\n      the comparison at line 7 char 12\n      the conditional branch at line 7 char 8")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 11" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter vals of exported circuit foo at line 12 char 50" ("\n    nature of the disclosure:\n      ledger operation might disclose the result of a multiplication involving the witness value\n    via this path through the program:\n      the second argument to bar at line 13 char 36\n      the computation at line 10 char 13\n      the right-hand side of = at line 10 char 11")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 11" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter ops of exported circuit foo at line 12 char 30" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the first argument to bar at line 13 char 36\n      the comparison at line 7 char 12\n      the conditional branch at line 7 char 8")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 13" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter ops of exported circuit foo at line 12 char 30" ("\n    nature of the disclosure:\n      performing this ledger operation might disclose the boolean value of the result of a comparison involving the witness value\n    via this path through the program:\n      the first argument to bar at line 13 char 36\n      the comparison at line 7 char 12\n      the conditional branch at line 7 char 8")))
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 13 char 25" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the value of parameter n of exported circuit foo at line 12 char 20" ("\n    nature of the disclosure:\n      ledger operation might disclose the witness value\n    via this path through the program:\n      the right-hand side of = at line 13 char 25"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "enum OP { plus, minus, times }"
      "ledger accum: Field;"
      "circuit bar(op: OP, x: Field): [] {"
      "  if (disclose(op) == OP.plus)"
      "    accum = accum + disclose(x);"
      "  else if (disclose(op) == OP.minus)"
      "    accum = accum - disclose(x);"
      "  else"
      "    accum = accum * disclose(x);"
      "}"
      "export circuit foo(n: Field, ops: Vector<3, OP>, vals: Vector<3, Field>): Field {"
      "  return (() => { accum = disclose(n); })(), map(bar, ops, vals), accum;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 7n, [0, 1, 2], [3n, 5n, 7n]).result).toEqual(35n);"
        "  expect(C.circuits.foo(context, 7n, [2, 1, 0], [7n, 5n, 3n]).result).toEqual(47n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "enum OP { plus, minus, times }"
      "ledger accum: Field;"
      "circuit bar(op: OP, x: Field): [] {"
      "  if (disclose(op) == OP.plus)"
      "    accum = accum + disclose(x);"
      "  else if (disclose(op) == OP.minus)"
      "    accum = accum - disclose(x);"
      "  else"
      "    accum = accum * disclose(x);"
      "}"
      "export circuit foo(n: Field, ops: Vector<3, OP>, vals: Vector<3, Field>): Field {"
      "  return (() => { accum = disclose(n); })(),"
      "         fold((a, op, val) => (bar(op, val), a), 0, ops, vals),"
      "         accum;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 7n, [0, 1, 2], [3n, 5n, 7n]).result).toEqual(35n);"
        "  expect(C.circuits.foo(context, 7n, [2, 1, 0], [7n, 5n, 3n]).result).toEqual(47n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "witness transientHash(x: Boolean): Field;"
      "export circuit transientHash(x: Field) : Boolean { return disclose(x + transientHash(true) + transientHash<Field>(x) != 107); }"
      )
    (stage-javascript
      '(
        "const witnesses = { transientHash(private_state: any, x: boolean): [any, bigint] { return [private_state, 101n]; }};"
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.transientHash(context, 7n).result).toEqual(true);"
        "});"
        ))
    )

  (test
    '(
      "module M {"
      "  export circuit foo(x: Field) : Field { return x + 1; }"
      "  export { foo }"
      "}"
      "import M prefix M$;"
      "export { M$foo }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.M$foo(context, 7n).result).toEqual(8n);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger F: Map<Field, Field>;"
      "export circuit post(message: Field): [] {"
      "  F.lookup(7) = 3;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 15" "expected left-hand side of = to have an ADT type, received ~a" ("Field")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger F: Map<Field, Vector<5, Field>>;"
      "export circuit foo(x: Field): Vector<5, Field> {"
      "  F.insert(disclose(x), default<Vector<5, Field>>);"
      "  return F.lookup(disclose(x));"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 7n).result).toEqual([0n, 0n, 0n, 0n, 0n]);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "module M<T> {"
      "  export ledger fld: T;"
      "}"
      "import M<Counter> prefix M1$;"
      "import M<Counter> prefix M2$;"
      "import M<Set<Field>> prefix M3$;"
      "import M<Field> prefix M4$;"
      "import M<Map<Uint<0..10>, Map<Uint<8>, List<Boolean>>>> prefix M5$;"
      "import M<Map<Uint<0..10>, Map<Uint<8>, List<Boolean>>>> prefix M6$;"
      "export circuit foo(x: Field): Vector<5, Field> {"
      "  M1$fld += 1;"
      "  M2$fld += 2;"
      "  M3$fld.insert(disclose(x));"
      "  M4$fld = 71;"
      "  M5$fld.insert(3, default<Map<Uint<8>, List<Boolean>>>);"
      "  M5$fld.lookup(3).insert(4, default<List<Boolean>>);"
      "  M5$fld.lookup(3).lookup(4).pushFront(true);"
      "  return [M1$fld, M2$fld, M3$fld.size(), M4$fld, M6$fld.lookup(3).lookup(4).head().value as Field];"
      "}"
      "export {M1$fld, M2$fld, M3$fld, M4$fld, M5$fld, M6$fld};"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  let t = C.circuits.foo(context, 93n);"
        "  expect(t.result).toEqual([3n, 3n, 1n, 71n, 1n]);"
        "  let L = contractCode.ledger(t.context.currentQueryContext.state);"
        "  expect(L.M1$fld).toEqual(3n);"
        "  expect(L.M2$fld).toEqual(3n);"
        "  expect(L.M3$fld.isEmpty()).toEqual(false);"
        "  expect(L.M3$fld.member(71n)).toEqual(false);"
        "  expect(L.M3$fld.member(93n)).toEqual(true);"
        "  expect(L.M4$fld).toEqual(71n);"
        "  expect(L.M5$fld.lookup(3n).member(4n)).toEqual(true);"
        "  expect(L.M5$fld.lookup(3n).lookup(4n).head().value).toEqual(true);"
        "  expect(L.M5$fld.lookup(3n).member(5n)).toEqual(false);"
        "  expect(L.M6$fld.lookup(3n).lookup(4n).head().value).toEqual(true);"
        "  expect(L.M6$fld.lookup(3n).member(4n)).toEqual(true);"
        "  expect(L.M6$fld.lookup(3n).lookup(4n).head().value).toEqual(true);"
        "  expect(L.M6$fld.lookup(3n).member(5n)).toEqual(false);"
        "});"
        ))
    )

  (test
    '(
      "circuit foo(): [] {"
      "  return;"
      "}"
      "export circuit bar(): Boolean {"
      "  return foo() == foo();"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt).result).toEqual(true);"
        "  });"
        ))
    )

  (test
    '(
      "struct S { x: [], y: Field };"
      "circuit void(): []{}"
      "circuit foo(n: Field): S {"
      "  return S { x: void(), y: n };"
      "}"
      "export circuit bar(n1: Field, n2: Field): Boolean {"
      "  return foo(n1) == foo(n2);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 17n, 17n).result).toEqual(true);"
        "  expect(C.circuits.bar(Ctxt, 17n, 19n).result).toEqual(false);"
        "  });"
        ))
    )

  (test
    '(
      "struct S { x: [], y: Field };"
      "export circuit foo(void: [], n: Field): S {"
      "  return S { x: void, y: n };"
      "}"
      "export circuit bar(void: [], n1: Field, n2: Field): Boolean {"
      "  return foo(void, n1) == foo(void, n2);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, [], 17n, 17n).result).toEqual(true);"
        "  expect(C.circuits.bar(Ctxt, [], 17n, 19n).result).toEqual(false);"
        "  expect(() => C.circuits.bar(Ctxt, 13n, 17n, 19n)).toThrow(runtime.CompactError);"
        "  });"
        ))
    )

  (test
    '(
      "struct S { x: [], y: Field };"
      "ledger X: [];"
      "ledger Y: S;"
      "ledger Z: Bytes<0>;"
      "circuit foo(n: Field): S {"
      "  return S { x: X, y: n };"
      "}"
      "export circuit bar(n1: Field, n2: Field): Boolean {"
      "  X = default<[]>;"
      "  Y = foo(disclose(n1));"
      "  Z = default<Bytes<0>>;"
      "  return foo(n2) == Y;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 17n, 17n).result).toEqual(true);"
        "  expect(C.circuits.bar(Ctxt, 17n, 19n).result).toEqual(false);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit oak(a: [Uint<8>, Bytes<8>], x: Uint<8>, y: Bytes<8>): [Boolean, [Uint<8>, Bytes<8>]] {"
      "  const q = [x, y];"
      "  return [a == q, q];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.oak(Ctxt, [17n, new Uint8Array([1,2,3,4,5,6,7,8])], 17n, new Uint8Array([1,2,3,4,5,6,7,8])).result).toEqual([true, [17n, new Uint8Array([1,2,3,4,5,6,7,8])]]);"
        "  expect(C.circuits.oak(Ctxt, [17n, new Uint8Array([1,2,3,4,5,6,7,8])], 19n, new Uint8Array([1,2,3,4,5,6,7,8])).result).toEqual([false, [19n, new Uint8Array([1,2,3,4,5,6,7,8])]]);"
        "  expect(C.circuits.oak(Ctxt, [17n, new Uint8Array([1,2,3,4,5,6,7,8])], 17n, new Uint8Array([0,2,3,4,5,6,7,8])).result).toEqual([false, [17n, new Uint8Array([0,2,3,4,5,6,7,8])]]);"
        "  expect(() => C.circuits.oak(Ctxt, [17n, new Uint8Array([0,1,2,3,4,5,6,7,8])], 17n, new Uint8Array([0,2,3,4,5,6,7,8]))).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.oak(Ctxt, [17n, new Uint8Array([0,1,2,3,4,5,6,7,8])], 17n, new Uint8Array([0,2,3,4,5,6,7,8]))).toThrow('type error: oak argument 1 at testfile.compact line 2 char 1; expected value of type [Uint<0..256>, Bytes<8>] but received [ 17n, Uint8Array [Uint8Array] { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8 } ]');"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { p: Uint<8>, q: Bytes<8> };"
      "ledger fir: S;"
      "ledger cedar: [Uint<8>, Bytes<8>];"
      "export circuit willow(x: Uint<8>, y: Bytes<8>): [] {"
      "  fir = disclose(S {x, y});"
      "  cedar = [disclose(x), disclose(y)];"
      "}"
      "export circuit birch(): [Uint<8>, Bytes<8>] {"
      "  return cedar;"
      "}"
      "export circuit maple(): S {"
      "  return fir;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.willow(Ctxt, 17n, new Uint8Array([1,2,3,4,5,6,7,8]));"
        "  expect(t.result).toEqual([]);"
        "  Ctxt = t.context;"
        "  expect(C.circuits.maple(Ctxt).result).toEqual({ p: 17n, q: new Uint8Array([1,2,3,4,5,6,7,8])})";
        "  expect(C.circuits.birch(Ctxt).result).toEqual([17n, new Uint8Array([1,2,3,4,5,6,7,8])])";
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger cedar: [Uint<8>, Bytes<8>];"
      "export circuit willow(x: Uint<8>, y: Bytes<8>): [] {"
      "  cedar = [disclose(x), disclose(y)];"
      "  return [];"
      "}"
      "export circuit birch(a: [Uint<8>, Bytes<8>]): Boolean {"
      "  return a == cedar;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.willow(Ctxt, 17n, new Uint8Array([1,2,3,4,5,6,7,8]));"
        "  expect(t.result).toEqual([]);"
        "  Ctxt = t.context;"
        "  expect(C.circuits.birch(Ctxt, [17n, new Uint8Array([1,2,3,4,5,6,7,8])]).result).toEqual(true);"
        "  expect(C.circuits.birch(Ctxt, [19n, new Uint8Array([1,2,3,4,5,6,7,8])]).result).toEqual(false);"
        "  expect(C.circuits.birch(Ctxt, [17n, new Uint8Array([0,2,3,4,5,6,7,8])]).result).toEqual(false);"
        "  expect(() => C.circuits.birch(Ctxt, [17n, new Uint8Array([0,1,2,3,4,5,6,7,8])])).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.birch(Ctxt, [17n, new Uint8Array([0,1,2,3,4,5,6,7,8])])).toThrow('type error: birch argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 7 char 1; expected value of type [Uint<0..256>, Bytes<8>] but received [ 17n, Uint8Array [Uint8Array] { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8 } ]');"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger cedar: Set<[Uint<8>, Bytes<8>]>;"
      "export circuit willow(x: Uint<8>, y: Bytes<8>): [] {"
      "  cedar.insert([disclose(x), disclose(y)]);"
      "  return [];"
      "}"
      "export circuit birch(a: [Uint<8>, Bytes<8>]): Boolean {"
      "  return cedar.member(disclose(a));"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.willow(Ctxt, 17n, new Uint8Array([1,2,3,4,5,6,7,8]));"
        "  expect(t.result).toEqual([]);"
        "  Ctxt = t.context;"
        "  expect(C.circuits.birch(Ctxt, [17n, new Uint8Array([1,2,3,4,5,6,7,8])]).result).toEqual(true);"
        "  expect(C.circuits.birch(Ctxt, [19n, new Uint8Array([1,2,3,4,5,6,7,8])]).result).toEqual(false);"
        "  expect(C.circuits.birch(Ctxt, [17n, new Uint8Array([0,2,3,4,5,6,7,8])]).result).toEqual(false);"
        "  expect(() => C.circuits.birch(Ctxt, [17n, new Uint8Array([0,1,2,3,4,5,6,7,8])])).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.birch(Ctxt, [17n, new Uint8Array([0,1,2,3,4,5,6,7,8])])).toThrow('type error: birch argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 7 char 1; expected value of type [Uint<0..256>, Bytes<8>] but received [ 17n, Uint8Array [Uint8Array] { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8 } ]');"
        "  expect(() => C.circuits.birch(Ctxt, [new Uint8Array([1,2,3,4,5,6,7,8])])).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.birch(Ctxt, [new Uint8Array([1,2,3,4,5,6,7,8])])).toThrow('type error: birch argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 7 char 1; expected value of type [Uint<0..256>, Bytes<8>] but received [ Uint8Array [Uint8Array] { 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8 } ]');"
        "  expect(() => C.circuits.birch(Ctxt, [17n, 19n])).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.birch(Ctxt, [17n, 19n])).toThrow('type error: birch argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 7 char 1; expected value of type [Uint<0..256>, Bytes<8>] but received [ 17n, 19n ]');"
        "  });"
        ))
    )

  (test
    '(
      "circuit crash(): [] { assert(false, 'oops'); }"
      "circuit bar(x: Vector<0, Field>): Field {"
      "  return 7;"
      "}"
      "export circuit foo(x: Vector<0, Uint<16>>): Field {"
      "  return bar((crash(), x));"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt, [])).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, [])).toThrow('oops');"
        "  });"
        ))
    )

  (test
    '(
      "circuit bar(vb: Vector<5, Boolean>, vn: Vector<5, Field>): Vector<5, Field> {"
      "  return map((b, n) => b ? n : 0, vb, vn);"
      "}"
      "export circuit foo(x: Vector<5, Boolean>): Vector<5, Field> {"
      "  return bar(x, [1, 3, 5, 7, 9]);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [true, false, true, false, true]).result).toEqual([1n, 0n, 5n, 0n, 9n]);"
        "  expect(C.circuits.foo(Ctxt, [false, true, false, true, false]).result).toEqual([0n, 3n, 0n, 7n, 0n]);"
        "  expect(() => C.circuits.foo(Ctxt, [])).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, [])).toThrow('type error: foo argument 1 at testfile.compact line 4 char 1; expected value of type Vector<5, Boolean> but received []');"
        "  expect(() => C.circuits.foo(Ctxt, [1, 2, 3, 4, 5])).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, [1, 2, 3, 4, 5])).toThrow('type error: foo argument 1 at testfile.compact line 4 char 1; expected value of type Vector<5, Boolean> but received [ 1, 2, 3, 4, 5 ]');"
        "  });"
        ))
    )

  (test
    '(
      "circuit bar(vb: Vector<5, Boolean>, vn: Vector<5, Field>): Field {"
      "  return fold((a, b, n) => b ? a + n : a, 0 as Field, vb, vn);"
      "}"
      "export circuit foo(x: Vector<5, Boolean>): Field {"
      "  return bar(x, [1, 3, 5, 7, 9]);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [true, false, true, false, true]).result).toEqual(15n);"
        "  expect(C.circuits.foo(Ctxt, [false, true, false, true, false]).result).toEqual(10n);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(): [Field, Field, Field] { return map((n) => n + 1, [1, 2, 3]); }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt,).result).toEqual([2n, 3n, 4n]);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(): [] { return map((n: Field) => n + 1, []); }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt,).result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(): Field { return fold((a, n): Field => a + n, 0, [1, 2, 3, 4, 5]); }"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt,).result).toEqual(15n);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger f1: Vector<3, Field>;"
      "export circuit foo(a: [Field, Field, Field]): [] {"
      "  f1 = disclose(a);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  Ctxt = C.circuits.foo(Ctxt, [1n, 2n, 3n]).context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.f1).toEqual([1n, 2n, 3n]);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger f1: [Field, Field, Field];"
      "export circuit foo(a: Vector<3, Field>): [] {"
      "  f1 = disclose(a);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  Ctxt = C.circuits.foo(Ctxt, [1n, 2n, 3n]).context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.f1).toEqual([1n, 2n, 3n]);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger f1: [];"
      "export circuit foo(a: Vector<0, Field>): [] {"
      "  f1 = disclose(a);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  Ctxt = C.circuits.foo(Ctxt, []).context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.f1).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger f1: Vector<0, Field>;"
      "export circuit foo(a: []): [] {"
      "  f1 = disclose(a);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  Ctxt = C.circuits.foo(Ctxt, []).context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.f1).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger f1: [];"
      "export circuit foo(a: []): [] {"
      "  f1 = disclose(a);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  Ctxt = C.circuits.foo(Ctxt, []).context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.f1).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger f1: MerkleTree<10, [Field, Boolean]>;"
      "export circuit foo(a: [Field, Boolean]): Boolean {"
      "  f1.insert(disclose(a));"
      "  return f1.isFull();"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, true]);"
        "  expect(t.result).toEqual(false);"
        "  Ctxt = t.context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.f1.findPathForLeaf([3n, false])).toEqual(undefined);"
        "  expect(L.f1.findPathForLeaf([7n, true])).toEqual(undefined);"
        "  expect(L.f1.findPathForLeaf([3n, true])).toHaveProperty('leaf');"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger f1: Map<Field, MerkleTree<10, [Field, Boolean]>>;"
      "export circuit foo(a: [Field, Boolean]): Boolean {"
      "  f1.insert(17, default<MerkleTree<10, [Field, Boolean]>>);"
      "  f1.lookup(17).insert(disclose(a));"
      "  return f1.lookup(17).isFull();"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, true]);"
        "  expect(t.result).toEqual(false);"
        "  Ctxt = t.context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.f1.lookup(17n).findPathForLeaf([3n, false])).toEqual(undefined);"
        "  expect(L.f1.lookup(17n).findPathForLeaf([7n, true])).toEqual(undefined);"
        "  expect(L.f1.lookup(17n).findPathForLeaf([3n, true])).toHaveProperty('leaf');"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger f00: Field;"
      "export ledger f01: Field;"
      "export ledger f02: Field;"
      "export ledger f03: Field;"
      "export ledger f04: Field;"
      "export ledger f05: Field;"
      "export ledger f06: Field;"
      "export ledger f07: Field;"
      "export ledger f08: Field;"
      "export ledger f09: Field;"
      "export ledger f10: Field;"
      "export ledger f11: Field;"
      "export ledger f12: Field;"
      "export ledger f13: Field;"
      "export ledger f14: Field;"
      "export ledger f15: Field;"
      "export ledger f16: Field;"
      "export ledger f17: Field;"
      "export ledger f18: Field;"
      "export ledger f19: Field;"
      "export ledger f20: Field;"
      "export ledger f21: Field;"
      "export ledger f22: Field;"
      "export ledger f23: Field;"
      "export ledger f24: Field;"
      "export ledger f25: Field;"
      "export ledger f26: Field;"
      "export ledger f27: Field;"
      "export ledger f28: Field;"
      "export ledger f29: Field;"
      "export ledger f30: Field;"
      "export ledger f31: Field;"
      "export ledger f32: Field;"
      "export ledger f33: Field;"
      "export ledger f34: Field;"
      "export ledger f35: Field;"
      "export ledger f36: Field;"
      "export ledger f37: Field;"
      "export ledger f38: Field;"
      "export ledger f39: Field;"
      "constructor() {"
      "  f17 = 101;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.f17).toEqual(101n);"
        "  expect(L.f32).toEqual(0n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): [Field, Boolean] {"
      "  return [y, x];"
      "}"
      "export circuit foo(x: Boolean, y: Field): Field {"
      "  const [a, b] = bar(x, y);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, 17n).result).toEqual(17n);"
        "  expect(C.circuits.foo(Ctxt, false, 17n).result).toEqual(34n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): [Field, Boolean] {"
      "  return [y, x];"
      "}"
      "export circuit foo(x: Boolean, y: Field): Field {"
      "  const [, b] = bar(x, y);"
      "  return b ? 43 : 47;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, 17n).result).toEqual(43n);"
        "  expect(C.circuits.foo(Ctxt, false, 17n).result).toEqual(47n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean, y: Field): [Field, Field, Boolean] {"
      "  return [y, y, x];"
      "}"
      "export circuit foo(x: Boolean, y: Field): Field {"
      "  const [, , b] = bar(x, y);"
      "  return b ? 43 : 47;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, 17n).result).toEqual(43n);"
        "  expect(C.circuits.foo(Ctxt, false, 17n).result).toEqual(47n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "circuit bar(x: Boolean): Vector<3, Boolean> {"
      "  return [x, x, x];"
      "}"
      "export circuit foo(x: Boolean): Field {"
      "  const [, , b] = bar(x);"
      "  return b ? 43 : 47;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true).result).toEqual(43n);"
        "  expect(C.circuits.foo(Ctxt, false).result).toEqual(47n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(x: Boolean, y: Field): Field {"
      "  const {, b} = bar(x, y);"
      "  return b ? y : 2 * y;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 7 char 10" "parse error: found ~a looking for~?" ("\",\"" "~#[ nothing~; ~a~; ~a or ~a~:;~@{~#[~; or~] ~a~^,~}~]" ("a pattern struct element" "\"}\""))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(x: Boolean, y: Field): Field {"
      "  const {b, } = bar(x, y);"
      "  return b ? y : 2 * y;"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.3 (tboolean))
          (%descriptor.4 (tfield))
          (%descriptor.5 (tstruct S (a (tfield)) (b (tboolean))))
          (%descriptor.6 (tunsigned 18446744073709551615))
          (%descriptor.7 (tbytes 32))
          (%descriptor.8 (tstruct ContractAddress
                           (bytes (tbytes 32))))
          (%descriptor.9 (tunsigned 255))
          (%descriptor.10 (tunsigned
                            340282366920938463463374607431768211455)))
        (kernel-declaration (%kernel.11 () (Kernel)))
        (public-ledger-declaration () (constructor () (tuple)))
        (circuit %bar.12 ([%x.13 (tboolean)] [%y.14 (tfield)])
             (tstruct S (a (tfield)) (b (tboolean)))
          (new (tstruct S (a (tfield)) (b (tboolean))) %y.14 %x.13))
        (circuit %foo.15 ([%x.16 (tboolean)] [%y.17 (tfield)])
             (tfield)
          (seq
            (const [%__compact_pattern_tmp1.18 (tstruct S
                                                 (a (tfield))
                                                 (b (tboolean)))]
              (call %bar.12 %x.16 %y.17))
            (seq
              (const [%b.19 (tboolean)]
                (elt-ref %__compact_pattern_tmp1.18 b 1))
              (if %b.19
                  %y.17
                  (* #f (safe-cast (tfield) (tunsigned 2) 2) %y.17)))))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(x: Boolean, y: Field): Field {"
      "  const { b} = bar(x, y);"
      "  return b ? 43 : 47;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, 17n).result).toEqual(43n);"
        "  expect(C.circuits.foo(Ctxt, false, 17n).result).toEqual(47n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export circuit bar(x: Boolean, y: Field): [Field, Boolean] {"
      "  return [y, x];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, true, 17n).result).toEqual([17n, true]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: Field, b: Boolean }"
      "circuit bar(x: Boolean, y: Field): S {"
      "  return S { y, x };"
      "}"
      "export circuit foo(x: Boolean, y: Field): Field {"
      "  const {a, b} = bar(x, y);"
      "  return b ? a : 2 * a;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, true, 17n).result).toEqual(17n);"
        "  expect(C.circuits.foo(Ctxt, false, 17n).result).toEqual(34n);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const [{a: [a, b], b: b1}, b2] = bar(x1, x2, y, z);"
      "  return [b1 ? a : 2 * a, b2 ? b : 'hello!'];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, false, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([34n, new Uint8Array([104, 101, 108, 108, 111, 33])]);"
        "  expect(C.circuits.foo(Ctxt, false, true, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([34n, new Uint8Array([97, 100, 105, 111, 115, 33])]);"
        "  expect(C.circuits.foo(Ctxt, true, false, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([17n, new Uint8Array([104, 101, 108, 108, 111, 33])]);"
        "  expect(C.circuits.foo(Ctxt, true, true, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([17n, new Uint8Array([97, 100, 105, 111, 115, 33])]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, [x2, y] : [Boolean, Field], z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "circuit go([{a: [a, b], b: b1}, b2] : [S, Boolean]): [Field, Bytes<6>] {"
      "  return [b1 ? a : 2 * a, b2 ? b : 'hello!'];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const t = bar(x1, [x2, y], z);"
      "  return go(t);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, false, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([34n, new Uint8Array([104, 101, 108, 108, 111, 33])]);"
        "  expect(C.circuits.foo(Ctxt, false, true, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([34n, new Uint8Array([97, 100, 105, 111, 115, 33])]);"
        "  expect(C.circuits.foo(Ctxt, true, false, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([17n, new Uint8Array([104, 101, 108, 108, 111, 33])]);"
        "  expect(C.circuits.foo(Ctxt, true, true, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([17n, new Uint8Array([97, 100, 105, 111, 115, 33])]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "struct S { a: [Field, Bytes<6>], b: Boolean }"
      "circuit bar(x1: Boolean, [x2, y] : [Boolean, Field], z: Bytes<6>): [S, Boolean] {"
      "  return [S{[y, z], x1}, x2];"
      "}"
      "export circuit foo(x1: Boolean, x2: Boolean, y: Field, z: Bytes<6>): [Field, Bytes<6>] {"
      "  const t = bar(x1, [x2, y], z);"
      "  return (([{a: [a, b], b: b1}, b2]) => [b1 ? a : 2 * a, b2 ? b : 'hello!'])(t);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, false, false, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([34n, new Uint8Array([104, 101, 108, 108, 111, 33])]);"
        "  expect(C.circuits.foo(Ctxt, false, true, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([34n, new Uint8Array([97, 100, 105, 111, 115, 33])]);"
        "  expect(C.circuits.foo(Ctxt, true, false, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([17n, new Uint8Array([104, 101, 108, 108, 111, 33])]);"
        "  expect(C.circuits.foo(Ctxt, true, true, 17n, new Uint8Array([97, 100, 105, 111, 115, 33])).result).toEqual([17n, new Uint8Array([97, 100, 105, 111, 115, 33])]);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo1([a, , c] : [Boolean, Field, Boolean]): [Boolean, Boolean] {"
      "  return [c, a];"
      "}"
      "export circuit foo2([, b, c] : [Boolean, Field, Boolean]): [Boolean, Field] {"
      "  return [c, b];"
      "}"
      "export circuit foo3([a, b, ] : [Boolean, Field, Boolean]): [Field, Boolean] {"
      "  return [b, a];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo1(Ctxt, [false, 17n, true]).result).toEqual([true, false]);"
        "  expect(C.circuits.foo2(Ctxt, [false, 17n, true]).result).toEqual([true, 17n]);"
        "  expect(C.circuits.foo3(Ctxt, [false, 17n, true]).result).toEqual([17n, false]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger c: Map<Field, List<Field>>;"
      ""
      "export circuit foo1(): [] {"
      "  assert(c.isEmpty() == true, 'Structure should be empty');"
      "  assert(c.size() == 0, 'Size should be 0');"
      "}"
      ""
      "export circuit foo2(): [] {"
      "  c.insert(0, default<List<Field>>);"
      "  assert(c.size() == 1, 'Size should be 1');"
      "  assert(c.lookup(0).length() == 0, 'Key 0 should have value 1');"
      "}"
      ""
      "export circuit foo3(): [] {"
      "  c.insertDefault(1);"
      "  assert(c.size() == 2, 'Size should be 2');"
      "  assert(c.lookup(1).length() == 0, 'Key 1 should have value 0');"
      "  assert(c.member(1) == true, 'Key 1 should be member');"
      "}"
      ""
      "export circuit foo4(): [] {"
      "  c.remove(0);"
      "  assert(c.size() == 1, 'Size should be 1');"
      "  assert(c.lookup(0).length() == 0, 'What should happen here');"
      "}"
      ""
      "export circuit foo5(): [] {"
      "  c.resetToDefault();"
      "  assert(c.size() == 0, 'Size should be 0');"
      "  assert(c.isEmpty() == true, 'Structure should be empty');"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.impureCircuits.foo1(context).result).toEqual([]);"
        "  expect(C.impureCircuits.foo2(context).result).toEqual([]);"
        "  expect(() => C.impureCircuits.foo3(context)).toThrow(runtime.CompactError);"
        "  expect(() => C.impureCircuits.foo4(context)).toThrow(runtime.CompactError);"
        "  expect(C.impureCircuits.foo5(context).result).toEqual([]);"
        "  });"
        ))
    )

  ; shows the threading of context (compared to the test above)
  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger c: Map<Field, List<Field>>;"
      ""
      "export circuit foo1(): [] {"
      "  assert(c.isEmpty() == true,'Structure should be empty');"
      "  assert(c.size() == 0, 'Size should be 0');"
      "}"
      ""
      "export circuit foo2(): [] {"
      "  c.insert(0, default<List<Field>>);"
      "  assert(c.size() == 1, 'Size should be 1');"
      "  assert(c.lookup(0).length() == 0, 'Key 0 should have value 1');"
      "}"
      ""
      "export circuit foo3(): [] {"
      "  c.insertDefault(1);"
      "  assert(c.size() == 2, 'Size should be 2');"
      "  assert(c.lookup(1).length() == 0, 'Key 1 should have value 0');"
      "  assert(c.member(1) == true, 'Key 1 should be member');"
      "}"
      ""
      "export circuit foo4(): [] {"
      "  c.remove(0);"
      "  assert(c.size() == 1, 'Size should be 1');"
      "  assert(c.lookup(0).length() == 0, 'What should happen here');"
      "}"
      ""
      "export circuit foo5(): [] {"
      "  c.resetToDefault();"
      "  assert(c.size() == 0, 'Size should be 0');"
      "  assert(c.isEmpty() == true, 'Structure should be empty');"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  var { result, context } = C.circuits.foo1(context);"
        "  expect(result).toEqual([]);"
        "  var { result, context } = C.circuits.foo2(context);"
        "  expect(result).toEqual([]);"
        "  var { result, context } = C.circuits.foo3(context);"
        "  expect(result).toEqual([]);"
        "  expect(() => C.circuits.foo4(context)).toThrow(runtime.CompactError);"
        "  var { result, context } = C.circuits.foo5(context);"
        "  expect(result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger coins: List<QualifiedCoinInfo>;"
      "export circuit receiveToken(dust: CoinInfo): [] {"
      "  receive(disclose(dust));"
      "  coins.pushFrontCoin(disclose(dust), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (stage-javascript
      '(
        "test('coin insertion succeeds for lists', () => {"
        "  const [C, ctxt] = startContract(contractCode, {}, undefined);"
        "  expect(() => C.circuits.receiveToken(ctxt, {"
        "    nonce: new Uint8Array(32),"
        "    color: new Uint8Array(32),"
        "    value: 5n"
        "  })).not.toThrow(runtime.CompactError);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger coins: List<QualifiedCoinInfo>;"
      "export circuit receiveToken(dust: CoinInfo): [] {"
      "  coins.pushFrontCoin(disclose(dust), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (stage-javascript
      '(
        "test('coin insertion fails informatively for lists when coin commitment does not exit in query context', () => {"
        "  const [C, ctxt] = startContract(contractCode, {}, undefined);"
        "  expect(() => C.circuits.receiveToken(ctxt, {"
        "    nonce: new Uint8Array(32),"
        "    color: new Uint8Array(32),"
        "    value: 5n"
        "  })).toThrow(new runtime.CompactError(`testfile.compact line 4 char 3: Coin commitment not found. Check the coin has been received (or call 'createZswapOutput')`));"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger coins: Map<Field, QualifiedCoinInfo>;"
      "export circuit receiveToken(dust: CoinInfo): [] {"
      "  receive(disclose(dust));"
      "  coins.insertCoin(0, disclose(dust), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (stage-javascript
      '(
        "test('coin insertion succeeds for maps', () => {"
        "  const [C, ctxt] = startContract(contractCode, {}, undefined);"
        "  expect(() => C.circuits.receiveToken(ctxt, {"
        "    nonce: new Uint8Array(32),"
        "    color: new Uint8Array(32),"
        "    value: 5n"
        "  })).not.toThrow(runtime.CompactError);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger coins: Map<Field, QualifiedCoinInfo>;"
      "export circuit receiveToken(dust: CoinInfo): [] {"
      "  coins.insertCoin(0, disclose(dust), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (stage-javascript
      '(
        "test('coin insertion fails informatively for maps when coin commitment does not exit in query context', () => {"
        "  const [C, ctxt] = startContract(contractCode, {}, undefined);"
        "  expect(() => C.circuits.receiveToken(ctxt, {"
        "    nonce: new Uint8Array(32),"
        "    color: new Uint8Array(32),"
        "    value: 5n"
        "  })).toThrow(new runtime.CompactError(`testfile.compact line 4 char 3: Coin commitment not found. Check the coin has been received (or call 'createZswapOutput')`));"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger coins: Set<QualifiedCoinInfo>;"
      "export circuit receiveToken(dust: CoinInfo): [] {"
      "  receive(disclose(dust));"
      "  coins.insertCoin(disclose(dust), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (stage-javascript
      '(
        "test('coin insertion succeeds for sets', () => {"
        "  const [C, ctxt] = startContract(contractCode, {}, undefined);"
        "  expect(() => C.circuits.receiveToken(ctxt, {"
        "    nonce: new Uint8Array(32),"
        "    color: new Uint8Array(32),"
        "    value: 5n"
        "  })).not.toThrow(runtime.CompactError);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger coins: Set<QualifiedCoinInfo>;"
      "export circuit receiveToken(dust: CoinInfo): [] {"
      "  coins.insertCoin(disclose(dust), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (stage-javascript
      '(
        "test('coin insertion fails informatively for sets when coin commitment does not exit in query context', () => {"
        "  const [C, ctxt] = startContract(contractCode, {}, undefined);"
        "  expect(() => C.circuits.receiveToken(ctxt, {"
        "    nonce: new Uint8Array(32),"
        "    color: new Uint8Array(32),"
        "    value: 5n"
        "  })).toThrow(new runtime.CompactError(`testfile.compact line 4 char 3: Coin commitment not found. Check the coin has been received (or call 'createZswapOutput')`));"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger coin: QualifiedCoinInfo;"
      "export circuit receiveToken(dust: CoinInfo): [] {"
      "  receive(disclose(dust));"
      "  coin.writeCoin(disclose(dust), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (stage-javascript
      '(
        "test('coin insertion succeeds for cells', () => {"
        "  const [C, ctxt] = startContract(contractCode, {}, undefined);"
        "  expect(() => C.circuits.receiveToken(ctxt, {"
        "    nonce: new Uint8Array(32),"
        "    color: new Uint8Array(32),"
        "    value: 5n"
        "  })).not.toThrow(runtime.CompactError);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger coin: QualifiedCoinInfo;"
      "export circuit receiveToken(dust: CoinInfo): [] {"
      "  coin.writeCoin(disclose(dust), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));"
      "}"
      )
    (stage-javascript
      '(
        "test('coin insertion fails informatively for cells when coin commitment does not exit in query context', () => {"
        "  const [C, ctxt] = startContract(contractCode, {}, undefined);"
        "  expect(() => C.circuits.receiveToken(ctxt, {"
        "    nonce: new Uint8Array(32),"
        "    color: new Uint8Array(32),"
        "    value: 5n"
        "  })).toThrow(new runtime.CompactError(`testfile.compact line 4 char 3: Coin commitment not found. Check the coin has been received (or call 'createZswapOutput')`));"
        "});"
        ))
    )

  ; Field addition edge cases
  (test
    '(
      "export circuit foo(x: Field, y: Field): Field {"
      "  return x + y;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 0n, 0n).result).toEqual(0n);"
        ,(format "  expect(C.circuits.foo(context, 0n, ~dn).result).toEqual(~:*~dn);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 1n, ~dn).result).toEqual(0n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn, 1n).result).toEqual(0n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 2n, ~dn).result).toEqual(1n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn, 2n).result).toEqual(1n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 5n, ~dn-1n).result).toEqual(3n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn-1n, 5n).result).toEqual(3n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn, ~:*~dn).result).toEqual(~:*~dn-1n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn-1n, ~:*~dn-3n).result).toEqual(~:*~dn-5n);" (max-field))
        "  expect(() => C.circuits.foo(context, -1n, 0n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, -1n, 0n)).toThrow('type error: foo argument 1 at testfile.compact line 1 char 1; expected value of type Field but received -1n');"
        "  expect(() => C.circuits.foo(context, 0n, -1n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 0n, -1n)).toThrow('type error: foo argument 2 at testfile.compact line 1 char 1; expected value of type Field but received -1n');"
        ,(format "  expect(() => C.circuits.foo(context, ~dn, ~:*~dn-1n)).toThrow(runtime.CompactError);" (+ (max-field) 1))
        ,(format "  expect(() => C.circuits.foo(context, ~dn, ~:*~dn-1n)).toThrow('type error: foo argument 1 at testfile.compact line 1 char 1; expected value of type Field but received ~:*~dn');" (+ (max-field) 1))
        ,(format "  expect(() => C.circuits.foo(context, ~dn-2n, ~:*~dn)).toThrow(runtime.CompactError);" (+ (max-field) 2))
        ,(format "  expect(() => C.circuits.foo(context, ~dn-2n, ~:*~dn)).toThrow('type error: foo argument 2 at testfile.compact line 1 char 1; expected value of type Field but received ~:*~dn');" (+ (max-field) 2))
        "});"
        ))
    )

  ; Field subtraction edge cases
  (test
    '(
      "export circuit foo(x: Field, y: Field): Field {"
      "  return x - y;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 0n, 0n).result).toEqual(0n);"
        ,(format "  expect(C.circuits.foo(context, 0n, 1n).result).toEqual(~dn);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 0n, 2n).result).toEqual(~dn-1n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 2n, 5n).result).toEqual(~dn-2n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 0n, ~dn).result).toEqual(1n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 0n, ~dn-1n).result).toEqual(2n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn, ~:*~dn-1n).result).toEqual(1n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn-1n, ~:*~dn).result).toEqual(~:*~dn);" (max-field))
        "  expect(() => C.circuits.foo(context, -1n, 0n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, -1n, 0n)).toThrow('type error: foo argument 1 at testfile.compact line 1 char 1; expected value of type Field but received -1n');"
        "  expect(() => C.circuits.foo(context, 0n, -1n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 0n, -1n)).toThrow('type error: foo argument 2 at testfile.compact line 1 char 1; expected value of type Field but received -1n');"
        ,(format "  expect(() => C.circuits.foo(context, ~dn, ~:*~dn-1n)).toThrow(runtime.CompactError);" (+ (max-field) 1))
        ,(format "  expect(() => C.circuits.foo(context, ~dn, ~:*~dn-1n)).toThrow('type error: foo argument 1 at testfile.compact line 1 char 1; expected value of type Field but received ~:*~dn');" (+ (max-field) 1))
        ,(format "  expect(() => C.circuits.foo(context, ~dn-2n, ~:*~dn)).toThrow(runtime.CompactError);" (+ (max-field) 2))
        ,(format "  expect(() => C.circuits.foo(context, ~dn-2n, ~:*~dn)).toThrow('type error: foo argument 2 at testfile.compact line 1 char 1; expected value of type Field but received ~:*~dn');" (+ (max-field) 2))
        "});"
        ))
    )

  ; Field subtraction regression test
  (test
    '(
      "export circuit foo(v: Vector<3,Field>) : Field {"
      "  return fold((a: Field, n: Field): Field => a - n, 0, v);"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, [0n, 0n, 0n]).result).toEqual(0n);"
        ,(format "  expect(C.circuits.foo(context, [5n, 6n, 7n]).result).toEqual(~dn-17n);" (max-field))
        "});"
        ))
    )

  ; Field subtraction regression test
  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger round: Counter;"
      "export circuit foo(v: Vector<3,Field>) : Field {"
      "  return fold((a: Field, n: Field): Field => a - n, 0, v);"
      "}"
      "constructor() {"
      "  const b = foo([5, 6, 7]);"
      "  round.increment(b as Uint<16>);"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  expect(() => startContract(contractCode, {}, 0)).toThrow(runtime.CompactError);"
        ,(format "  expect(() => startContract(contractCode, {}, 0)).toThrow('testfile.compact line 8 char 19: cast from Field or Uint value to smaller Uint value failed: ~d is greater than 65535');" (- (max-field) 17))
        "});"
        ))
    )

  ; Field multiplication edge cases
  (test
    '(
      "export circuit foo(x: Field, y: Field): Field {"
      "  return x * y;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, context] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(context, 0n, 0n).result).toEqual(0n);"
        ,(format "  expect(C.circuits.foo(context, 0n, ~dn).result).toEqual(0n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn, 0n).result).toEqual(0n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 1n, ~dn).result).toEqual(~:*~dn);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn, 1n).result).toEqual(~:*~dn);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 2n, ~dn).result).toEqual(~:*~dn-1n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn, 2n).result).toEqual(~:*~dn-1n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, 5n, ~dn-1n).result).toEqual(~:*~dn-9n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn-1n, 5n).result).toEqual(~:*~dn-9n);" (max-field))
        ,(format "  expect(C.circuits.foo(context, ~dn, ~:*~dn).result).toEqual((~:*~dn*~:*~dn) % (~:*~dn+1n));" (max-field))
        "  expect(() => C.circuits.foo(context, -1n, 0n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, -1n, 0n)).toThrow('type error: foo argument 1 at testfile.compact line 1 char 1; expected value of type Field but received -1n');"
        "  expect(() => C.circuits.foo(context, 0n, -1n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(context, 0n, -1n)).toThrow('type error: foo argument 2 at testfile.compact line 1 char 1; expected value of type Field but received -1n');"
        ,(format "  expect(() => C.circuits.foo(context, ~dn, ~:*~dn-1n)).toThrow(runtime.CompactError);" (+ (max-field) 1))
        ,(format "  expect(() => C.circuits.foo(context, ~dn, ~:*~dn-1n)).toThrow('type error: foo argument 1 at testfile.compact line 1 char 1; expected value of type Field but received ~:*~dn');" (+ (max-field) 1))
        ,(format "  expect(() => C.circuits.foo(context, ~dn-2n, ~:*~dn)).toThrow(runtime.CompactError);" (+ (max-field) 2))
        ,(format "  expect(() => C.circuits.foo(context, ~dn-2n, ~:*~dn)).toThrow('type error: foo argument 2 at testfile.compact line 1 char 1; expected value of type Field but received ~:*~dn');" (+ (max-field) 2))
        "});"
        ))
    )

  (test-group
    ((create-file "M.compact"
       '(
         "module M {"
         "  export circuit foo(x: Field): Field { return x * 2; }"
         "}"
         ))
     (succeeds))
    ((create-file "useM.compact"
       '(
         "import M;"
         "export { foo }"
         ))
     (stage-javascript
       '(
         "test('check 1', () => {"
         "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
         "  expect(C.circuits.foo(Ctxt, 5n).result).toEqual(10n);"
         "  });"
         )))
    )

  (test-group
    ((create-file "I.compact"
       '(
         "circuit foo(x: Field): Field { return x * 2; }"
         ))
     (succeeds))
    ((create-file "useI.compact"
       '(
         "include 'I';"
         "export { foo }"
         ))
     (stage-javascript
       '(
         "test('check 1', () => {"
         "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
         "  expect(C.circuits.foo(Ctxt, 5n).result).toEqual(10n);"
         "  });"
         )))
    )

  ; pm-16064
  ; was producing an unparenthesized expression sequence between ? and :
  (test
    '(
      "witness w(x: Boolean): Boolean;"
      "export circuit foo(): Boolean {"
      " return disclose(w(w(true) ? (w(false), w(true)) : w(false)));"
      "}"
      )
    (stage-javascript
      '(
        "const witnesses = { w({privateState}: runtime.WitnessContext<{}, number>, b: boolean): [number, boolean] { return [privateState, true]; } };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(true);"
        "  });"
        ))
    )

  ; pm-16064
  (test
    '(
      "witness w(x: Boolean): Boolean;"
      "export circuit foo(): Boolean {"
      " return disclose(w(w(true) ? w(false) ? w(true) : w(false) : w(false)));"
      "}"
      )
    (stage-javascript
      '(
        "const witnesses = { w({privateState}: runtime.WitnessContext<{}, number>, b: boolean): [number, boolean] { return [privateState, true]; } };"
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(true);"
        "  });"
        ))
    )

  ; pm-16075
  ; same root cause as pm-16064
  ; was producing an unparenthesized expression sequence between ? and :
  (test
    '(
      "pragma language_version >= 0.14.0;"
      "import CompactStandardLibrary;"
      "export ledger y: Map<Boolean, Vector<1, []>>;"
      "export circuit foo(): [] {  }"
      ""
      "constructor() {"
      "  y.insert(true, (() => {"
      "    if(y.isEmpty()) {"
      "      y.insert(true, [foo()]);"
      "    }"
      "    return [[]];"
      "  })());"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "circuit bar(v: Vector<5, Field>, i: Uint<0..5>): Field {"
      "  return v[i];"
      "}"
      "export circuit foo(v: Vector<5, Field>): Field {"
      "  return bar(v, 3);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [7n, 11n, 13n, 17n, 19n]).result).toEqual(17n);"
        "  });"
        ))
    )
  (test
    '(
      "ledger v: Vector<10, Uint<16>>;"
      "export circuit foo(vv: Vector<10, Uint<8>>): Vector<10, Uint<16>> {"
      "  v = disclose(vv);"
      "  return v;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [1n,2n,3n,4n,5n,6n,7n,8n,9n,10n]).result).toEqual([1n,2n,3n,4n,5n,6n,7n,8n,9n,10n]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger x: Counter;"
      "export circuit foo(v: Vector<5, Uint<16>>): [] {"
      "  for (const i of 2..5) x += disclose(v[i] - v[i-1]);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [7n, 11n, 13n, 17n, 19n]);"
        "  expect(t.result).toEqual([]);"
        "  Ctxt = t.context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.x).toEqual(8n);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(bv: Bytes<10>): Vector<10, Uint<16>> {"
      "  return bv as Vector<10, Uint<8>>;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([1,2,3,4,5,6,7,8,9,10])).result).toEqual([1n,2n,3n,4n,5n,6n,7n,8n,9n,10n]);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(bv: Bytes<5>): Vector<5, Uint<16>> {"
      "  return bv as Vector<5, Uint<8>>;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  var a = Array.from({ length: 5 }, (v, i) => i+1);"
        "  expect(a).toEqual([1,2,3,4,5]);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array(a)).result).toEqual([1n,2n,3n,4n,5n]);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array(a)).result).toEqual(a.map((t) => BigInt(t)));"
        "  });"
        ))
    )

  (test
    `(
      "module M<#N> {"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<16>> {"
      "    return bv as Vector<N, Uint<8>>;"
      "  }"
      "}"
      ,(format "import M<~d>;" (field-bytes))
      "export { foo }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "const k = ~d\n" (field-bytes))
        "  var a = Array.from({ length: k }, (v, i) => i+1);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array(a)).result).toEqual(a.map((t) => BigInt(t)));"
        "  });"
        ))
    )

  (test
    `(
      "module M<#N> {"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<16>> {"
      "    return bv as Vector<N, Uint<8>>;"
      "  }"
      "}"
      ,(format "import M<~d>;" (+ (field-bytes) 1))
      "export { foo }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "const k = ~d\n" (+ (field-bytes) 1))
        "  var a = Array.from({ length: k }, (v, i) => i+1);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array(a)).result).toEqual(a.map((t) => BigInt(t)));"
        "  });"
        ))
    )

  (test
    `(
      "module M<#N> {"
      "  export circuit foo(bv: Bytes<N>): Vector<N, Uint<16>> {"
      "    return bv as Vector<N, Uint<8>>;"
      "  }"
      "}"
      ,(format "import M<~d>;" (+ (* (field-bytes) 2) 1))
      "export { foo }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "const k = ~d\n" (+ (* (field-bytes) 2) 1))
        "  var a = Array.from({ length: k }, (v, i) => i+1);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array(a)).result).toEqual(a.map((t) => BigInt(t)));"
        "  });"
        ))
    )

  (test
    '(
      "ledger v: Vector<10, Uint<16>>;"
      "export circuit foo(bv: Bytes<10>): Vector<10, Uint<16>> {"
      "  v = disclose(bv) as Vector<10, Uint<8>>;"
      "  return v;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([1,2,3,4,5,6,7,8,9,10])).result).toEqual([1n,2n,3n,4n,5n,6n,7n,8n,9n,10n]);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(vv: Vector<10, Uint<8>>): Bytes<10> {"
      "  return vv as Bytes<10>;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [1n,2n,3n,4n,5n,6n,7n,8n,9n,10n]).result).toEqual(new Uint8Array([1,2,3,4,5,6,7,8,9,10]));"
        "  });"
        ))
    )

  (test
    '(
      "ledger v: Bytes<10>;"
      "export circuit foo(vv: Vector<10, Uint<8>>): Bytes<10> {"
      "  v = disclose(vv) as Bytes<10>;"
      "  return v;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [1n,2n,3n,4n,5n,6n,7n,8n,9n,10n]).result).toEqual(new Uint8Array([1,2,3,4,5,6,7,8,9,10]));"
        "  });"
        ))
    )

  (test
    `(
      "module M<#N> {"
      "  export circuit foo(vv: Vector<N, Uint<8>>): Bytes<N> {"
      "    return vv as Bytes<N>;"
      "  }"
      "}"
      ,(format "import M<~d>;" (- (field-bytes) 1))
      "export { foo }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "const k = ~d\n" (- (field-bytes) 1))
        "  var a = Array.from({ length: k }, (v, i) => i+1);"
        "  expect(C.circuits.foo(Ctxt, a.map((t) => BigInt(t))).result).toEqual(new Uint8Array(a));"
        "  });"
        ))
    )

  (test
    `(
      "module M<#N> {"
      "  export circuit foo(vv: Vector<N, Uint<8>>): Bytes<N> {"
      "    return vv as Bytes<N>;"
      "  }"
      "}"
      ,(format "import M<~d>;" (field-bytes))
      "export { foo }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "const k = ~d\n" (field-bytes))
        "  var a = Array.from({ length: k }, (v, i) => i+1);"
        "  expect(C.circuits.foo(Ctxt, a.map((t) => BigInt(t))).result).toEqual(new Uint8Array(a));"
        "  });"
        ))
    )

  (test
    `(
      "module M<#N> {"
      "  export circuit foo(vv: Vector<N, Uint<8>>): Bytes<N> {"
      "    return vv as Bytes<N>;"
      "  }"
      "}"
      ,(format "import M<~d>;" (+ (* (field-bytes) 2) 1))
      "export { foo }"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "const k = ~d\n" (+ (* (field-bytes) 2) 1))
        "  var a = Array.from({ length: k }, (v, i) => i+1);"
        "  expect(C.circuits.foo(Ctxt, a.map((t) => BigInt(t))).result).toEqual(new Uint8Array(a));"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(v: Vector<0, Field>): Field {"
      "  const k = 0;"
      "  return v[k];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 10" "expected a non-empty vector or tuple type, received ~a" ("Vector<0, Field>")))
    )

  (test
    '(
      "export circuit foo(v: Vector<1, Field>): Field {"
      "  const k = 0;"
      "  return v[k];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [3n]).result).toEqual(3n);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(v: []): [] {"
      "  const k = 0;"
      "  return slice<0>(v, k);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, []).result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(v: [Field, Boolean, Uint<16>]): [] {"
      "  const k = 1;"
      "  return slice<1>(v, k);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 1 char 23" "~a should be a vector but has a tuple type ~a that cannot be converted to a vector because its element types are unrelated" ("tuple slice with a non-constant index" "[Field, Boolean, Uint<16>]")))
    )

  (test
    '(
      "export circuit foo(v: [Field, Uint<8>, Uint<16>]): [Field] {"
      "  const k = 1;"
      "  return slice<1>(v, k);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [3n, 5n, 7n]).result).toEqual([5n]);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(v: Vector<6, Field>): [Field, Field] {"
      "  const k = 2;"
      "  return slice<2>(v, k);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [3n, 5n, 7n, 11n, 13n, 17n]).result).toEqual([7n, 11n]);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: Vector<6, Uint<32>>;"
      "export circuit foo(iv: Vector<32, Uint<16>>): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  F = [v[0], ...slice<2>(v, 4), ...[v[15], v[16]], v[31]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n];"
        "  const q2 = [0n, 4n, 5n, 15n, 16n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q1);"
        "  expect(t.result).toEqual(q2);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: Vector<6, Uint<32>>;"
      "export circuit foo(iv: Vector<32, Uint<16>>): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  const k: Vector<2, Uint<16>> = slice<2>(v, 4);"
      "  F = [v[0], ...k, ...[v[15], v[16]], v[31]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n];"
        "  const q2 = [0n, 4n, 5n, 15n, 16n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q1);"
        "  expect(t.result).toEqual(q2);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: Vector<6, Uint<32>>;"
      "export circuit foo(iv: Vector<32, Uint<16>>): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  const k: Vector<2, Uint<16>> = slice<2>(v, 4);"
      "  // unused vector-construction form"
      "  const v2 = [v[0], ...k, ...[v[15], v[16]], v[31]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q1);"
        "  expect(t.result).toEqual([0n, 0n, 0n, 0n, 0n, 0n]);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: Vector<6, Uint<32>>;"
      "export circuit foo(iv: Vector<32, Uint<16>>): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  const k: [Uint<32>, Uint<32>] = slice<2>(v, 4);"
      "  // unused tuple-construction form"
      "  const v2 = [v[0], ...k, ...[v[15], v[16]], v[31]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q1);"
        "  expect(t.result).toEqual([0n, 0n, 0n, 0n, 0n, 0n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<4, Field>;"
      "export circuit foo(vi: [Field, Field, Field, Field, Field, Field]): [Field, Field, Field, Field] {"
      "  const v = disclose(vi);"
      "  const k = 2;"
      "  F = [v[k-2], ...slice<2>(v, k), v[k+3]];"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, [3n, 5n, 7n, 11n, 13n, 17n]).result).toEqual([3n, 7n, 11n, 17n]);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: Vector<6, Uint<32>>;"
      "export circuit foo(iv: Vector<32, Uint<16>>): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  F = [v[0], ...slice<2>(v, 4), ...[v[15], v[16]], v[31]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n];"
        "  const q2 = [0n, 4n, 5n, 15n, 16n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q1);"
        "  expect(t.result).toEqual(q2);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: Vector<6, Uint<32>>;"
      "export circuit foo(iv: Vector<32, Uint<16>>): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  const k: Vector<0, Boolean> = [];"
      "  F = [v[0], ...slice<2>(v, 4), ...k, ...[v[15], v[16]], v[31]];"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 7" "tuple/vector construction expression with vector-typed spreads has unrelated element types ~a and ~a" ("Uint<16>" "Boolean")))
    )

  (test
    '(
      "export ledger F: Vector<20, Uint<32>>;"
      "export circuit foo(iv: Vector<32, Uint<16>>): [Vector<11, Uint<32>>, Vector<12, Uint<32>>] {"
      "  const v = disclose(iv);"
      "  F = [v[0], ...slice<8>(v, 4), v[15], v[16], ...slice<8>(v, 20), v[31]];"
      "  const k = F;"
      "  return [slice<11>(k, 0), slice<12>(k, 8)];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n];"
        "  const q2 = [0n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 15n, 16n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 31n];"
        "  const q3 = [0n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 15n, 16n];"
        "  const q4 = [11n, 15n, 16n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q1);"
        "  expect(t.result).toEqual([q3, q4]);"
        "  Ctxt = t.context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.F).toEqual(q2);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: Vector<6, Uint<32>>;"
      "export circuit foo(iv: [Uint<1>, Uint<2>, Uint<3>, Uint<4>, Uint<5>, Uint<6>, Uint<7>, Uint<8>, Uint<9>, Uint<10>, Uint<11>, Uint<12>, Uint<13>, Uint<14>, Uint<15>, Uint<16>, Uint<17>, Uint<18>, Uint<19>, Uint<20>, Uint<21>, Uint<22>, Uint<23>, Uint<24>, Uint<25>, Uint<26>, Uint<27>, Uint<28>, Uint<29>, Uint<30>, Uint<31>, Uint<32>]): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  F = [v[0], ...slice<2>(v, 4), v[15], v[16], v[31]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n];"
        "  // TypeScript assigns type bigint[] to q1 then complains that it might not have enough elemenets for foo's tuple argument, so we have to cast it explicitly to a tuple of bigints."
        "  // In other words, to TypeScript, [expr, ..., expr] is always an array, and if the elements have different types, it is an array of some union type."
        "  const q2 = q1 as [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint];"
        "  const q3 = [0n, 4n, 5n, 15n, 16n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q2);"
        "  expect(t.result).toEqual(q3);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: [Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>];"
      "export circuit foo(iv: [Uint<1>, Uint<2>, Uint<3>, Uint<4>, Uint<5>, Uint<6>, Uint<7>, Uint<8>, Uint<9>, Uint<10>, Uint<11>, Uint<12>, Uint<13>, Uint<14>, Uint<15>, Uint<16>, Uint<17>, Uint<18>, Uint<19>, Uint<20>, Uint<21>, Uint<22>, Uint<23>, Uint<24>, Uint<25>, Uint<26>, Uint<27>, Uint<28>, Uint<29>, Uint<30>, Uint<31>, Uint<32>]): [Vector<11, Uint<32>>, Vector<12, Uint<32>>] {"
      "  const v = disclose(iv);"
      "  F = [v[0], ...slice<8>(v, 4), v[15], v[16], ...slice<8>(v, 20), v[31]];"
      "  const k = F;"
      "  return [slice<11>(k, 0), slice<12>(k, 8)];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  // stupid semicolon insertion doesn't allow this:"
        "  /*"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n]"
        "           as [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint];"
        "  */"
        "  // so we have to write it differently, e.g., with 'as' on the end of the first line:"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n] as"
        "           [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint];"
        "  const q2 = [0n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 15n, 16n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 31n];"
        "  const q3 = [0n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 15n, 16n];"
        "  const q4 = [11n, 15n, 16n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q1);"
        "  expect(t.result).toEqual([q3, q4]);"
        "  Ctxt = t.context;"
        "  let L = contractCode.ledger(Ctxt.currentQueryContext.state);"
        "  expect(L.F).toEqual(q2);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: [Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>];"
      "export circuit foo(iv: Vector<32, Uint<16>>): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  F = [v[0], ...slice<2>(v, 4), v[15], v[16], v[31]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n];"
        "  const q2 = [0n, 4n, 5n, 15n, 16n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q1);"
        "  expect(t.result).toEqual(q2);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: [Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>];"
      "export circuit foo(iv: Vector<32, Uint<16>>): Vector<6, Uint<32>> {"
      "  const v = disclose(iv);"
      "  const k1: [Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>, Uint<32>] = [v[0], ...slice<2>(v, 4), v[15], v[16], v[31]];"
      "  const k2: Vector<6, Uint<32>> = k1;"
      "  F = k2;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const q1 = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 16n, 17n, 18n, 19n, 20n, 21n, 22n, 23n, 24n, 25n, 26n, 27n, 28n, 29n, 30n, 31n];"
        "  const q2 = [0n, 4n, 5n, 15n, 16n, 31n];"
        "  const t = C.circuits.foo(Ctxt, q1);"
        "  expect(t.result).toEqual(q2);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: Vector<0, Uint<32>>;"
      "export circuit foo(iv: Vector<0, Uint<16>>): Vector<0, Uint<32>> {"
      "  const v = disclose(iv);"
      "  F = [...v, ...[], ...v];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, []);"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: Vector<0, Uint<32>>;"
      "export circuit foo(iv: []): Vector<0, Uint<32>> {"
      "  const v = disclose(iv);"
      "  F = [...map((x) => x, v), ...[]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, []);"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "struct S { a: Uint<64>, b: Boolean };"
      "export ledger F: Vector<7, S>;"
      "export circuit foo(iv: [Uint<2>, Uint<32>, Uint<4>, Uint<16>, Uint<8>]): Vector<3, S> {"
      "  const v = disclose(iv);"
      "  const k = 4;"
      "  F = [S { a: 9997, b: false}, ...map((x) => S { a: x, b: true }, v), S {a: 9999, b: false}];"
      "  return slice<3>(F, k);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, 5n, 7n, 9n, 11n]);"
        "  expect(t.result).toEqual([{a: 9n, b: true}, {a: 11n, b: true}, {a: 9999n, b: false}]);"
        "  let L = contractCode.ledger(t.context.currentQueryContext.state);"
        "  expect(L.F).toEqual([{a: 9997n, b: false}, {a: 3n, b: true}, {a: 5n, b: true}, {a: 7n, b: true}, {a: 9n, b: true}, {a: 11n, b: true}, {a: 9999n, b: false}]);"
        "  });"
        ))
    )

  (test
    '(
      "struct S { a: Uint<64>, b: Boolean };"
      "export ledger F: Vector<7, S>;"
      "export circuit foo(iv: [Uint<2>, Uint<32>, Uint<4>, Uint<16>, Uint<8>]): Vector<3, S> {"
      "  const v = disclose(iv);"
      "  const k = 4;"
      "  const t: Vector<6, S> = [S { a: 9997, b: false}, ...map((x) => S { a: x, b: true }, v), S {a: 9999, b: false}];"
      "  F = t;"
      "  return slice<3>(F, k);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 9" "mismatch between actual type ~a and declared type ~a of const binding" ("Vector<7, struct S<a: Uint<64>, b: Boolean>>" "Vector<6, struct S<a: Uint<64>, b: Boolean>>")))
    )

  (test
    '(
      "struct S { a: Uint<64>, b: Boolean };"
      "struct T { x: Bytes<3> };"
      "export ledger F: [ T, S, S, S, S, S, T ];"
      "export circuit foo(iv: [Uint<2>, Uint<32>, Uint<4>, Uint<16>, Uint<8>]): [ S, S, T ] {"
      "  const v = disclose(iv);"
      "  const k = 4;"
      "  const q = [S {v[4], true}, S {v[3], true}, S {v[2], true}, S {v[1], true}, S {v[0], true}];"
      "  F = [T {'abc'}, ...q, T {'zyx'}];"
      "  return slice<3>(F, k);"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 18" "~a should be a vector but has a tuple type ~a that cannot be converted to a vector because its element types are unrelated" ("tuple slice with a non-constant index" "[struct T<x: Bytes<3>>, struct S<a: Uint<64>, b: Boolean>, struct S<a: Uint<64>, b: Boolean>, struct S<a: Uint<64>, b: Boolean>, struct S<a: Uint<64>, b: Boolean>, struct S<a: Uint<64>, b: Boolean>, struct T<x: Bytes<3>>]")))
    )

  (test
    '(
      "struct S { a: Uint<64>, b: Boolean };"
      "struct T { x: Bytes<3> };"
      "export ledger F: [ T, S, S, S, S, S, T ];"
      "export circuit foo(iv: [Uint<2>, Uint<32>, Uint<4>, Uint<16>, Uint<8>]): [ S, S, T ] {"
      "  const v = disclose(iv);"
      "  const q = [S {v[4], true}, S {v[3], true}, S {v[2], true}, S {v[1], true}, S {v[0], true}];"
      "  F = [T {'abc'}, ...q, T {'zyx'}];"
      "  return slice<3>(F, 4);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, 5n, 7n, 9n, 11n]);"
        "  expect(t.result).toEqual([{a: 5n, b: true}, {a: 3n, b: true}, {x: new Uint8Array([0x7a, 0x79, 0x78])}]);"
        "  let L = contractCode.ledger(t.context.currentQueryContext.state);"
        "  expect(L.F).toEqual([{x: new Uint8Array([0x61, 0x62, 0x63])}, {a: 11n, b: true}, {a: 9n, b: true}, {a: 7n, b: true}, {a: 5n, b: true}, {a: 3n, b: true}, {x: new Uint8Array([0x7a, 0x79, 0x78])}]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Field>;"
      "export circuit foo(iv: [Uint<2>, Uint<32>, Uint<4>, Uint<16>, Uint<8>]): Vector<10, Field> {"
      "  const v = disclose(iv);"
      "  F = [...[...[...slice<3>(v, 0), ...[...slice<0>(v, 5), ...slice<4>(v, 1)], ...slice<0>(v, 3)], ...[], ...slice<3>(v, 2)]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, 5n, 7n, 9n, 11n]);"
        "  expect(t.result).toEqual([3n, 5n, 7n, 5n, 7n, 9n, 11n, 7n, 9n, 11n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Field>;"
      "export circuit foo(iv: Vector<5, Uint<8>>): Vector<10, Field> {"
      "  const v = disclose(iv);"
      "  F = [...[...[...slice<3>(v, 0), ...[...slice<0>(v, 5), ...slice<4>(v, 1)], ...slice<0>(v, 3)], ...[], ...slice<3>(v, 2)]];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, 5n, 7n, 9n, 11n]);"
        "  expect(t.result).toEqual([3n, 5n, 7n, 5n, 7n, 9n, 11n, 7n, 9n, 11n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<4, Field>;"
      "export circuit foo(v: Vector<2, Field>, i: Vector<2, Uint<32>>): Vector<4, Field> {"
      "  F = [...disclose(v), ...disclose(i)];"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, 5n], [7n, 9n]);"
        "  expect(t.result).toEqual([3n, 5n, 7n, 9n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<5, Field>;"
      "export circuit foo(v: Vector<2, Field>, i: Vector<2, Uint<32>>, q: Uint<8>): Vector<5, Field> {"
      "  F = disclose([...v, q, ...i]);"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, 5n], [7n, 9n], 11n);"
        "  expect(t.result).toEqual([3n, 5n, 11n, 7n, 9n]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger m: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit test(): Field {"
      "  m.insert(1000, default<Map<Field, Field>>);"
      "  m.lookup(1000).insert(2000, 1);"
      "  return m.lookup(1000).lookup(2000);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.test(Ctxt);"
        "  expect(t.result).toEqual(1n);"
        "  });"
        ))
  )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger m: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit test(x: Field): Field {"
      "  m.insert(1000, default<Map<Field, Field>>);"
      "  m.lookup(1000).insert(disclose(x), 1);"
      "  return m.lookup(1000).lookup(disclose(x));"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.test(Ctxt, 2n);"
        "  expect(t.result).toEqual(1n);"
        "  });"
        ))
  )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger m: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit test(x: Field): Field {"
      "  m.insert(disclose(x), default<Map<Field, Field>>);"
      "  m.lookup(disclose(x)).insert(1000, 1);"
      "  return m.lookup(disclose(x)).lookup(1000);"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.test(Ctxt, 2n);"
        "  expect(t.result).toEqual(1n);"
        "  });"
        ))
  )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger m: Map<Field, Map<Field, Field>>;"
      ""
      "export circuit test(x: Field, y: Field): Field {"
      "  m.insert(disclose(x), default<Map<Field, Field>>);"
      "  m.lookup(disclose(x)).insert(disclose(y), 1);"
      "  return m.lookup(disclose(x)).lookup(disclose(y));"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.test(Ctxt, 2n, 3n);"
        "  expect(t.result).toEqual(1n);"
        "  });"
        ))
  )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "ledger x: Opaque<'spam'>;"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 11" "opaque type ~a is not supported" ("spam")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(q: Opaque<'spam'>): [] {"
      "  const x = default<Opaque<'spam'>>;"
      "  assert(x == q, 'oops');"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 23" "opaque type ~a is not supported" ("spam")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "export circuit foo(): [] {"
      "  const x = default<Opaque<'spam'>>;"
      "  assert(x == default<Opaque<'spam'>>, 'oops');"
      "}"
     )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 21" "opaque type ~a is not supported" ("spam")))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = default<Bytes<0>>;"
      "  F = bv as Field;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual(0n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(ibv: Bytes<0>): Field {"
      "  const bv = disclose(ibv);"
      "  F = bv as Field;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([]));"
        "  expect(t.result).toEqual(0n);"
        "  });"
        ))
    )

  (test
    '(
      "struct S {"
      "  a: Boolean,"
      "  b: Field,"
      "}"
      ""
      "ledger F: [Boolean, Field];"
      "export circuit foo(): [Boolean, Field] {"
      "  const t1 = [true, default<S>];"
      "  const t2 = [...t1];"
      "  F = [t2[0], t2[1].b];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([true, 0n]);"
        "  });"
        ))
    )

  (test
    '(
      "struct S {"
      "  a: Boolean,"
      "  b: Field,"
      "}"
      ""
      "ledger F: [Boolean, Field];"
      "export circuit foo(): [Boolean, Field] {"
      "  const t0 = default<Vector<3, S>>;"
      "  const t1 = [true, [...t0]];"
      "  const t2 = [...t1];"
      "  F = [!t2[0], t2[1][2].b];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([false, 0n]);"
        "  });"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness getData(): Field;"
      "ledger hash: Field;"
      ""
      "export circuit test(): Field {"
      "    // disclose is needed for transientHash"
      "    hash = transientHash<Field>(getData());"
      "    return hash;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 8 char 10" "potential witness-value disclosure must be declared but is not:\n    witness value potentially disclosed:\n      ~a~{~a~}" ("the return value of witness getData at line 3 char 1" ("\n    nature of the disclosure:\n      ledger operation might disclose a hash of the witness value\n    via this path through the program:\n      the argument to transientHash at line 8 char 12\n      the right-hand side of = at line 8 char 10"))))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      ""
      "witness getData(): Field;"
      "witness getRandomness(): Field;"
      "ledger hash: Field;"
      ""
      "export circuit test(): Field {"
      "    // no disclose needed for transientCommit"
      "    hash = transientCommit<Field>(getData(), getRandomness());"
      "    return hash;"
      "}"
      )
    (stage-javascript
      '(
        "const witnesses = {"
        "  getData({privateState}: runtime.WitnessContext<any, number>): [number, bigint] { return [privateState, 37n]; },"
        "  getRandomness({privateState}: runtime.WitnessContext<any, number>): [number, bigint] { return [privateState, 59n]; },"
        "  };"
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, witnesses, 0);"
        "  const t = C.circuits.test(Ctxt);"
        "  expect(typeof(t.result)).toEqual('bigint');"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(bv: Bytes<10>): Vector<10, Uint<16>> {"
      "  return [...bv];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([1,2,3,4,5,6,7,8,9,10])).result).toEqual([1n,2n,3n,4n,5n,6n,7n,8n,9n,10n]);"
        "  });"
        ))
    )

   (test
    '(
      "export circuit foo(bv: Bytes<0>): Vector<0, Uint<16>> {"
      "  return [...bv];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([])).result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "export circuit foo(bv: Bytes<4>): Vector<10, Uint<16>> {"
      "  return [...bv, 17, 60000, ...bv];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([1,2,3,4])).result).toEqual([1n,2n,3n,4n,17n,60000n,1n,2n,3n,4n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<5>;"
      "export circuit foo(a: Uint<3>, b: Uint<4>, c: Uint<5>): Bytes<5> {"
      "  F = disclose(Bytes[a, b, c, a + b, a + c]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, 5n, 7n, 9n);"
        "  expect(t.result).toEqual(new Uint8Array([5, 7, 9, 12, 14]));"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<5>;"
      "export circuit foo(a: Uint<3>, b: Uint<4>, c: Uint<5>): Bytes<5> {"
      "  F = disclose(Bytes[a, ...Bytes[], b, c, ...Bytes[a + b, a + c]]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, 5n, 7n, 9n);"
        "  expect(t.result).toEqual(new Uint8Array([5, 7, 9, 12, 14]));"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<5>;"
      "export circuit foo(a: Uint<3>, b: Uint<4>, c: Uint<5>): Bytes<5> {"
      "  const v: Vector<0, Uint<8>> = [];"
      "  F = disclose(Bytes[a, b, ...[], ...v, c, ...[a + b as Uint<8>, a + c]]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, 5n, 7n, 9n);"
        "  expect(t.result).toEqual(new Uint8Array([5, 7, 9, 12, 14]));"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<5>;"
      "export circuit foo(a: Uint<3>, b: Uint<4>, c: Uint<5>): Bytes<5> {"
      "  const k: Vector<2, Uint<8>> = [a + b, a + c];"
      "  F = disclose(Bytes[a, b, c, ...k]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, 5n, 7n, 9n);"
        "  expect(t.result).toEqual(new Uint8Array([5, 7, 9, 12, 14]));"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<5>;"
      "export circuit foo(a: Uint<3>, b: Uint<4>, c: Uint<5>): Bytes<5> {"
      "  const k: Vector<2, Uint<6>> = [a + b, a + c];"
      "  F = disclose(Bytes[a, b, c, ...k]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, 5n, 7n, 9n);"
        "  expect(t.result).toEqual(new Uint8Array([5, 7, 9, 12, 14]));"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<5>;"
      "export circuit foo(a: Uint<3>, b: Uint<4>, c: Uint<5>, d: Vector<2, Uint<6>>): Bytes<5> {"
      "  F = disclose(Bytes[a, b, c, ...d]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, 5n, 7n, 9n, [12n, 14n]);"
        "  expect(t.result).toEqual(new Uint8Array([5, 7, 9, 12, 14]));"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<1003>;"
      "export circuit foo(a: Uint<3>, b: Uint<4>, c: Uint<5>, d: Vector<1000, Uint<6>>): Bytes<1003> {"
      "  F = disclose(Bytes[a, b, c, ...d]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, 5n, 7n, 9n, new Array(1000).fill(37n));"
        "  expect(t.result.length).toEqual(1003);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: [Bytes<5>, Uint<8>];"
      "export circuit foo(bv: Bytes<10>): [Bytes<5>, Uint<8>] {"
      "  F = disclose([slice<5>(bv, 1), bv[8]]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual([new Uint8Array([5, 7, 9, 11, 13]), 19n]);"
        "  });"
        ))
    )

  (test
    '(
      "export ledger F: [Bytes<5>, Uint<8>];"
      "export circuit foo(bv: Bytes<10>): [Bytes<5>, Uint<8>] {"
      "  const t = [slice<5>(bv, 1), bv[8]];"
      "  F = disclose(t);"
      "  return t;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual([new Uint8Array([5, 7, 9, 11, 13]), 19n]);"
        "  let L = contractCode.ledger(t.context.currentQueryContext.state);"
        "  expect(L.F).toEqual([new Uint8Array([5, 7, 9, 11, 13]), 19n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: [Bytes<5>, Uint<8>];"
      "export circuit foo(bv: Bytes<10>): [Bytes<5>, Uint<8>] {"
      "  const k1 = 1;"
      "  const k2 = 8;"
      "  F = disclose([slice<5>(bv, k1), bv[k2]]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual([new Uint8Array([5, 7, 9, 11, 13]), 19n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<9>;"
      "export circuit foo(bv: Bytes<10>): Bytes<9> {"
      "  const k1 = 1;"
      "  const k2 = 9;"
      "  F = disclose(Bytes[...slice<5>(bv, k1), bv[k2], ...slice<3>(bv, 6)]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual(new Uint8Array([5, 7, 9, 11, 13, 21, 15, 17, 19]));"
        "  });"
        ))
    )

 (let* ([input-size (* (field-bytes) 2)]
        [output-size (field-bytes)]
        [start-index 0]
        [ls (reverse (iota input-size))])
  (test
    `(
      ,(format "ledger F: Bytes<~d>;" output-size)
      ,(format "export circuit foo(bv: Bytes<~d>): Bytes<~d> {" input-size output-size)
      ,(format "  F = Bytes[...slice<~d>(disclose(bv), ~d)];" output-size start-index)
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" ls)
        ,(format "  expect(t.result).toEqual(new Uint8Array([~{~d~^, ~}]));" (list-head (list-tail ls start-index) output-size))
        "  });"
        ))
    ))

 (let* ([input-size (* (field-bytes) 2)]
        [output-size (+ (field-bytes) 1)]
        [start-index 0]
        [ls (reverse (iota input-size))])
  (test
    `(
      ,(format "ledger F: Bytes<~d>;" output-size)
      ,(format "export circuit foo(bv: Bytes<~d>): Bytes<~d> {" input-size output-size)
      ,(format "  F = Bytes[...slice<~d>(disclose(bv), ~d)];" output-size start-index)
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" (reverse (iota input-size)))
        ,(format "  expect(t.result).toEqual(new Uint8Array([~{~d~^, ~}]));" (list-head (list-tail ls start-index) output-size))
        "  });"
        ))
    ))

 (let* ([input-size (* (field-bytes) 2)]
        [output-size (+ (field-bytes) 1)]
        [start-index 7]
        [ls (reverse (iota input-size))])
  (test
    `(
      ,(format "ledger F: Bytes<~d>;" output-size)
      ,(format "export circuit foo(bv: Bytes<~d>): Bytes<~d> {" input-size output-size)
      ,(format "  F = Bytes[...slice<~d>(disclose(bv), ~d)];" output-size start-index)
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" (reverse (iota input-size)))
        ,(format "  expect(t.result).toEqual(new Uint8Array([~{~d~^, ~}]));" (list-head (list-tail ls start-index) output-size))
        "  });"
        ))
    ))

 (let* ([input-size (* (field-bytes) 2)]
        [output-size (+ (field-bytes) 1)]
        [start-index 7]
        [ls (reverse (iota input-size))])
  (test
    `(
      ,(format "ledger F: Bytes<~d>;" output-size)
      ,(format "export circuit foo(v: Vector<~d, Uint<8>>): Bytes<~d> {" input-size output-size)
      ,(format "  F = Bytes[...slice<~d>(disclose(v), ~d)];" output-size start-index)
      "  return F;"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.32 (tbytes 32))
          (%descriptor.33 (tunsigned 255))
          (%descriptor.34 (tvector 62 (tunsigned 255)))
          (%descriptor.35 (tunsigned 18446744073709551615))
          (%descriptor.36 (tboolean))
          (%descriptor.37 (tstruct ContractAddress
                            (bytes (tbytes 32))))
          (%descriptor.38 (tunsigned
                            340282366920938463463374607431768211455)))
        (kernel-declaration (%kernel.39 () (Kernel)))
        (public-ledger-declaration
          ((%F.40 (0) (__compact_Cell (tbytes 32))))
          (constructor () (tuple)))
        (circuit %foo.41 ([%v.42 (tvector 62 (tunsigned 255))])
             (tbytes 32)
          (seq
            (seq
              (const [%tmp.43 (tbytes 32)]
                (vector->bytes
                  32
                  (vector (spread 32 (tuple-slice %v.42 7 32)))))
              (public-ledger %F.40 (0) write %tmp.43))
            (public-ledger %F.40 (0) read)))))
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, [~{~dn~^, ~}]);" (reverse (iota input-size)))
        ,(format "  expect(t.result).toEqual(new Uint8Array([~{~d~^, ~}]));" (list-head (list-tail ls start-index) output-size))
        "  });"
        ))
    ))

  (test
    `(
      "export circuit foo(bv: Bytes<10>): Boolean {"
      "  const k = Bytes[true, ...slice<8>(disclose(bv), 1)];"
      "  return k[0];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 19" "expected type of Bytes constructor argument to be a subtype of Uint<8> but received ~a" ("Boolean")))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      "export circuit foo(bv: Bytes<10>): Bytes<10> {"
      "  F = Bytes[255, ...slice<8>(disclose(bv), 1), 0];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array(10).fill(37));"
        "  expect(t.result).toEqual(new Uint8Array([255, 37, 37, 37, 37, 37, 37, 37, 37, 0]));"
        "  });"
        ))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      "export circuit foo(v: Vector<10, Uint<8>>): Bytes<10> {"
      "  F = Bytes[254, ...slice<8>(disclose(v), 1), 0];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Array(10).fill(255n));"
        "  expect(t.result).toEqual(new Uint8Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 0]));"
        "  expect(() => C.circuits.foo(Ctxt, new Array(10).fill(256n))).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, new Array(10).fill(256n))).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 2 char 1; expected value of type Vector<10, Uint<0..256>> but received [ 256n, 256n, 256n, 256n, 256n, 256n, 256n, 256n, 256n, 256n ]');"
        "  });"
        ))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      "export circuit foo(v: Vector<10, Uint<8>>): Bytes<10> {"
      "  F = Bytes[254, ...Bytes[...slice<4>(disclose(v), 1), ...slice<0>(disclose(v), 0), ...slice<4>(disclose(v), 5)], ...[], ...Bytes[], 0];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Array(10).fill(255n));"
        "  expect(t.result).toEqual(new Uint8Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 0]));"
        "  expect(() => C.circuits.foo(Ctxt, new Array(10).fill(256n))).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, new Array(10).fill(256n))).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 2 char 1; expected value of type Vector<10, Uint<0..256>> but received [ 256n, 256n, 256n, 256n, 256n, 256n, 256n, 256n, 256n, 256n ]');"
        "  });"
        ))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      "export circuit foo(bv: Bytes<10>): Bytes<10> {"
      "  F = Bytes[...slice<8>(disclose(bv), 1), 0, 256];"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 46" "expected type of Bytes constructor argument to be a subtype of Uint<8> but received ~a" ("Uint<0..257>")))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      "export circuit foo(v: Vector<10, Uint<0..257>>): Bytes<10> {"
      "  F = Bytes[...slice<8>(disclose(v), 1), 0, 255];"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 13" "expected type of Bytes spread to be a Bytes value or a Tuple or Vector of Uint<8> subtypes but received ~a" ("Vector<8, Uint<0..257>>")))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      "export circuit foo(): Bytes<10> {"
      "  const t = [0, 7, 107, 207, 255, 256, 17, 27];"
      "  F = Bytes[0, ...t, 1];"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 16" "expected type of Bytes spread to be a Bytes value or a Tuple or Vector of Uint<8> subtypes but received ~a" ("[Uint<0..1>, Uint<3>, Uint<0..108>, Uint<0..208>, Uint<8>, Uint<0..257>, Uint<0..18>, Uint<0..28>]")))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      "export circuit foo(): Bytes<10> {"
      "  const t = [0, 7, 107, 207, 255, false, 17, 27];"
      "  F = Bytes[0, ...t, 1];"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 16" "expected type of Bytes spread to be a Bytes value or a Tuple or Vector of Uint<8> subtypes but received ~a" ("[Uint<0..1>, Uint<3>, Uint<0..108>, Uint<0..208>, Uint<8>, Boolean, Uint<0..18>, Uint<0..28>]")))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      "export circuit foo(v: Vector<10, Field>): Bytes<10> {"
      "  F = Bytes[...slice<8>(disclose(v), 1), 0, 255];"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 13" "expected type of Bytes spread to be a Bytes value or a Tuple or Vector of Uint<8> subtypes but received ~a" ("Vector<8, Field>")))
    )

  (test
    `(
      "ledger F: Bytes<10>;"
      "export circuit foo(v: Vector<10, Boolean>): Bytes<10> {"
      "  F = Bytes[...slice<8>(disclose(v), 1), 0, 255];"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 13" "expected type of Bytes spread to be a Bytes value or a Tuple or Vector of Uint<8> subtypes but received ~a" ("Vector<8, Boolean>")))
    )

  (test
    `(
      "export circuit foo(bv: Bytes<10>): Field {"
      "  const k = [...slice<6>(disclose(bv), 2), false];"
      "  return k[0];"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 2 char 13" "tuple/vector construction expression with vector-typed spreads has unrelated element types ~a and ~a" ("Uint<8>" "Boolean")))
    )

  (test
    '(
      "export pure circuit foo(bv: Bytes<10000>): Bytes<7000> {"
      "  return Bytes[...slice<7000>(disclose(bv), 1000)];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array(10000).fill(37));"
        "  expect(t.result.length).toEqual(7000);"
        "  });"
        ))
    )

  (test
    '(
      "export pure circuit foo(bv: Bytes<10000>): Vector<7000, Uint<8>> {"
      "  return [...slice<7000>(disclose(bv), 1000)];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array(10000).fill(37));"
        "  expect(t.result.length).toEqual(7000);"
        "  });"
        ))
    )

  (test
    '(
      "export pure circuit foo(v: Vector<10000, Uint<8>>): Vector<7000, Uint<8>> {"
      "  return [...slice<7000>(disclose(v), 1000)];"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Array(10000).fill(37n));"
        "  expect(t.result.length).toEqual(7000);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<70>;"
      "export circuit foo(v: Vector<1000, Uint<6>>): Bytes<70> {"
      "  F = Bytes[...slice<70>(disclose(v), 0)];"
      "  return F;"
      "}"
      )
    (returns
      (program
        (type-descriptors
          (%descriptor.70 (tbytes 70))
          (%descriptor.71 (tunsigned 63))
          (%descriptor.72 (tvector 1000 (tunsigned 63)))
          (%descriptor.73 (tunsigned 18446744073709551615))
          (%descriptor.74 (tboolean))
          (%descriptor.75 (tbytes 32))
          (%descriptor.76 (tstruct ContractAddress
                            (bytes (tbytes 32))))
          (%descriptor.77 (tunsigned 255))
          (%descriptor.78 (tunsigned
                            340282366920938463463374607431768211455)))
        (kernel-declaration (%kernel.79 () (Kernel)))
        (public-ledger-declaration
          ((%F.80 (0) (__compact_Cell (tbytes 70))))
          (constructor () (tuple)))
        (circuit %foo.81 ([%v.82 (tvector 1000 (tunsigned 63))])
             (tbytes 70)
          (seq
            (seq
              (const [%tmp.83 (tbytes 70)]
                (vector->bytes
                  70
                  (vector
                    (spread
                      70
                      (safe-cast (tvector 70 (tunsigned 255))
                                 (tvector 70 (tunsigned 63))
                        (tuple-slice %v.82 0 70))))))
              (public-ledger %F.80 (0) write %tmp.83))
            (public-ledger %F.80 (0) read)))))
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Array(1000).fill(37n));"
        "  expect(t.result.length).toEqual(70);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv: Bytes<10>): Vector<10, Uint<16>> {"
      "  F = map((x) => x + 1, disclose(bv));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual([4n, 6n, 8n, 10n, 12n, 14n, 16n, 18n, 20n, 22n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv: Bytes<10>): Vector<10, Uint<16>> {"
      "  F = map((x: Uint<8>) => x + 1, disclose(bv));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual([4n, 6n, 8n, 10n, 12n, 14n, 16n, 18n, 20n, 22n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv: Bytes<10>): Vector<10, Uint<16>> {"
      "  F = map((x: Uint<7>) => x + 1, disclose(bv));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>") ("Uint<7>"))))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(bv: Bytes<10>): Vector<0, Uint<16>> {"
      "  F = map((x: Uint<9>) => x + 1, disclose(slice<0>(bv, 7)));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(bv: Bytes<10>): Vector<0, Uint<16>> {"
      "  F = map((x: Uint<7>) => x + 1, disclose(slice<0>(bv, 7)));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>") ("Uint<7>"))))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(): Vector<10, Uint<16>> {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x) => x + 1, disclose(bv));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([4n, 6n, 8n, 10n, 12n, 14n, 16n, 18n, 20n, 22n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(): Vector<10, Uint<16>> {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x: Uint<8>) => x + 1, disclose(bv));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([4n, 6n, 8n, 10n, 12n, 14n, 16n, 18n, 20n, 22n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(): Vector<10, Uint<16>> {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x: Uint<8>) => x + 1, disclose(bv));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([4n, 6n, 8n, 10n, 12n, 14n, 16n, 18n, 20n, 22n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(): Vector<10, Uint<16>> {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x: Uint<7>) => x + 1, disclose(bv));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>") ("Uint<7>"))))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(): Vector<0, Uint<16>> {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x: Uint<9>) => x + 1, disclose(slice<0>(bv, 7)));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(): Vector<0, Uint<16>> {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x: Uint<7>) => x + 1, disclose(slice<0>(bv, 7)));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>") ("Uint<7>"))))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  F = map((x, y) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([8n, 14n, 20n, 26n, 32n, 28n, 34n, 40n, 46n, 52n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  F = map((x: Uint<8>, y: Uint<8>) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([8n, 14n, 20n, 26n, 32n, 28n, 34n, 40n, 46n, 52n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  F = map((x: Uint<8>, y: Uint<8>) => x * 2 + y, disclose(bv1), disclose(bv2));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "mismatch in ~s-argument vector lengths" (map)))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  F = map((x: Uint<9>, y: Uint<9>) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([8n, 14n, 20n, 26n, 32n, 28n, 34n, 40n, 46n, 52n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  F = map((x: Uint<7>, y: Uint<8>) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<8>") ("Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  F = map((x: Uint<8>, y: Uint<7>) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<8>") ("Uint<8>" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<0, Uint<16>> {"
      "  F = map((x, y) => x * 2 + y, disclose(slice<0>(bv1, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<0, Uint<16>> {"
      "  F = map((x: Uint<8>, y: Uint<8>) => x * 2 + y, disclose(slice<0>(bv2, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<0, Uint<16>> {"
      "  F = map((x: Uint<9>, y: Uint<9>) => x * 2 + y, disclose(slice<0>(bv2, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  F = map((x: Uint<7>, y: Uint<8>) => x * 2 + y, disclose(slice<0>(bv2, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<8>") ("Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  F = map((x: Uint<8>, y: Uint<7>) => x * 2 + y, disclose(slice<0>(bv2, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<8>") ("Uint<8>" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x, y) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([8n, 14n, 20n, 26n, 32n, 28n, 34n, 40n, 46n, 52n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>): Vector<10, Uint<16>> {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = map((x: Uint<8>, y: Uint<8>) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual([8n, 14n, 20n, 26n, 32n, 28n, 34n, 40n, 46n, 52n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x: Uint<8>, y: Uint<8>) => x * 2 + y, disclose(bv1), disclose(bv2));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "mismatch in ~s-argument vector lengths" (map)))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>): Vector<10, Uint<16>> {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = map((x: Uint<9>, y: Uint<9>) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual([8n, 14n, 20n, 26n, 32n, 28n, 34n, 40n, 46n, 52n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x: Uint<7>, y: Uint<8>) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<8>") ("Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>): Vector<10, Uint<16>> {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = map((x: Uint<8>, y: Uint<7>) => x * 2 + y, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<8>") ("Uint<8>" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(bv2: Bytes<5>): Vector<0, Uint<16>> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x, y) => x * 2 + y, disclose(slice<0>(bv1, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>): Vector<0, Uint<16>> {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = map((x: Uint<8>, y: Uint<8>) => x * 2 + y, disclose(slice<0>(bv2, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<0, Uint<16>>;"
      "export circuit foo(bv2: Bytes<5>): Vector<0, Uint<16>> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x: Uint<9>, y: Uint<9>) => x * 2 + y, disclose(slice<0>(bv2, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>): Vector<0, Uint<16>> {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = map((x: Uint<7>, y: Uint<8>) => x * 2 + y, disclose(slice<0>(bv2, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<8>") ("Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv2: Bytes<5>): Vector<0, Uint<16>> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = map((x: Uint<8>, y: Uint<7>) => x * 2 + y, disclose(slice<0>(bv2, 0)), disclose(Bytes[]));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<8>") ("Uint<8>" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv2: Bytes<5>): Vector<10, Uint<16>> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  const bv3 = Bytes[1, 3, 5, 7, 9, 11, 13, 15, 17, 19];"
      "  F = map((x: Uint<9>, y: Uint<8>, z) => x * 2 + y + 3 * z, disclose(bv1), disclose(Bytes[...bv2, ...bv2]), disclose(bv3));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual([11n, 23n, 35n, 47n, 59n, 61n, 73n, 85n, 97n, 109n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(): Vector<10, Uint<16>> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  const bv3 = Bytes[1, 3, 5, 7, 9, 11, 13, 15, 17, 19];"
      "  F = map((x: Uint<9>, y: Uint<8>, z) => x * 2 + y + 3 * z, disclose(bv1), disclose([...bv2, ...bv2]), disclose(bv3));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([11n, 23n, 35n, 47n, 59n, 61n, 73n, 85n, 97n, 109n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Field>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<5, Uint<8>>, bv3: Bytes<10>): Vector<10, Field> {"
      "  F = map((x: Uint<9>, y: Uint<8>, z: Field) => x * 2 + y + 3 * z, disclose(bv1), disclose([...bv2, ...bv2]), disclose(bv3));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), [2n, 4n, 6n, 8n, 10n], new Uint8Array([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]));"
        "  expect(t.result).toEqual([11n, 23n, 35n, 47n, 59n, 61n, 73n, 85n, 97n, 109n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Field>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<4, Uint<8>>, bv3: Bytes<10>): Vector<10, Field> {"
      "  F = map((x: Uint<9>, y: Uint<8>, z: Field) => x * 2 + y + 3 * z, disclose(bv1), disclose([...bv2, ...bv2]), disclose(bv3));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "mismatch in ~s-argument vector lengths" (map)))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<5, Uint<8>>, bv3: Bytes<10>): Vector<10, Field> {"
      "  F = map((x: Uint<9>, y: Uint<7>, z) => x * 2 + y + 3 * z, disclose(bv1), disclose([...bv2, ...bv2]), disclose(bv3));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<8>" "Uint<8>") ("Uint<9>" "Uint<7>" "Undeclared"))))
    )

  (test
    '(
      "ledger F: Vector<0, Field>;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<5, Uint<8>>, bv3: Bytes<10>): Vector<0, Field> {"
      "  F = map((x: Uint<9>, y: Uint<8>, z: Field) => x * 2 + y + 3 * z, disclose(slice<0>(bv1, 0)), disclose(slice<0>([...bv2, ...bv2], 0)), disclose(slice<0>(bv3, 0)));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), [2n, 4n, 6n, 8n, 10n], new Uint8Array([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]));"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10000, Field>;"
      "export circuit foo(bv1: Bytes<10000>, bv2: Vector<5000, Uint<8>>, bv3: Bytes<10000>): Vector<10000, Field> {"
      "  F = map((x: Uint<9>, y: Uint<8>, z: Field) => x * 2 + y + 3 * z, disclose(bv1), disclose([...bv2, ...bv2]), disclose(bv3));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array(10000).fill(37), new Array(5000).fill(41n), new Uint8Array(10000).fill(43));"
        "  expect(t.result.length).toEqual(10000);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Field>;"
      "export circuit foo(): Vector<10, Field> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  const bv2 = [2, 4, 6, 8, 10];"
      "  const bv3 = Bytes[1, 3, 5, 7, 9, 11, 13, 15, 17, 19];"
      "  F = map((x: Uint<9>, y: Uint<8>, z: Field) => x * 2 + y + 3 * z, disclose(bv1), disclose([...bv2, ...bv2]), disclose(bv3));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([11n, 23n, 35n, 47n, 59n, 61n, 73n, 85n, 97n, 109n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<10, Field>;"
      "export circuit foo(): Vector<10, Field> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  const bv2 = [2, 4, 8, 10];"
      "  const bv3 = Bytes[1, 3, 5, 7, 9, 11, 13, 15, 17, 19];"
      "  F = map((x: Uint<9>, y: Uint<8>, z: Field) => x * 2 + y + 3 * z, disclose(bv1), disclose([...bv2, ...bv2]), disclose(bv3));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 7" "mismatch in ~s-argument vector lengths" (map)))
    )

  (test
    '(
      "ledger F: Vector<10, Uint<16>>;"
      "export circuit foo(): Vector<10, Uint<16>> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  const bv2 = [2, 4, 6, 8, 10];"
      "  const bv3 = Bytes[1, 3, 5, 7, 9, 11, 13, 15, 17, 19];"
      "  F = map((x: Uint<7>, y: Uint<9>, z) => x * 2 + y + 3 * z, disclose(bv1), disclose([...bv2, ...bv2]), disclose(bv3));"
      " return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 6 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<8>" "Uint<0..11>" "Uint<8>") ("Uint<7>" "Uint<9>" "Undeclared"))))
    )

  (test
    '(
      "ledger F: Vector<0, Field>;"
      "export circuit foo(): Vector<0, Field> {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  const bv2 = [2, 4, 6, 8, 10];"
      "  const bv3 = Bytes[1, 3, 5, 7, 9, 11, 13, 15, 17, 19];"
      "  F = map((x: Uint<9>, y: Uint<8>, z: Field) => x * 2 + y + 3 * z, disclose(slice<0>(bv1, 0)), disclose(slice<0>([...bv2, ...bv2], 0)), disclose(slice<0>(bv3, 0)));"
      " return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv: Bytes<10>): Field {"
      "  F = fold((q: Field, x) => q + x + 1, 7, disclose(bv));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual(137n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv: Bytes<10>): Field {"
      "  F = fold((q: Field, x: Uint<8>) => q + x + 1, 7, disclose(bv));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual(137n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv: Bytes<10>): Field {"
      "  F = fold((q: Field, x: Uint<7>) => q + x + 1, 7, disclose(bv));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>") ("Field" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv: Bytes<0>): Field {"
      "  F = fold((q: Field, x: Uint<8>) => q + x + 1, 7, disclose(bv));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([]));"
        "  expect(t.result).toEqual(7n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv: Bytes<0>): Field {"
      "  F = fold((q: Field, x: Uint<7>) => q + x + 1, 7, disclose(bv));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>") ("Field" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = fold((q: Field, x) => q + x + 1, 7, bv);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual(137n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = fold((q: Field, x: Uint<8>) => q + x + 1, 7, bv);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual(137n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = fold((q: Field, x: Uint<7>) => q + x + 1, 7, bv);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>") ("Field" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[];"
      "  F = fold((q: Field, x: Uint<8>) => q + x + 1, 7, bv);"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual(7n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[];"
      "  F = fold((q: Field, x: Uint<7>) => q + x + 1, 7, bv);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>") ("Field" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Field {"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(bv2));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "mismatch in ~s-argument vector lengths" (fold)))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Field {"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual(23549n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Field {"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual(23549n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Field {"
      "  F = fold((q: Field, x: Uint<7>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Field {"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<7>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<8>" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Field {"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(slice<0>(bv1, 0)), disclose(Bytes[]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual(7n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Field {"
      "  F = fold((q: Field, x: Uint<7>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(slice<0>(bv1, 5)), disclose(Bytes[]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Bytes<5>): Field {"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<7>) => q * 2 + x + y * 3, 7, disclose(slice<0>(bv1, 5)), disclose(Bytes[]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<8>" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv2: Bytes<5>): Field {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([2, 4, 6, 8, 10]));"
        "  expect(t.result).toEqual(23549n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>): Field {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual(23549n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv2: Bytes<5>): Field {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = fold((q: Field, x: Uint<7>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>): Field {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = fold((q: Field, x: Uint<7>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv3: Bytes<10>): Field {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>, z: Uint<8>) => q * 2 + x + 2 * y - z, 7, disclose(bv1), Bytes[...bv2, ...bv2], disclose(bv3));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), new Uint8Array([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]));"
        "  expect(t.result).toEqual(16738n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>): Field {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(bv2));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "mismatch in ~s-argument vector lengths" (fold)))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  const bv3 = Bytes[1, 3, 5, 7, 9, 11, 13, 15, 17, 19];"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>, z: Uint<8>) => q * 2 + x + 2 * y - z, 7, disclose(bv1), Bytes[...bv2, ...bv2], disclose(bv3));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual(16738n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>): Field {"
      "  const bv2 = Bytes[];"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(slice<0>(bv1, 3)), disclose(bv2));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual(7n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<5, Uint<6>>): Field {"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(bv2));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "mismatch in ~s-argument vector lengths" (fold)))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<5, Field>): Field {"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(bv1), disclose([...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), [2n, 4n, 6n, 8n, 10n]);"
        "  expect(t.result).toEqual(23549n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<5, Uint<8>>): Field {"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose([...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), [2n, 4n, 6n, 8n, 10n]);"
        "  expect(t.result).toEqual(23549n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<5, Uint<8>>): Field {"
      "  F = fold((q: Field, x: Uint<7>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose([...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<5, Uint<8>>): Field {"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<7>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose([...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<8>" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<5, Uint<8>>): Field {"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(slice<0>(bv1, 0)), disclose([]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]), [2n, 4n, 6n, 8n, 10n]);"
        "  expect(t.result).toEqual(7n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<0, Uint<8>>): Field {"
      "  F = fold((q: Field, x: Uint<7>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(slice<0>(bv1, 5)), disclose(bv2));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>, bv2: Vector<0, Uint<8>>): Field {"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<7>) => q * 2 + x + y * 3, 7, disclose(slice<0>(bv1, 5)), disclose(bv2));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<8>" "Uint<7>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv2: Vector<5, Uint<8>>): Field {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(bv1), disclose([...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [2n, 4n, 6n, 8n, 10n]);"
        "  expect(t.result).toEqual(23549n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Bytes<10>): Field {"
      "  const bv2 = [2, 4, 6, 8, 10];"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose([...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual(23549n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv2: Vector<5, Uint<8>>): Field {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  F = fold((q: Field, x: Uint<7>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose([...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Vector<10, Uint<8>>): Field {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = fold((q: Field, x: Uint<7>, y: Uint<8>) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(Bytes[...bv2, ...bv2]));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "incompatible arguments in call to anonymous circuit\n    supplied argument types:\n      (~{~a~^, ~})\n    declared circuit type:\n      (~{~a~^, ~})" (("Uint<3>" "Uint<8>" "Uint<8>") ("Field" "Uint<7>" "Uint<8>"))))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Vector<10, Uint<8>>, bv3: Bytes<10>): Field {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>, z: Uint<8>) => q * 2 + x + 2 * y - z, 7, disclose(bv1), Bytes[...bv2, ...bv2], disclose(bv3));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, 5n, 7n, 9n, 11n, 13n, 15n, 17n, 19n, 21n], new Uint8Array([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]));"
        "  expect(t.result).toEqual(16738n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Vector<10, Uint<8>>): Field {"
      "  const bv2 = Bytes[2, 4, 6, 8, 10];"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(bv1), disclose(bv2));"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 7" "mismatch in ~s-argument vector lengths" (fold)))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv1 = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  const bv2 = [2, 4, 6, 8, 10];"
      "  const bv3 = Bytes[1, 3, 5, 7, 9, 11, 13, 15, 17, 19];"
      "  F = fold((q: Field, x: Uint<8>, y: Uint<8>, z: Uint<8>) => q * 2 + x + 2 * y - z, 7, disclose(bv1), [...bv2, ...bv2], disclose(bv3));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual(16738n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv1: Vector<10, Field>): Field {"
      "  const bv2 = Bytes[];"
      "  F = fold((q: Field, x, y) => q * 2 + x + y * 3, 7, disclose(slice<0>(bv1, 3)), disclose(bv2));"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, [3n, 5n, 7n, 9n, 11n, 13n, 15n, 17n, 19n, 21n]);"
        "  expect(t.result).toEqual(7n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv: Bytes<10>): Field {"
      "  for (const n of disclose(bv)) F = F * 2 + n;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual(5095n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Boolean;"
      "export circuit foo(bv: Bytes<10>): Boolean {"
      "  for (const n of disclose(bv)) F = n ? F : !F;"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 37" "expected test to have type Boolean, received ~a" ("Uint<8>")))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  for (const n of disclose(bv)) F = F * 2 + n;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual(5095n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Boolean;"
      "export circuit foo(): Boolean {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  for (const n of disclose(bv)) F = n ? F : !F;"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 37" "expected test to have type Boolean, received ~a" ("Uint<8>")))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(bv: Bytes<0>): Field {"
      "  for (const n of disclose(bv)) F = F * 2 + n;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([]));"
        "  expect(t.result).toEqual(0n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Boolean;"
      "export circuit foo(bv: Bytes<0>): Boolean {"
      "  for (const n of disclose(bv)) F = n ? F : !F;"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 3 char 37" "expected test to have type Boolean, received ~a" ("Uint<8>")))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[];"
      "  for (const n of bv) F = F * 2 + n;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual(0n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Boolean;"
      "export circuit foo(): Boolean {"
      "  const bv = Bytes[];"
      "  for (const n of bv) F = n ? F : !F;"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 27" "expected test to have type Boolean, received ~a" ("Uint<8>")))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(ibv: Bytes<10>): Field {"
      "  const bv = disclose(ibv);"
      "  const k = bv[3]; // intentionally unused"
      "  for (const n of 1..10) {"
      "    F = F * bv[0] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([3, 5, 7, 9, 11, 13, 15, 17, 19, 21]));"
        "  expect(t.result).toEqual(59037n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(ibv: Bytes<10>): Field {"
      "  const bv = disclose(ibv);"
      "  for (const n of 1..10) {"
      "    F = F * bv[10] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 13" "invalid Bytes index ~d for a Bytes value of length ~d" (10 10)))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(ibv: Bytes<10>): Field {"
      "  const bv = disclose(ibv);"
      "  for (const n of 1..10) {"
      "    F = F * bv[true] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 13" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(ibv: Bytes<10>): Field {"
      "  const bv = disclose(ibv);"
      "  for (const n of 1..11) {"
      "    F = F * bv[0] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 21" "invalid Bytes index ~d for a Bytes value of length ~d" (10 10)))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(ibv: Bytes<10>): Field {"
      "  const bv = disclose(ibv);"
      "  for (const n of [true]) {"
      "    F = F * bv[0] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 21" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  for (const n of 1..10) {"
      "    F = F * bv[5] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual(4565826117n);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  for (const n of 1..10) {"
      "    F = F * bv[10] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 13" "invalid Bytes index ~d for a Bytes value of length ~d" (10 10)))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  for (const n of 1..10) {"
      "    F = F * bv[true] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 13" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  for (const n of 1..11) {"
      "    F = F * bv[0] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 21" "invalid Bytes index ~d for a Bytes value of length ~d" (10 10)))
    )

  (test
    '(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      "  const bv = Bytes[3, 5, 7, 9, 11, 13, 15, 17, 19, 21];"
      "  for (const n of [true]) {"
      "    F = F * bv[0] + bv[n];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 21" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

 (let ([size (+ (* (field-bytes) 2) 1)])
  (test
    `(
      "ledger F: Field;"
      "export circuit foo(): Field {"
      ,(format "  const bv = Bytes[~{~d~^, ~}];" (map add1 (iota size)))
      ,(format "  F = bv[~d];" (+ (field-bytes) 1))
      ,(format "  for (const i of 0..~d) {" size)
      "    F = F + bv[i];"
      "  }"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        ,(format "  expect(t.result).toEqual(~dn);" (+ (field-bytes) 2 (/ (* size (+ size 1)) 2)))
        "  });"
        ))
    ))

 (let ([size (+ (* (field-bytes) 2) 1)])
  (test
    `(
      "ledger F: Field;"
      ,(format "export circuit foo(ibv: Bytes<~d>): Field {" size)
      "  const bv = disclose(ibv);"
      ,(format "  F = bv[~d];" (+ (field-bytes) 1))
      ,(format "  for (const i of 0..~d) {" size)
      "    F = F + bv[i];"
      "  }"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" (map add1 (iota size)))
        ,(format "  expect(t.result).toEqual(~dn);" (+ (field-bytes) 2 (/ (* size (+ size 1)) 2)))
        "  });"
        ))
    ))

 (let ([N (* (field-bytes) 2)] [S (+ (field-bytes) 1)] [I 7])
  (test
    `(
      "module M<#N, #S, #I> {"
      "  ledger F1: Bytes<S>;"
      "  ledger F2: Bytes<S>;"
      "  export circuit foo(ibv: Bytes<N>): Vector<2, Bytes<S>> {"
      "    const bv = disclose(ibv);"
      ,(format "    const cbv = Bytes[~{~d~^, ~}];" (reverse (iota N)))
      "    F1 = slice<S>(bv, I);"
      "    F2 = slice<S>(cbv, I);"
      "    return [F1, F2];"
      "  }"
      "}"
      ,(format "import M<~d, ~d, ~d>;" N S I)
      "export { foo };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" (iota N))
        ,(let ([ls (iota N)] [f (lambda (ls) (list-head (list-tail ls I) S))])
           (format "  expect(t.result).toEqual([new Uint8Array([~{~d~^, ~}]), new Uint8Array([~{~d~^, ~}])]);"
             (f ls)
             (f (reverse ls))))
        "  });"
        ))
    ))

 (let ([N (* (field-bytes) 2)] [S (- (field-bytes) 1)] [I 0])
  (test
    `(
      "module M<#N, #S, #I> {"
      "  ledger F1: Bytes<S>;"
      "  ledger F2: Bytes<S>;"
      "  export circuit foo(ibv: Bytes<N>): Vector<2, Bytes<S>> {"
      "    const bv = disclose(ibv);"
      ,(format "    const cbv = Bytes[~{~d~^, ~}];" (reverse (iota N)))
      "    F1 = slice<S>(bv, I);"
      "    F2 = slice<S>(cbv, I);"
      "    return [F1, F2];"
      "  }"
      "}"
      ,(format "import M<~d, ~d, ~d>;" N S I)
      "export { foo };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" (iota N))
        ,(let ([ls (iota N)] [f (lambda (ls) (list-head (list-tail ls I) S))])
           (format "  expect(t.result).toEqual([new Uint8Array([~{~d~^, ~}]), new Uint8Array([~{~d~^, ~}])]);"
             (f ls)
             (f (reverse ls))))
        "  });"
        ))
    ))

 (let ([N (* (field-bytes) 2)] [S (field-bytes)] [I 7])
  (test
    `(
      "module M<#N, #S, #I> {"
      "  ledger F1: Bytes<S>;"
      "  ledger F2: Bytes<S>;"
      "  export circuit foo(ibv: Bytes<N>): Vector<2, Bytes<S>> {"
      "    const bv = disclose(ibv);"
      ,(format "    const cbv = Bytes[~{~d~^, ~}];" (reverse (iota N)))
      "    F1 = slice<S>(bv, I);"
      "    F2 = slice<S>(cbv, I);"
      "    return [F1, F2];"
      "  }"
      "}"
      ,(format "import M<~d, ~d, ~d>;" N S I)
      "export { foo };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" (iota N))
        ,(let ([ls (iota N)] [f (lambda (ls) (list-head (list-tail ls I) S))])
           (format "  expect(t.result).toEqual([new Uint8Array([~{~d~^, ~}]), new Uint8Array([~{~d~^, ~}])]);"
             (f ls)
             (f (reverse ls))))
        "  });"
        ))
    ))

 (let ([N (* (field-bytes) 2)] [S 0] [I 7])
  (test
    `(
      "module M<#N, #S, #I> {"
      "  ledger F1: Bytes<S>;"
      "  ledger F2: Bytes<S>;"
      "  export circuit foo(ibv: Bytes<N>): Vector<2, Bytes<S>> {"
      "    const bv = disclose(ibv);"
      ,(format "    const cbv = Bytes[~{~d~^, ~}];" (reverse (iota N)))
      "    F1 = slice<S>(bv, I);"
      "    F2 = slice<S>(cbv, I);"
      "    return [F1, F2];"
      "  }"
      "}"
      ,(format "import M<~d, ~d, ~d>;" N S I)
      "export { foo };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" (iota N))
        ,(let ([ls (iota N)] [f (lambda (ls) (list-head (list-tail ls I) S))])
           (format "  expect(t.result).toEqual([new Uint8Array([~{~d~^, ~}]), new Uint8Array([~{~d~^, ~}])]);"
             (f ls)
             (f (reverse ls))))
        "  });"
        ))
    ))

 (let ([N (* (field-bytes) 2)] [S (+ (field-bytes) 1)] [I 7])
  (test
    `(
      "module M<#N, #S, #I> {"
      "  ledger F1: Bytes<S>;"
      "  ledger F2: Bytes<S>;"
      "  export circuit foo(ibv: Bytes<N>): Vector<2, Bytes<S>> {"
      "    const bv = disclose(ibv); const k = I;"
      ,(format "    const cbv = Bytes[~{~d~^, ~}];" (reverse (iota N)))
      "    F1 = slice<S>(bv, k);"
      "    F2 = slice<S>(cbv, k);"
      "    return [F1, F2];"
      "  }"
      "}"
      ,(format "import M<~d, ~d, ~d>;" N S I)
      "export { foo };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" (iota N))
        ,(let ([ls (iota N)] [f (lambda (ls) (list-head (list-tail ls I) S))])
           (format "  expect(t.result).toEqual([new Uint8Array([~{~d~^, ~}]), new Uint8Array([~{~d~^, ~}])]);"
             (f ls)
             (f (reverse ls))))
        "  });"
        ))
    ))

 (let ([N (* (field-bytes) 2)] [S 0] [I 7])
  (test
    `(
      "module M<#N, #S, #I> {"
      "  ledger F1: Bytes<S>;"
      "  ledger F2: Bytes<S>;"
      "  export circuit foo(ibv: Bytes<N>): Vector<2, Bytes<S>> {"
      "    const bv = disclose(ibv), k = I;"
      ,(format "    const cbv = Bytes[~{~d~^, ~}];" (reverse (iota N)))
      "    F1 = slice<S>(bv, k);"
      "    F2 = slice<S>(cbv, k);"
      "    return [F1, F2];"
      "  }"
      "}"
      ,(format "import M<~d, ~d, ~d>;" N S I)
      "export { foo };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));" (iota N))
        ,(let ([ls (iota N)] [f (lambda (ls) (list-head (list-tail ls I) S))])
           (format "  expect(t.result).toEqual([new Uint8Array([~{~d~^, ~}]), new Uint8Array([~{~d~^, ~}])]);"
             (f ls)
             (f (reverse ls))))
        "  });"
        ))
    ))

  (test
    '(
      "ledger F: Vector<11, Bytes<10>>;"
      "export circuit foo(ibv: Bytes<20>): Vector<11, Bytes<10>> {"
      "  const bv = disclose(ibv);"
      "  F = map((i) => i == 3 ? slice<10>(bv, 3) : slice<10>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  const t = C.circuits.foo(Ctxt, new Uint8Array([~{~d~^, ~}]));"
           (reverse (iota 20)))
        ,(format "  expect(t.result).toEqual([~{~a~^, ~}]);"
           (let f ([ls (reverse (iota 20))])
             (if (< (length ls) 10)
                 '()
                 (cons (format "new Uint8Array([~{~a~^, ~}])" (list-head ls 10))
                       (f (cdr ls))))))
        "  });"
        ))
    )

  (test
    `(
      "ledger F: Vector<11, Bytes<10>>;"
      "export circuit foo(): Vector<11, Bytes<10>> {"
      ,(format "  const bv = Bytes[~{~d~^, ~}];" (reverse (iota 20)))
      "  F = map((i) => i == 3 ? slice<10>(bv, 3) : slice<10>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        ,(format "  expect(t.result).toEqual([~{~a~^, ~}]);"
           (let f ([ls (reverse (iota 20))])
             (if (< (length ls) 10)
                 '()
                 (cons (format "new Uint8Array([~{~a~^, ~}])" (list-head ls 10))
                       (f (cdr ls))))))
        "  });"
        ))
    )

  (test
    `(
      "ledger F: Vector<11, Bytes<10>>;"
      "export circuit foo(ibv: Bytes<20>): Vector<11, Bytes<10>> {"
      "  const bv = disclose(ibv);"
      "  F = map((i) => i == 3 ? slice<10>(bv, 11) : slice<10>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 27" "invalid slice index ~d and length ~d for a Bytes value of length ~d" (11 10 20)))
    )

  (test
    `(
      "ledger F: Vector<11, Bytes<10>>;"
      "export circuit foo(ibv: Bytes<20>): Vector<11, Bytes<10>> {"
      "  const bv = disclose(ibv);"
      "  F = map((i) => i == 3 ? slice<10>(bv, true) : slice<10>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 27" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

  (test
    `(
      "ledger F: Vector<11, Bytes<10>>;"
      "export circuit foo(ibv: Bytes<20>, b: Boolean): Vector<11, Bytes<10>> {"
      "  const bv = disclose(ibv);"
      "  F = map((i) => i == 3 ? slice<10>(bv, b) : slice<10>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 27" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

  (test
    `(
      "ledger F: Vector<11, Bytes<21>>;"
      "export circuit foo(ibv: Bytes<20>): Vector<11, Bytes<10>> {"
      "  const bv = disclose(ibv);"
      "  F = map((i) => slice<21>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 18" "slice length ~d exceeds the length ~d of the input Bytes" (21 20)))
    )

  (test
    `(
      "ledger F: Vector<11, Bytes<10>>;"
      "export circuit foo(): Vector<11, Bytes<10>> {"
      ,(format "  const bv = Bytes[~{~d~^, ~}];" (reverse (iota 20)))
      "  F = map((i) => i == 3 ? slice<10>(bv, 11) : slice<10>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 27" "invalid slice index ~d and length ~d for a Bytes value of length ~d" (11 10 20)))
    )

  (test
    `(
      "ledger F: Vector<11, Bytes<10>>;"
      "export circuit foo(): Vector<11, Bytes<10>> {"
      ,(format "  const bv = Bytes[~{~d~^, ~}];" (reverse (iota 20)))
      "  F = map((i) => i == 3 ? slice<10>(bv, true) : slice<10>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 27" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

  (test
    `(
      "ledger F: Vector<11, Bytes<10>>;"
      "export circuit foo(b: Boolean): Vector<11, Bytes<10>> {"
      ,(format "  const bv = Bytes[~{~d~^, ~}];" (reverse (iota 20)))
      "  F = map((i) => i == 3 ? slice<10>(bv, b) : slice<10>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 27" "expected index to have an unsigned type, received ~a" ("Boolean")))
    )

  (test
    `(
      "ledger F: Vector<11, Bytes<21>>;"
      "export circuit foo(): Vector<11, Bytes<21>> {"
      ,(format "  const bv = Bytes[~{~d~^, ~}];" (reverse (iota 20)))
      "  F = map((i) => slice<21>(bv, i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 18" "slice length ~d exceeds the length ~d of the input Bytes" (21 20)))
    )

  (test
    '(
      "ledger F: Bytes<7>;"
      "export circuit foo(ibv: Bytes<10>): Bytes<7> {"
      "  const bv = disclose(ibv);"
      "  for (const x of [37]) {"
      "    F = Bytes[...slice<2>(bv, 3), x, ...[x], ...slice<3>(bv, 6)];"
      "  }"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]));"
        "  expect(t.result).toEqual(new Uint8Array([5, 6, 37, 37, 8, 9, 10]));"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Bytes<7>;"
      "export circuit foo(ibv: Bytes<10>): Bytes<7> {"
      "  const bv = disclose(ibv);"
      "  for (const x of []) {"
      "    F = Bytes[...slice<2>(bv, 3), x, ...[x], ...slice<3>(bv, 6)];"
      "  }"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt, new Uint8Array([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]));"
        "  expect(t.result).toEqual(new Uint8Array([0, 0, 0, 0, 0, 0, 0]));"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<2, Field>;"
      "export circuit foo(): Vector<2, Field> {"
      "  for (const x of []) {"
      "    F = [x, ...[x],];"
      "  }"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const t = C.circuits.foo(Ctxt);"
        "  expect(t.result).toEqual([0n, 0n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<2, Field>;"
      "export circuit foo(): Vector<2, Field> {"
      "  for (const x of []) {"
      "    F = [x, ...[x], ...x];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 21" "expected tuple/vector spread expression to have a tuple, Vector, or Bytes type but received ~a" ("Unknown")))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger F: Field;"
      "export circuit foo(bv: Bytes<10>, offset: Uint<8>): Field {"
      "  for (const i of 0..10) {"
      "    F = F + disclose(bv)[i+disclose(offset)];"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 5 char 13" "Bytes index did not reduce to a constant nonnegative value at compile time" ()))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "ledger F: Field;"
      "export circuit foo(bv: Bytes<10>, offset: Uint<8>): Field {"
      "  for (const x of disclose(slice<5>(bv, offset))) {"
      "    F = F + x;"
      "  }"
      "  return F;"
      "}"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 4 char 28" "slice index did not reduce to a constant nonnegative value at compile time" ()))
    )

  ; self-casts for Boolean, Field, Uint, Bytes, Opaque, Vector, tuple, struct, and enum types
  (test
    '(
      "module M<T> {"
      "  ledger F: T;"
      "  export circuit foo(x: T): T {"
      "    F = disclose(x) as T;"
      "    return F;"
      "  }"
      "}"
      "import M<Boolean> prefix boolean$;"
      "import M<Field> prefix field$;"
      "import M<Uint<16>> prefix uint16$;"
      "import M<Bytes<9>> prefix bytes$;"
      "import M<Opaque<'string'>> prefix opaque$;"
      "import M<Vector<5, Uint<16>>> prefix vector16$;"
      "import M<[Boolean, Uint<16>]> prefix tuple16$;"
      "struct S {x: Boolean, y: Field};"
      "import M<S> prefix struct$;"
      "enum E {vanilla, strawberry, chocolate};"
      "import M<E> prefix enum$;"
      ""
      "export { boolean$foo, field$foo, uint16$foo, bytes$foo, opaque$foo, vector16$foo, tuple16$foo, struct$foo, enum$foo };"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.boolean$foo(Ctxt, true).result).toEqual(true);"
        "  expect(C.circuits.field$foo(Ctxt, 37n).result).toEqual(37n);"
        "  expect(C.circuits.uint16$foo(Ctxt, 73n).result).toEqual(73n);"
        "  expect(C.circuits.bytes$foo(Ctxt, new Uint8Array([61, 62, 63, 64, 65, 66, 67, 68, 69])).result).toEqual(new Uint8Array([61, 62, 63, 64, 65, 66, 67, 68, 69]));"
        "  expect(C.circuits.opaque$foo(Ctxt, 'hello').result).toEqual('hello');"
        "  expect(C.circuits.vector16$foo(Ctxt, [17n, 23n, 29n, 31n, 37n]).result).toEqual([17n, 23n, 29n, 31n, 37n]);"
        "  expect(C.circuits.tuple16$foo(Ctxt, [true, 101n]).result).toEqual([true, 101n]);"
        "  expect(C.circuits.struct$foo(Ctxt, {x: false, y: 0xc7c7n}).result).toEqual({x: false, y: 0xc7c7n});"
        "  expect(C.circuits.enum$foo(Ctxt, 1).result).toEqual(1);"
        "  });"
        ))
    )

  ; upcasts for Field, Uint, Vector, and tuple types
  (test
    '(
      "module M<T, U> {"
      "  ledger F: U;"
      "  export circuit foo(x: T): U {"
      "    F = disclose(x) as U;"
      "    return F;"
      "  }"
      "}"
      "import M<Uint<32>, Field> prefix field$;"
      "import M<Uint<8>, Uint<16>> prefix uint16$;"
      "import M<Vector<5, Uint<8>>, Vector<5, Uint<16>>> prefix vector16$;"
      "import M<[Boolean, Uint<8>], [Boolean, Uint<16>]> prefix tuple16$;"
      "import M<Vector<5, Uint<16>>, [Uint<16>, Uint<17>, Uint<18>, Uint<19>, Uint<20>]> prefix tuple20$;"
      "import M<[Uint<8>, Uint<32>], Vector<2, Uint<32>>> prefix vector32$;"
      ""
      "export { field$foo, uint16$foo, vector16$foo, tuple16$foo, tuple20$foo, vector32$foo };"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.field$foo(Ctxt, 37n).result).toEqual(37n);"
        "  expect(C.circuits.uint16$foo(Ctxt, 73n).result).toEqual(73n);"
        "  expect(C.circuits.vector16$foo(Ctxt, [17n, 23n, 29n, 31n, 37n]).result).toEqual([17n, 23n, 29n, 31n, 37n]);"
        "  expect(C.circuits.tuple16$foo(Ctxt, [true, 101n]).result).toEqual([true, 101n]);"
        "  expect(C.circuits.tuple20$foo(Ctxt, [17n, 23n, 29n, 31n, 37n]).result).toEqual([17n, 23n, 29n, 31n, 37n]);"
        "  expect(C.circuits.vector32$foo(Ctxt, [31n, 37n]).result).toEqual([31n, 37n]);"
        "  });"
        ))
    )

  ; upcasts for nested Vector and tuple types
  (test
    '(
      "export struct S {x: Boolean, y: [Field, Opaque<'string'>]};"
      "enum E {vanilla, strawberry, chocolate};"
      "module M<T, U> {"
      "  ledger F: U;"
      "  export circuit foo(x: T): U {"
      "    F = disclose(x) as U;"
      "    return F;"
      "  }"
      "}"
      "import M<Vector<2, Vector<3, Uint<16>>>, Vector<2, Vector<3, Uint<32>>>> prefix v1$;"
      "import M<Vector<2, Vector<3, [E, Uint<16>, S]>>, Vector<2, Vector<3, [E, Uint<32>, S]>>> prefix v2$;"
      "import M<[Vector<3, [E, Uint<16>, S]>, Vector<3, [E, Uint<8>, S]>], Vector<2, Vector<3, [E, Uint<32>, S]>>> prefix v3$;"
      "import M<Vector<2, Vector<3, [E, Uint<16>, S]>>, [Vector<3, [E, Uint<32>, S]>, Vector<3, [E, Uint<32>, S]>]> prefix v4$;"
      ""
      "export { v1$foo, v2$foo, v3$foo, v4$foo };"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const v1 = [[1n, 3n, 5n], [7n, 9n, 11n]];"
        "  expect(C.circuits.v1$foo(Ctxt, v1).result).toEqual(v1);"
        "  });"
        "test('check 2', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const e = 1;"
        "  const s = {x: true, y: [37n, 'e=mc^2']};"
        "  const v2 = [[[e, 1n, s], [e, 3n, s], [e, 5n, s]], [[e, 7n, s], [e, 9n, s], [e, 11n, s]]];"
        "  expect(C.circuits.v2$foo(Ctxt, <any>v2).result).toEqual(v2);"
        "  });"
        "test('check 3', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const e = 1;"
        "  const s = {x: true, y: [37n, 'e=mc^2']};"
        "  const v3 = [[[e, 1n, s], [e, 3n, s], [e, 5n, s]], [[e, 7n, s], [e, 9n, s], [e, 11n, s]]];"
        "  expect(C.circuits.v3$foo(Ctxt, <any>v3).result).toEqual(v3);"
        "  });"
        "test('check 4', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  const e = 1;"
        "  const s = {x: true, y: [37n, 'e=mc^2']};"
        "  const v4 = [[[e, 1n, s], [e, 3n, s], [e, 5n, s]], [[e, 7n, s], [e, 9n, s], [e, 11n, s]]];"
        "  expect(C.circuits.v4$foo(Ctxt, <any>v4).result).toEqual(v4);"
        "  });"
        ))
    )

  ; self-test and upcast tests for Contract types
  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): Field { return x * x; }"
         "export circuit bar(): [] { return; }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "module M1 {"
         "  export ledger F: C;"
         "  export contract C {"
         "    circuit foo(x: Field): Field;"
         "    circuit bar(): [];"
         "  }"
         "}"
         "module M2 {"
         "  export ledger F: C;"
         "  export contract C {"
         "    circuit foo(x: Field): Field;"
         "  }"
         "}"
         "import M1 prefix M1$;"
         "import M2 prefix M2$;"
         "constructor(c1: M1$C) {"
         "  M1$F = disclose(c1) as M1$C;"
         "  M2$F = disclose(c1) as M2$C;"
         "}"
         ))
     ; FIXME replace with stage-javascript checks for CC print-TS pass implementation
     (returns
       (program
         (type-descriptors
           (%descriptor.0 (tunsigned 18446744073709551615))
           (%descriptor.1 (tboolean))
           (%descriptor.2 (tbytes 32))
           (%descriptor.3 (tstruct ContractAddress
                            (bytes (tbytes 32))))
           (%descriptor.4 (tunsigned 255))
           (%descriptor.5 (tunsigned
                            340282366920938463463374607431768211455)))
         (kernel-declaration (%kernel.6 () (Kernel)))
         (public-ledger-declaration
           ((%F.7
              (0)
              (__compact_Cell
                (tcontract C
                  (foo #f ((tfield)) (tfield))
                  (bar #f () (ttuple)))))
            (%F.8
              (1)
              (__compact_Cell
                (tcontract C (foo #f ((tfield)) (tfield))))))
           (constructor ([%c1.9 (tcontract C
                                  (foo #f ((tfield)) (tfield))
                                  (bar #f () (ttuple)))])
             (seq
               (public-ledger %F.7 (0) write %c1.9)
               (seq
                 (const [%tmp.10 (tcontract C (foo #f ((tfield)) (tfield)))]
                   (safe-cast (tcontract C (foo #f ((tfield)) (tfield)))
                              (tcontract C
                                (foo #f ((tfield)) (tfield))
                                (bar #f () (ttuple)))
                     %c1.9))
                 (public-ledger %F.8 (1) write %tmp.10))
               (tuple))))))
     ))

  ; downcast failure for Contract types
  (test-group
    ((create-file "C.compact"
       '(
         "export circuit foo(x: Field): Field { return x * x; }"
         "export circuit bar(): [] { return; }"
         ))
      (succeeds))
    ((create-file "testfile.compact"
       '(
         "module M1 {"
         "  export ledger F: C;"
         "  export contract C {"
         "    circuit foo(x: Field): Field;"
         "    circuit bar(): [];"
         "  }"
         "}"
         "module M2 {"
         "  export ledger F: C;"
         "  export contract C {"
         "    circuit foo(x: Field): Field;"
         "  }"
         "}"
         "import M1 prefix M1$;"
         "import M2 prefix M2$;"
         "constructor(c2: M2$C) {"
         "  M1$F = disclose(c2) as M1$C;"
         "  M2$F = disclose(c2) as M2$C;"
         "}"
         ))
     (oops
       message: "~a:\n  ~?"
       irritants: '("testfile.compact line 17 char 10" "cannot cast from type ~a to type ~a" ("contract C<foo(Field): Field>" "contract C<foo(Field): Field, bar(): []>")))
     ))

  (test
    '(
      "ledger F: Vector<5, Uint<32>>;"
      "export circuit foo(bv: Bytes<5>): Vector<5, Uint<32>> {"
      "  F = disclose(bv) as Vector<5, Uint<16>>;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([17, 23, 29, 31, 37])).result).toEqual([17n, 23n, 29n, 31n, 37n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: Vector<5, Field>;"
      "export circuit foo(bv: Bytes<5>): Vector<5, Field> {"
      "  F = disclose(bv) as Vector<5, Field>;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([17, 23, 29, 31, 37])).result).toEqual([17n, 23n, 29n, 31n, 37n]);"
        "  });"
        ))
    )

  (test
    '(
      "ledger F: [Uint<8>, Uint<16>, Uint<32>, Uint<64>, Field];"
      "export circuit foo(bv: Bytes<5>): [Uint<8>, Uint<16>, Uint<32>, Uint<64>, Field] {"
      "  F = disclose(bv) as [Uint<8>, Uint<16>, Uint<32>, Uint<64>, Field];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, new Uint8Array([17, 23, 29, 31, 37])).result).toEqual([17n, 23n, 29n, 31n, 37n]);"
        "  });"
        ))
    )

  ; casts from Field and Uint to enum
  (test
    '(
      "enum E { fore, the, ring, pinky }"
      "ledger F: E;"
      "export circuit foo(ix: Field): E {"
      "  const x = disclose(ix);"
      "  F = x as E;"
      "  if (x == 0) assert(F == E.fore, 'oops0');"
      "  else if (x == 1) assert(F == E.the, 'oops1');"
      "  else if (x == 2) assert(F == E.ring, 'oops2');"
      "  else if (x == 3) assert(F == E.pinky, 'oops3');"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n).result).toEqual(0);"
        "  expect(C.circuits.foo(Ctxt, 1n).result).toEqual(1);"
        "  expect(C.circuits.foo(Ctxt, 2n).result).toEqual(2);"
        "  expect(C.circuits.foo(Ctxt, 3n).result).toEqual(3);"
        "  expect(() => C.circuits.foo(Ctxt, 4n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 4n)).toThrow('testfile.compact line 5 char 7: cast from Field or Uint value to enum E failed: 4 is greater than maximum enum value 3n');"
        "  });"
        ))
    )

  (test
    '(
      "enum E { fore, the, ring, pinky }"
      "ledger F: E;"
      "export circuit foo(ix: Uint<8>): E {"
      "  const x = disclose(ix);"
      "  F = x as E;"
      "  if (x == 0) assert(F == E.fore, 'oops0');"
      "  else if (x == 1) assert(F == E.the, 'oops1');"
      "  else if (x == 2) assert(F == E.ring, 'oops2');"
      "  else if (x == 3) assert(F == E.pinky, 'oops3');"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n).result).toEqual(0);"
        "  expect(C.circuits.foo(Ctxt, 1n).result).toEqual(1);"
        "  expect(C.circuits.foo(Ctxt, 2n).result).toEqual(2);"
        "  expect(C.circuits.foo(Ctxt, 3n).result).toEqual(3);"
        "  expect(() => C.circuits.foo(Ctxt, 4n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 4n)).toThrow('testfile.compact line 5 char 7: cast from Field or Uint value to enum E failed: 4 is greater than maximum enum value 3n');"
        "  });"
        ))
    )

  (test
    '(
      "enum E { thumb, fore, the, ring, pinky }"
      "ledger F: E;"
      "export circuit foo(ix: Uint<0..4>): E {"
      "  const x = disclose(ix);"
      "  F = x as E;"
      "  if (x == 0) assert(F == E.thumb, 'oops0');"
      "  else if (x == 1) assert(F == E.fore, 'oops1');"
      "  else if (x == 2) assert(F == E.the, 'oops2');"
      "  else if (x == 3) assert(F == E.ring, 'oops3');"
      "  else if (x == 4) assert(F == E.pinky, 'oops4');"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n).result).toEqual(0);"
        "  expect(C.circuits.foo(Ctxt, 1n).result).toEqual(1);"
        "  expect(C.circuits.foo(Ctxt, 2n).result).toEqual(2);"
        "  expect(C.circuits.foo(Ctxt, 3n).result).toEqual(3);"
        "  expect(() => C.circuits.foo(Ctxt, 4n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 4n)).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 3 char 1; expected value of type Uint<0..4> but received 4n');"
        "  });"
        ))
    )

  (test
    '(
      "enum E { thumb, fore, the, ring, pinky }"
      "ledger F: E;"
      "export circuit foo(ix: Uint<0..5>): E {"
      "  const x = disclose(ix);"
      "  F = x as E;"
      "  if (x == 0) assert(F == E.thumb, 'oops0');"
      "  else if (x == 1) assert(F == E.fore, 'oops1');"
      "  else if (x == 2) assert(F == E.the, 'oops2');"
      "  else if (x == 3) assert(F == E.ring, 'oops3');"
      "  else if (x == 4) assert(F == E.pinky, 'oops4');"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0n).result).toEqual(0);"
        "  expect(C.circuits.foo(Ctxt, 1n).result).toEqual(1);"
        "  expect(C.circuits.foo(Ctxt, 2n).result).toEqual(2);"
        "  expect(C.circuits.foo(Ctxt, 3n).result).toEqual(3);"
        "  expect(C.circuits.foo(Ctxt, 4n).result).toEqual(4);"
        "  expect(() => C.circuits.foo(Ctxt, 5n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 5n)).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 3 char 1; expected value of type Uint<0..5> but received 5n');"
        "  });"
        ))
    )

  (test
    '(
      "enum E { thumb, fore, the, ring, pinky }"
      "ledger F: Vector<4, E>;"
      "export circuit foo(): Vector<4, E> {"
      "  F = [1 as E, 3 as E, 0 as E, 2 as E];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([1, 3, 0, 2]);"
        "  });"
        ))
    )

  ; casts from enum to Field and Uint
  (test
    '(
      "enum E { spring, summer, fall, winter }"
      "ledger F: Field;"
      "export circuit foo(e: E) : Field {"
      "  F = disclose(e) as Field;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0).result).toEqual(0n);"
        "  expect(C.circuits.foo(Ctxt, 1).result).toEqual(1n);"
        "  expect(C.circuits.foo(Ctxt, 2).result).toEqual(2n);"
        "  expect(C.circuits.foo(Ctxt, 3).result).toEqual(3n);"
        "  expect(() => C.circuits.foo(Ctxt, 4)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 4)).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 3 char 1; expected value of type Enum<E, spring, summer, fall, winter> but received 4');"
        "});"
        ))
    )

  (test
    '(
      "enum E { spring, summer, fall, winter }"
      "ledger F: Uint<0..5>;"
      "export circuit foo(e: E) : Uint<0..5> {"
      "  F = disclose(e) as Uint<0..5>;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0).result).toEqual(0n);"
        "  expect(C.circuits.foo(Ctxt, 1).result).toEqual(1n);"
        "  expect(C.circuits.foo(Ctxt, 2).result).toEqual(2n);"
        "  expect(C.circuits.foo(Ctxt, 3).result).toEqual(3n);"
        "  expect(() => C.circuits.foo(Ctxt, 4)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 4)).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 3 char 1; expected value of type Enum<E, spring, summer, fall, winter> but received 4');"
        "});"
        ))
    )

  (test
    '(
      "enum E { spring, summer, fall, winter }"
      "ledger F: Uint<0..4>;"
      "export circuit foo(e: E) : Uint<0..4> {"
      "  F = disclose(e) as Uint<0..4>;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0).result).toEqual(0n);"
        "  expect(C.circuits.foo(Ctxt, 1).result).toEqual(1n);"
        "  expect(C.circuits.foo(Ctxt, 2).result).toEqual(2n);"
        "  expect(C.circuits.foo(Ctxt, 3).result).toEqual(3n);"
        "  expect(() => C.circuits.foo(Ctxt, 4)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 4)).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 3 char 1; expected value of type Enum<E, spring, summer, fall, winter> but received 4');"
        "});"
        ))
    )

  (test
    '(
      "enum E { spring, summer, fall, winter }"
      "ledger F: Uint<0..3>;"
      "export circuit foo(e: E) : Uint<0..3> {"
      "  F = disclose(e) as Uint<0..3>;"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0).result).toEqual(0n);"
        "  expect(C.circuits.foo(Ctxt, 1).result).toEqual(1n);"
        "  expect(C.circuits.foo(Ctxt, 2).result).toEqual(2n);"
        "  expect(() => C.circuits.foo(Ctxt, 3)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 3)).toThrow('testfile.compact line 4 char 7: cast from enum E to Uint<0..3> failed: enum value 3 is greater than 2');"
        "  expect(() => C.circuits.foo(Ctxt, 4)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 4)).toThrow('type error: foo argument 1 (argument 2 as invoked from Typescript) at testfile.compact line 3 char 1; expected value of type Enum<E, spring, summer, fall, winter> but received 4');"
        "});"
        ))
    )

  (test
    '(
      "enum E { spring, summer, fall, winter }"
      "ledger F: [ Field, Field, Field, Field ];"
      "export circuit foo() : [ Field, Field, Field, Field ] {"
      "  F = [E.summer as Field, E.spring as Field, E.winter as Field, E.fall as Field];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([1n, 0n, 3n, 2n]);"
        "});"
        ))
    )

  (test
    '(
      "enum E { spring, summer, fall, winter }"
      "ledger F: Vector<4, Uint<0..5>>;"
      "export circuit foo() : Vector<4, Uint<0..5>> {"
      "  F = [E.summer as Uint<0..5>, E.spring as Uint<0..5>, E.winter as Uint<0..5>, E.fall as Uint<0..5>];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([1n, 0n, 3n, 2n]);"
        "});"
        ))
    )

  (test
    '(
      "enum E { spring, summer, fall, winter }"
      "ledger F: Vector<4, Uint<0..4>>;"
      "export circuit foo() : Vector<4, Uint<0..4>> {"
      "  F = [E.summer as Uint<0..4>, E.spring as Uint<0..4>, E.winter as Uint<0..4>, E.fall as Uint<0..4>];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([1n, 0n, 3n, 2n]);"
        "});"
        ))
    )

  (test
    '(
      "enum E { spring, summer, fall, winter }"
      "ledger F: Vector<4, Uint<0..3>>;"
      "export circuit foo() : Vector<4, Uint<0..3>> {"
      "  F = [E.summer as Uint<0..3>, E.spring as Uint<0..3>, E.winter as Uint<0..3>, E.fall as Uint<0..3>];"
      "  return F;"
      "}"
      )
    (stage-javascript
      '(
        "test('check 1', () => {"
        "  var [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(() => C.circuits.foo(Ctxt)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt)).toThrow('testfile.compact line 4 char 56: cast from enum E to Uint<0..3> failed: enum value 3 is greater than 2');"
        "});"
        ))
    )

  ; casts from Field and Uint to Bytes
  (test
    '(
      "ledger F: Bytes<3>;"
      "export circuit foo(x: Field) : Bytes<3> {"
      "  F = disclose(x) as Bytes<3>;"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0x0201n).result).toEqual(new Uint8Array([ 1, 2, 0 ]));"
        "  expect(C.circuits.foo(Ctxt, 0x030201n).result).toEqual(new Uint8Array([ 1, 2, 3 ]));"
        "  expect(() => C.circuits.foo(Ctxt, 0x04030201n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 0x04030201n)).toThrow('range error at testfile.compact line 3 char 7: Field or Uint value 67305985 does not fit into 3 bytes');"
        "});"
        ))
    )

  (test
    '(
      "ledger F: Bytes<3>;"
      "export circuit foo(x: Uint<32>) : Bytes<3> {"
      "  F = disclose(x) as Bytes<3>;"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 0x0201n).result).toEqual(new Uint8Array([ 1, 2, 0 ]));"
        "  expect(C.circuits.foo(Ctxt, 0x030201n).result).toEqual(new Uint8Array([ 1, 2, 3 ]));"
        "  expect(() => C.circuits.foo(Ctxt, 0x04030201n)).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, 0x04030201n)).toThrow('range error at testfile.compact line 3 char 7: Field or Uint value 67305985 does not fit into 3 bytes');"
        "});"
        ))
    )

  ; casts from Bytes to Field and Uint
  (test
    '(
      "ledger F: Field;"
      "export circuit foo(x: Bytes<60>) : Field {"
      "  F = disclose(x) as Field;"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  expect(C.circuits.foo(Ctxt, new Uint8Array([6,7,8,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])).result).toEqual(~dn);" #x09080706)
        "  expect(() => C.circuits.foo(Ctxt, new Uint8Array([9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4]))).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, new Uint8Array([9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4]))).toThrow('range error at testfile.compact line 3 char 7: the integer value of 9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4 is greater than the maximum value of a Field');"
        "});"
        ))
    )

  (test
    '(
      "ledger F: Uint<32>;"
      "export circuit foo(x: Bytes<60>) : Uint<32> {"
      "  F = disclose(x) as Uint<32>;"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        ,(format "  expect(C.circuits.foo(Ctxt, new Uint8Array([6,7,8,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])).result).toEqual(~dn);" #x09080706)
        "  expect(() => C.circuits.foo(Ctxt, new Uint8Array([9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4]))).toThrow(runtime.CompactError);"
        "  expect(() => C.circuits.foo(Ctxt, new Uint8Array([9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4]))).toThrow('range error at testfile.compact line 3 char 7: the integer value of 9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,9,8,7,6,5,4 is greater than the maximum value of Uint<0..4294967296>');"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger tree: HistoricMerkleTree<8, Field>;"
      "export circuit foo(): [] {"
      "  tree.insertIndexDefault(4); // Insert default Field value (0) at position 4"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([]);"
        "});"
        ))
    )

  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger tree: MerkleTree<8, Field>;"
      "export circuit foo(): [] {"
      "  tree.insertIndexDefault(4); // Insert default Field value (0) at position 4"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([]);"
        "});"
        ))
    )

  ; pm-19287
  (test
    '(
      "export ledger complex_sum : Field;"
      ""
      "circuit transform_vector(input: Vector<3, Field>): Vector<3, Field> {"
      "  return [input[0] * 2, input[1] + 10, input[2] - 5];"
      "}"
      ""
      "export circuit foo(): Field {"
      "  const matrix = [[5, 6], [13, 14], [15, 16]];"
      "  for (const row of matrix) {"
      "    const transformed_row = transform_vector([row[0], row[1], row[0] + row[1]]);"
      "    for (const transformed_val of transformed_row) {"
      "      if ((transformed_val as Uint<64>) > 10) {"
      "        complex_sum = complex_sum + transformed_val;"
      "      }"
      "    }"
      "  }"
      "  return complex_sum;"
      "}"
      ""
      "export circuit bar(): Field {"
      "  return foo();"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(170n);"
        "  expect(C.circuits.bar(Ctxt).result).toEqual(170n);"
        "});"
        ))
    )

  (test
    '(
      "export ledger test9a_var: Bytes<2>;"
      "export circuit test9a(): Bytes<2> {"
      "    const sliced_data = slice<2>(Bytes[10, 20, 30, 40], 1);"
      "    assert(sliced_data[1] == 30, 'Sliced data second element should be 30');"
      "    test9a_var = sliced_data;"
      "    return sliced_data;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.test9a(Ctxt).result).toEqual(new Uint8Array([20, 30]));"
        "});"
        ))
    )

  (test
    '(
      "export ledger test9b_var: Bytes<2>;"
      "export circuit test9b(bv: Bytes<2>): Bytes<2> {"
      "    const sliced_data = disclose(bv);"
      "    assert(sliced_data[1] == 30, 'Sliced data second element should be 30');"
      "    test9b_var = sliced_data;"
      "    return sliced_data;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.test9b(Ctxt, new Uint8Array([20, 30])).result).toEqual(new Uint8Array([20, 30]));"
        "});"
        ))
    )

  (test
    '(
      "export ledger test9c_var: Bytes<2>;"
      "export circuit test9c(): Bytes<2> {"
      "    const sliced_data = Bytes[20, 30];"
      "    assert(sliced_data[1] == 30, 'Sliced data second element should be 30');"
      "    test9c_var = sliced_data;"
      "    return sliced_data;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.test9c(Ctxt).result).toEqual(new Uint8Array([20, 30]));"
        "});"
        ))
    )

  (test
    '(
      "export ledger test9d_var: Bytes<2>;"
      "export circuit test9d(): Bytes<2> {"
      "    const sliced_data = slice<2>(Bytes[10, 20, 30, 40], 1);"
      "    assert(sliced_data == Bytes[20, 30], 'Sliced data should be Bytes[20, 30]');"
      "    test9d_var = sliced_data;"
      "    return sliced_data;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.test9d(Ctxt).result).toEqual(new Uint8Array([20, 30]));"
        "});"
        ))
    )

  (test
    '(
      "export ledger test9e_var: Uint<8>;"
      "export circuit test9e(): Uint<8> {"
      "    const sliced_data = slice<2>(Bytes[10, 20, 30, 40], 1);"
      "    test9e_var = sliced_data[1];"
      "    return test9e_var;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.test9e(Ctxt).result).toEqual(30n);"
        "});"
        ))
    )

  (test
    '(
      "export ledger test9f_var: Bytes<2>;"
      "export circuit test9f(): Bytes<2> {"
      "    const sliced_data = Bytes[20, 30];"
      "    test9f_var = sliced_data;"
      "    return sliced_data;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.test9f(Ctxt).result).toEqual(new Uint8Array([20, 30]));"
        "});"
        ))
    )

  ; PM-19297
  (test
   '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit identity(x: Field): Field {"
      "  return x;"
      "}"
      "export circuit foo(): [] {"
      "  Q = identity(10);"
      "}"
      )
   (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([]);"
        "});"
        ))
   )

  (test
   '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit identity(x: Field): Field {"
      "  return x;"
      "}"
      "export circuit foo(): Field {"
      "  Q = identity(10);"
      "  return Q;"
      "}"
      )
   (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(10n);"
        "});"
        ))
   )

  (test
   '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit identity(x: Field): Field {"
      "  return x;"
      "}"
      "export circuit foo(): Field {"
      "  const x = identity(10);"
      "  Q = x;"
      "  return Q;"
      "}"
      )
   (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(10n);"
        "});"
        ))
   )

  (test
    '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit identity(x: Field): Field {"
      "  return x;"
      "}"
      "export circuit foo(): Vector<4, Field> {"
      "  F = map(identity, [10, 20, 30, 40]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([10n, 20n, 30n, 40n]);"
        "});"
        ))
    )

  (test
    '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit identity(x: Field): Field {"
      "  return x;"
      "}"
      "export circuit foo(): Vector<4, Field> {"
      "  const x = map(identity, [10, 20, 30, 40]);"
      "  F = x;"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([10n, 20n, 30n, 40n]);"
        "});"
        ))
    )

  (test
    '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit identity(x: Field): Field {"
      "  return x;"
      "}"
      "export circuit foo(): Vector<4, Field> {"
      "  F = map(((x) => x), [10, 20, 30, 40]);"
      "  return F;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([10n ,20n, 30n, 40n]);"
        "});"
        ))
    )

  (test
    '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit identity(x: Field): Field {"
      "  return x;"
      "}"
      "export circuit foo(): [Field, Vector<4, Field>] {"
      "  F = map(((x) => { Q = x; return x;}), [10, 20, 30, 40]);"
      "  return [Q, F];"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([40n, [10n ,20n, 30n, 40n]]);"
        "});"
        ))
    )

  (test
    '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit add(x: Field, y: Field): Field {"
      "  return x + y;"
      "}"
      "export circuit foo(): Field {"
      "  Q = fold(add, 0, [10, 20, 30, 40]);"
      "  return Q;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(100n);"
        "});"
        ))
    )

  (test
    '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit add(x: Field, y: Field): Field {"
      "  return x + y;"
      "}"
      "export circuit foo(): Field {"
      "  const x = fold(add, 0, [10, 20, 30, 40]);"
      "  Q = x;"
      "  return Q;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(100n);"
        "});"
        ))
    )

  (test
    '(
      "export ledger F: Vector<4, Field>;"
      "export ledger Q: Field;"
      "circuit add(x: Field, y: Field): Field {"
      "  return x + y;"
      "}"
      "export circuit foo(): Field {"
      "  Q = fold(((x, y) : Field => x + y), 0, [10, 20, 30, 40]);"
      "  return Q;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual(100n);"
        "});"
        ))
    )

  ; pm-19189
  (test
    '(
      "import CompactStandardLibrary;"
      "export ledger F: Map<Field, Vector<8, Uint<32>>>;"
      "    "
      "export circuit foo(): [Uint<32>] {"
      "  F.insert(1, [1, 3, 5, 7, 9, 11, 13, 15]);"
      "  return slice<1>(F.lookup(1), 0 + 1);"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt).result).toEqual([3n]);"
        "});"
        ))
    )

  (test
    '(
      "ledger F: Field;"
      "ledger B: Boolean;"
      "export circuit foo(ix: Field, ibv: Bytes<10>): Vector<10, Uint<16>> {"
      "  const x = disclose(ix), bv = disclose(ibv);"
      "  const b1 = x == 0;"
      "  const b2 = x == 0;"
      "  return (b1 == b2 ? Bytes[1, 2, 3, 4, 5, 6, 7, 8, 9, 0] : bv) as Vector<10, Uint<16>>;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 17n, new Uint8Array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])).result).toEqual([1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 0n]);"
        "});"
        ))
    )

  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    F = disclose(ix + ix);"
      "    return F;"
      "  }"
      "}"
      "import { foo, F } from M;"
      "export { foo };"
      "enum F { a, b, c };"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 10 char 1" "another binding found for ~s in the same scope at ~a" (F "line 8 char 15")))
    )

  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    F = disclose(ix + ix);"
      "    return F;"
      "  }"
      "}"
      "import {} from M;"
      "export { foo };"
      )
    (oops
      message: "~a:\n  ~?"
      irritants: '("testfile.compact line 9 char 10" "unbound identifier ~s" (foo)))
    )

  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    F = disclose(ix + ix);"
      "    return F;"
      "  }"
      "}"
      "import { foo, F as G } from M;"
      "export { foo };"
      "enum F { a, b, c };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 17n).result).toEqual(34n);"
        "});"
        ))
    )

  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    F = disclose(ix + ix);"
      "    return F;"
      "  }"
      "}"
      "import { foo } from M;"
      "export { foo };"
      "enum F { a, b, c };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 17n).result).toEqual(34n);"
        "});"
        ))
    )

  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    F = disclose(ix + ix);"
      "    return F;"
      "  }"
      "}"
      "import { foo as bar } from M;"
      "export { bar };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 17n).result).toEqual(34n);"
        "});"
        ))
    )

  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    F = disclose(ix + ix);"
      "    return F;"
      "  }"
      "}"
      "import { foo as peter, foo as paul, foo as mary, foo } from M;"
      "export { peter, paul, mary, foo };"
      "import { foo as peter, foo as paul, foo as mary, foo } from M prefix M$;"
      "export { M$peter, M$paul, M$mary, M$foo };"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.foo(Ctxt, 17n).result).toEqual(34n);"
        "  expect(C.circuits.peter(Ctxt, 17n).result).toEqual(34n);"
        "  expect(C.circuits.paul(Ctxt, 17n).result).toEqual(34n);"
        "  expect(C.circuits.mary(Ctxt, 17n).result).toEqual(34n);"
        "  expect(C.circuits.M$foo(Ctxt, 17n).result).toEqual(34n);"
        "  expect(C.circuits.M$peter(Ctxt, 17n).result).toEqual(34n);"
        "  expect(C.circuits.M$paul(Ctxt, 17n).result).toEqual(34n);"
        "  expect(C.circuits.M$mary(Ctxt, 17n).result).toEqual(34n);"
        "});"
        ))
    )

  (test
    '(
      "module M {"
      "  export ledger F: Field;"
      "  export circuit foo(ix: Field): Field {"
      "    const x = disclose(ix);"
      "    F = disclose(x * 3);"
      "    return F;"
      "  }"
      "  export circuit foo(ix: Field, iy: Field): Field {"
      "    const x = disclose(ix), y = disclose(iy);"
      "    F = disclose(x + y);"
      "    return F;"
      "  }"
      "}"
      "import { foo } from M;"
      "export circuit bar(ix: Uint<32>): [Field, Field] {"
      "  return [foo(ix), foo(ix, ix)];"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.bar(Ctxt, 17n).result).toEqual([51n, 34n]);"
        "});"
        ))
    )

  ; pm-20004
  (test
    '(
      "ledger vt2a: Boolean;"
      "export circuit test2(): Boolean {"
      "  return (vt2a = true, true) || true;"
      "}"
      )
    (stage-javascript
      `(
        "test('check 1', () => {"
        "  const [C, Ctxt] = startContract(contractCode, {}, 0);"
        "  expect(C.circuits.test2(Ctxt).result).toEqual(true);"
        "});"
        ))
    )
)

(run-javascript)
