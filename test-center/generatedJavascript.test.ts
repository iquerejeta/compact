// This file is part of Compact.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import * as ts from 'typescript';
import * as glob from 'glob';
import { resolve } from 'node:path';
import * as fs from 'node:fs';
import { describe, beforeAll, it, expect } from 'vitest';

/**
 * A utility function that transforms zero-offset based line and character values to their equivalent one-based values.
 *
 * @param lc The zero-offset based {@link ts.LineAndCharacter}.
 * @returns A one-offset based version of `lc`.
 */
const toOneOffsetLineAndCharacter = (lc?: ts.LineAndCharacter) => ({
  line: (lc?.line ?? 0) + 1,
  character: (lc?.character ?? 0) + 1
}) as ts.LineAndCharacter;

/**
 * Test fixture that ensures all JavaScript files generated by the `compactc` compiler
 * are valid ES modules and don't contain CommonJS patterns.
 */
describe('Compiled JavaScript files (ESM validation)', () => {
  let javascriptFiles: string[] = [];
  let program: ts.Program | null = null;

  beforeAll(() => {
    // Find all generated index.js files
    javascriptFiles = glob.sync(resolve(__dirname, '../compiler/javascript-code/**/contract/index.js'));

    // Create a TypeScript program to parse the JavaScript files as ESM
    const compilerOptions: ts.CompilerOptions = {
      target: ts.ScriptTarget.ES2020,
      module: ts.ModuleKind.ESNext, // Force ESM parsing
      moduleResolution: ts.ModuleResolutionKind.NodeNext,
      allowJs: true,
      checkJs: true,
      strict: true,
      skipLibCheck: true,
      noEmit: true
    };

    program = ts.createProgram(javascriptFiles, compilerOptions);
  });

  it('should find JavaScript files to test', () => {
    expect(javascriptFiles.length).toBeGreaterThan(0);
  });

  it('should be valid ESM syntax', () => {
    const syntaxErrors = program!.getSyntacticDiagnostics()
      .filter(diagnostic => diagnostic.file && javascriptFiles.includes(diagnostic.file.fileName))
      .map(diagnostic => [
        diagnostic.file!.fileName.replace(/^.*\/javascript-code\//, ''),
        diagnostic.messageText,
        toOneOffsetLineAndCharacter(diagnostic.file!.getLineAndCharacterOfPosition(diagnostic.start ?? 0))
      ]);

    expect(syntaxErrors).toEqual([]);
  });

  it('should not contain CommonJS exports patterns', () => {
    const filesWithExports: Array<[string, number, string]> = [];

    for (const file of javascriptFiles) {
      const content = fs.readFileSync(file, 'utf-8');
      const lines = content.split('\n');

      lines.forEach((line, index) => {
        // Check for any reference to 'exports' object
        if (/\bexports\./.test(line)) {
          filesWithExports.push([
            file.replace(/^.*\/javascript-code\//, ''),
            index + 1,
            line.trim()
          ]);
        }
      });
    }

    expect(filesWithExports).toEqual([]);
  });

  it('should be parseable as ES modules by TypeScript', () => {
    const semanticErrors = program!.getSemanticDiagnostics()
      .filter(diagnostic => {
        // Filter to only our JavaScript files and module-related errors
        if (!diagnostic.file || !javascriptFiles.includes(diagnostic.file.fileName)) {
          return false;
        }

        const moduleRelatedCodes = [
          1259, // Module '"{0}"' can only be default-imported using the 'esModuleInterop' flag
          2304, // Cannot find name 'exports'
          2580, // Cannot find name 'module'
          2591, // Cannot find name 'require'
          7027, // Unreachable code detected
        ];

        return moduleRelatedCodes.includes(diagnostic.code);
      })
      .map(diagnostic => [
        diagnostic.file!.fileName.replace(/^.*\/javascript-code\//, ''),
        `TS${diagnostic.code}: ${ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n')}`,
        toOneOffsetLineAndCharacter(diagnostic.file!.getLineAndCharacterOfPosition(diagnostic.start ?? 0))
      ]);

    expect(semanticErrors).toEqual([]);
  });
});
