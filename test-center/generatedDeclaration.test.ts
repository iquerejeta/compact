// This file is part of Compact.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import * as ts from 'typescript';
import * as glob from 'glob';
import { resolve } from 'node:path';
import * as fs from 'node:fs';
import {describe, beforeAll, it, expect} from 'vitest';

/**
 * A utility function that transforms zero-offset based line and character values to their equivalent one-based values.
 * 
 * @param lc The zero-offset based {@link ts.LineAndCharacter}.
 * @returns A one-offset based version of `lc`.
 */
const toOneOffsetLineAndCharacter = (lc?: ts.LineAndCharacter) => ({
    line: (lc?.line ?? 0) + 1,
    character: (lc?.character ?? 0) + 1
  }) as ts.LineAndCharacter;

/**
 * A test fixture that ensure that all declaration files generated by the `compactc` compiler are free
 * from syntax and semantic errors.
 */
describe('Compiled TypeScript declaration files', () => {
  let program: ts.Program | null = null;

  beforeAll(() => {
    const tsConfig = ts.parseJsonSourceFileConfigFileContent(
      ts.readJsonConfigFile(resolve(__dirname, 'tsconfig.json'), (path) => fs.readFileSync(path, {encoding: 'utf-8'})),
      ts.sys,
      resolve(__dirname, '..')
    );

    program = ts.createProgram(
      glob.sync(resolve(__dirname, '../compiler/javascript-code/**/*.d.ts')),
      {
        ...tsConfig.options,
        alwaysStrict: true,
        skipLibCheck: false
      }
    );
  });

  it('should be free of syntax errors', () => {
    const syntaxErrors = program!.getSyntacticDiagnostics().map(diagnostic => 
      [diagnostic.file.fileName, 
       diagnostic.messageText,  
       toOneOffsetLineAndCharacter(diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start))]);

    expect(syntaxErrors).toEqual([]);
  });
  
  it('should be free of semantic errors', () => {
    const semanticErrors = program!.getGlobalDiagnostics()
      .concat(program!.getSemanticDiagnostics())
      .concat(program!.getDeclarationDiagnostics())
      .map(diagnostic => 
        [diagnostic.file?.fileName, 
         diagnostic.messageText,  
         toOneOffsetLineAndCharacter(diagnostic.file?.getLineAndCharacterOfPosition(diagnostic.start ?? 0))]);

    expect(semanticErrors).toEqual([]);
  });
});