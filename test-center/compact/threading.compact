// This file is part of Compact.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/* This Compact program exports two circuits fib:
   fib takes a number c and returns the corresponding number from the fibonacci sequence. It requires that c is
   counter + 1, o.w., it throws an error. if c goes from a number more than 1 to 1, it resets to the beginning of
   the fibonacci sequence. The corresponding typescript file for testing is located at
   test-center/tests/test-threading-hacky.ts.
   fib2 takes a boolean, if it is false the function returns the next fibonacci sequence each time it is called.
   If it is true it resets to the beginning of the sequence. The corresponding typescript file for testing is
   located at test-center/tests/test-threading.ts.
   Both circuits use a ledger that has a counter to keep track of where we are in the sequence. 
*/

import CompactStandardLibrary;

export ledger counter: Counter;
constructor() {
  counter.resetToDefault();
}

witness num(n: Field): Field;

export circuit fib(c0: Field): Field{
  const c = disclose(c0);
  if (c == 1 && counter != 0 ) {
    counter.resetToDefault();
    counter.increment(1);
  } else {
    assert(c == counter + 1, "invalid fib num requested");
    counter.increment(1);
  }
  return disclose(num(c) + num(counter - 1));
}

export circuit fib2(reset: Boolean) : Field {
  if (disclose(reset))
    counter.resetToDefault();
  else 
    counter.increment(1);
  return disclose(num(counter));
}
