// This file is part of Compact.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import CompactStandardLibrary;

ledger maps: Map<Field, Field>;
ledger set: Set<QualifiedCoinInfo>;
ledger list: List<QualifiedCoinInfo>;
ledger field: Field;
ledger counter: Counter;
ledger bool: Boolean;

witness antonio(): Boolean;
witness brad(): Field;

export circuit toby(a: Field): Field {
  field.write((() => { const p = disclose([a]); field.write(p[0]); return field.read();})());
  return field;
}

// For all operations on a ledger field the parameter passed to an exported circuit
// must be disclosed since the parameter can be back tracked from the changes
// to the ledger.
export circuit bob(b: Boolean) :[] {
  if (disclose(b) || bool == disclose(b)) maps.remove(1);
  if (disclose(b) != disclose(b)) maps.insert(1, 1);
  if (disclose(b) == disclose(b)) maps.insertDefault(2);
  if (disclose(b != b)) maps.lookup(2);
  if (disclose(b || b)) maps.member(2);
  if (disclose(b && b)) maps.size();
  if (disclose(!b)) maps.resetToDefault();
}

export circuit greg(b: Boolean): Field {
  const p = disclose([b as Uint<16>, b as Uint<16>]);

  if(p[0] > 0) {
    counter.increment(p[1]);
  }

  return p[0] + p[1];
}

export circuit alan(a: Uint<8>, b: Uint<8>) :[] {
  if (disclose(a + b) > disclose(a + b)) list.head();
  if (disclose(a - b) > disclose(a) - disclose(b)) list.isEmpty();
  if (disclose(a * b > a * b)) list.length();
  if (disclose(a + a + b) > 0) list.popFront();
  if (disclose(b + a - a) < 0) list.pushFront(default<QualifiedCoinInfo>);
  if (disclose(b * a * b) < 0) list.pushFrontCoin(default<CoinInfo>, default<Either<ZswapCoinPublicKey, ContractAddress>>);
  if (disclose(b - b - a) < 0) list.resetToDefault();

  const z = disclose(a) + disclose(b) > 0 ? field.write(1) : field.write(2);
  const f = disclose(antonio()) ? field.read() : field.read();
}

// there is no need to disclose the parameters of unexported circuits.
circuit graham(a: Field, b: Field): Field {
  return a - b;
}

export circuit paulo() : Field{
  return graham(disclose(brad()), disclose(brad()));
}

constructor(f: Uint<8>, z: Uint<8>, u: Vector<1, Uint<8>>) {
  if (disclose(f) > 0) {
    set.insert(default<QualifiedCoinInfo>);
  } else {
    const p = default<Boolean>;
    if(p && disclose(f) > 0) {
      set.insertCoin(default<CoinInfo>, default<Either<ZswapCoinPublicKey, ContractAddress>>);
    } else {
      if(disclose(u[0]) > 0) {
        set.member(default<QualifiedCoinInfo>);
      } else {
        if(disclose(f + z) > 0) {
          set.remove(default<QualifiedCoinInfo>);
        } else {
          if(disclose(z - f) < 0) {
            const z = 8;
            const f = 4;

            if(z + f > 0) {
              set.size();
            } else {
              const p = z;
              if (p > 0) {
                set.resetToDefault();
              }
            }
          }
        }
      }
    }
  }
}
