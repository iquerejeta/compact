// This file is part of Compact.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

pragma language_version >= 0.15.0;

import CompactStandardLibrary;
export ledger round: Counter;
export ledger maps: Map<Field, Field>;
export ledger maps2: Map<[], []>;
export ledger maps3: Map<Field, []>;
export ledger mapsy: Map<Field, Counter>;
export ledger kris: Map<Field, bobson>;
export ledger stan: Map<Field, bobson>;

struct bobson {
  a: Vector<1, Field>,
  b: Field,
  c: Boolean
}

constructor(b : Boolean) {
  maps.insert(1, 1);

  adam();
  assert (1 > 2, "bob 1");
  assert (don() > 1, "bob 2");
  assert (assert (true != false, "bob 3") != [], "bob 4");
  assert ((true && false) || (false && true), "bob 5");
  assert (don() > don(), "");
  assert (bob(don()) > bob(don()), "");
  assert (maps.size() > maps.size() + maps.size(), "maps maps");
  assert (round.lessThan(5) == true, "counter");
  (() => assert( 1 > 2, ""))();
  
  const c = bobson{[1], 1, true };
  ellen(c);
  abel();
  mandolin(false);
  maria(1,2);
  const f = myswitch(5, 4, true);
  
  assert(pad(50, 'a') == pad(50, 'b'), 'greg 1');
  assert([1] == [1], 'greg 2');
  assert((999 - 999 - 999 - 999) - 999 - 999 - 1 as Field == 1 - 1 - 1 - 1 as Field, 'greg 3');
  assert((0 + 1 > 0 ? 1 + 2 > 1 ? 1 : 2 : 0 - 1 > 0 ? 1 + 2 > 3 ? 1 : 2 : b ? 1 : 1) > 0, "greg 4");
  assert([false, false][1] == true, 'greg 5');
  assert(default<Opaque<'string'>> == default<Opaque<'string'>>, 'greg 6');
  assert(0 == 0, "0"), round.read(), [];
  return (() => assert( 1 > 2, ""))();
}

export circuit don(): Uint<8> {
  return 1;
}

export circuit bob(value: Uint<8>): Uint<8> {
  return value;
}

export circuit bella(): [] {
  assert ([1,2,3,4,5,6,7] == [1,2,3,4,5,6,7], "hello hello");
}

export circuit adam(): [] {
  if(assert(1 + 1 >= 1 + 1, "fob") != []) {
    const p = 5;
  }

  for(const y of assert(1 + 1 >= 2, "bob")) {
    const z = 3;
  }

  assert(greg() == fred(), "clap clap");

  maps2.insert(assert(greg() == fred(), "clap clap 2"), assert(greg() == fred(), "clap clap 2"));
  maps2.lookup([]);
}

export circuit greg(): [] {
  return [];
}

export circuit fred(): [] {
  return [];
}

export circuit ellen(x: bobson): [] {
  stan.insert(1, disclose(x));
  kris.insert(1, disclose(x));
  assert(kris.lookup(1).a[0] as Boolean == stan.lookup(1).a[0] as Boolean, "stan and kris");
}

export circuit myswitch(x: Field, y: Field, b: Boolean): Field {
  if(disclose(b)) {
    assert(x != y, "same");
    assert(round.increment(disclose(x) as Uint<16>) == round.increment(disclose(y) as Uint<16>), "counter");
    return x;
  } else {
    assert(y != x, "same");
    assert(round.increment(disclose(y) as Uint<16>) == round.increment(disclose(x) as Uint<16>), "counter");
    return y;
  }
}

export circuit maria(x: Field, y: Field): Field {
  (() => {
    for (const p of assert(round.lessThan(5) == true, "true")) {
      assert([round.increment(1), round.read(), round.resetToDefault()] != [round.increment(0), round.read(), round.resetToDefault()], "counter 2");
    }
  })();

  return 1;
}

export circuit abel(): [] {
  mapsy.insert(1, default<Counter>);

  assert(mapsy.lookup(1).read() != 2, "equal 1");
  assert(mapsy.lookup(1).increment(1) == [], "equal 2");
  assert((mapsy.lookup(1) += 2) == [], "equal 3");
}

export circuit mandolin(b: Boolean): [] {
  const f = disclose(b);
  const p = f ? maps3.insert(1, assert(f == true || 1 <= 2, "true")) : maps3.insert(2, assert(f == false || round.read() > 3, "false"));

  if(f) {
    maps3.lookup(1);
  } else {
    maps3.lookup(2);
  }
}
